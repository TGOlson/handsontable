(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * SheetClip - Spreadsheet Clipboard Parser
 * version 0.2
 *
 * This tiny library transforms JavaScript arrays to strings that are pasteable by LibreOffice, OpenOffice,
 * Google Docs and Microsoft Excel.
 *
 * Copyright 2012, Marcin Warpechowski
 * Licensed under the MIT license.
 * http://github.com/warpech/sheetclip/
 */
/*jslint white: true*/
(function (global) {
  "use strict";

  function countQuotes(str) {
    return str.split('"').length - 1;
  }

  var SheetClip = {
    /**
     * Decode spreadsheet string into array
     *
     * @param {String} str
     * @returns {Array}
     */
    parse: function (str) {
      var r, rLen, rows, arr = [], a = 0, c, cLen, multiline, last;

      rows = str.split('\n');

      if (rows.length > 1 && rows[rows.length - 1] === '') {
        rows.pop();
      }
      for (r = 0, rLen = rows.length; r < rLen; r += 1) {
        rows[r] = rows[r].split('\t');

        for (c = 0, cLen = rows[r].length; c < cLen; c += 1) {
          if (!arr[a]) {
            arr[a] = [];
          }
          if (multiline && c === 0) {
            last = arr[a].length - 1;
            arr[a][last] = arr[a][last] + '\n' + rows[r][0];

            if (multiline && (countQuotes(rows[r][0]) & 1)) { //& 1 is a bitwise way of performing mod 2
              multiline = false;
              arr[a][last] = arr[a][last].substring(0, arr[a][last].length - 1).replace(/""/g, '"');
            }
          }
          else {
            if (c === cLen - 1 && rows[r][c].indexOf('"') === 0 && (countQuotes(rows[r][c]) & 1)) {
              arr[a].push(rows[r][c].substring(1).replace(/""/g, '"'));
              multiline = true;
            }
            else {
              arr[a].push(rows[r][c].replace(/""/g, '"'));
              multiline = false;
            }
          }
        }
        if (!multiline) {
          a += 1;
        }
      }

      return arr;
    },

    /**
     * Encode array into valid spreadsheet string
     *
     * @param arr
     * @returns {String}
     */
    stringify: function (arr) {
      var r, rLen, c, cLen, str = '', val;

      for (r = 0, rLen = arr.length; r < rLen; r += 1) {
        cLen = arr[r].length;

        for (c = 0; c < cLen; c += 1) {
          if (c > 0) {
            str += '\t';
          }
          val = arr[r][c];

          if (typeof val === 'string') {
            if (val.indexOf('\n') > -1) {
              str += '"' + val.replace(/"/g, '""') + '"';
            }
            else {
              str += val;
            }
          }
          else if (val === null || val === void 0) { // void 0 resolves to undefined
            str += '';
          }
          else {
            str += val;
          }
        }
        str += '\n';
      }

      return str;
    }
  };

  if (typeof exports !== 'undefined') {
    exports.parse = SheetClip.parse;
    exports.stringify = SheetClip.stringify;
  } else {
    global.SheetClip = SheetClip;
  }
}(window));

},{}],2:[function(require,module,exports){
/**
 * autoResize - resizes a DOM element to the width and height of another DOM element
 *
 * Copyright 2014, Marcin Warpechowski
 * Licensed under the MIT license
 */


function autoResize() {
  var defaults = {
      minHeight: 200,
      maxHeight: 300,
      minWidth: 100,
      maxWidth: 300
    },
    el,
    body = document.body,
    text = document.createTextNode(''),
    span = document.createElement('SPAN'),
    observe = function (element, event, handler) {
      if (window.attachEvent) {
        element.attachEvent('on' + event, handler);
      } else {
        element.addEventListener(event, handler, false);
      }
    },
    unObserve = function (element, event, handler) {
      if (window.removeEventListener) {
        element.removeEventListener(event, handler, false);
      } else {
        element.detachEvent('on' + event, handler);
      }
    },
    resize = function (newChar) {
      var width, scrollHeight;

      if (!newChar) {
        newChar = "";
      } else if (!/^[a-zA-Z \.,\\\/\|0-9]$/.test(newChar)) {
        newChar = ".";
      }

      if (text.textContent !== void 0) {
        text.textContent = el.value + newChar;
      }
      else {
        text.data = el.value + newChar; //IE8
      }
      span.style.fontSize = Handsontable.Dom.getComputedStyle(el).fontSize;
      span.style.fontFamily = Handsontable.Dom.getComputedStyle(el).fontFamily;
      span.style.whiteSpace = "pre";

      body.appendChild(span);
      width = span.clientWidth + 2;
      body.removeChild(span);

      el.style.height = defaults.minHeight + 'px';

      if (defaults.minWidth > width) {
        el.style.width = defaults.minWidth + 'px';

      } else if (width > defaults.maxWidth) {
        el.style.width = defaults.maxWidth + 'px';

      } else {
        el.style.width = width + 'px';
      }
      scrollHeight = el.scrollHeight ? el.scrollHeight - 1 : 0;

      if (defaults.minHeight > scrollHeight) {
        el.style.height = defaults.minHeight + 'px';

      } else if (defaults.maxHeight < scrollHeight) {
        el.style.height = defaults.maxHeight + 'px';
        el.style.overflowY = 'visible';

      } else {
        el.style.height = scrollHeight + 'px';
      }
    },
    delayedResize = function () {
      window.setTimeout(resize, 0);
    },
    extendDefaults = function (config) {

      if (config && config.minHeight) {
        if (config.minHeight == 'inherit') {
          defaults.minHeight = el.clientHeight;
        } else {
          var minHeight = parseInt(config.minHeight);
          if (!isNaN(minHeight)) {
            defaults.minHeight = minHeight;
          }
        }
      }

      if (config && config.maxHeight) {
        if (config.maxHeight == 'inherit') {
          defaults.maxHeight = el.clientHeight;
        } else {
          var maxHeight = parseInt(config.maxHeight);
          if (!isNaN(maxHeight)) {
            defaults.maxHeight = maxHeight;
          }
        }
      }

      if (config && config.minWidth) {
        if (config.minWidth == 'inherit') {
          defaults.minWidth = el.clientWidth;
        } else {
          var minWidth = parseInt(config.minWidth);
          if (!isNaN(minWidth)) {
            defaults.minWidth = minWidth;
          }
        }
      }

      if (config && config.maxWidth) {
        if (config.maxWidth == 'inherit') {
          defaults.maxWidth = el.clientWidth;
        } else {
          var maxWidth = parseInt(config.maxWidth);
          if (!isNaN(maxWidth)) {
            defaults.maxWidth = maxWidth;
          }
        }
      }

      if(!span.firstChild) {
        span.className = "autoResize";
        span.style.display = 'inline-block';
        span.appendChild(text);
      }
    },
    init = function (el_, config, doObserve) {
      el = el_;
      extendDefaults(config);

      if (el.nodeName == 'TEXTAREA') {

        el.style.resize = 'none';
        el.style.overflowY = '';
        el.style.height = defaults.minHeight + 'px';
        el.style.minWidth = defaults.minWidth + 'px';
        el.style.maxWidth = defaults.maxWidth + 'px';
        el.style.overflowY = 'hidden';
      }

      if(doObserve) {
        observe(el, 'change', resize);
        observe(el, 'cut', delayedResize);
        observe(el, 'paste', delayedResize);
        observe(el, 'drop', delayedResize);
        observe(el, 'keydown', delayedResize);
      }

      resize();
    };

  return {
    init: function (el_, config, doObserve) {
      init(el_, config, doObserve);
    },
    unObserve: function () {
      unObserve(el, 'change', resize);
      unObserve(el, 'cut', delayedResize);
      unObserve(el, 'paste', delayedResize);
      unObserve(el, 'drop', delayedResize);
      unObserve(el, 'keydown', delayedResize);
    },
    resize: resize
  };
}

if (typeof exports !== 'undefined') {
  module.exports = autoResize;
}

},{}],3:[function(require,module,exports){
(function (global){
/*!
 * Copyright (C) 2011 by Andrea Giammarchi, @WebReflection
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
(function(exports) {
  'use strict';
  //shared pointer
  var i;
  //shortcuts
  var defineProperty = Object.defineProperty,
    is = function(a, b) {
      return isNaN(a) ? isNaN(b) : a === b;
    };


  //Polyfill global objects
  if (typeof WeakMap == 'undefined') {
    exports.WeakMap = createCollection({
      // WeakMap#delete(key:void*):boolean
      'delete': sharedDelete,
      // WeakMap#clear():
      clear: sharedClear,
      // WeakMap#get(key:void*):void*
      get: sharedGet,
      // WeakMap#has(key:void*):boolean
      has: mapHas,
      // WeakMap#set(key:void*, value:void*):void
      set: sharedSet
    }, true);
  }

  if (typeof Map == 'undefined') {
    exports.Map = createCollection({
      // WeakMap#delete(key:void*):boolean
      'delete': sharedDelete,
      //:was Map#get(key:void*[, d3fault:void*]):void*
      // Map#has(key:void*):boolean
      has: mapHas,
      // Map#get(key:void*):boolean
      get: sharedGet,
      // Map#set(key:void*, value:void*):void
      set: sharedSet,
      // Map#keys(void):Iterator
      keys: sharedKeys,
      // Map#values(void):Iterator
      values: sharedValues,
      // Map#entries(void):Iterator
      entries: mapEntries,
      // Map#forEach(callback:Function, context:void*):void ==> callback.call(context, key, value, mapObject) === not in specs`
      forEach: sharedForEach,
      // Map#clear():
      clear: sharedClear
    });
  }

  if (typeof Set == 'undefined') {
    exports.Set = createCollection({
      // Set#has(value:void*):boolean
      has: setHas,
      // Set#add(value:void*):boolean
      add: sharedAdd,
      // Set#delete(key:void*):boolean
      'delete': sharedDelete,
      // Set#clear():
      clear: sharedClear,
      // Set#keys(void):Iterator
      keys: sharedValues, // specs actually say "the same function object as the initial value of the values property"
      // Set#values(void):Iterator
      values: sharedValues,
      // Set#entries(void):Iterator
      entries: setEntries,
      // Set#forEach(callback:Function, context:void*):void ==> callback.call(context, value, index) === not in specs
      forEach: sharedForEach
    });
  }

  if (typeof WeakSet == 'undefined') {
    exports.WeakSet = createCollection({
      // WeakSet#delete(key:void*):boolean
      'delete': sharedDelete,
      // WeakSet#add(value:void*):boolean
      add: sharedAdd,
      // WeakSet#clear():
      clear: sharedClear,
      // WeakSet#has(value:void*):boolean
      has: setHas
    }, true);
  }


  /**
   * ES6 collection constructor
   * @return {Function} a collection class
   */
  function createCollection(proto, objectOnly) {
    function Collection(a) {
      if (!this || this.constructor !== Collection) return new Collection(a);
      this._keys = [];
      this._values = [];
      this._itp = []; // iteration pointers
      this.objectOnly = objectOnly;

      //parse initial iterable argument passed
      if (a) init.call(this, a);
    }

    //define size for non object-only collections
    if (!objectOnly) {
      defineProperty(proto, 'size', {
        get: sharedSize
      });
    }

    //set prototype
    proto.constructor = Collection;
    Collection.prototype = proto;

    return Collection;
  }


  /** parse initial iterable argument passed */
  function init(a) {
    var i;
    //init Set argument, like `[1,2,3,{}]`
    if (this.add) a.forEach(this.add, this);
    //init Map argument like `[[1,2], [{}, 4]]`
    else a.forEach(function(a) {
      this.set(a[0], a[1])
    }, this);
  }


  /** delete */
  function sharedDelete(key) {
    if (this.has(key)) {
      this._keys.splice(i, 1);
      this._values.splice(i, 1);
      // update iteration pointers
      this._itp.forEach(function(p) {
        if (i < p[0]) p[0]--;
      });
    }
    // Aurora here does it while Canary doesn't
    return -1 < i;
  };

  function sharedGet(key) {
    return this.has(key) ? this._values[i] : undefined;
  }

  function has(list, key) {
    if (this.objectOnly && key !== Object(key)) throw new TypeError("Invalid value used as weak collection key");
    //NaN or 0 passed
    if (key != key || key === 0) for (i = list.length; i-- && !is(list[i], key);) {} else i = list.indexOf(key);
    return -1 < i;
  }

  function setHas(value) {
    return has.call(this, this._values, value);
  }

  function mapHas(value) {
    return has.call(this, this._keys, value);
  }

  /** @chainable */
  function sharedSet(key, value) {
    this.has(key) ? this._values[i] = value : this._values[this._keys.push(key) - 1] = value;
    return this;
  }

  /** @chainable */
  function sharedAdd(value) {
    if (!this.has(value)) this._values.push(value);
    return this;
  }

  function sharedClear() {
    this._values.length = 0;
  }

  /** keys, values, and iterate related methods */
  function sharedKeys() {
    return sharedIterator(this._itp, this._keys);
  }

  function sharedValues() {
    return sharedIterator(this._itp, this._values);
  }

  function mapEntries() {
    return sharedIterator(this._itp, this._keys, this._values);
  }

  function setEntries() {
    return sharedIterator(this._itp, this._values, this._values);
  }

  function sharedIterator(itp, array, array2) {
    var p = [0],
      done = false;
    itp.push(p);
    return {
      next: function() {
        var v, k = p[0];
        if (!done && k < array.length) {
          v = array2 ? [array[k], array2[k]] : array[k];
          p[0]++;
        } else {
          done = true;
          itp.splice(itp.indexOf(p), 1);
        }
        return {
          done: done,
          value: v
        };
      }
    };
  }

  function sharedSize() {
    return this._values.length;
  }

  function sharedForEach(callback, context) {
    var it = this.entries();
    for (;;) {
      var r = it.next();
      if (r.done) break;
      callback.call(context, r.value[1], r.value[0], this);
    }
  }

})(typeof exports != 'undefined' && typeof global != 'undefined' ? global : window);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],4:[function(require,module,exports){
//! moment.js
//! version : 2.10.6
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, function () { 'use strict';

    var hookCallback;

    function utils_hooks__hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function create_utc__createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            m._isValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function valid__createInvalid (flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    var momentProperties = utils_hooks__hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (typeof from._isAMomentObject !== 'undefined') {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== 'undefined') {
            to._i = from._i;
        }
        if (typeof from._f !== 'undefined') {
            to._f = from._f;
        }
        if (typeof from._l !== 'undefined') {
            to._l = from._l;
        }
        if (typeof from._strict !== 'undefined') {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== 'undefined') {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== 'undefined') {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== 'undefined') {
            to._offset = from._offset;
        }
        if (typeof from._pf !== 'undefined') {
            to._pf = getParsingFlags(from);
        }
        if (typeof from._locale !== 'undefined') {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== 'undefined') {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function Locale() {
    }

    var locales = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && typeof module !== 'undefined' &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function locale_locales__getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (typeof values === 'undefined') {
                data = locale_locales__getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, values) {
        if (values !== null) {
            values.abbr = name;
            locales[name] = locales[name] || new Locale();
            locales[name].set(values);

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    // returns locale data
    function locale_locales__getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }

    function get_set__get (mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function get_set__set (mom, unit, value) {
        return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }

    // MOMENTS

    function getSet (units, value) {
        var unit;
        if (typeof units === 'object') {
            for (unit in units) {
                this.set(unit, units[unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '';
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;

    var regexes = {};

    function isFunction (sth) {
        // https://github.com/moment/moment/issues/2325
        return typeof sth === 'function' &&
            Object.prototype.toString.call(sth) === '[object Function]';
    }


    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (typeof callback === 'number') {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  matchWord);
    addRegexToken('MMMM', matchWord);

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m) {
        return this._months[m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m) {
        return this._monthsShort[m.month()];
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (firstTime) {
                warn(msg + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    utils_hooks__hooks.suppressDeprecationWarnings = false;

    var from_string__isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
        ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
        ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d{2}/],
        ['YYYY-DDD', /\d{4}-\d{3}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
        ['HH:mm', /(T| )\d\d:\d\d/],
        ['HH', /(T| )\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = from_string__isoRegex.exec(string);

        if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    config._f = isoDates[i][0];
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    // match[6] should be 'T' or space
                    config._f += (match[6] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (string.match(matchOffset)) {
                config._f += 'Z';
            }
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    utils_hooks__hooks.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'https://github.com/moment/moment/issues/1407 for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    function createDate (y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    utils_hooks__hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', false);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, 'd');
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var week1Jan = 6 + firstDayOfWeek - firstDayOfWeekOfYear, janX = createUTCDate(year, 0, 1 + week1Jan), d = janX.getUTCDay(), dayOfYear;
        if (d < firstDayOfWeek) {
            d += 7;
        }

        weekday = weekday != null ? 1 * weekday : firstDayOfWeek;

        dayOfYear = 1 + week1Jan + 7 * (week - 1) - d + weekday;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()];
        }
        return [now.getFullYear(), now.getMonth(), now.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }

    utils_hooks__hooks.ISO_8601 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }

        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (getParsingFlags(config).bigHour === true &&
                config._a[HOUR] <= 12 &&
                config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!valid__isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = [i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond];

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || locale_locales__getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return valid__createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else if (isDate(input)) {
            config._d = input;
        } else {
            configFromInput(config);
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof(input) === 'object') {
            configFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function local__createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
         'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
         function () {
             var other = local__createLocal.apply(null, arguments);
             return other < this ? this : other;
         }
     );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
        function () {
            var other = local__createLocal.apply(null, arguments);
            return other > this ? this : other;
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = locale_locales__getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchOffset);
    addRegexToken('ZZ', matchOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(string) {
        var matches = ((string || '').match(matchOffset) || []);
        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(+res._d + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    utils_hooks__hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(input);
            }
            if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
            this.utcOffset(offsetFromString(this._i));
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        input = input ? local__createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (typeof this._isDSTShifted !== 'undefined') {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return !this._isUTC;
    }

    function isUtcOffset () {
        return this._isUTC;
    }

    function isUtc () {
        return this._isUTC && this._offset === 0;
    }

    var aspNetRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;

    function create__createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])        * sign,
                h  : toInt(match[HOUR])        * sign,
                m  : toInt(match[MINUTE])      * sign,
                s  : toInt(match[SECOND])      * sign,
                ms : toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = create__isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                d : parseIso(match[4], sign),
                h : parseIso(match[5], sign),
                m : parseIso(match[6], sign),
                s : parseIso(match[7], sign),
                w : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    create__createDuration.fn = Duration.prototype;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }

    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }

    var add_subtract__add      = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');

    function moment_calendar__calendar (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            diff = this.diff(sod, 'days', true),
            format = diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
        return this.format(formats && formats[format] || this.localeData().calendar(format, this, local__createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this > +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return inputMs < +this.clone().startOf(units);
        }
    }

    function isBefore (input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this < +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return +this.clone().endOf(units) < inputMs;
        }
    }

    function isBetween (from, to, units) {
        return this.isAfter(from, units) && this.isBefore(to, units);
    }

    function isSame (input, units) {
        var inputMs;
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this === +input;
        } else {
            inputMs = +local__createLocal(input);
            return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
        }
    }

    function diff (input, units, asFloat) {
        var that = cloneWithOffset(input, this),
            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4,
            delta, output;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
                units === 'minute' ? delta / 6e4 : // 1000 * 60
                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        return -(wholeMonthDiff + adjust);
    }

    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function moment_format__toISOString () {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if ('function' === typeof Date.prototype.toISOString) {
                // native implementation is ~50x faster, use it when we can
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        } else {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    }

    function format (inputString) {
        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    }

    function fromNow (withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    }

    function toNow (withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }

    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }
        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function to_type__valueOf () {
        return +this._d - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(+this / 1000);
    }

    function toDate () {
        return this._offset ? new Date(+this) : this._d;
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function moment_valid__isValid () {
        return valid__isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // HELPERS

    function weeksInYear(year, dow, doy) {
        return weekOfYear(local__createLocal([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    // MOMENTS

    function getSetWeekYear (input) {
        var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
        return input == null ? year : this.add((input - year), 'y');
    }

    function getSetISOWeekYear (input) {
        var year = weekOfYear(this, 1, 4).year;
        return input == null ? year : this.add((input - year), 'y');
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    addFormatToken('Q', 0, 0, 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   matchWord);
    addRegexToken('ddd',  matchWord);
    addRegexToken('dddd', matchWord);

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config) {
        var weekday = config._locale.weekdaysParse(input);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m) {
        return this._weekdays[m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return this._weekdaysShort[m.day()];
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return this._weekdaysMin[m.day()];
    }

    function localeWeekdaysParse (weekdayName) {
        var i, mom, regex;

        this._weekdaysParse = this._weekdaysParse || [];

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            if (!this._weekdaysParse[i]) {
                mom = local__createLocal([2000, 1]).day(i);
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.
        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, function () {
        return this.hours() % 12 || 12;
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var momentPrototype__proto = Moment.prototype;

    momentPrototype__proto.add          = add_subtract__add;
    momentPrototype__proto.calendar     = moment_calendar__calendar;
    momentPrototype__proto.clone        = clone;
    momentPrototype__proto.diff         = diff;
    momentPrototype__proto.endOf        = endOf;
    momentPrototype__proto.format       = format;
    momentPrototype__proto.from         = from;
    momentPrototype__proto.fromNow      = fromNow;
    momentPrototype__proto.to           = to;
    momentPrototype__proto.toNow        = toNow;
    momentPrototype__proto.get          = getSet;
    momentPrototype__proto.invalidAt    = invalidAt;
    momentPrototype__proto.isAfter      = isAfter;
    momentPrototype__proto.isBefore     = isBefore;
    momentPrototype__proto.isBetween    = isBetween;
    momentPrototype__proto.isSame       = isSame;
    momentPrototype__proto.isValid      = moment_valid__isValid;
    momentPrototype__proto.lang         = lang;
    momentPrototype__proto.locale       = locale;
    momentPrototype__proto.localeData   = localeData;
    momentPrototype__proto.max          = prototypeMax;
    momentPrototype__proto.min          = prototypeMin;
    momentPrototype__proto.parsingFlags = parsingFlags;
    momentPrototype__proto.set          = getSet;
    momentPrototype__proto.startOf      = startOf;
    momentPrototype__proto.subtract     = add_subtract__subtract;
    momentPrototype__proto.toArray      = toArray;
    momentPrototype__proto.toObject     = toObject;
    momentPrototype__proto.toDate       = toDate;
    momentPrototype__proto.toISOString  = moment_format__toISOString;
    momentPrototype__proto.toJSON       = moment_format__toISOString;
    momentPrototype__proto.toString     = toString;
    momentPrototype__proto.unix         = unix;
    momentPrototype__proto.valueOf      = to_type__valueOf;

    // Year
    momentPrototype__proto.year       = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;

    // Week Year
    momentPrototype__proto.weekYear    = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

    // Month
    momentPrototype__proto.month       = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;

    // Week
    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
    momentPrototype__proto.weeksInYear    = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    momentPrototype__proto.date       = getSetDayOfMonth;
    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

    // Hour
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

    // Minute
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

    // Second
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

    // Millisecond
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

    // Offset
    momentPrototype__proto.utcOffset            = getSetOffset;
    momentPrototype__proto.utc                  = setOffsetToUTC;
    momentPrototype__proto.local                = setOffsetToLocal;
    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST                = isDaylightSavingTime;
    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
    momentPrototype__proto.isLocal              = isLocal;
    momentPrototype__proto.isUtcOffset          = isUtcOffset;
    momentPrototype__proto.isUtc                = isUtc;
    momentPrototype__proto.isUTC                = isUtc;

    // Timezone
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;

    // Deprecations
    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);

    var momentPrototype = momentPrototype__proto;

    function moment__createUnix (input) {
        return local__createLocal(input * 1000);
    }

    function moment__createInZone () {
        return local__createLocal.apply(null, arguments).parseZone();
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function locale_calendar__calendar (key, mom, now) {
        var output = this._calendar[key];
        return typeof output === 'function' ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    function preParsePostFormat (string) {
        return string;
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (typeof output === 'function') ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
    }

    function locale_set__set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (typeof prop === 'function') {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }

    var prototype__proto = Locale.prototype;

    prototype__proto._calendar       = defaultCalendar;
    prototype__proto.calendar        = locale_calendar__calendar;
    prototype__proto._longDateFormat = defaultLongDateFormat;
    prototype__proto.longDateFormat  = longDateFormat;
    prototype__proto._invalidDate    = defaultInvalidDate;
    prototype__proto.invalidDate     = invalidDate;
    prototype__proto._ordinal        = defaultOrdinal;
    prototype__proto.ordinal         = ordinal;
    prototype__proto._ordinalParse   = defaultOrdinalParse;
    prototype__proto.preparse        = preParsePostFormat;
    prototype__proto.postformat      = preParsePostFormat;
    prototype__proto._relativeTime   = defaultRelativeTime;
    prototype__proto.relativeTime    = relative__relativeTime;
    prototype__proto.pastFuture      = pastFuture;
    prototype__proto.set             = locale_set__set;

    // Month
    prototype__proto.months       =        localeMonths;
    prototype__proto._months      = defaultLocaleMonths;
    prototype__proto.monthsShort  =        localeMonthsShort;
    prototype__proto._monthsShort = defaultLocaleMonthsShort;
    prototype__proto.monthsParse  =        localeMonthsParse;

    // Week
    prototype__proto.week = localeWeek;
    prototype__proto._week = defaultLocaleWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    prototype__proto.weekdays       =        localeWeekdays;
    prototype__proto._weekdays      = defaultLocaleWeekdays;
    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

    // Hours
    prototype__proto.isPM = localeIsPM;
    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
    prototype__proto.meridiem = localeMeridiem;

    function lists__get (format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function list (format, index, field, count, setter) {
        if (typeof format === 'number') {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return lists__get(format, index, field, setter);
        }

        var i;
        var out = [];
        for (i = 0; i < count; i++) {
            out[i] = lists__get(format, i, field, setter);
        }
        return out;
    }

    function lists__listMonths (format, index) {
        return list(format, index, 'months', 12, 'month');
    }

    function lists__listMonthsShort (format, index) {
        return list(format, index, 'monthsShort', 12, 'month');
    }

    function lists__listWeekdays (format, index) {
        return list(format, index, 'weekdays', 7, 'day');
    }

    function lists__listWeekdaysShort (format, index) {
        return list(format, index, 'weekdaysShort', 7, 'day');
    }

    function lists__listWeekdaysMin (format, index) {
        return list(format, index, 'weekdaysMin', 7, 'day');
    }

    locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

    var mathAbs = Math.abs;

    function duration_abs__abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function duration_add_subtract__addSubtract (duration, input, value, direction) {
        var other = create__createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function duration_add_subtract__add (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function duration_add_subtract__subtract (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function duration_as__valueOf () {
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function duration_get__get (units) {
        units = normalizeUnits(units);
        return this[units + 's']();
    }

    function makeGetter(name) {
        return function () {
            return this._data[name];
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        s: 45,  // seconds to minute
        m: 45,  // minutes to hour
        h: 22,  // hours to day
        d: 26,  // days to month
        M: 11   // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds < thresholds.s && ['s', seconds]  ||
                minutes === 1          && ['m']           ||
                minutes < thresholds.m && ['mm', minutes] ||
                hours   === 1          && ['h']           ||
                hours   < thresholds.h && ['hh', hours]   ||
                days    === 1          && ['d']           ||
                days    < thresholds.d && ['dd', days]    ||
                months  === 1          && ['M']           ||
                months  < thresholds.M && ['MM', months]  ||
                years   === 1          && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set a threshold for relative time strings
    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }

    function humanize (withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var iso_string__abs = Math.abs;

    function iso_string__toISOString() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        var seconds = iso_string__abs(this._milliseconds) / 1000;
        var days         = iso_string__abs(this._days);
        var months       = iso_string__abs(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') +
            'P' +
            (Y ? Y + 'Y' : '') +
            (M ? M + 'M' : '') +
            (D ? D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? h + 'H' : '') +
            (m ? m + 'M' : '') +
            (s ? s + 'S' : '');
    }

    var duration_prototype__proto = Duration.prototype;

    duration_prototype__proto.abs            = duration_abs__abs;
    duration_prototype__proto.add            = duration_add_subtract__add;
    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
    duration_prototype__proto.as             = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds      = asSeconds;
    duration_prototype__proto.asMinutes      = asMinutes;
    duration_prototype__proto.asHours        = asHours;
    duration_prototype__proto.asDays         = asDays;
    duration_prototype__proto.asWeeks        = asWeeks;
    duration_prototype__proto.asMonths       = asMonths;
    duration_prototype__proto.asYears        = asYears;
    duration_prototype__proto.valueOf        = duration_as__valueOf;
    duration_prototype__proto._bubble        = bubble;
    duration_prototype__proto.get            = duration_get__get;
    duration_prototype__proto.milliseconds   = milliseconds;
    duration_prototype__proto.seconds        = seconds;
    duration_prototype__proto.minutes        = minutes;
    duration_prototype__proto.hours          = hours;
    duration_prototype__proto.days           = days;
    duration_prototype__proto.weeks          = weeks;
    duration_prototype__proto.months         = months;
    duration_prototype__proto.years          = years;
    duration_prototype__proto.humanize       = humanize;
    duration_prototype__proto.toISOString    = iso_string__toISOString;
    duration_prototype__proto.toString       = iso_string__toISOString;
    duration_prototype__proto.toJSON         = iso_string__toISOString;
    duration_prototype__proto.locale         = locale;
    duration_prototype__proto.localeData     = localeData;

    // Deprecations
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;

    // Side effect imports

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    utils_hooks__hooks.version = '2.10.6';

    setHookCallback(local__createLocal);

    utils_hooks__hooks.fn                    = momentPrototype;
    utils_hooks__hooks.min                   = min;
    utils_hooks__hooks.max                   = max;
    utils_hooks__hooks.utc                   = create_utc__createUTC;
    utils_hooks__hooks.unix                  = moment__createUnix;
    utils_hooks__hooks.months                = lists__listMonths;
    utils_hooks__hooks.isDate                = isDate;
    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid               = valid__createInvalid;
    utils_hooks__hooks.duration              = create__createDuration;
    utils_hooks__hooks.isMoment              = isMoment;
    utils_hooks__hooks.weekdays              = lists__listWeekdays;
    utils_hooks__hooks.parseZone             = moment__createInZone;
    utils_hooks__hooks.localeData            = locale_locales__getLocale;
    utils_hooks__hooks.isDuration            = isDuration;
    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale          = defineLocale;
    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;

    var _moment = utils_hooks__hooks;

    return _moment;

}));
},{}],5:[function(require,module,exports){
/*!
 * numeral.js
 * version : 1.5.3
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */

(function () {

    /************************************
        Constants
    ************************************/

    var numeral,
        VERSION = '1.5.3',
        // internal storage for language config files
        languages = {},
        currentLanguage = 'en',
        zeroFormat = null,
        defaultFormat = '0,0',
        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module.exports);


    /************************************
        Constructors
    ************************************/


    // Numeral prototype object
    function Numeral (number) {
        this._value = number;
    }

    /**
     * Implementation of toFixed() that treats floats more like decimals
     *
     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
     * problems for accounting- and finance-related software.
     */
    function toFixed (value, precision, roundingFunction, optionals) {
        var power = Math.pow(10, precision),
            optionalsRegExp,
            output;

        //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);
        // Multiply up by precision, round accurately, then divide and use native toFixed():
        output = (roundingFunction(value * power) / power).toFixed(precision);

        if (optionals) {
            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');
            output = output.replace(optionalsRegExp, '');
        }

        return output;
    }

    /************************************
        Formatting
    ************************************/

    // determine what type of formatting we need to do
    function formatNumeral (n, format, roundingFunction) {
        var output;

        // figure out what kind of format we are dealing with
        if (format.indexOf('$') > -1) { // currency!!!!!
            output = formatCurrency(n, format, roundingFunction);
        } else if (format.indexOf('%') > -1) { // percentage
            output = formatPercentage(n, format, roundingFunction);
        } else if (format.indexOf(':') > -1) { // time
            output = formatTime(n, format);
        } else { // plain ol' numbers or bytes
            output = formatNumber(n._value, format, roundingFunction);
        }

        // return string
        return output;
    }

    // revert to number
    function unformatNumeral (n, string) {
        var stringOriginal = string,
            thousandRegExp,
            millionRegExp,
            billionRegExp,
            trillionRegExp,
            suffixes = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            bytesMultiplier = false,
            power;

        if (string.indexOf(':') > -1) {
            n._value = unformatTime(string);
        } else {
            if (string === zeroFormat) {
                n._value = 0;
            } else {
                if (languages[currentLanguage].delimiters.decimal !== '.') {
                    string = string.replace(/\./g,'').replace(languages[currentLanguage].delimiters.decimal, '.');
                }

                // see if abbreviations are there so that we can multiply to the correct number
                thousandRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.thousand + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                millionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.million + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                billionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.billion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                trillionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.trillion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');

                // see if bytes are there so that we can multiply to the correct number
                for (power = 0; power <= suffixes.length; power++) {
                    bytesMultiplier = (string.indexOf(suffixes[power]) > -1) ? Math.pow(1024, power + 1) : false;

                    if (bytesMultiplier) {
                        break;
                    }
                }

                // do some math to create our number
                n._value = ((bytesMultiplier) ? bytesMultiplier : 1) * ((stringOriginal.match(thousandRegExp)) ? Math.pow(10, 3) : 1) * ((stringOriginal.match(millionRegExp)) ? Math.pow(10, 6) : 1) * ((stringOriginal.match(billionRegExp)) ? Math.pow(10, 9) : 1) * ((stringOriginal.match(trillionRegExp)) ? Math.pow(10, 12) : 1) * ((string.indexOf('%') > -1) ? 0.01 : 1) * (((string.split('-').length + Math.min(string.split('(').length-1, string.split(')').length-1)) % 2)? 1: -1) * Number(string.replace(/[^0-9\.]+/g, ''));

                // round if we are talking about bytes
                n._value = (bytesMultiplier) ? Math.ceil(n._value) : n._value;
            }
        }
        return n._value;
    }

    function formatCurrency (n, format, roundingFunction) {
        var symbolIndex = format.indexOf('$'),
            openParenIndex = format.indexOf('('),
            minusSignIndex = format.indexOf('-'),
            space = '',
            spliceIndex,
            output;

        // check for space before or after currency
        if (format.indexOf(' $') > -1) {
            space = ' ';
            format = format.replace(' $', '');
        } else if (format.indexOf('$ ') > -1) {
            space = ' ';
            format = format.replace('$ ', '');
        } else {
            format = format.replace('$', '');
        }

        // format the number
        output = formatNumber(n._value, format, roundingFunction);

        // position the symbol
        if (symbolIndex <= 1) {
            if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {
                output = output.split('');
                spliceIndex = 1;
                if (symbolIndex < openParenIndex || symbolIndex < minusSignIndex){
                    // the symbol appears before the "(" or "-"
                    spliceIndex = 0;
                }
                output.splice(spliceIndex, 0, languages[currentLanguage].currency.symbol + space);
                output = output.join('');
            } else {
                output = languages[currentLanguage].currency.symbol + space + output;
            }
        } else {
            if (output.indexOf(')') > -1) {
                output = output.split('');
                output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);
                output = output.join('');
            } else {
                output = output + space + languages[currentLanguage].currency.symbol;
            }
        }

        return output;
    }

    function formatPercentage (n, format, roundingFunction) {
        var space = '',
            output,
            value = n._value * 100;

        // check for space before %
        if (format.indexOf(' %') > -1) {
            space = ' ';
            format = format.replace(' %', '');
        } else {
            format = format.replace('%', '');
        }

        output = formatNumber(value, format, roundingFunction);

        if (output.indexOf(')') > -1 ) {
            output = output.split('');
            output.splice(-1, 0, space + '%');
            output = output.join('');
        } else {
            output = output + space + '%';
        }

        return output;
    }

    function formatTime (n) {
        var hours = Math.floor(n._value/60/60),
            minutes = Math.floor((n._value - (hours * 60 * 60))/60),
            seconds = Math.round(n._value - (hours * 60 * 60) - (minutes * 60));
        return hours + ':' + ((minutes < 10) ? '0' + minutes : minutes) + ':' + ((seconds < 10) ? '0' + seconds : seconds);
    }

    function unformatTime (string) {
        var timeArray = string.split(':'),
            seconds = 0;
        // turn hours and minutes into seconds and add them all up
        if (timeArray.length === 3) {
            // hours
            seconds = seconds + (Number(timeArray[0]) * 60 * 60);
            // minutes
            seconds = seconds + (Number(timeArray[1]) * 60);
            // seconds
            seconds = seconds + Number(timeArray[2]);
        } else if (timeArray.length === 2) {
            // minutes
            seconds = seconds + (Number(timeArray[0]) * 60);
            // seconds
            seconds = seconds + Number(timeArray[1]);
        }
        return Number(seconds);
    }

    function formatNumber (value, format, roundingFunction) {
        var negP = false,
            signed = false,
            optDec = false,
            abbr = '',
            abbrK = false, // force abbreviation to thousands
            abbrM = false, // force abbreviation to millions
            abbrB = false, // force abbreviation to billions
            abbrT = false, // force abbreviation to trillions
            abbrForce = false, // force abbreviation
            bytes = '',
            ord = '',
            abs = Math.abs(value),
            suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            min,
            max,
            power,
            w,
            precision,
            thousands,
            d = '',
            neg = false;

        // check if number is zero and a custom zero format has been set
        if (value === 0 && zeroFormat !== null) {
            return zeroFormat;
        } else {
            // see if we should use parentheses for negative number or if we should prefix with a sign
            // if both are present we default to parentheses
            if (format.indexOf('(') > -1) {
                negP = true;
                format = format.slice(1, -1);
            } else if (format.indexOf('+') > -1) {
                signed = true;
                format = format.replace(/\+/g, '');
            }

            // see if abbreviation is wanted
            if (format.indexOf('a') > -1) {
                // check if abbreviation is specified
                abbrK = format.indexOf('aK') >= 0;
                abbrM = format.indexOf('aM') >= 0;
                abbrB = format.indexOf('aB') >= 0;
                abbrT = format.indexOf('aT') >= 0;
                abbrForce = abbrK || abbrM || abbrB || abbrT;

                // check for space before abbreviation
                if (format.indexOf(' a') > -1) {
                    abbr = ' ';
                    format = format.replace(' a', '');
                } else {
                    format = format.replace('a', '');
                }

                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {
                    // trillion
                    abbr = abbr + languages[currentLanguage].abbreviations.trillion;
                    value = value / Math.pow(10, 12);
                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {
                    // billion
                    abbr = abbr + languages[currentLanguage].abbreviations.billion;
                    value = value / Math.pow(10, 9);
                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {
                    // million
                    abbr = abbr + languages[currentLanguage].abbreviations.million;
                    value = value / Math.pow(10, 6);
                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {
                    // thousand
                    abbr = abbr + languages[currentLanguage].abbreviations.thousand;
                    value = value / Math.pow(10, 3);
                }
            }

            // see if we are formatting bytes
            if (format.indexOf('b') > -1) {
                // check for space before
                if (format.indexOf(' b') > -1) {
                    bytes = ' ';
                    format = format.replace(' b', '');
                } else {
                    format = format.replace('b', '');
                }

                for (power = 0; power <= suffixes.length; power++) {
                    min = Math.pow(1024, power);
                    max = Math.pow(1024, power+1);

                    if (value >= min && value < max) {
                        bytes = bytes + suffixes[power];
                        if (min > 0) {
                            value = value / min;
                        }
                        break;
                    }
                }
            }

            // see if ordinal is wanted
            if (format.indexOf('o') > -1) {
                // check for space before
                if (format.indexOf(' o') > -1) {
                    ord = ' ';
                    format = format.replace(' o', '');
                } else {
                    format = format.replace('o', '');
                }

                ord = ord + languages[currentLanguage].ordinal(value);
            }

            if (format.indexOf('[.]') > -1) {
                optDec = true;
                format = format.replace('[.]', '.');
            }

            w = value.toString().split('.')[0];
            precision = format.split('.')[1];
            thousands = format.indexOf(',');

            if (precision) {
                if (precision.indexOf('[') > -1) {
                    precision = precision.replace(']', '');
                    precision = precision.split('[');
                    d = toFixed(value, (precision[0].length + precision[1].length), roundingFunction, precision[1].length);
                } else {
                    d = toFixed(value, precision.length, roundingFunction);
                }

                w = d.split('.')[0];

                if (d.split('.')[1].length) {
                    d = languages[currentLanguage].delimiters.decimal + d.split('.')[1];
                } else {
                    d = '';
                }

                if (optDec && Number(d.slice(1)) === 0) {
                    d = '';
                }
            } else {
                w = toFixed(value, null, roundingFunction);
            }

            // format number
            if (w.indexOf('-') > -1) {
                w = w.slice(1);
                neg = true;
            }

            if (thousands > -1) {
                w = w.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + languages[currentLanguage].delimiters.thousands);
            }

            if (format.indexOf('.') === 0) {
                w = '';
            }

            return ((negP && neg) ? '(' : '') + ((!negP && neg) ? '-' : '') + ((!neg && signed) ? '+' : '') + w + d + ((ord) ? ord : '') + ((abbr) ? abbr : '') + ((bytes) ? bytes : '') + ((negP && neg) ? ')' : '');
        }
    }

    /************************************
        Top Level Functions
    ************************************/

    numeral = function (input) {
        if (numeral.isNumeral(input)) {
            input = input.value();
        } else if (input === 0 || typeof input === 'undefined') {
            input = 0;
        } else if (!Number(input)) {
            input = numeral.fn.unformat(input);
        }

        return new Numeral(Number(input));
    };

    // version number
    numeral.version = VERSION;

    // compare numeral object
    numeral.isNumeral = function (obj) {
        return obj instanceof Numeral;
    };

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    numeral.language = function (key, values) {
        if (!key) {
            return currentLanguage;
        }

        if (key && !values) {
            if(!languages[key]) {
                throw new Error('Unknown language : ' + key);
            }
            currentLanguage = key;
        }

        if (values || !languages[key]) {
            loadLanguage(key, values);
        }

        return numeral;
    };

    // This function provides access to the loaded language data.  If
    // no arguments are passed in, it will simply return the current
    // global language object.
    numeral.languageData = function (key) {
        if (!key) {
            return languages[currentLanguage];
        }

        if (!languages[key]) {
            throw new Error('Unknown language : ' + key);
        }

        return languages[key];
    };

    numeral.language('en', {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function (number) {
            var b = number % 10;
            return (~~ (number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
        },
        currency: {
            symbol: '$'
        }
    });

    numeral.zeroFormat = function (format) {
        zeroFormat = typeof(format) === 'string' ? format : null;
    };

    numeral.defaultFormat = function (format) {
        defaultFormat = typeof(format) === 'string' ? format : '0.0';
    };

    numeral.validate = function(val, culture) {

        var _decimalSep,
          _thousandSep,
          _currSymbol,
          _valArray,
          _abbrObj,
          _thousandRegEx,
          languageData,
          temp;

        //coerce val to string
        if (typeof val !== 'string') {
            val += '';
            if (console.warn) {
                console.warn('Numeral.js: Value is not string. It has been co-erced to: ', val);
            }
        }

        //trim whitespaces from either sides
        val = val.trim();


        //if val is empty return false
        if (val === '') {
            return false;
        }

        //replace the initial '+' or '-' sign if present
        val = val.replace(/^[+-]?/, '');


        //get the decimal and thousands separator from numeral.languageData
        try {
            //check if the culture is understood by numeral. if not, default it to current language
            languageData = numeral.languageData(culture);
        } catch (e) {
            languageData = numeral.languageData(numeral.language());
        }

        //setup the delimiters and currency symbol based on culture/language
        _currSymbol = languageData.currency.symbol;
        _abbrObj = languageData.abbreviations;
        _decimalSep = languageData.delimiters.decimal;
        if (languageData.delimiters.thousands === '.') {
            _thousandSep = '\\.';
        } else {
            _thousandSep = languageData.delimiters.thousands;
        }

        //validating currency symbol
        temp = val.match(/^[^\d\.\,]+/);
        if (temp !== null) {
            //chuck the currency symbol away
            val = val.substr(1);
            if (temp[0] !== _currSymbol) {
                return false;
            }
        }

        //validating abbreviation symbol
        temp = val.match(/[^\d]+$/);
        if (temp !== null) {
            val = val.slice(0, - 1);
            if (temp[0] !== _abbrObj.thousand && temp[0] !== _abbrObj.million && temp[0] !== _abbrObj.billion && temp[0] !== _abbrObj.trillion) {
                return false;
            }
        }

        //if val is just digits the return true
        if ( !! val.match(/^\d+$/)) {
            return true;
        }
        _thousandRegEx = new RegExp(_thousandSep + '{2}');

        if (!val.match(/[^\d.,]/g)) {
            _valArray = val.split(_decimalSep);
            if (_valArray.length > 2) {
                return false;
            } else {
                if (_valArray.length < 2) {
                    return ( !! _valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx));
                } else {
                    // for values without leading zero eg. .984
                    if (_valArray[0] === '') {
                        return ( !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\d+$/));
                    } else if (_valArray[0].length === 1) {
                        return ( !! _valArray[0].match(/^\d+$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\d+$/));
                    } else {
                        return ( !! _valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx) && !! _valArray[1].match(/^\d+$/));
                    }
                }
            }
        }

        return false;
    };

    /************************************
        Helpers
    ************************************/

    function loadLanguage(key, values) {
        languages[key] = values;
    }

    /************************************
        Floating-point helpers
    ************************************/

    // The floating-point helper functions and implementation
    // borrows heavily from sinful.js: http://guipn.github.io/sinful.js/

    /**
     * Array.prototype.reduce for browsers that don't support it
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Compatibility
     */
    if ('function' !== typeof Array.prototype.reduce) {
        Array.prototype.reduce = function (callback, opt_initialValue) {
            'use strict';

            if (null === this || 'undefined' === typeof this) {
                // At the moment all modern browsers, that support strict mode, have
                // native implementation of Array.prototype.reduce. For instance, IE8
                // does not support strict mode, so this check is actually useless.
                throw new TypeError('Array.prototype.reduce called on null or undefined');
            }

            if ('function' !== typeof callback) {
                throw new TypeError(callback + ' is not a function');
            }

            var index,
                value,
                length = this.length >>> 0,
                isValueSet = false;

            if (1 < arguments.length) {
                value = opt_initialValue;
                isValueSet = true;
            }

            for (index = 0; length > index; ++index) {
                if (this.hasOwnProperty(index)) {
                    if (isValueSet) {
                        value = callback(value, this[index], index, this);
                    } else {
                        value = this[index];
                        isValueSet = true;
                    }
                }
            }

            if (!isValueSet) {
                throw new TypeError('Reduce of empty array with no initial value');
            }

            return value;
        };
    }


    /**
     * Computes the multiplier necessary to make x >= 1,
     * effectively eliminating miscalculations caused by
     * finite precision.
     */
    function multiplier(x) {
        var parts = x.toString().split('.');
        if (parts.length < 2) {
            return 1;
        }
        return Math.pow(10, parts[1].length);
    }

    /**
     * Given a variable number of arguments, returns the maximum
     * multiplier that must be used to normalize an operation involving
     * all of them.
     */
    function correctionFactor() {
        var args = Array.prototype.slice.call(arguments);
        return args.reduce(function (prev, next) {
            var mp = multiplier(prev),
                mn = multiplier(next);
        return mp > mn ? mp : mn;
        }, -Infinity);
    }


    /************************************
        Numeral Prototype
    ************************************/


    numeral.fn = Numeral.prototype = {

        clone : function () {
            return numeral(this);
        },

        format : function (inputString, roundingFunction) {
            return formatNumeral(this,
                  inputString ? inputString : defaultFormat,
                  (roundingFunction !== undefined) ? roundingFunction : Math.round
              );
        },

        unformat : function (inputString) {
            if (Object.prototype.toString.call(inputString) === '[object Number]') {
                return inputString;
            }
            return unformatNumeral(this, inputString ? inputString : defaultFormat);
        },

        value : function () {
            return this._value;
        },

        valueOf : function () {
            return this._value;
        },

        set : function (value) {
            this._value = Number(value);
            return this;
        },

        add : function (value) {
            var corrFactor = correctionFactor.call(null, this._value, value);

            function cback(accum, curr, currI, O) {
                return accum + corrFactor * curr;
            }
            this._value = [this._value, value].reduce(cback, 0) / corrFactor;
            return this;
        },

        subtract : function (value) {
            var corrFactor = correctionFactor.call(null, this._value, value);

            function cback(accum, curr, currI, O) {
                return accum - corrFactor * curr;
            }
            this._value = [value].reduce(cback, this._value * corrFactor) / corrFactor;
            return this;
        },

        multiply : function (value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return (accum * corrFactor) * (curr * corrFactor) /
                    (corrFactor * corrFactor);
            }
            this._value = [this._value, value].reduce(cback, 1);
            return this;
        },

        divide : function (value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return (accum * corrFactor) / (curr * corrFactor);
            }
            this._value = [this._value, value].reduce(cback);
            return this;
        },

        difference : function (value) {
            return Math.abs(numeral(this._value).subtract(value).value());
        }

    };

    /************************************
        Exposing Numeral
    ************************************/

    // CommonJS module is defined
    if (hasModule) {
        module.exports = numeral;
    }

    /*global ender:false */
    if (typeof ender === 'undefined') {
        // here, `this` means `window` in the browser, or `global` on the server
        // add `numeral` as a global object via a string identifier,
        // for Closure Compiler 'advanced' mode
        this['numeral'] = numeral;
    }

    /*global define:false */
    if (typeof define === 'function' && define.amd) {
        define([], function () {
            return numeral;
        });
    }
}).call(window);

},{}],6:[function(require,module,exports){
/*!
 * Pikaday
 *
 * Copyright  2014 David Bushell | BSD & MIT license | https://github.com/dbushell/Pikaday
 */

(function (root, factory)
{
    'use strict';

    var moment;
    if (typeof exports === 'object') {
        // CommonJS module
        // Load moment.js as an optional dependency
        try { moment = require('moment'); } catch (e) {}
        module.exports = factory(moment);
    } else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(function (req)
        {
            // Load moment.js as an optional dependency
            var id = 'moment';
            try { moment = req(id); } catch (e) {}
            return factory(moment);
        });
    } else {
        root.Pikaday = factory(root.moment);
    }
}(this, function (moment)
{
    'use strict';

    /**
     * feature detection and helper functions
     */
    var hasMoment = typeof moment === 'function',

    hasEventListeners = !!window.addEventListener,

    document = window.document,

    sto = window.setTimeout,

    addEvent = function(el, e, callback, capture)
    {
        if (hasEventListeners) {
            el.addEventListener(e, callback, !!capture);
        } else {
            el.attachEvent('on' + e, callback);
        }
    },

    removeEvent = function(el, e, callback, capture)
    {
        if (hasEventListeners) {
            el.removeEventListener(e, callback, !!capture);
        } else {
            el.detachEvent('on' + e, callback);
        }
    },

    fireEvent = function(el, eventName, data)
    {
        var ev;

        if (document.createEvent) {
            ev = document.createEvent('HTMLEvents');
            ev.initEvent(eventName, true, false);
            ev = extend(ev, data);
            el.dispatchEvent(ev);
        } else if (document.createEventObject) {
            ev = document.createEventObject();
            ev = extend(ev, data);
            el.fireEvent('on' + eventName, ev);
        }
    },

    trim = function(str)
    {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g,'');
    },

    hasClass = function(el, cn)
    {
        return (' ' + el.className + ' ').indexOf(' ' + cn + ' ') !== -1;
    },

    addClass = function(el, cn)
    {
        if (!hasClass(el, cn)) {
            el.className = (el.className === '') ? cn : el.className + ' ' + cn;
        }
    },

    removeClass = function(el, cn)
    {
        el.className = trim((' ' + el.className + ' ').replace(' ' + cn + ' ', ' '));
    },

    isArray = function(obj)
    {
        return (/Array/).test(Object.prototype.toString.call(obj));
    },

    isDate = function(obj)
    {
        return (/Date/).test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime());
    },

    isWeekend = function(date)
    {
        var day = date.getDay();
        return day === 0 || day === 6;
    },

    isLeapYear = function(year)
    {
        // solution by Matti Virkkunen: http://stackoverflow.com/a/4881951
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    },

    getDaysInMonth = function(year, month)
    {
        return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
    },

    setToStartOfDay = function(date)
    {
        if (isDate(date)) date.setHours(0,0,0,0);
    },

    compareDates = function(a,b)
    {
        // weak date comparison (use setToStartOfDay(date) to ensure correct result)
        return a.getTime() === b.getTime();
    },

    extend = function(to, from, overwrite)
    {
        var prop, hasProp;
        for (prop in from) {
            hasProp = to[prop] !== undefined;
            if (hasProp && typeof from[prop] === 'object' && from[prop] !== null && from[prop].nodeName === undefined) {
                if (isDate(from[prop])) {
                    if (overwrite) {
                        to[prop] = new Date(from[prop].getTime());
                    }
                }
                else if (isArray(from[prop])) {
                    if (overwrite) {
                        to[prop] = from[prop].slice(0);
                    }
                } else {
                    to[prop] = extend({}, from[prop], overwrite);
                }
            } else if (overwrite || !hasProp) {
                to[prop] = from[prop];
            }
        }
        return to;
    },

    adjustCalendar = function(calendar) {
        if (calendar.month < 0) {
            calendar.year -= Math.ceil(Math.abs(calendar.month)/12);
            calendar.month += 12;
        }
        if (calendar.month > 11) {
            calendar.year += Math.floor(Math.abs(calendar.month)/12);
            calendar.month -= 12;
        }
        return calendar;
    },

    /**
     * defaults and localisation
     */
    defaults = {

        // bind the picker to a form field
        field: null,

        // automatically show/hide the picker on `field` focus (default `true` if `field` is set)
        bound: undefined,

        // position of the datepicker, relative to the field (default to bottom & left)
        // ('bottom' & 'left' keywords are not used, 'top' & 'right' are modifier on the bottom/left position)
        position: 'bottom left',

        // automatically fit in the viewport even if it means repositioning from the position option
        reposition: true,

        // the default output format for `.toString()` and `field` value
        format: 'YYYY-MM-DD',

        // the initial date to view when first opened
        defaultDate: null,

        // make the `defaultDate` the initial selected value
        setDefaultDate: false,

        // first day of week (0: Sunday, 1: Monday etc)
        firstDay: 0,

        // the minimum/earliest date that can be selected
        minDate: null,
        // the maximum/latest date that can be selected
        maxDate: null,

        // number of years either side, or array of upper/lower range
        yearRange: 10,

        // show week numbers at head of row
        showWeekNumber: false,

        // used internally (don't config outside)
        minYear: 0,
        maxYear: 9999,
        minMonth: undefined,
        maxMonth: undefined,

        startRange: null,
        endRange: null,

        isRTL: false,

        // Additional text to append to the year in the calendar title
        yearSuffix: '',

        // Render the month after year in the calendar title
        showMonthAfterYear: false,

        // how many months are visible
        numberOfMonths: 1,

        // when numberOfMonths is used, this will help you to choose where the main calendar will be (default `left`, can be set to `right`)
        // only used for the first display or when a selected date is not visible
        mainCalendar: 'left',

        // Specify a DOM element to render the calendar in
        container: undefined,

        // internationalization
        i18n: {
            previousMonth : 'Previous Month',
            nextMonth     : 'Next Month',
            months        : ['January','February','March','April','May','June','July','August','September','October','November','December'],
            weekdays      : ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],
            weekdaysShort : ['Sun','Mon','Tue','Wed','Thu','Fri','Sat']
        },

        // Theme Classname
        theme: null,

        // callback function
        onSelect: null,
        onOpen: null,
        onClose: null,
        onDraw: null
    },


    /**
     * templating functions to abstract HTML rendering
     */
    renderDayName = function(opts, day, abbr)
    {
        day += opts.firstDay;
        while (day >= 7) {
            day -= 7;
        }
        return abbr ? opts.i18n.weekdaysShort[day] : opts.i18n.weekdays[day];
    },

    renderDay = function(opts)
    {
        if (opts.isEmpty) {
            return '<td class="is-empty"></td>';
        }
        var arr = [];
        if (opts.isDisabled) {
            arr.push('is-disabled');
        }
        if (opts.isToday) {
            arr.push('is-today');
        }
        if (opts.isSelected) {
            arr.push('is-selected');
        }
        if (opts.isInRange) {
            arr.push('is-inrange');
        }
        if (opts.isStartRange) {
            arr.push('is-startrange');
        }
        if (opts.isEndRange) {
            arr.push('is-endrange');
        }
        return '<td data-day="' + opts.day + '" class="' + arr.join(' ') + '">' +
                 '<button class="pika-button pika-day" type="button" ' +
                    'data-pika-year="' + opts.year + '" data-pika-month="' + opts.month + '" data-pika-day="' + opts.day + '">' +
                        opts.day +
                 '</button>' +
               '</td>';
    },

    renderWeek = function (d, m, y) {
        // Lifted from http://javascript.about.com/library/blweekyear.htm, lightly modified.
        var onejan = new Date(y, 0, 1),
            weekNum = Math.ceil((((new Date(y, m, d) - onejan) / 86400000) + onejan.getDay()+1)/7);
        return '<td class="pika-week">' + weekNum + '</td>';
    },

    renderRow = function(days, isRTL)
    {
        return '<tr>' + (isRTL ? days.reverse() : days).join('') + '</tr>';
    },

    renderBody = function(rows)
    {
        return '<tbody>' + rows.join('') + '</tbody>';
    },

    renderHead = function(opts)
    {
        var i, arr = [];
        if (opts.showWeekNumber) {
            arr.push('<th></th>');
        }
        for (i = 0; i < 7; i++) {
            arr.push('<th scope="col"><abbr title="' + renderDayName(opts, i) + '">' + renderDayName(opts, i, true) + '</abbr></th>');
        }
        return '<thead>' + (opts.isRTL ? arr.reverse() : arr).join('') + '</thead>';
    },

    renderTitle = function(instance, c, year, month, refYear)
    {
        var i, j, arr,
            opts = instance._o,
            isMinYear = year === opts.minYear,
            isMaxYear = year === opts.maxYear,
            html = '<div class="pika-title">',
            monthHtml,
            yearHtml,
            prev = true,
            next = true;

        for (arr = [], i = 0; i < 12; i++) {
            arr.push('<option value="' + (year === refYear ? i - c : 12 + i - c) + '"' +
                (i === month ? ' selected': '') +
                ((isMinYear && i < opts.minMonth) || (isMaxYear && i > opts.maxMonth) ? 'disabled' : '') + '>' +
                opts.i18n.months[i] + '</option>');
        }
        monthHtml = '<div class="pika-label">' + opts.i18n.months[month] + '<select class="pika-select pika-select-month" tabindex="-1">' + arr.join('') + '</select></div>';

        if (isArray(opts.yearRange)) {
            i = opts.yearRange[0];
            j = opts.yearRange[1] + 1;
        } else {
            i = year - opts.yearRange;
            j = 1 + year + opts.yearRange;
        }

        for (arr = []; i < j && i <= opts.maxYear; i++) {
            if (i >= opts.minYear) {
                arr.push('<option value="' + i + '"' + (i === year ? ' selected': '') + '>' + (i) + '</option>');
            }
        }
        yearHtml = '<div class="pika-label">' + year + opts.yearSuffix + '<select class="pika-select pika-select-year" tabindex="-1">' + arr.join('') + '</select></div>';

        if (opts.showMonthAfterYear) {
            html += yearHtml + monthHtml;
        } else {
            html += monthHtml + yearHtml;
        }

        if (isMinYear && (month === 0 || opts.minMonth >= month)) {
            prev = false;
        }

        if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {
            next = false;
        }

        if (c === 0) {
            html += '<button class="pika-prev' + (prev ? '' : ' is-disabled') + '" type="button">' + opts.i18n.previousMonth + '</button>';
        }
        if (c === (instance._o.numberOfMonths - 1) ) {
            html += '<button class="pika-next' + (next ? '' : ' is-disabled') + '" type="button">' + opts.i18n.nextMonth + '</button>';
        }

        return html += '</div>';
    },

    renderTable = function(opts, data)
    {
        return '<table cellpadding="0" cellspacing="0" class="pika-table">' + renderHead(opts) + renderBody(data) + '</table>';
    },


    /**
     * Pikaday constructor
     */
    Pikaday = function(options)
    {
        var self = this,
            opts = self.config(options);

        self._onMouseDown = function(e)
        {
            if (!self._v) {
                return;
            }
            e = e || window.event;
            var target = e.target || e.srcElement;
            if (!target) {
                return;
            }

            if (!hasClass(target.parentNode, 'is-disabled')) {
                if (hasClass(target, 'pika-button') && !hasClass(target, 'is-empty')) {
                    self.setDate(new Date(target.getAttribute('data-pika-year'), target.getAttribute('data-pika-month'), target.getAttribute('data-pika-day')));
                    if (opts.bound) {
                        sto(function() {
                            self.hide();
                            if (opts.field) {
                                opts.field.blur();
                            }
                        }, 100);
                    }
                    return;
                }
                else if (hasClass(target, 'pika-prev')) {
                    self.prevMonth();
                }
                else if (hasClass(target, 'pika-next')) {
                    self.nextMonth();
                }
            }
            if (!hasClass(target, 'pika-select')) {
                if (e.preventDefault) {
                    e.preventDefault();
                } else {
                    e.returnValue = false;
                    return false;
                }
            } else {
                self._c = true;
            }
        };

        self._onChange = function(e)
        {
            e = e || window.event;
            var target = e.target || e.srcElement;
            if (!target) {
                return;
            }
            if (hasClass(target, 'pika-select-month')) {
                self.gotoMonth(target.value);
            }
            else if (hasClass(target, 'pika-select-year')) {
                self.gotoYear(target.value);
            }
        };

        self._onInputChange = function(e)
        {
            var date;

            if (e.firedBy === self) {
                return;
            }
            if (hasMoment) {
                date = moment(opts.field.value, opts.format);
                date = (date && date.isValid()) ? date.toDate() : null;
            }
            else {
                date = new Date(Date.parse(opts.field.value));
            }
            if (isDate(date)) {
              self.setDate(date);
            }
            if (!self._v) {
                self.show();
            }
        };

        self._onInputFocus = function()
        {
            self.show();
        };

        self._onInputClick = function()
        {
            self.show();
        };

        self._onInputBlur = function()
        {
            // IE allows pika div to gain focus; catch blur the input field
            var pEl = document.activeElement;
            do {
                if (hasClass(pEl, 'pika-single')) {
                    return;
                }
            }
            while ((pEl = pEl.parentNode));

            if (!self._c) {
                self._b = sto(function() {
                    self.hide();
                }, 50);
            }
            self._c = false;
        };

        self._onClick = function(e)
        {
            e = e || window.event;
            var target = e.target || e.srcElement,
                pEl = target;
            if (!target) {
                return;
            }
            if (!hasEventListeners && hasClass(target, 'pika-select')) {
                if (!target.onchange) {
                    target.setAttribute('onchange', 'return;');
                    addEvent(target, 'change', self._onChange);
                }
            }
            do {
                if (hasClass(pEl, 'pika-single') || pEl === opts.trigger) {
                    return;
                }
            }
            while ((pEl = pEl.parentNode));
            if (self._v && target !== opts.trigger && pEl !== opts.trigger) {
                self.hide();
            }
        };

        self.el = document.createElement('div');
        self.el.className = 'pika-single' + (opts.isRTL ? ' is-rtl' : '') + (opts.theme ? ' ' + opts.theme : '');

        addEvent(self.el, 'ontouchend' in document ? 'touchend' : 'mousedown', self._onMouseDown, true);
        addEvent(self.el, 'change', self._onChange);

        if (opts.field) {
            if (opts.container) {
                opts.container.appendChild(self.el);
            } else if (opts.bound) {
                document.body.appendChild(self.el);
            } else {
                opts.field.parentNode.insertBefore(self.el, opts.field.nextSibling);
            }
            addEvent(opts.field, 'change', self._onInputChange);

            if (!opts.defaultDate) {
                if (hasMoment && opts.field.value) {
                    opts.defaultDate = moment(opts.field.value, opts.format).toDate();
                } else {
                    opts.defaultDate = new Date(Date.parse(opts.field.value));
                }
                opts.setDefaultDate = true;
            }
        }

        var defDate = opts.defaultDate;

        if (isDate(defDate)) {
            if (opts.setDefaultDate) {
                self.setDate(defDate, true);
            } else {
                self.gotoDate(defDate);
            }
        } else {
            self.gotoDate(new Date());
        }

        if (opts.bound) {
            this.hide();
            self.el.className += ' is-bound';
            addEvent(opts.trigger, 'click', self._onInputClick);
            addEvent(opts.trigger, 'focus', self._onInputFocus);
            addEvent(opts.trigger, 'blur', self._onInputBlur);
        } else {
            this.show();
        }
    };


    /**
     * public Pikaday API
     */
    Pikaday.prototype = {


        /**
         * configure functionality
         */
        config: function(options)
        {
            if (!this._o) {
                this._o = extend({}, defaults, true);
            }

            var opts = extend(this._o, options, true);

            opts.isRTL = !!opts.isRTL;

            opts.field = (opts.field && opts.field.nodeName) ? opts.field : null;

            opts.theme = (typeof opts.theme) === 'string' && opts.theme ? opts.theme : null;

            opts.bound = !!(opts.bound !== undefined ? opts.field && opts.bound : opts.field);

            opts.trigger = (opts.trigger && opts.trigger.nodeName) ? opts.trigger : opts.field;

            opts.disableWeekends = !!opts.disableWeekends;

            opts.disableDayFn = (typeof opts.disableDayFn) === 'function' ? opts.disableDayFn : null;

            var nom = parseInt(opts.numberOfMonths, 10) || 1;
            opts.numberOfMonths = nom > 4 ? 4 : nom;

            if (!isDate(opts.minDate)) {
                opts.minDate = false;
            }
            if (!isDate(opts.maxDate)) {
                opts.maxDate = false;
            }
            if ((opts.minDate && opts.maxDate) && opts.maxDate < opts.minDate) {
                opts.maxDate = opts.minDate = false;
            }
            if (opts.minDate) {
                this.setMinDate(opts.minDate);
            }
            if (opts.maxDate) {
                setToStartOfDay(opts.maxDate);
                opts.maxYear  = opts.maxDate.getFullYear();
                opts.maxMonth = opts.maxDate.getMonth();
            }

            if (isArray(opts.yearRange)) {
                var fallback = new Date().getFullYear() - 10;
                opts.yearRange[0] = parseInt(opts.yearRange[0], 10) || fallback;
                opts.yearRange[1] = parseInt(opts.yearRange[1], 10) || fallback;
            } else {
                opts.yearRange = Math.abs(parseInt(opts.yearRange, 10)) || defaults.yearRange;
                if (opts.yearRange > 100) {
                    opts.yearRange = 100;
                }
            }

            return opts;
        },

        /**
         * return a formatted string of the current selection (using Moment.js if available)
         */
        toString: function(format)
        {
            return !isDate(this._d) ? '' : hasMoment ? moment(this._d).format(format || this._o.format) : this._d.toDateString();
        },

        /**
         * return a Moment.js object of the current selection (if available)
         */
        getMoment: function()
        {
            return hasMoment ? moment(this._d) : null;
        },

        /**
         * set the current selection from a Moment.js object (if available)
         */
        setMoment: function(date, preventOnSelect)
        {
            if (hasMoment && moment.isMoment(date)) {
                this.setDate(date.toDate(), preventOnSelect);
            }
        },

        /**
         * return a Date object of the current selection
         */
        getDate: function()
        {
            return isDate(this._d) ? new Date(this._d.getTime()) : null;
        },

        /**
         * set the current selection
         */
        setDate: function(date, preventOnSelect)
        {
            if (!date) {
                this._d = null;

                if (this._o.field) {
                    this._o.field.value = '';
                    fireEvent(this._o.field, 'change', { firedBy: this });
                }

                return this.draw();
            }
            if (typeof date === 'string') {
                date = new Date(Date.parse(date));
            }
            if (!isDate(date)) {
                return;
            }

            var min = this._o.minDate,
                max = this._o.maxDate;

            if (isDate(min) && date < min) {
                date = min;
            } else if (isDate(max) && date > max) {
                date = max;
            }

            this._d = new Date(date.getTime());
            setToStartOfDay(this._d);
            this.gotoDate(this._d);

            if (this._o.field) {
                this._o.field.value = this.toString();
                fireEvent(this._o.field, 'change', { firedBy: this });
            }
            if (!preventOnSelect && typeof this._o.onSelect === 'function') {
                this._o.onSelect.call(this, this.getDate());
            }
        },

        /**
         * change view to a specific date
         */
        gotoDate: function(date)
        {
            var newCalendar = true;

            if (!isDate(date)) {
                return;
            }

            if (this.calendars) {
                var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1),
                    lastVisibleDate = new Date(this.calendars[this.calendars.length-1].year, this.calendars[this.calendars.length-1].month, 1),
                    visibleDate = date.getTime();
                // get the end of the month
                lastVisibleDate.setMonth(lastVisibleDate.getMonth()+1);
                lastVisibleDate.setDate(lastVisibleDate.getDate()-1);
                newCalendar = (visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate);
            }

            if (newCalendar) {
                this.calendars = [{
                    month: date.getMonth(),
                    year: date.getFullYear()
                }];
                if (this._o.mainCalendar === 'right') {
                    this.calendars[0].month += 1 - this._o.numberOfMonths;
                }
            }

            this.adjustCalendars();
        },

        adjustCalendars: function() {
            this.calendars[0] = adjustCalendar(this.calendars[0]);
            for (var c = 1; c < this._o.numberOfMonths; c++) {
                this.calendars[c] = adjustCalendar({
                    month: this.calendars[0].month + c,
                    year: this.calendars[0].year
                });
            }
            this.draw();
        },

        gotoToday: function()
        {
            this.gotoDate(new Date());
        },

        /**
         * change view to a specific month (zero-index, e.g. 0: January)
         */
        gotoMonth: function(month)
        {
            if (!isNaN(month)) {
                this.calendars[0].month = parseInt(month, 10);
                this.adjustCalendars();
            }
        },

        nextMonth: function()
        {
            this.calendars[0].month++;
            this.adjustCalendars();
        },

        prevMonth: function()
        {
            this.calendars[0].month--;
            this.adjustCalendars();
        },

        /**
         * change view to a specific full year (e.g. "2012")
         */
        gotoYear: function(year)
        {
            if (!isNaN(year)) {
                this.calendars[0].year = parseInt(year, 10);
                this.adjustCalendars();
            }
        },

        /**
         * change the minDate
         */
        setMinDate: function(value)
        {
            setToStartOfDay(value);
            this._o.minDate = value;
            this._o.minYear  = value.getFullYear();
            this._o.minMonth = value.getMonth();
        },

        /**
         * change the maxDate
         */
        setMaxDate: function(value)
        {
            this._o.maxDate = value;
        },

        setStartRange: function(value)
        {
            this._o.startRange = value;
        },

        setEndRange: function(value)
        {
            this._o.endRange = value;
        },

        /**
         * refresh the HTML
         */
        draw: function(force)
        {
            if (!this._v && !force) {
                return;
            }
            var opts = this._o,
                minYear = opts.minYear,
                maxYear = opts.maxYear,
                minMonth = opts.minMonth,
                maxMonth = opts.maxMonth,
                html = '';

            if (this._y <= minYear) {
                this._y = minYear;
                if (!isNaN(minMonth) && this._m < minMonth) {
                    this._m = minMonth;
                }
            }
            if (this._y >= maxYear) {
                this._y = maxYear;
                if (!isNaN(maxMonth) && this._m > maxMonth) {
                    this._m = maxMonth;
                }
            }

            for (var c = 0; c < opts.numberOfMonths; c++) {
                html += '<div class="pika-lendar">' + renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year) + this.render(this.calendars[c].year, this.calendars[c].month) + '</div>';
            }

            this.el.innerHTML = html;

            if (opts.bound) {
                if(opts.field.type !== 'hidden') {
                    sto(function() {
                        opts.trigger.focus();
                    }, 1);
                }
            }

            if (typeof this._o.onDraw === 'function') {
                var self = this;
                sto(function() {
                    self._o.onDraw.call(self);
                }, 0);
            }
        },

        adjustPosition: function()
        {
            var field, pEl, width, height, viewportWidth, viewportHeight, scrollTop, left, top, clientRect;
            
            if (this._o.container) return;
            
            this.el.style.position = 'absolute';
            
            field = this._o.trigger;
            pEl = field;
            width = this.el.offsetWidth;
            height = this.el.offsetHeight;
            viewportWidth = window.innerWidth || document.documentElement.clientWidth;
            viewportHeight = window.innerHeight || document.documentElement.clientHeight;
            scrollTop = window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop;

            if (typeof field.getBoundingClientRect === 'function') {
                clientRect = field.getBoundingClientRect();
                left = clientRect.left + window.pageXOffset;
                top = clientRect.bottom + window.pageYOffset;
            } else {
                left = pEl.offsetLeft;
                top  = pEl.offsetTop + pEl.offsetHeight;
                while((pEl = pEl.offsetParent)) {
                    left += pEl.offsetLeft;
                    top  += pEl.offsetTop;
                }
            }

            // default position is bottom & left
            if ((this._o.reposition && left + width > viewportWidth) ||
                (
                    this._o.position.indexOf('right') > -1 &&
                    left - width + field.offsetWidth > 0
                )
            ) {
                left = left - width + field.offsetWidth;
            }
            if ((this._o.reposition && top + height > viewportHeight + scrollTop) ||
                (
                    this._o.position.indexOf('top') > -1 &&
                    top - height - field.offsetHeight > 0
                )
            ) {
                top = top - height - field.offsetHeight;
            }

            this.el.style.left = left + 'px';
            this.el.style.top = top + 'px';
        },

        /**
         * render HTML for a particular month
         */
        render: function(year, month)
        {
            var opts   = this._o,
                now    = new Date(),
                days   = getDaysInMonth(year, month),
                before = new Date(year, month, 1).getDay(),
                data   = [],
                row    = [];
            setToStartOfDay(now);
            if (opts.firstDay > 0) {
                before -= opts.firstDay;
                if (before < 0) {
                    before += 7;
                }
            }
            var cells = days + before,
                after = cells;
            while(after > 7) {
                after -= 7;
            }
            cells += 7 - after;
            for (var i = 0, r = 0; i < cells; i++)
            {
                var dayConfig,
                    day = new Date(year, month, 1 + (i - before)),
                    isSelected = isDate(this._d) ? compareDates(day, this._d) : false,
                    isToday = compareDates(day, now),
                    isEmpty = i < before || i >= (days + before),
                    isStartRange = opts.startRange && compareDates(opts.startRange, day),
                    isEndRange = opts.endRange && compareDates(opts.endRange, day),
                    isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange,
                    isDisabled = (opts.minDate && day < opts.minDate) ||
                                 (opts.maxDate && day > opts.maxDate) ||
                                 (opts.disableWeekends && isWeekend(day)) ||
                                 (opts.disableDayFn && opts.disableDayFn(day)),
                    dayConfig = {
                        day: 1 + (i - before),
                        month: month,
                        year: year,
                        isSelected: isSelected,
                        isToday: isToday,
                        isDisabled: isDisabled,
                        isEmpty: isEmpty,
                        isStartRange: isStartRange,
                        isEndRange: isEndRange,
                        isInRange: isInRange
                    };

                row.push(renderDay(dayConfig));

                if (++r === 7) {
                    if (opts.showWeekNumber) {
                        row.unshift(renderWeek(i - before, month, year));
                    }
                    data.push(renderRow(row, opts.isRTL));
                    row = [];
                    r = 0;
                }
            }
            return renderTable(opts, data);
        },

        isVisible: function()
        {
            return this._v;
        },

        show: function()
        {
            if (!this._v) {
                removeClass(this.el, 'is-hidden');
                this._v = true;
                this.draw();
                if (this._o.bound) {
                    addEvent(document, 'click', this._onClick);
                    this.adjustPosition();
                }
                if (typeof this._o.onOpen === 'function') {
                    this._o.onOpen.call(this);
                }
            }
        },

        hide: function()
        {
            var v = this._v;
            if (v !== false) {
                if (this._o.bound) {
                    removeEvent(document, 'click', this._onClick);
                }
                this.el.style.position = 'static'; // reset
                this.el.style.left = 'auto';
                this.el.style.top = 'auto';
                addClass(this.el, 'is-hidden');
                this._v = false;
                if (v !== undefined && typeof this._o.onClose === 'function') {
                    this._o.onClose.call(this);
                }
            }
        },

        /**
         * GAME OVER
         */
        destroy: function()
        {
            this.hide();
            removeEvent(this.el, 'mousedown', this._onMouseDown, true);
            removeEvent(this.el, 'change', this._onChange);
            if (this._o.field) {
                removeEvent(this._o.field, 'change', this._onInputChange);
                if (this._o.bound) {
                    removeEvent(this._o.trigger, 'click', this._onInputClick);
                    removeEvent(this._o.trigger, 'focus', this._onInputFocus);
                    removeEvent(this._o.trigger, 'blur', this._onInputBlur);
                }
            }
            if (this.el.parentNode) {
                this.el.parentNode.removeChild(this.el);
            }
        }

    };

    return Pikaday;

}));

},{"moment":4}],7:[function(require,module,exports){
'use strict';

if (window.jQuery) {
  (function (window, $, Handsontable) {
    $.fn.handsontable = function (action) {
      var i,
          ilen,
          args,
          output,
          userSettings,
          $this = this.first(),
          // Use only first element from list
      instance = $this.data('handsontable');

      // Init case
      if (typeof action !== 'string') {
        userSettings = action || {};
        if (instance) {
          instance.updateSettings(userSettings);
        } else {
          instance = new Handsontable.Core($this[0], userSettings);
          $this.data('handsontable', instance);
          instance.init();
        }

        return $this;
      }
      // Action case
      else {
          args = [];
          if (arguments.length > 1) {
            for (i = 1, ilen = arguments.length; i < ilen; i++) {
              args.push(arguments[i]);
            }
          }

          if (instance) {
            if (typeof instance[action] !== 'undefined') {
              output = instance[action].apply(instance, args);

              if (action === 'destroy') {
                $this.removeData();
              }
            } else {
              throw new Error('Handsontable do not provide action: ' + action);
            }
          }

          return output;
        }
    };
  })(window, jQuery, Handsontable);
}

},{}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _helpersDomElement = require('./../../../helpers/dom/element');

var _helpersDomEvent = require('./../../../helpers/dom/event');

var _eventManager = require('./../../../eventManager');

var _cellCoords = require('./cell/coords');

var WalkontableBorder = (function () {
  /**
   * @param {Walkontable} wotInstance
   * @param {Object} settings
   */

  function WalkontableBorder(wotInstance, settings) {
    _classCallCheck(this, WalkontableBorder);

    if (!settings) {
      return;
    }
    this.eventManager = new _eventManager.EventManager(wotInstance);
    this.instance = wotInstance;
    this.wot = wotInstance;
    this.settings = settings;
    this.mouseDown = false;
    this.main = null;

    this.top = null;
    this.left = null;
    this.bottom = null;
    this.right = null;

    this.topStyle = null;
    this.leftStyle = null;
    this.bottomStyle = null;
    this.rightStyle = null;

    this.cornerDefaultStyle = {
      width: '5px',
      height: '5px',
      borderWidth: '2px',
      borderStyle: 'solid',
      borderColor: '#FFF'
    };
    this.corner = null;
    this.cornerStyle = null;

    this.createBorders(settings);
    this.registerListeners();
  }

  /**
   * Register all necessary events
   */

  _createClass(WalkontableBorder, [{
    key: 'registerListeners',
    value: function registerListeners() {
      var _this2 = this;

      this.eventManager.addEventListener(document.body, 'mousedown', function () {
        return _this2.onMouseDown();
      });
      this.eventManager.addEventListener(document.body, 'mouseup', function () {
        return _this2.onMouseUp();
      });

      for (var c = 0, len = this.main.childNodes.length; c < len; c++) {
        this.eventManager.addEventListener(this.main.childNodes[c], 'mouseenter', function (event) {
          return _this2.onMouseEnter(event);
        });
      }
    }

    /**
     * Mouse down listener
     *
     * @private
     */
  }, {
    key: 'onMouseDown',
    value: function onMouseDown() {
      this.mouseDown = true;
    }

    /**
     * Mouse up listener
     *
     * @private
     */
  }, {
    key: 'onMouseUp',
    value: function onMouseUp() {
      this.mouseDown = false;
    }

    /**
     * Mouse enter listener
     *
     * @private
     * @param {Event} event Dom event
     */
  }, {
    key: 'onMouseEnter',
    value: function onMouseEnter(event) {
      if (!this.mouseDown || !this.wot.getSetting('hideBorderOnMouseDownOver')) {
        return;
      }
      event.preventDefault();
      (0, _helpersDomEvent.stopImmediatePropagation)(event);

      var _this = this;
      var bounds = this.getBoundingClientRect();
      this.style.display = 'none';

      function isOutside(event) {
        if (event.clientY < Math.floor(bounds.top)) {
          return true;
        }
        if (event.clientY > Math.ceil(bounds.top + bounds.height)) {
          return true;
        }
        if (event.clientX < Math.floor(bounds.left)) {
          return true;
        }
        if (event.clientX > Math.ceil(bounds.left + bounds.width)) {
          return true;
        }
      }
      function handler(event) {
        if (isOutside(event)) {
          _this.eventManager.removeEventListener(document.body, 'mousemove', handler);
          _this.style.display = 'block';
        }
      }
      this.eventManager.addEventListener(document.body, 'mousemove', handler);
    }

    /**
     * Create border elements
     *
     * @param {Object} settings
     */
  }, {
    key: 'createBorders',
    value: function createBorders(settings) {
      this.main = document.createElement('div');

      var borderDivs = ['top', 'left', 'bottom', 'right', 'corner'];
      var style = this.main.style;
      style.position = 'absolute';
      style.top = 0;
      style.left = 0;

      for (var i = 0; i < 5; i++) {
        var position = borderDivs[i];
        var div = document.createElement('div');
        div.className = 'wtBorder ' + (this.settings.className || ''); // + borderDivs[i];

        if (this.settings[position] && this.settings[position].hide) {
          div.className += ' hidden';
        }
        style = div.style;
        style.backgroundColor = this.settings[position] && this.settings[position].color ? this.settings[position].color : settings.border.color;
        style.height = this.settings[position] && this.settings[position].width ? this.settings[position].width + 'px' : settings.border.width + 'px';
        style.width = this.settings[position] && this.settings[position].width ? this.settings[position].width + 'px' : settings.border.width + 'px';

        this.main.appendChild(div);
      }
      this.top = this.main.childNodes[0];
      this.left = this.main.childNodes[1];
      this.bottom = this.main.childNodes[2];
      this.right = this.main.childNodes[3];

      this.topStyle = this.top.style;
      this.leftStyle = this.left.style;
      this.bottomStyle = this.bottom.style;
      this.rightStyle = this.right.style;

      this.corner = this.main.childNodes[4];
      this.corner.className += ' corner';
      this.cornerStyle = this.corner.style;
      this.cornerStyle.width = this.cornerDefaultStyle.width;
      this.cornerStyle.height = this.cornerDefaultStyle.height;
      this.cornerStyle.border = [this.cornerDefaultStyle.borderWidth, this.cornerDefaultStyle.borderStyle, this.cornerDefaultStyle.borderColor].join(' ');

      if (Handsontable.mobileBrowser) {
        this.createMultipleSelectorHandles();
      }
      this.disappear();

      if (!this.wot.wtTable.bordersHolder) {
        this.wot.wtTable.bordersHolder = document.createElement('div');
        this.wot.wtTable.bordersHolder.className = 'htBorders';
        this.wot.wtTable.spreader.appendChild(this.wot.wtTable.bordersHolder);
      }
      this.wot.wtTable.bordersHolder.insertBefore(this.main, this.wot.wtTable.bordersHolder.firstChild);
    }

    /**
     * Create multiple selector handler for mobile devices
     */
  }, {
    key: 'createMultipleSelectorHandles',
    value: function createMultipleSelectorHandles() {
      this.selectionHandles = {
        topLeft: document.createElement('DIV'),
        topLeftHitArea: document.createElement('DIV'),
        bottomRight: document.createElement('DIV'),
        bottomRightHitArea: document.createElement('DIV')
      };
      var width = 10;
      var hitAreaWidth = 40;

      this.selectionHandles.topLeft.className = 'topLeftSelectionHandle';
      this.selectionHandles.topLeftHitArea.className = 'topLeftSelectionHandle-HitArea';
      this.selectionHandles.bottomRight.className = 'bottomRightSelectionHandle';
      this.selectionHandles.bottomRightHitArea.className = 'bottomRightSelectionHandle-HitArea';

      this.selectionHandles.styles = {
        topLeft: this.selectionHandles.topLeft.style,
        topLeftHitArea: this.selectionHandles.topLeftHitArea.style,
        bottomRight: this.selectionHandles.bottomRight.style,
        bottomRightHitArea: this.selectionHandles.bottomRightHitArea.style
      };

      var hitAreaStyle = {
        'position': 'absolute',
        'height': hitAreaWidth + 'px',
        'width': hitAreaWidth + 'px',
        'border-radius': parseInt(hitAreaWidth / 1.5, 10) + 'px'
      };

      for (var prop in hitAreaStyle) {
        if (hitAreaStyle.hasOwnProperty(prop)) {
          this.selectionHandles.styles.bottomRightHitArea[prop] = hitAreaStyle[prop];
          this.selectionHandles.styles.topLeftHitArea[prop] = hitAreaStyle[prop];
        }
      }

      var handleStyle = {
        'position': 'absolute',
        'height': width + 'px',
        'width': width + 'px',
        'border-radius': parseInt(width / 1.5, 10) + 'px',
        'background': '#F5F5FF',
        'border': '1px solid #4285c8'
      };

      for (var prop in handleStyle) {
        if (handleStyle.hasOwnProperty(prop)) {
          this.selectionHandles.styles.bottomRight[prop] = handleStyle[prop];
          this.selectionHandles.styles.topLeft[prop] = handleStyle[prop];
        }
      }
      this.main.appendChild(this.selectionHandles.topLeft);
      this.main.appendChild(this.selectionHandles.bottomRight);
      this.main.appendChild(this.selectionHandles.topLeftHitArea);
      this.main.appendChild(this.selectionHandles.bottomRightHitArea);
    }
  }, {
    key: 'isPartRange',
    value: function isPartRange(row, col) {
      if (this.wot.selections.area.cellRange) {
        if (row != this.wot.selections.area.cellRange.to.row || col != this.wot.selections.area.cellRange.to.col) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: 'updateMultipleSelectionHandlesPosition',
    value: function updateMultipleSelectionHandlesPosition(row, col, top, left, width, height) {
      var handleWidth = parseInt(this.selectionHandles.styles.topLeft.width, 10);
      var hitAreaWidth = parseInt(this.selectionHandles.styles.topLeftHitArea.width, 10);

      this.selectionHandles.styles.topLeft.top = parseInt(top - handleWidth, 10) + "px";
      this.selectionHandles.styles.topLeft.left = parseInt(left - handleWidth, 10) + "px";

      this.selectionHandles.styles.topLeftHitArea.top = parseInt(top - hitAreaWidth / 4 * 3, 10) + "px";
      this.selectionHandles.styles.topLeftHitArea.left = parseInt(left - hitAreaWidth / 4 * 3, 10) + "px";

      this.selectionHandles.styles.bottomRight.top = parseInt(top + height, 10) + "px";
      this.selectionHandles.styles.bottomRight.left = parseInt(left + width, 10) + "px";

      this.selectionHandles.styles.bottomRightHitArea.top = parseInt(top + height - hitAreaWidth / 4, 10) + "px";
      this.selectionHandles.styles.bottomRightHitArea.left = parseInt(left + width - hitAreaWidth / 4, 10) + "px";

      if (this.settings.border.multipleSelectionHandlesVisible && this.settings.border.multipleSelectionHandlesVisible()) {
        this.selectionHandles.styles.topLeft.display = "block";
        this.selectionHandles.styles.topLeftHitArea.display = "block";

        if (!this.isPartRange(row, col)) {
          this.selectionHandles.styles.bottomRight.display = "block";
          this.selectionHandles.styles.bottomRightHitArea.display = "block";
        } else {
          this.selectionHandles.styles.bottomRight.display = "none";
          this.selectionHandles.styles.bottomRightHitArea.display = "none";
        }
      } else {
        this.selectionHandles.styles.topLeft.display = "none";
        this.selectionHandles.styles.bottomRight.display = "none";
        this.selectionHandles.styles.topLeftHitArea.display = "none";
        this.selectionHandles.styles.bottomRightHitArea.display = "none";
      }

      if (row == this.wot.wtSettings.getSetting('fixedRowsTop') || col == this.wot.wtSettings.getSetting('fixedColumnsLeft')) {
        this.selectionHandles.styles.topLeft.zIndex = "9999";
        this.selectionHandles.styles.topLeftHitArea.zIndex = "9999";
      } else {
        this.selectionHandles.styles.topLeft.zIndex = "";
        this.selectionHandles.styles.topLeftHitArea.zIndex = "";
      }
    }

    /**
     * Show border around one or many cells
     *
     * @param {Array} corners
     */
  }, {
    key: 'appear',
    value: function appear(corners) {
      if (this.disabled) {
        return;
      }
      var isMultiple, fromTD, toTD, fromOffset, toOffset, containerOffset, top, minTop, left, minLeft, height, width, fromRow, fromColumn, toRow, toColumn, ilen;

      if (this.wot.cloneOverlay instanceof WalkontableTopOverlay || this.wot.cloneOverlay instanceof WalkontableCornerOverlay) {
        ilen = this.wot.getSetting('fixedRowsTop');
      } else {
        ilen = this.wot.wtTable.getRenderedRowsCount();
      }

      for (var i = 0; i < ilen; i++) {
        var s = this.wot.wtTable.rowFilter.renderedToSource(i);

        if (s >= corners[0] && s <= corners[2]) {
          fromRow = s;
          break;
        }
      }

      for (var i = ilen - 1; i >= 0; i--) {
        var s = this.wot.wtTable.rowFilter.renderedToSource(i);

        if (s >= corners[0] && s <= corners[2]) {
          toRow = s;
          break;
        }
      }

      ilen = this.wot.wtTable.getRenderedColumnsCount();

      for (var i = 0; i < ilen; i++) {
        var s = this.wot.wtTable.columnFilter.renderedToSource(i);

        if (s >= corners[1] && s <= corners[3]) {
          fromColumn = s;
          break;
        }
      }

      for (var i = ilen - 1; i >= 0; i--) {
        var s = this.wot.wtTable.columnFilter.renderedToSource(i);

        if (s >= corners[1] && s <= corners[3]) {
          toColumn = s;
          break;
        }
      }
      if (fromRow === void 0 || fromColumn === void 0) {
        this.disappear();

        return;
      }
      isMultiple = fromRow !== toRow || fromColumn !== toColumn;
      fromTD = this.wot.wtTable.getCell(new _cellCoords.WalkontableCellCoords(fromRow, fromColumn));
      toTD = isMultiple ? this.wot.wtTable.getCell(new _cellCoords.WalkontableCellCoords(toRow, toColumn)) : fromTD;
      fromOffset = (0, _helpersDomElement.offset)(fromTD);
      toOffset = isMultiple ? (0, _helpersDomElement.offset)(toTD) : fromOffset;
      containerOffset = (0, _helpersDomElement.offset)(this.wot.wtTable.TABLE);

      minTop = fromOffset.top;
      height = toOffset.top + (0, _helpersDomElement.outerHeight)(toTD) - minTop;
      minLeft = fromOffset.left;
      width = toOffset.left + (0, _helpersDomElement.outerWidth)(toTD) - minLeft;

      top = minTop - containerOffset.top - 1;
      left = minLeft - containerOffset.left - 1;
      var style = (0, _helpersDomElement.getComputedStyle)(fromTD);

      if (parseInt(style.borderTopWidth, 10) > 0) {
        top += 1;
        height = height > 0 ? height - 1 : 0;
      }
      if (parseInt(style.borderLeftWidth, 10) > 0) {
        left += 1;
        width = width > 0 ? width - 1 : 0;
      }

      this.topStyle.top = top + 'px';
      this.topStyle.left = left + 'px';
      this.topStyle.width = width + 'px';
      this.topStyle.display = 'block';

      this.leftStyle.top = top + 'px';
      this.leftStyle.left = left + 'px';
      this.leftStyle.height = height + 'px';
      this.leftStyle.display = 'block';

      var delta = Math.floor(this.settings.border.width / 2);

      this.bottomStyle.top = top + height - delta + 'px';
      this.bottomStyle.left = left + 'px';
      this.bottomStyle.width = width + 'px';
      this.bottomStyle.display = 'block';

      this.rightStyle.top = top + 'px';
      this.rightStyle.left = left + width - delta + 'px';
      this.rightStyle.height = height + 1 + 'px';
      this.rightStyle.display = 'block';

      if (Handsontable.mobileBrowser || (!this.hasSetting(this.settings.border.cornerVisible) || this.isPartRange(toRow, toColumn))) {
        this.cornerStyle.display = 'none';
      } else {
        this.cornerStyle.top = top + height - 4 + 'px';
        this.cornerStyle.left = left + width - 4 + 'px';
        this.cornerStyle.borderRightWidth = this.cornerDefaultStyle.borderWidth;
        this.cornerStyle.width = this.cornerDefaultStyle.width;
        this.cornerStyle.display = 'block';

        if (toColumn === this.wot.getSetting('totalColumns') - 1) {
          var trimmingContainer = (0, _helpersDomElement.getTrimmingContainer)(this.wot.wtTable.TABLE);
          var cornerOverlappingContainer = toTD.offsetLeft + (0, _helpersDomElement.outerWidth)(toTD) >= (0, _helpersDomElement.innerWidth)(trimmingContainer);

          if (cornerOverlappingContainer) {
            this.cornerStyle.left = Math.floor(left + width - 3 - parseInt(this.cornerDefaultStyle.width) / 2) + "px";
            this.cornerStyle.borderRightWidth = 0;
          }
        }
      }

      if (Handsontable.mobileBrowser) {
        this.updateMultipleSelectionHandlesPosition(fromRow, fromColumn, top, left, width, height);
      }
    }

    /**
     * Hide border
     */
  }, {
    key: 'disappear',
    value: function disappear() {
      this.topStyle.display = 'none';
      this.leftStyle.display = 'none';
      this.bottomStyle.display = 'none';
      this.rightStyle.display = 'none';
      this.cornerStyle.display = 'none';

      if (Handsontable.mobileBrowser) {
        this.selectionHandles.styles.topLeft.display = 'none';
        this.selectionHandles.styles.bottomRight.display = 'none';
      }
    }

    /**
     * @param {Function} setting
     * @returns {*}
     */
  }, {
    key: 'hasSetting',
    value: function hasSetting(setting) {
      if (typeof setting === 'function') {
        return setting();
      }

      return !!setting;
    }
  }]);

  return WalkontableBorder;
})();

exports.WalkontableBorder = WalkontableBorder;

window.WalkontableBorder = WalkontableBorder;

},{"./../../../eventManager":46,"./../../../helpers/dom/element":50,"./../../../helpers/dom/event":51,"./cell/coords":11}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var privatePool = new WeakMap();

/**
 * Calculates indexes of columns to render OR columns that are visible.
 * To redo the calculation, you need to create a new calculator.
 *
 * @class WalkontableViewportColumnsCalculator
 */

var WalkontableViewportColumnsCalculator = (function () {
  _createClass(WalkontableViewportColumnsCalculator, null, [{
    key: 'DEFAULT_WIDTH',

    /**
     * Default column width
     *
     * @type {Number}
     */
    get: function get() {
      return 50;
    }

    /**
     * @param {Number} viewportWidth Width of the viewport
     * @param {Number} scrollOffset Current horizontal scroll position of the viewport
     * @param {Number} totalColumns Total number of rows
     * @param {Function} columnWidthFn Function that returns the width of the column at a given index (in px)
     * @param {Function} overrideFn Function that changes calculated this.startRow, this.endRow (used by MergeCells plugin)
     * @param {Boolean} onlyFullyVisible if `true`, only startRow and endRow will be indexes of rows that are fully in viewport
     * @param {Boolean} stretchH
     */
  }]);

  function WalkontableViewportColumnsCalculator(viewportWidth, scrollOffset, totalColumns, columnWidthFn, overrideFn, onlyFullyVisible, stretchH) {
    _classCallCheck(this, WalkontableViewportColumnsCalculator);

    privatePool.set(this, {
      viewportWidth: viewportWidth,
      scrollOffset: scrollOffset,
      totalColumns: totalColumns,
      columnWidthFn: columnWidthFn,
      overrideFn: overrideFn,
      onlyFullyVisible: onlyFullyVisible
    });

    /**
     * Number of rendered/visible columns
     *
     * @type {Number}
     */
    this.count = 0;

    /**
     * Index of the first rendered/visible column (can be overwritten using overrideFn)
     *
     * @type {Number|null}
     */
    this.startColumn = null;

    /**
     * Index of the last rendered/visible column (can be overwritten using overrideFn)
     *
     * @type {null}
     */
    this.endColumn = null;

    /**
     * Position of the first rendered/visible column (in px)
     *
     * @type {Number|null}
     */
    this.startPosition = null;

    this.stretchAllRatio = 0;
    this.stretchLastWidth = 0;
    this.stretch = stretchH;
    this.totalTargetWidth = 0;
    this.needVerifyLastColumnWidth = true;
    this.stretchAllColumnsWidth = [];

    this.calculate();
  }

  /**
   * Calculates viewport
   */

  _createClass(WalkontableViewportColumnsCalculator, [{
    key: 'calculate',
    value: function calculate() {
      var sum = 0;
      var needReverse = true;
      var startPositions = [];
      var columnWidth = undefined;

      var priv = privatePool.get(this);
      var onlyFullyVisible = priv.onlyFullyVisible;
      var overrideFn = priv.overrideFn;
      var scrollOffset = priv.scrollOffset;
      var totalColumns = priv.totalColumns;
      var viewportWidth = priv.viewportWidth;

      for (var i = 0; i < totalColumns; i++) {
        columnWidth = this._getColumnWidth(i);

        if (sum <= scrollOffset && !onlyFullyVisible) {
          this.startColumn = i;
        }

        if (sum >= scrollOffset && sum + columnWidth <= scrollOffset + viewportWidth) {
          if (this.startColumn == null) {
            this.startColumn = i;
          }
          this.endColumn = i;
        }
        startPositions.push(sum);
        sum += columnWidth;

        if (!onlyFullyVisible) {
          this.endColumn = i;
        }
        if (sum >= scrollOffset + viewportWidth) {
          needReverse = false;
          break;
        }
      }

      if (this.endColumn === totalColumns - 1 && needReverse) {
        this.startColumn = this.endColumn;

        while (this.startColumn > 0) {
          var viewportSum = startPositions[this.endColumn] + columnWidth - startPositions[this.startColumn - 1];

          if (viewportSum <= viewportWidth || !onlyFullyVisible) {
            this.startColumn--;
          }
          if (viewportSum > viewportWidth) {
            break;
          }
        }
      }

      if (this.startColumn !== null && overrideFn) {
        overrideFn(this);
      }
      this.startPosition = startPositions[this.startColumn];

      if (this.startPosition == void 0) {
        this.startPosition = null;
      }
      if (this.startColumn !== null) {
        this.count = this.endColumn - this.startColumn + 1;
      }
    }

    /**
     * Recalculate columns stretching.
     *
     * @param {Number} totalWidth
     */
  }, {
    key: 'refreshStretching',
    value: function refreshStretching(totalWidth) {
      if (this.stretch === 'none') {
        return;
      }
      var sumAll = 0;
      var columnWidth = undefined;
      var remainingSize = undefined;

      var priv = privatePool.get(this);
      var totalColumns = priv.totalColumns;

      for (var i = 0; i < totalColumns; i++) {
        columnWidth = this._getColumnWidth(i);
        sumAll += columnWidth;
      }
      this.totalTargetWidth = totalWidth;
      remainingSize = sumAll - totalWidth;

      if (this.stretch === 'all' && remainingSize < 0) {
        this.stretchAllRatio = totalWidth / sumAll;
        this.stretchAllColumnsWidth = [];
        this.needVerifyLastColumnWidth = true;
      } else if (this.stretch === 'last' && totalWidth !== Infinity) {
        this.stretchLastWidth = -remainingSize + this._getColumnWidth(totalColumns - 1);
      }
    }

    /**
     * Get stretched column width based on stretchH (all or last) setting passed in handsontable instance.
     *
     * @param {Number} column
     * @param {Number} baseWidth
     * @returns {Number|null}
     */
  }, {
    key: 'getStretchedColumnWidth',
    value: function getStretchedColumnWidth(column, baseWidth) {
      var result = null;

      if (this.stretch === 'all' && this.stretchAllRatio !== 0) {
        result = this._getStretchedAllColumnWidth(column, baseWidth);
      } else if (this.stretch === 'last' && this.stretchLastWidth !== 0) {
        result = this._getStretchedLastColumnWidth(column);
      }

      return result;
    }

    /**
     * @param {Number} column
     * @param {Number} baseWidth
     * @returns {Number}
     * @private
     */
  }, {
    key: '_getStretchedAllColumnWidth',
    value: function _getStretchedAllColumnWidth(column, baseWidth) {
      var sumRatioWidth = 0;
      var priv = privatePool.get(this);
      var totalColumns = priv.totalColumns;

      if (!this.stretchAllColumnsWidth[column]) {
        this.stretchAllColumnsWidth[column] = Math.round(baseWidth * this.stretchAllRatio);
      }

      if (this.stretchAllColumnsWidth.length === totalColumns && this.needVerifyLastColumnWidth) {
        this.needVerifyLastColumnWidth = false;

        for (var i = 0; i < this.stretchAllColumnsWidth.length; i++) {
          sumRatioWidth += this.stretchAllColumnsWidth[i];
        }
        if (sumRatioWidth !== this.totalTargetWidth) {
          this.stretchAllColumnsWidth[this.stretchAllColumnsWidth.length - 1] += this.totalTargetWidth - sumRatioWidth;
        }
      }

      return this.stretchAllColumnsWidth[column];
    }

    /**
     * @param {Number} column
     * @returns {Number|null}
     * @private
     */
  }, {
    key: '_getStretchedLastColumnWidth',
    value: function _getStretchedLastColumnWidth(column) {
      var priv = privatePool.get(this);
      var totalColumns = priv.totalColumns;

      if (column === totalColumns - 1) {
        return this.stretchLastWidth;
      }

      return null;
    }

    /**
     * @param {Number} column
     * @returns {Number}
     * @private
     */
  }, {
    key: '_getColumnWidth',
    value: function _getColumnWidth(column) {
      var width = privatePool.get(this).columnWidthFn(column);

      if (width === undefined) {
        width = WalkontableViewportColumnsCalculator.DEFAULT_WIDTH;
      }

      return width;
    }
  }]);

  return WalkontableViewportColumnsCalculator;
})();

exports.WalkontableViewportColumnsCalculator = WalkontableViewportColumnsCalculator;

window.WalkontableViewportColumnsCalculator = WalkontableViewportColumnsCalculator;

},{}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var privatePool = new WeakMap();

/**
 * Calculates indexes of rows to render OR rows that are visible.
 * To redo the calculation, you need to create a new calculator.
 *
 * @class WalkontableViewportRowsCalculator
 */

var WalkontableViewportRowsCalculator = (function () {
  _createClass(WalkontableViewportRowsCalculator, null, [{
    key: "DEFAULT_HEIGHT",

    /**
     * Default row height
     *
     * @type {Number}
     */
    get: function get() {
      return 23;
    }

    /**
     * @param {Number} viewportHeight Height of the viewport
     * @param {Number} scrollOffset Current vertical scroll position of the viewport
     * @param {Number} totalRows Total number of rows
     * @param {Function} rowHeightFn Function that returns the height of the row at a given index (in px)
     * @param {Function} overrideFn Function that changes calculated this.startRow, this.endRow (used by MergeCells plugin)
     * @param {Boolean} onlyFullyVisible if `true`, only startRow and endRow will be indexes of rows that are fully in viewport
     */
  }]);

  function WalkontableViewportRowsCalculator(viewportHeight, scrollOffset, totalRows, rowHeightFn, overrideFn, onlyFullyVisible, horizontalScrollbarHeight) {
    _classCallCheck(this, WalkontableViewportRowsCalculator);

    privatePool.set(this, {
      viewportHeight: viewportHeight,
      scrollOffset: scrollOffset,
      totalRows: totalRows,
      rowHeightFn: rowHeightFn,
      overrideFn: overrideFn,
      onlyFullyVisible: onlyFullyVisible,
      horizontalScrollbarHeight: horizontalScrollbarHeight
    });

    /**
     * Number of rendered/visible rows
     *
     * @type {Number}
     */
    this.count = 0;

    /**
     * Index of the first rendered/visible row (can be overwritten using overrideFn)
     *
     * @type {Number|null}
     */
    this.startRow = null;

    /**
     * Index of the last rendered/visible row (can be overwritten using overrideFn)
     *
     * @type {null}
     */
    this.endRow = null;

    /**
     * Position of the first rendered/visible row (in px)
     *
     * @type {Number|null}
     */
    this.startPosition = null;

    this.calculate();
  }

  /**
   * Calculates viewport
   */

  _createClass(WalkontableViewportRowsCalculator, [{
    key: "calculate",
    value: function calculate() {
      var sum = 0;
      var needReverse = true;
      var startPositions = [];

      var priv = privatePool.get(this);
      var onlyFullyVisible = priv.onlyFullyVisible;
      var overrideFn = priv.overrideFn;
      var rowHeightFn = priv.rowHeightFn;
      var scrollOffset = priv.scrollOffset;
      var totalRows = priv.totalRows;
      var viewportHeight = priv.viewportHeight;
      var horizontalScrollbarHeight = priv.horizontalScrollbarHeight || 0;

      // Calculate the number (start and end index) of rows needed
      for (var i = 0; i < totalRows; i++) {
        var _rowHeight = rowHeightFn(i);

        if (_rowHeight === undefined) {
          _rowHeight = WalkontableViewportRowsCalculator.DEFAULT_HEIGHT;
        }
        if (sum <= scrollOffset && !onlyFullyVisible) {
          this.startRow = i;
        }

        // the row is within the "visible range"
        if (sum >= scrollOffset && sum + _rowHeight <= scrollOffset + viewportHeight - horizontalScrollbarHeight) {
          if (this.startRow === null) {
            this.startRow = i;
          }
          this.endRow = i;
        }
        startPositions.push(sum);
        sum += _rowHeight;

        if (!onlyFullyVisible) {
          this.endRow = i;
        }
        if (sum >= scrollOffset + viewportHeight - horizontalScrollbarHeight) {
          needReverse = false;
          break;
        }
      }

      //If the estimation has reached the last row and there is still some space available in the viewport,
      //we need to render in reverse in order to fill the whole viewport with rows
      if (this.endRow === totalRows - 1 && needReverse) {
        this.startRow = this.endRow;

        while (this.startRow > 0) {
          // rowHeight is the height of the last row
          var viewportSum = startPositions[this.endRow] + rowHeight - startPositions[this.startRow - 1];

          if (viewportSum <= viewportHeight - horizontalScrollbarHeight || !onlyFullyVisible) {
            this.startRow--;
          }
          if (viewportSum >= viewportHeight - horizontalScrollbarHeight) {
            break;
          }
        }
      }

      if (this.startRow !== null && overrideFn) {
        overrideFn(this);
      }
      this.startPosition = startPositions[this.startRow];

      if (this.startPosition == void 0) {
        this.startPosition = null;
      }
      if (this.startRow !== null) {
        this.count = this.endRow - this.startRow + 1;
      }
    }
  }]);

  return WalkontableViewportRowsCalculator;
})();

exports.WalkontableViewportRowsCalculator = WalkontableViewportRowsCalculator;

window.WalkontableViewportRowsCalculator = WalkontableViewportRowsCalculator;

},{}],11:[function(require,module,exports){

/**
 * WalkontableCellCoords holds cell coordinates (row, column) and few method to validate them and
 * retrieve as an array or an object
 *
 * @class WalkontableCellCoords
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var WalkontableCellCoords = (function () {
  /**
   * @param {Number} row Row index
   * @param {Number} col Column index
   */

  function WalkontableCellCoords(row, col) {
    _classCallCheck(this, WalkontableCellCoords);

    if (typeof row !== 'undefined' && typeof col !== 'undefined') {
      this.row = row;
      this.col = col;
    } else {
      this.row = null;
      this.col = null;
    }
  }

  /**
   * Checks if given set of coordinates is valid in context of a given Walkontable instance
   *
   * @param {Walkontable} wotInstance
   * @returns {Boolean}
   */

  _createClass(WalkontableCellCoords, [{
    key: 'isValid',
    value: function isValid(wotInstance) {
      // is it a valid cell index (0 or higher)
      if (this.row < 0 || this.col < 0) {
        return false;
      }
      // is selection within total rows and columns
      if (this.row >= wotInstance.getSetting('totalRows') || this.col >= wotInstance.getSetting('totalColumns')) {
        return false;
      }

      return true;
    }

    /**
     * Checks if this cell coords are the same as cell coords given as a parameter
     *
     * @param {WalkontableCellCoords} cellCoords
     * @returns {Boolean}
     */
  }, {
    key: 'isEqual',
    value: function isEqual(cellCoords) {
      if (cellCoords === this) {
        return true;
      }

      return this.row === cellCoords.row && this.col === cellCoords.col;
    }

    /**
     * Checks if tested coordinates are positioned in south-east from this cell coords
     *
     * @param {Object} testedCoords
     * @returns {Boolean}
     */
  }, {
    key: 'isSouthEastOf',
    value: function isSouthEastOf(testedCoords) {
      return this.row >= testedCoords.row && this.col >= testedCoords.col;
    }

    /**
     * Checks if tested coordinates are positioned in north-east from this cell coords
     *
     * @param {Object} testedCoords
     * @returns {Boolean}
     */
  }, {
    key: 'isNorthWestOf',
    value: function isNorthWestOf(testedCoords) {
      return this.row <= testedCoords.row && this.col <= testedCoords.col;
    }

    /**
     * Checks if tested coordinates are positioned in south-west from this cell coords
     *
     * @param {Object} testedCoords
     * @returns {Boolean}
     */
  }, {
    key: 'isSouthWestOf',
    value: function isSouthWestOf(testedCoords) {
      return this.row >= testedCoords.row && this.col <= testedCoords.col;
    }

    /**
     * Checks if tested coordinates are positioned in north-east from this cell coords
     *
     * @param {Object} testedCoords
     * @returns {Boolean}
     */
  }, {
    key: 'isNorthEastOf',
    value: function isNorthEastOf(testedCoords) {
      return this.row <= testedCoords.row && this.col >= testedCoords.col;
    }
  }]);

  return WalkontableCellCoords;
})();

exports.WalkontableCellCoords = WalkontableCellCoords;

window.WalkontableCellCoords = WalkontableCellCoords;

},{}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _cellCoords = require('./../cell/coords');

/**
 * A cell range is a set of exactly two WalkontableCellCoords (that can be the same or different)
 *
 * @class WalkontableCellRange
 */

var WalkontableCellRange = (function () {
  /**
   * @param {WalkontableCellCoords} highlight Used to draw bold border around a cell where selection was
   *                                          started and to edit the cell when you press Enter
   * @param {WalkontableCellCoords} from Usually the same as highlight, but in Excel there is distinction - one can change
   *                                     highlight within a selection
   * @param {WalkontableCellCoords} to End selection
   */

  function WalkontableCellRange(highlight, from, to) {
    _classCallCheck(this, WalkontableCellRange);

    this.highlight = highlight;
    this.from = from;
    this.to = to;
  }

  /**
   * Checks if given coords are valid in context of a given Walkontable instance
   *
   * @param {Walkontable} wotInstance
   * @returns {Boolean}
   */

  _createClass(WalkontableCellRange, [{
    key: 'isValid',
    value: function isValid(wotInstance) {
      return this.from.isValid(wotInstance) && this.to.isValid(wotInstance);
    }

    /**
     * Checks if this cell range is restricted to one cell
     *
     * @returns {Boolean}
     */
  }, {
    key: 'isSingle',
    value: function isSingle() {
      return this.from.row === this.to.row && this.from.col === this.to.col;
    }

    /**
     * Returns selected range height (in number of rows)
     *
     * @returns {Number}
     */
  }, {
    key: 'getHeight',
    value: function getHeight() {
      return Math.max(this.from.row, this.to.row) - Math.min(this.from.row, this.to.row) + 1;
    }

    /**
     * Returns selected range width (in number of columns)
     *
     * @returns {Number}
     */
  }, {
    key: 'getWidth',
    value: function getWidth() {
      return Math.max(this.from.col, this.to.col) - Math.min(this.from.col, this.to.col) + 1;
    }

    /**
     * Checks if given cell coords is within `from` and `to` cell coords of this range
     *
     * @param {WalkontableCellCoords} cellCoords
     * @returns {Boolean}
     */
  }, {
    key: 'includes',
    value: function includes(cellCoords) {
      var topLeft = this.getTopLeftCorner();
      var bottomRight = this.getBottomRightCorner();

      if (cellCoords.row < 0) {
        cellCoords.row = 0;
      }
      if (cellCoords.col < 0) {
        cellCoords.col = 0;
      }

      return topLeft.row <= cellCoords.row && bottomRight.row >= cellCoords.row && topLeft.col <= cellCoords.col && bottomRight.col >= cellCoords.col;
    }

    /**
     * Checks if given range is within of this range
     *
     * @param {WalkontableCellRange} testedRange
     * @returns {Boolean}
     */
  }, {
    key: 'includesRange',
    value: function includesRange(testedRange) {
      return this.includes(testedRange.getTopLeftCorner()) && this.includes(testedRange.getBottomRightCorner());
    }

    /**
     * Checks if given range is equal to this range
     *
     * @param {WalkontableCellRange} testedRange
     * @returns {Boolean}
     */
  }, {
    key: 'isEqual',
    value: function isEqual(testedRange) {
      return Math.min(this.from.row, this.to.row) == Math.min(testedRange.from.row, testedRange.to.row) && Math.max(this.from.row, this.to.row) == Math.max(testedRange.from.row, testedRange.to.row) && Math.min(this.from.col, this.to.col) == Math.min(testedRange.from.col, testedRange.to.col) && Math.max(this.from.col, this.to.col) == Math.max(testedRange.from.col, testedRange.to.col);
    }

    /**
     * Checks if tested range overlaps with the range.
     * Range A is considered to to be overlapping with range B if intersection of A and B or B and A is not empty.
     *
     * @param {WalkontableCellRange} testedRange
     * @returns {Boolean}
     */
  }, {
    key: 'overlaps',
    value: function overlaps(testedRange) {
      return testedRange.isSouthEastOf(this.getTopLeftCorner()) && testedRange.isNorthWestOf(this.getBottomRightCorner());
    }

    /**
     * @param {WalkontableCellRange} testedCoords
     * @returns {Boolean}
     */
  }, {
    key: 'isSouthEastOf',
    value: function isSouthEastOf(testedCoords) {
      return this.getTopLeftCorner().isSouthEastOf(testedCoords) || this.getBottomRightCorner().isSouthEastOf(testedCoords);
    }

    /**
     * @param {WalkontableCellRange} testedCoords
     * @returns {Boolean}
     */
  }, {
    key: 'isNorthWestOf',
    value: function isNorthWestOf(testedCoords) {
      return this.getTopLeftCorner().isNorthWestOf(testedCoords) || this.getBottomRightCorner().isNorthWestOf(testedCoords);
    }

    /**
     * Adds a cell to a range (only if exceeds corners of the range). Returns information if range was expanded
     *
     * @param {WalkontableCellCoords} cellCoords
     * @returns {Boolean}
     */
  }, {
    key: 'expand',
    value: function expand(cellCoords) {
      var topLeft = this.getTopLeftCorner();
      var bottomRight = this.getBottomRightCorner();

      if (cellCoords.row < topLeft.row || cellCoords.col < topLeft.col || cellCoords.row > bottomRight.row || cellCoords.col > bottomRight.col) {
        this.from = new _cellCoords.WalkontableCellCoords(Math.min(topLeft.row, cellCoords.row), Math.min(topLeft.col, cellCoords.col));
        this.to = new _cellCoords.WalkontableCellCoords(Math.max(bottomRight.row, cellCoords.row), Math.max(bottomRight.col, cellCoords.col));

        return true;
      }

      return false;
    }

    /**
     * @param {WalkontableCellRange} expandingRange
     * @returns {Boolean}
     */
  }, {
    key: 'expandByRange',
    value: function expandByRange(expandingRange) {
      if (this.includesRange(expandingRange) || !this.overlaps(expandingRange)) {
        return false;
      }

      var topLeft = this.getTopLeftCorner();
      var bottomRight = this.getBottomRightCorner();
      var topRight = this.getTopRightCorner();
      var bottomLeft = this.getBottomLeftCorner();

      var expandingTopLeft = expandingRange.getTopLeftCorner();
      var expandingBottomRight = expandingRange.getBottomRightCorner();

      var resultTopRow = Math.min(topLeft.row, expandingTopLeft.row);
      var resultTopCol = Math.min(topLeft.col, expandingTopLeft.col);
      var resultBottomRow = Math.max(bottomRight.row, expandingBottomRight.row);
      var resultBottomCol = Math.max(bottomRight.col, expandingBottomRight.col);

      var finalFrom = new _cellCoords.WalkontableCellCoords(resultTopRow, resultTopCol),
          finalTo = new _cellCoords.WalkontableCellCoords(resultBottomRow, resultBottomCol);
      var isCorner = new WalkontableCellRange(finalFrom, finalFrom, finalTo).isCorner(this.from, expandingRange),
          onlyMerge = expandingRange.isEqual(new WalkontableCellRange(finalFrom, finalFrom, finalTo));

      if (isCorner && !onlyMerge) {
        if (this.from.col > finalFrom.col) {
          finalFrom.col = resultBottomCol;
          finalTo.col = resultTopCol;
        }
        if (this.from.row > finalFrom.row) {
          finalFrom.row = resultBottomRow;
          finalTo.row = resultTopRow;
        }
      }
      this.from = finalFrom;
      this.to = finalTo;

      return true;
    }

    /**
     * @returns {String}
     */
  }, {
    key: 'getDirection',
    value: function getDirection() {
      if (this.from.isNorthWestOf(this.to)) {
        // NorthWest - SouthEast
        return 'NW-SE';
      } else if (this.from.isNorthEastOf(this.to)) {
        // NorthEast - SouthWest
        return 'NE-SW';
      } else if (this.from.isSouthEastOf(this.to)) {
        // SouthEast - NorthWest
        return 'SE-NW';
      } else if (this.from.isSouthWestOf(this.to)) {
        // SouthWest - NorthEast
        return 'SW-NE';
      }
    }

    /**
     * @param {String} direction
     */
  }, {
    key: 'setDirection',
    value: function setDirection(direction) {
      switch (direction) {
        case 'NW-SE':
          this.from = this.getTopLeftCorner();
          this.to = this.getBottomRightCorner();
          break;
        case 'NE-SW':
          this.from = this.getTopRightCorner();
          this.to = this.getBottomLeftCorner();
          break;
        case 'SE-NW':
          this.from = this.getBottomRightCorner();
          this.to = this.getTopLeftCorner();
          break;
        case 'SW-NE':
          this.from = this.getBottomLeftCorner();
          this.to = this.getTopRightCorner();
          break;
      }
    }

    /**
     * Get top left corner of this range
     *
     * @returns {WalkontableCellCoords}
     */
  }, {
    key: 'getTopLeftCorner',
    value: function getTopLeftCorner() {
      return new _cellCoords.WalkontableCellCoords(Math.min(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));
    }

    /**
     * Get bottom right corner of this range
     *
     * @returns {WalkontableCellCoords}
     */
  }, {
    key: 'getBottomRightCorner',
    value: function getBottomRightCorner() {
      return new _cellCoords.WalkontableCellCoords(Math.max(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));
    }

    /**
     * Get top right corner of this range
     *
     * @returns {WalkontableCellCoords}
     */
  }, {
    key: 'getTopRightCorner',
    value: function getTopRightCorner() {
      return new _cellCoords.WalkontableCellCoords(Math.min(this.from.row, this.to.row), Math.max(this.from.col, this.to.col));
    }

    /**
     * Get bottom left corner of this range
     *
     * @returns {WalkontableCellCoords}
     */
  }, {
    key: 'getBottomLeftCorner',
    value: function getBottomLeftCorner() {
      return new _cellCoords.WalkontableCellCoords(Math.max(this.from.row, this.to.row), Math.min(this.from.col, this.to.col));
    }

    /**
     * @param {WalkontableCellCoords} coords
     * @param {WalkontableCellRange} expandedRange
     * @returns {*}
     */
  }, {
    key: 'isCorner',
    value: function isCorner(coords, expandedRange) {
      if (expandedRange) {
        if (expandedRange.includes(coords)) {
          if (this.getTopLeftCorner().isEqual(new _cellCoords.WalkontableCellCoords(expandedRange.from.row, expandedRange.from.col)) || this.getTopRightCorner().isEqual(new _cellCoords.WalkontableCellCoords(expandedRange.from.row, expandedRange.to.col)) || this.getBottomLeftCorner().isEqual(new _cellCoords.WalkontableCellCoords(expandedRange.to.row, expandedRange.from.col)) || this.getBottomRightCorner().isEqual(new _cellCoords.WalkontableCellCoords(expandedRange.to.row, expandedRange.to.col))) {
            return true;
          }
        }
      }

      return coords.isEqual(this.getTopLeftCorner()) || coords.isEqual(this.getTopRightCorner()) || coords.isEqual(this.getBottomLeftCorner()) || coords.isEqual(this.getBottomRightCorner());
    }

    /**
     * @param {WalkontableCellCoords} coords
     * @param {WalkontableCellRange} expandedRange
     * @returns {WalkontableCellCoords}
     */
  }, {
    key: 'getOppositeCorner',
    value: function getOppositeCorner(coords, expandedRange) {
      if (!(coords instanceof _cellCoords.WalkontableCellCoords)) {
        return false;
      }

      if (expandedRange) {
        if (expandedRange.includes(coords)) {
          if (this.getTopLeftCorner().isEqual(new _cellCoords.WalkontableCellCoords(expandedRange.from.row, expandedRange.from.col))) {
            return this.getBottomRightCorner();
          }
          if (this.getTopRightCorner().isEqual(new _cellCoords.WalkontableCellCoords(expandedRange.from.row, expandedRange.to.col))) {
            return this.getBottomLeftCorner();
          }
          if (this.getBottomLeftCorner().isEqual(new _cellCoords.WalkontableCellCoords(expandedRange.to.row, expandedRange.from.col))) {
            return this.getTopRightCorner();
          }
          if (this.getBottomRightCorner().isEqual(new _cellCoords.WalkontableCellCoords(expandedRange.to.row, expandedRange.to.col))) {
            return this.getTopLeftCorner();
          }
        }
      }

      if (coords.isEqual(this.getBottomRightCorner())) {
        return this.getTopLeftCorner();
      } else if (coords.isEqual(this.getTopLeftCorner())) {
        return this.getBottomRightCorner();
      } else if (coords.isEqual(this.getTopRightCorner())) {
        return this.getBottomLeftCorner();
      } else if (coords.isEqual(this.getBottomLeftCorner())) {
        return this.getTopRightCorner();
      }
    }

    /**
     * @param {WalkontableCellRange} range
     * @returns {Array}
     */
  }, {
    key: 'getBordersSharedWith',
    value: function getBordersSharedWith(range) {
      if (!this.includesRange(range)) {
        return [];
      }

      var thisBorders = {
        top: Math.min(this.from.row, this.to.row),
        bottom: Math.max(this.from.row, this.to.row),
        left: Math.min(this.from.col, this.to.col),
        right: Math.max(this.from.col, this.to.col)
      };
      var rangeBorders = {
        top: Math.min(range.from.row, range.to.row),
        bottom: Math.max(range.from.row, range.to.row),
        left: Math.min(range.from.col, range.to.col),
        right: Math.max(range.from.col, range.to.col)
      };
      var result = [];

      if (thisBorders.top == rangeBorders.top) {
        result.push('top');
      }
      if (thisBorders.right == rangeBorders.right) {
        result.push('right');
      }
      if (thisBorders.bottom == rangeBorders.bottom) {
        result.push('bottom');
      }
      if (thisBorders.left == rangeBorders.left) {
        result.push('left');
      }

      return result;
    }

    /**
     * Get inner selected cell coords defined by this range
     *
     * @returns {Array}
     */
  }, {
    key: 'getInner',
    value: function getInner() {
      var topLeft = this.getTopLeftCorner();
      var bottomRight = this.getBottomRightCorner();
      var out = [];

      for (var r = topLeft.row; r <= bottomRight.row; r++) {
        for (var c = topLeft.col; c <= bottomRight.col; c++) {
          if (!(this.from.row === r && this.from.col === c) && !(this.to.row === r && this.to.col === c)) {
            out.push(new _cellCoords.WalkontableCellCoords(r, c));
          }
        }
      }
      return out;
    }

    /**
     * Get all selected cell coords defined by this range
     *
     * @returns {Array}
     */
  }, {
    key: 'getAll',
    value: function getAll() {
      var topLeft = this.getTopLeftCorner();
      var bottomRight = this.getBottomRightCorner();
      var out = [];

      for (var r = topLeft.row; r <= bottomRight.row; r++) {
        for (var c = topLeft.col; c <= bottomRight.col; c++) {
          if (topLeft.row === r && topLeft.col === c) {
            out.push(topLeft);
          } else if (bottomRight.row === r && bottomRight.col === c) {
            out.push(bottomRight);
          } else {
            out.push(new _cellCoords.WalkontableCellCoords(r, c));
          }
        }
      }

      return out;
    }

    /**
     * Runs a callback function against all cells in the range. You can break the iteration by returning
     * `false` in the callback function
     *
     * @param callback {Function}
     */
  }, {
    key: 'forAll',
    value: function forAll(callback) {
      var topLeft = this.getTopLeftCorner();
      var bottomRight = this.getBottomRightCorner();

      for (var r = topLeft.row; r <= bottomRight.row; r++) {
        for (var c = topLeft.col; c <= bottomRight.col; c++) {
          var breakIteration = callback(r, c);

          if (breakIteration === false) {
            return;
          }
        }
      }
    }
  }]);

  return WalkontableCellRange;
})();

exports.WalkontableCellRange = WalkontableCellRange;

window.WalkontableCellRange = WalkontableCellRange;

},{"./../cell/coords":11}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _helpersDomElement = require('./../../../helpers/dom/element');

var _helpersObject = require('./../../../helpers/object');

var _helpersString = require('./../../../helpers/string');

var _event = require('./event');

var _overlays = require('./overlays');

var _scroll = require('./scroll');

var _settings = require('./settings');

var _table = require('./table');

var _viewport = require('./viewport');

/**
 * @class Walkontable
 */

var Walkontable = (function () {
  /**
   * @param {Object} settings
   */

  function Walkontable(settings) {
    _classCallCheck(this, Walkontable);

    var originalHeaders = [];

    // this is the namespace for global events
    this.guid = 'wt_' + (0, _helpersString.randomString)();

    // bootstrap from settings
    if (settings.cloneSource) {
      this.cloneSource = settings.cloneSource;
      this.cloneOverlay = settings.cloneOverlay;
      this.wtSettings = settings.cloneSource.wtSettings;
      this.wtTable = new _table.WalkontableTable(this, settings.table, settings.wtRootElement);
      this.wtScroll = new _scroll.WalkontableScroll(this);
      this.wtViewport = settings.cloneSource.wtViewport;
      this.wtEvent = new _event.WalkontableEvent(this);
      this.selections = this.cloneSource.selections;
    } else {
      this.wtSettings = new _settings.WalkontableSettings(this, settings);
      this.wtTable = new _table.WalkontableTable(this, settings.table);
      this.wtScroll = new _scroll.WalkontableScroll(this);
      this.wtViewport = new _viewport.WalkontableViewport(this);
      this.wtEvent = new _event.WalkontableEvent(this);
      this.selections = this.getSetting('selections');
      this.wtOverlays = new _overlays.WalkontableOverlays(this);
      this.exportSettingsAsClassNames();
    }

    // find original headers
    if (this.wtTable.THEAD.childNodes.length && this.wtTable.THEAD.childNodes[0].childNodes.length) {
      for (var c = 0, clen = this.wtTable.THEAD.childNodes[0].childNodes.length; c < clen; c++) {
        originalHeaders.push(this.wtTable.THEAD.childNodes[0].childNodes[c].innerHTML);
      }
      if (!this.getSetting('columnHeaders').length) {
        this.update('columnHeaders', [function (column, TH) {
          (0, _helpersDomElement.fastInnerText)(TH, originalHeaders[column]);
        }]);
      }
    }
    this.drawn = false;
    this.drawInterrupted = false;
  }

  /**
   * Force rerender of Walkontable
   *
   * @param {Boolean} [fastDraw=false] When `true`, try to refresh only the positions of borders without rerendering
   *                                   the data. It will only work if WalkontableTable.draw() does not force
   *                                   rendering anyway
   * @returns {Walkontable}
   */

  _createClass(Walkontable, [{
    key: 'draw',
    value: function draw() {
      var fastDraw = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

      this.drawInterrupted = false;

      if (!fastDraw && !(0, _helpersDomElement.isVisible)(this.wtTable.TABLE)) {
        // draw interrupted because TABLE is not visible
        this.drawInterrupted = true;
      } else {
        this.wtTable.draw(fastDraw);
      }

      return this;
    }

    /**
     * Returns the TD at coords. If topmost is set to true, returns TD from the topmost overlay layer,
     * if not set or set to false, returns TD from the master table.
     *
     * @param {WalkontableCellCoords} coords
     * @param {Boolean} [topmost=false]
     * @returns {Object}
     */
  }, {
    key: 'getCell',
    value: function getCell(coords) {
      var topmost = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

      if (!topmost) {
        return this.wtTable.getCell(coords);
      }

      var fixedRows = this.wtSettings.getSetting('fixedRowsTop');
      var fixedColumns = this.wtSettings.getSetting('fixedColumnsLeft');

      if (coords.row < fixedRows && coords.col < fixedColumns) {
        return this.wtOverlays.topLeftCornerOverlay.clone.wtTable.getCell(coords);
      } else if (coords.row < fixedRows) {
        return this.wtOverlays.topOverlay.clone.wtTable.getCell(coords);
      } else if (coords.col < fixedColumns) {
        return this.wtOverlays.leftOverlay.clone.wtTable.getCell(coords);
      }

      return this.wtTable.getCell(coords);
    }

    /**
     * @param {Object} settings
     * @param {*} value
     * @returns {Walkontable}
     */
  }, {
    key: 'update',
    value: function update(settings, value) {
      return this.wtSettings.update(settings, value);
    }

    /**
     * Scroll the viewport to a row at the given index in the data source
     *
     * @param {Number} row
     * @returns {Walkontable}
     */
  }, {
    key: 'scrollVertical',
    value: function scrollVertical(row) {
      this.wtOverlays.topOverlay.scrollTo(row);
      this.getSetting('onScrollVertically');

      return this;
    }

    /**
     * Scroll the viewport to a column at the given index in the data source
     *
     * @param {Number} column
     * @returns {Walkontable}
     */
  }, {
    key: 'scrollHorizontal',
    value: function scrollHorizontal(column) {
      this.wtOverlays.leftOverlay.scrollTo(column);
      this.getSetting('onScrollHorizontally');

      return this;
    }

    /**
     * Scrolls the viewport to a cell (rerenders if needed)
     *
     * @param {WalkontableCellCoords} coords
     * @returns {Walkontable}
     */
  }, {
    key: 'scrollViewport',
    value: function scrollViewport(coords) {
      this.wtScroll.scrollViewport(coords);

      return this;
    }

    /**
     * @returns {Array}
     */
  }, {
    key: 'getViewport',
    value: function getViewport() {
      return [this.wtTable.getFirstVisibleRow(), this.wtTable.getFirstVisibleColumn(), this.wtTable.getLastVisibleRow(), this.wtTable.getLastVisibleColumn()];
    }

    /**
     * Get overlay name
     *
     * @returns {String}
     */
  }, {
    key: 'getOverlayName',
    value: function getOverlayName() {
      return this.cloneOverlay ? this.cloneOverlay.type : 'master';
    }

    /**
     * Export settings as class names added to the parent element of the table.
     */
  }, {
    key: 'exportSettingsAsClassNames',
    value: function exportSettingsAsClassNames() {
      var _this = this;

      var toExport = {
        rowHeaders: ['array'],
        columnHeaders: ['array']
      };
      var allClassNames = [];
      var newClassNames = [];

      (0, _helpersObject.objectEach)(toExport, function (optionType, key) {
        if (optionType.indexOf('array') > -1 && _this.getSetting(key).length) {
          newClassNames.push('ht' + (0, _helpersString.toUpperCaseFirst)(key));
        }
        allClassNames.push('ht' + (0, _helpersString.toUpperCaseFirst)(key));
      });
      (0, _helpersDomElement.removeClass)(this.wtTable.wtRootElement.parentNode, allClassNames);
      (0, _helpersDomElement.addClass)(this.wtTable.wtRootElement.parentNode, newClassNames);
    }

    /**
     * Get/Set Walkontable instance setting
     *
     * @param {String} key
     * @param {*} [param1]
     * @param {*} [param2]
     * @param {*} [param3]
     * @param {*} [param4]
     * @returns {*}
     */
  }, {
    key: 'getSetting',
    value: function getSetting(key, param1, param2, param3, param4) {
      // this is faster than .apply - https://github.com/handsontable/handsontable/wiki/JavaScript-&-DOM-performance-tips
      return this.wtSettings.getSetting(key, param1, param2, param3, param4);
    }

    /**
     * Checks if setting exists
     *
     * @param {String} key
     * @returns {Boolean}
     */
  }, {
    key: 'hasSetting',
    value: function hasSetting(key) {
      return this.wtSettings.has(key);
    }

    /**
     * Destroy instance
     */
  }, {
    key: 'destroy',
    value: function destroy() {
      this.wtOverlays.destroy();
      this.wtEvent.destroy();
    }
  }]);

  return Walkontable;
})();

exports.Walkontable = Walkontable;

window.Walkontable = Walkontable;

},{"./../../../helpers/dom/element":50,"./../../../helpers/object":55,"./../../../helpers/string":57,"./event":14,"./overlays":22,"./scroll":23,"./settings":25,"./table":26,"./viewport":28}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _helpersDomElement = require('./../../../helpers/dom/element');

var _eventManager = require('./../../../eventManager');

function WalkontableEvent(instance) {
  var that = this;

  var eventManager = (0, _eventManager.eventManager)(instance);

  //reference to instance
  this.instance = instance;

  var dblClickOrigin = [null, null];
  this.dblClickTimeout = [null, null];

  var onMouseDown = function onMouseDown(event) {
    var cell = that.parentCell(event.realTarget);

    if ((0, _helpersDomElement.hasClass)(event.realTarget, 'corner')) {
      that.instance.getSetting('onCellCornerMouseDown', event, event.realTarget);
    } else if (cell.TD) {
      if (that.instance.hasSetting('onCellMouseDown')) {
        that.instance.getSetting('onCellMouseDown', event, cell.coords, cell.TD, that.instance);
      }
    }

    if (event.button !== 2) {
      //if not right mouse button
      if (cell.TD) {
        dblClickOrigin[0] = cell.TD;
        clearTimeout(that.dblClickTimeout[0]);
        that.dblClickTimeout[0] = setTimeout(function () {
          dblClickOrigin[0] = null;
        }, 1000);
      }
    }
  };

  var onTouchMove = function onTouchMove(event) {
    that.instance.touchMoving = true;
  };

  var longTouchTimeout;

  ///**
  // * Update touch event target - if user taps on resize handle 'hit area', update the target to the cell itself
  // * @param event
  // */
  /*
   var adjustTapTarget = function (event) {
   var currentSelection
   , properTarget;
    if(hasClass(event.target,'SelectionHandle')) {
   if(that.instance.selections[0].cellRange) {
   currentSelection = that.instance.selections[0].cellRange.highlight;
    properTarget = that.instance.getCell(currentSelection, true);
   }
   }
    if(properTarget) {
   Object.defineProperty(event,'target',{
   value: properTarget
   });
   }
    return event;
   };*/

  var onTouchStart = function onTouchStart(event) {
    var container = this;

    eventManager.addEventListener(this, 'touchmove', onTouchMove);

    //this.addEventListener("touchmove", onTouchMove, false);

    // touch-and-hold event
    //longTouchTimeout = setTimeout(function () {
    //  if(!that.instance.touchMoving) {
    //    that.instance.longTouch = true;
    //
    //    var targetCoords = offset(event.target);
    //    var contextMenuEvent = new MouseEvent('contextmenu', {
    //      clientX: targetCoords.left + event.target.offsetWidth,
    //      clientY: targetCoords.top + event.target.offsetHeight,
    //      button: 2
    //    });
    //
    //    that.instance.wtTable.holder.parentNode.parentNode.dispatchEvent(contextMenuEvent);
    //  }
    //},200);

    // Prevent cell selection when scrolling with touch event - not the best solution performance-wise
    that.checkIfTouchMove = setTimeout(function () {
      if (that.instance.touchMoving === true) {
        that.instance.touchMoving = void 0;

        eventManager.removeEventListener("touchmove", onTouchMove, false);

        return;
      } else {
        //event = adjustTapTarget(event);

        onMouseDown(event);
      }
    }, 30);

    //eventManager.removeEventListener(that.instance.wtTable.holder, "mousedown", onMouseDown);
  };

  var lastMouseOver;
  var onMouseOver = function onMouseOver(event) {
    var table, td;

    if (that.instance.hasSetting('onCellMouseOver')) {
      table = that.instance.wtTable.TABLE;
      td = (0, _helpersDomElement.closest)(event.realTarget, ['TD', 'TH'], table);

      if (td && td !== lastMouseOver && (0, _helpersDomElement.isChildOf)(td, table)) {
        lastMouseOver = td;
        that.instance.getSetting('onCellMouseOver', event, that.instance.wtTable.getCoords(td), td, that.instance);
      }
    }
  };

  /*  var lastMouseOut;
   var onMouseOut = function (event) {
   if (that.instance.hasSetting('onCellMouseOut')) {
   var TABLE = that.instance.wtTable.TABLE;
   var TD = closest(event.target, ['TD', 'TH'], TABLE);
   if (TD && TD !== lastMouseOut && isChildOf(TD, TABLE)) {
   lastMouseOut = TD;
   if (TD.nodeName === 'TD') {
   that.instance.getSetting('onCellMouseOut', event, that.instance.wtTable.getCoords(TD), TD);
   }
   }
   }
   };*/

  var onMouseUp = function onMouseUp(event) {
    if (event.button !== 2) {
      //if not right mouse button
      var cell = that.parentCell(event.realTarget);

      if (cell.TD === dblClickOrigin[0] && cell.TD === dblClickOrigin[1]) {
        if ((0, _helpersDomElement.hasClass)(event.realTarget, 'corner')) {
          that.instance.getSetting('onCellCornerDblClick', event, cell.coords, cell.TD, that.instance);
        } else {
          that.instance.getSetting('onCellDblClick', event, cell.coords, cell.TD, that.instance);
        }

        dblClickOrigin[0] = null;
        dblClickOrigin[1] = null;
      } else if (cell.TD === dblClickOrigin[0]) {
        dblClickOrigin[1] = cell.TD;
        clearTimeout(that.dblClickTimeout[1]);
        that.dblClickTimeout[1] = setTimeout(function () {
          dblClickOrigin[1] = null;
        }, 500);
      }
    }
  };

  var onTouchEnd = function onTouchEnd(event) {
    clearTimeout(longTouchTimeout);
    //that.instance.longTouch == void 0;

    event.preventDefault();

    onMouseUp(event);

    //eventManager.removeEventListener(that.instance.wtTable.holder, "mouseup", onMouseUp);
  };

  eventManager.addEventListener(this.instance.wtTable.holder, 'mousedown', onMouseDown);

  eventManager.addEventListener(this.instance.wtTable.TABLE, 'mouseover', onMouseOver);

  eventManager.addEventListener(this.instance.wtTable.holder, 'mouseup', onMouseUp);

  // check if full HOT instance, or detached WOT AND run on mobile device
  if (this.instance.wtTable.holder.parentNode.parentNode && Handsontable.mobileBrowser && !that.instance.wtTable.isWorkingOnClone()) {
    var classSelector = "." + this.instance.wtTable.holder.parentNode.className.split(" ").join(".");

    eventManager.addEventListener(this.instance.wtTable.holder, 'touchstart', function (event) {
      that.instance.touchApplied = true;
      if ((0, _helpersDomElement.isChildOf)(event.target, classSelector)) {
        onTouchStart.call(event.target, event);
      }
    });
    eventManager.addEventListener(this.instance.wtTable.holder, 'touchend', function (event) {
      that.instance.touchApplied = false;
      if ((0, _helpersDomElement.isChildOf)(event.target, classSelector)) {
        onTouchEnd.call(event.target, event);
      }
    });

    if (!that.instance.momentumScrolling) {
      that.instance.momentumScrolling = {};
    }
    eventManager.addEventListener(this.instance.wtTable.holder, 'scroll', function (event) {
      clearTimeout(that.instance.momentumScrolling._timeout);

      if (!that.instance.momentumScrolling.ongoing) {
        that.instance.getSetting('onBeforeTouchScroll');
      }
      that.instance.momentumScrolling.ongoing = true;

      that.instance.momentumScrolling._timeout = setTimeout(function () {
        if (!that.instance.touchApplied) {
          that.instance.momentumScrolling.ongoing = false;

          that.instance.getSetting('onAfterMomentumScroll');
        }
      }, 200);
    });
  }

  eventManager.addEventListener(window, 'resize', function () {
    if (that.instance.getSetting('stretchH') !== 'none') {
      that.instance.draw();
    }
  });

  this.destroy = function () {
    clearTimeout(this.dblClickTimeout[0]);
    clearTimeout(this.dblClickTimeout[1]);

    eventManager.destroy();
  };
}

WalkontableEvent.prototype.parentCell = function (elem) {
  var cell = {};
  var TABLE = this.instance.wtTable.TABLE;
  var TD = (0, _helpersDomElement.closest)(elem, ['TD', 'TH'], TABLE);

  if (TD && (0, _helpersDomElement.isChildOf)(TD, TABLE)) {
    cell.coords = this.instance.wtTable.getCoords(TD);
    cell.TD = TD;
  } else if ((0, _helpersDomElement.hasClass)(elem, 'wtBorder') && (0, _helpersDomElement.hasClass)(elem, 'current')) {
    cell.coords = this.instance.selections.current.cellRange.highlight; //selections.current is current selected cell
    cell.TD = this.instance.wtTable.getCell(cell.coords);
  } else if ((0, _helpersDomElement.hasClass)(elem, 'wtBorder') && (0, _helpersDomElement.hasClass)(elem, 'area')) {
    if (this.instance.selections.area.cellRange) {
      cell.coords = this.instance.selections.area.cellRange.to; //selections.area is area selected cells
      cell.TD = this.instance.wtTable.getCell(cell.coords);
    }
  }

  return cell;
};

exports.WalkontableEvent = WalkontableEvent;

window.WalkontableEvent = WalkontableEvent;

},{"./../../../eventManager":46,"./../../../helpers/dom/element":50}],15:[function(require,module,exports){

/**
 * @class WalkontableColumnFilter
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var WalkontableColumnFilter = (function () {
  /**
   * @param {Number} offset
   * @param {Number} total
   * @param {Number} countTH
   */

  function WalkontableColumnFilter(offset, total, countTH) {
    _classCallCheck(this, WalkontableColumnFilter);

    this.offset = offset;
    this.total = total;
    this.countTH = countTH;
  }

  /**
   * @param index
   * @returns {Number}
   */

  _createClass(WalkontableColumnFilter, [{
    key: "offsetted",
    value: function offsetted(index) {
      return index + this.offset;
    }

    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "unOffsetted",
    value: function unOffsetted(index) {
      return index - this.offset;
    }

    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "renderedToSource",
    value: function renderedToSource(index) {
      return this.offsetted(index);
    }

    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "sourceToRendered",
    value: function sourceToRendered(index) {
      return this.unOffsetted(index);
    }

    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "offsettedTH",
    value: function offsettedTH(index) {
      return index - this.countTH;
    }

    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "unOffsettedTH",
    value: function unOffsettedTH(index) {
      return index + this.countTH;
    }

    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "visibleRowHeadedColumnToSourceColumn",
    value: function visibleRowHeadedColumnToSourceColumn(index) {
      return this.renderedToSource(this.offsettedTH(index));
    }

    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "sourceColumnToVisibleRowHeadedColumn",
    value: function sourceColumnToVisibleRowHeadedColumn(index) {
      return this.unOffsettedTH(this.sourceToRendered(index));
    }
  }]);

  return WalkontableColumnFilter;
})();

exports.WalkontableColumnFilter = WalkontableColumnFilter;

window.WalkontableColumnFilter = WalkontableColumnFilter;

},{}],16:[function(require,module,exports){

/**
 * @class WalkontableRowFilter
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var WalkontableRowFilter = (function () {
  /**
   * @param {Number} offset
   * @param {Number} total
   * @param {Number} countTH
   */

  function WalkontableRowFilter(offset, total, countTH) {
    _classCallCheck(this, WalkontableRowFilter);

    this.offset = offset;
    this.total = total;
    this.countTH = countTH;
  }

  /**
   * @param index
   * @returns {Number}
   */

  _createClass(WalkontableRowFilter, [{
    key: "offsetted",
    value: function offsetted(index) {
      return index + this.offset;
    }

    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "unOffsetted",
    value: function unOffsetted(index) {
      return index - this.offset;
    }

    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "renderedToSource",
    value: function renderedToSource(index) {
      return this.offsetted(index);
    }

    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "sourceToRendered",
    value: function sourceToRendered(index) {
      return this.unOffsetted(index);
    }

    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "offsettedTH",
    value: function offsettedTH(index) {
      return index - this.countTH;
    }

    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "unOffsettedTH",
    value: function unOffsettedTH(index) {
      return index + this.countTH;
    }

    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "visibleColHeadedRowToSourceRow",
    value: function visibleColHeadedRowToSourceRow(index) {
      return this.renderedToSource(this.offsettedTH(index));
    }

    /**
     * @param index
     * @returns {Number}
     */
  }, {
    key: "sourceRowToVisibleColHeadedRow",
    value: function sourceRowToVisibleColHeadedRow(index) {
      return this.unOffsettedTH(this.sourceToRendered(index));
    }
  }]);

  return WalkontableRowFilter;
})();

exports.WalkontableRowFilter = WalkontableRowFilter;

window.WalkontableRowFilter = WalkontableRowFilter;

},{}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _helpersDomElement = require('./../../../../helpers/dom/element');

var _helpersObject = require('./../../../../helpers/object');

var _eventManager = require('./../../../../eventManager');

/**
 * Creates an overlay over the original Walkontable instance. The overlay renders the clone of the original Walkontable
 * and (optionally) implements behavior needed for native horizontal and vertical scrolling.
 *
 * @class WalkontableOverlay
 */

var WalkontableOverlay = (function () {
  _createClass(WalkontableOverlay, null, [{
    key: 'CLONE_TOP',

    /**
     * @type {String}
     */
    get: function get() {
      return 'top';
    }

    /**
     * @type {String}
     */
  }, {
    key: 'CLONE_LEFT',
    get: function get() {
      return 'left';
    }

    /**
     * @type {String}
     */
  }, {
    key: 'CLONE_CORNER',
    get: function get() {
      return 'corner';
    }

    /**
     * @type {String}
     */
  }, {
    key: 'CLONE_DEBUG',
    get: function get() {
      return 'debug';
    }

    /**
     * List of all availables clone types
     *
     * @type {Array}
     */
  }, {
    key: 'CLONE_TYPES',
    get: function get() {
      return [WalkontableOverlay.CLONE_TOP, WalkontableOverlay.CLONE_LEFT, WalkontableOverlay.CLONE_CORNER, WalkontableOverlay.CLONE_DEBUG];
    }

    /**
     * @param {Walkontable} wotInstance
     */
  }]);

  function WalkontableOverlay(wotInstance) {
    _classCallCheck(this, WalkontableOverlay);

    (0, _helpersObject.defineGetter)(this, 'wot', wotInstance, {
      writable: false
    });

    // legacy support, deprecated in the future
    this.instance = this.wot;

    this.type = '';
    this.TABLE = this.wot.wtTable.TABLE;
    this.hider = this.wot.wtTable.hider;
    this.spreader = this.wot.wtTable.spreader;
    this.holder = this.wot.wtTable.holder;
    this.wtRootElement = this.wot.wtTable.wtRootElement;
    this.trimmingContainer = (0, _helpersDomElement.getTrimmingContainer)(this.hider.parentNode.parentNode);
    this.mainTableScrollableElement = (0, _helpersDomElement.getScrollableElement)(this.wot.wtTable.TABLE);
    this.needFullRender = this.shouldBeRendered();
    this.areElementSizesAdjusted = false;
  }

  /**
   * Checks if overlay should be fully rendered
   *
   * @returns {Boolean}
   */

  _createClass(WalkontableOverlay, [{
    key: 'shouldBeRendered',
    value: function shouldBeRendered() {
      return true;
    }

    /**
     * Make a clone of table for overlay
     *
     * @param {String} direction Can be `WalkontableOverlay.CLONE_TOP`, `WalkontableOverlay.CLONE_LEFT`,
     *                           `WalkontableOverlay.CLONE_CORNER`, `WalkontableOverlay.CLONE_DEBUG`
     * @returns {Walkontable}
     */
  }, {
    key: 'makeClone',
    value: function makeClone(direction) {
      if (WalkontableOverlay.CLONE_TYPES.indexOf(direction) === -1) {
        throw new Error('Clone type "' + direction + '" is not supported.');
      }
      var clone = document.createElement('DIV');
      var clonedTable = document.createElement('TABLE');

      clone.className = 'ht_clone_' + direction + ' handsontable';
      clone.style.position = 'absolute';
      clone.style.top = 0;
      clone.style.left = 0;
      clone.style.overflow = 'hidden';

      clonedTable.className = this.wot.wtTable.TABLE.className;
      clone.appendChild(clonedTable);

      this.type = direction;
      this.wot.wtTable.wtRootElement.parentNode.appendChild(clone);

      return new Walkontable({
        cloneSource: this.wot,
        cloneOverlay: this,
        table: clonedTable
      });
    }

    /**
     * Refresh/Redraw overlay
     *
     * @param {Boolean} [fastDraw=false]
     */
  }, {
    key: 'refresh',
    value: function refresh() {
      var fastDraw = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

      // When hot settings are changed we allow to refresh overlay once before blocking
      var nextCycleRenderFlag = this.shouldBeRendered();

      if (this.clone && (this.needFullRender || nextCycleRenderFlag)) {
        this.clone.draw(fastDraw);
      }
      this.needFullRender = nextCycleRenderFlag;
    }

    /**
     * Destroy overlay instance
     */
  }, {
    key: 'destroy',
    value: function destroy() {
      (0, _eventManager.eventManager)(this.clone).destroy();
    }
  }]);

  return WalkontableOverlay;
})();

exports.WalkontableOverlay = WalkontableOverlay;

window.WalkontableOverlay = WalkontableOverlay;

},{"./../../../../eventManager":46,"./../../../../helpers/dom/element":50,"./../../../../helpers/object":55}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _helpersDomElement = require('./../../../../helpers/dom/element');

var _base = require('./_base');

/**
 * @class WalkontableCornerOverlay
 */

var WalkontableCornerOverlay = (function (_WalkontableOverlay) {
  _inherits(WalkontableCornerOverlay, _WalkontableOverlay);

  /**
   * @param {Walkontable} wotInstance
   */

  function WalkontableCornerOverlay(wotInstance) {
    _classCallCheck(this, WalkontableCornerOverlay);

    _get(Object.getPrototypeOf(WalkontableCornerOverlay.prototype), 'constructor', this).call(this, wotInstance);
    this.clone = this.makeClone(_base.WalkontableOverlay.CLONE_CORNER);
  }

  /**
   * Checks if overlay should be fully rendered
   *
   * @returns {Boolean}
   */

  _createClass(WalkontableCornerOverlay, [{
    key: 'shouldBeRendered',
    value: function shouldBeRendered() {
      return (this.wot.getSetting('fixedRowsTop') || this.wot.getSetting('columnHeaders').length) && (this.wot.getSetting('fixedColumnsLeft') || this.wot.getSetting('rowHeaders').length) ? true : false;
    }

    /**
     * Updates the corner overlay position
     */
  }, {
    key: 'resetFixedPosition',
    value: function resetFixedPosition() {
      if (!this.wot.wtTable.holder.parentNode) {
        // removed from DOM
        return;
      }
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      var tableHeight = (0, _helpersDomElement.outerHeight)(this.clone.wtTable.TABLE);
      var tableWidth = (0, _helpersDomElement.outerWidth)(this.clone.wtTable.TABLE);

      if (this.trimmingContainer === window) {
        var box = this.wot.wtTable.hider.getBoundingClientRect();
        var _top = Math.ceil(box.top);
        var left = Math.ceil(box.left);
        var bottom = Math.ceil(box.bottom);
        var right = Math.ceil(box.right);
        var finalLeft = undefined;
        var finalTop = undefined;

        if (left < 0 && right - overlayRoot.offsetWidth > 0) {
          finalLeft = -left + 'px';
        } else {
          finalLeft = '0';
        }

        if (_top < 0 && bottom - overlayRoot.offsetHeight > 0) {
          finalTop = -_top + 'px';
        } else {
          finalTop = '0';
        }
        (0, _helpersDomElement.setOverlayPosition)(overlayRoot, finalLeft, finalTop);
      }
      overlayRoot.style.height = (tableHeight === 0 ? tableHeight : tableHeight + 4) + 'px';
      overlayRoot.style.width = (tableWidth === 0 ? tableWidth : tableWidth + 4) + 'px';
    }
  }]);

  return WalkontableCornerOverlay;
})(_base.WalkontableOverlay);

exports.WalkontableCornerOverlay = WalkontableCornerOverlay;

window.WalkontableCornerOverlay = WalkontableCornerOverlay;

},{"./../../../../helpers/dom/element":50,"./_base":17}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _helpersDomElement = require('./../../../../helpers/dom/element');

var _base = require('./_base');

/**
 * A overlay that renders ALL available rows & columns positioned on top of the original Walkontable instance and all other overlays.
 * Used for debugging purposes to see if the other overlays (that render only part of the rows & columns) are positioned correctly
 *
 * @class WalkontableDebugOverlay
 */

var WalkontableDebugOverlay = (function (_WalkontableOverlay) {
  _inherits(WalkontableDebugOverlay, _WalkontableOverlay);

  /**
   * @param {Walkontable} wotInstance
   */

  function WalkontableDebugOverlay(wotInstance) {
    _classCallCheck(this, WalkontableDebugOverlay);

    _get(Object.getPrototypeOf(WalkontableDebugOverlay.prototype), 'constructor', this).call(this, wotInstance);

    this.clone = this.makeClone(_base.WalkontableOverlay.CLONE_DEBUG);
    this.clone.wtTable.holder.style.opacity = 0.4;
    this.clone.wtTable.holder.style.textShadow = '0 0 2px #ff0000';

    (0, _helpersDomElement.addClass)(this.clone.wtTable.holder.parentNode, 'wtDebugVisible');
  }

  return WalkontableDebugOverlay;
})(_base.WalkontableOverlay);

exports.WalkontableDebugOverlay = WalkontableDebugOverlay;

window.WalkontableDebugOverlay = WalkontableDebugOverlay;

},{"./../../../../helpers/dom/element":50,"./_base":17}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _helpersDomElement = require('./../../../../helpers/dom/element');

var _base = require('./_base');

/**
 * @class WalkontableLeftOverlay
 */

var WalkontableLeftOverlay = (function (_WalkontableOverlay) {
  _inherits(WalkontableLeftOverlay, _WalkontableOverlay);

  /**
   * @param {Walkontable} wotInstance
   */

  function WalkontableLeftOverlay(wotInstance) {
    _classCallCheck(this, WalkontableLeftOverlay);

    _get(Object.getPrototypeOf(WalkontableLeftOverlay.prototype), 'constructor', this).call(this, wotInstance);
    this.clone = this.makeClone(_base.WalkontableOverlay.CLONE_LEFT);
  }

  /**
   * Checks if overlay should be fully rendered
   *
   * @returns {Boolean}
   */

  _createClass(WalkontableLeftOverlay, [{
    key: 'shouldBeRendered',
    value: function shouldBeRendered() {
      return this.wot.getSetting('fixedColumnsLeft') || this.wot.getSetting('rowHeaders').length ? true : false;
    }

    /**
     * Updates the left overlay position
     */
  }, {
    key: 'resetFixedPosition',
    value: function resetFixedPosition() {
      if (!this.needFullRender || !this.wot.wtTable.holder.parentNode) {
        // removed from DOM
        return;
      }
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      var headerPosition = 0;

      if (this.trimmingContainer === window) {
        var box = this.wot.wtTable.hider.getBoundingClientRect();
        var left = Math.ceil(box.left);
        var right = Math.ceil(box.right);
        var finalLeft = undefined;
        var finalTop = undefined;

        finalTop = this.wot.wtTable.hider.style.top;
        finalTop = finalTop === '' ? 0 : finalTop;

        if (left < 0 && right - overlayRoot.offsetWidth > 0) {
          finalLeft = -left;
        } else {
          finalLeft = 0;
        }
        headerPosition = finalLeft;
        finalLeft = finalLeft + 'px';

        (0, _helpersDomElement.setOverlayPosition)(overlayRoot, finalLeft, finalTop);
      } else {
        headerPosition = this.getScrollPosition();
      }
      this.adjustHeaderBordersPosition(headerPosition);

      this.adjustElementsSize();
    }

    /**
     * Sets the main overlay's horizontal scroll position
     *
     * @param {Number} pos
     */
  }, {
    key: 'setScrollPosition',
    value: function setScrollPosition(pos) {
      if (this.mainTableScrollableElement === window) {
        window.scrollTo(pos, (0, _helpersDomElement.getWindowScrollTop)());
      } else {
        this.mainTableScrollableElement.scrollLeft = pos;
      }
    }

    /**
     * Triggers onScroll hook callback
     */
  }, {
    key: 'onScroll',
    value: function onScroll() {
      this.wot.getSetting('onScrollHorizontally');
    }

    /**
     * Calculates total sum cells width
     *
     * @param {Number} from Column index which calculates started from
     * @param {Number} to Column index where calculation is finished
     * @returns {Number} Width sum
     */
  }, {
    key: 'sumCellSizes',
    value: function sumCellSizes(from, to) {
      var sum = 0;
      var defaultColumnWidth = this.wot.wtSettings.defaultColumnWidth;

      while (from < to) {
        sum += this.wot.wtTable.getStretchedColumnWidth(from) || defaultColumnWidth;
        from++;
      }

      return sum;
    }

    /**
     * Adjust overlay root element, childs and master table element sizes (width, height).
     *
     * @param {Boolean} [force=false]
     */
  }, {
    key: 'adjustElementsSize',
    value: function adjustElementsSize() {
      var force = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

      if (this.needFullRender || force) {
        this.adjustRootElementSize();
        this.adjustRootChildsSize();

        if (!force) {
          this.areElementSizesAdjusted = true;
        }
      }
    }

    /**
     * Adjust overlay root element size (width and height).
     */
  }, {
    key: 'adjustRootElementSize',
    value: function adjustRootElementSize() {
      var masterHolder = this.wot.wtTable.holder;
      var scrollbarHeight = masterHolder.clientHeight !== masterHolder.offsetHeight ? (0, _helpersDomElement.getScrollbarWidth)() : 0;
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      var overlayRootStyle = overlayRoot.style;
      var tableWidth = undefined;

      if (this.trimmingContainer !== window) {
        overlayRootStyle.height = this.wot.wtViewport.getWorkspaceHeight() - scrollbarHeight + 'px';
      }
      this.clone.wtTable.holder.style.height = overlayRootStyle.height;

      tableWidth = (0, _helpersDomElement.outerWidth)(this.clone.wtTable.TABLE);
      overlayRootStyle.width = (tableWidth === 0 ? tableWidth : tableWidth + 4) + 'px';
    }

    /**
     * Adjust overlay root childs size
     */
  }, {
    key: 'adjustRootChildsSize',
    value: function adjustRootChildsSize() {
      var scrollbarWidth = (0, _helpersDomElement.getScrollbarWidth)();

      this.clone.wtTable.hider.style.height = this.hider.style.height;
      this.clone.wtTable.holder.style.height = this.clone.wtTable.holder.parentNode.style.height;

      if (scrollbarWidth === 0) {
        scrollbarWidth = 30;
      }
      this.clone.wtTable.holder.style.width = parseInt(this.clone.wtTable.holder.parentNode.style.width, 10) + scrollbarWidth + 'px';
    }

    /**
     * Adjust the overlay dimensions and position
     */
  }, {
    key: 'applyToDOM',
    value: function applyToDOM() {
      var total = this.wot.getSetting('totalColumns');

      if (!this.areElementSizesAdjusted) {
        this.adjustElementsSize();
      }
      if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === 'number') {
        this.spreader.style.left = this.wot.wtViewport.columnsRenderCalculator.startPosition + 'px';
      } else if (total === 0) {
        this.spreader.style.left = '0';
      } else {
        throw new Error('Incorrect value of the columnsRenderCalculator');
      }
      this.spreader.style.right = '';

      if (this.needFullRender) {
        this.syncOverlayOffset();
      }
    }

    /**
     * Synchronize calculated top position to an element
     */
  }, {
    key: 'syncOverlayOffset',
    value: function syncOverlayOffset() {
      if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === 'number') {
        this.clone.wtTable.spreader.style.top = this.wot.wtViewport.rowsRenderCalculator.startPosition + 'px';
      } else {
        this.clone.wtTable.spreader.style.top = '';
      }
    }

    /**
     * Scrolls horizontally to a column at the left edge of the viewport
     *
     * @param sourceCol {Number} Column index which you want to scroll to
     * @param [beyondRendered=false] {Boolean} if `true`, scrolls according to the bottom edge (top edge is by default)
     */
  }, {
    key: 'scrollTo',
    value: function scrollTo(sourceCol, beyondRendered) {
      var newX = this.getTableParentOffset();
      var sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;
      var mainHolder = sourceInstance.wtTable.holder;
      var scrollbarCompensation = 0;

      if (beyondRendered && mainHolder.offsetWidth !== mainHolder.clientWidth) {
        scrollbarCompensation = (0, _helpersDomElement.getScrollbarWidth)();
      }
      if (beyondRendered) {
        newX += this.sumCellSizes(0, sourceCol + 1);
        newX -= this.wot.wtViewport.getViewportWidth();
      } else {
        newX += this.sumCellSizes(this.wot.getSetting('fixedColumnsLeft'), sourceCol);
      }
      newX += scrollbarCompensation;

      this.setScrollPosition(newX);
    }

    /**
     * Gets table parent left position
     *
     * @returns {Number}
     */
  }, {
    key: 'getTableParentOffset',
    value: function getTableParentOffset() {
      if (this.trimmingContainer === window) {
        return this.wot.wtTable.holderOffset.left;
      } else {
        return 0;
      }
    }

    /**
     * Gets the main overlay's horizontal scroll position
     *
     * @returns {Number} Main table's vertical scroll position
     */
  }, {
    key: 'getScrollPosition',
    value: function getScrollPosition() {
      return (0, _helpersDomElement.getScrollLeft)(this.mainTableScrollableElement);
    }

    /**
     * Adds css classes to hide the header border's header (cell-selection border hiding issue)
     *
     * @param {Number} position Header X position if trimming container is window or scroll top if not
     */
  }, {
    key: 'adjustHeaderBordersPosition',
    value: function adjustHeaderBordersPosition(position) {
      var masterParent = this.wot.wtTable.holder.parentNode;
      var rowHeaders = this.wot.getSetting('rowHeaders');
      var fixedColumnsLeft = this.wot.getSetting('fixedColumnsLeft');

      if (fixedColumnsLeft && !rowHeaders.length) {
        (0, _helpersDomElement.addClass)(masterParent, 'innerBorderLeft');
      } else if (!fixedColumnsLeft && rowHeaders.length) {
        var previousState = (0, _helpersDomElement.hasClass)(masterParent, 'innerBorderLeft');

        if (position) {
          (0, _helpersDomElement.addClass)(masterParent, 'innerBorderLeft');
        } else {
          (0, _helpersDomElement.removeClass)(masterParent, 'innerBorderLeft');
        }
        if (!previousState && position || previousState && !position) {
          this.wot.wtOverlays.adjustElementsSize();
        }
      }
    }
  }]);

  return WalkontableLeftOverlay;
})(_base.WalkontableOverlay);

exports.WalkontableLeftOverlay = WalkontableLeftOverlay;

window.WalkontableLeftOverlay = WalkontableLeftOverlay;

},{"./../../../../helpers/dom/element":50,"./_base":17}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _helpersDomElement = require('./../../../../helpers/dom/element');

var _base = require('./_base');

/**
 * @class WalkontableTopOverlay
 */

var WalkontableTopOverlay = (function (_WalkontableOverlay) {
  _inherits(WalkontableTopOverlay, _WalkontableOverlay);

  /**
   * @param {Walkontable} wotInstance
   */

  function WalkontableTopOverlay(wotInstance) {
    _classCallCheck(this, WalkontableTopOverlay);

    _get(Object.getPrototypeOf(WalkontableTopOverlay.prototype), 'constructor', this).call(this, wotInstance);
    this.clone = this.makeClone(_base.WalkontableOverlay.CLONE_TOP);
  }

  /**
   * Checks if overlay should be fully rendered
   *
   * @returns {Boolean}
   */

  _createClass(WalkontableTopOverlay, [{
    key: 'shouldBeRendered',
    value: function shouldBeRendered() {
      return this.wot.getSetting('fixedRowsTop') || this.wot.getSetting('columnHeaders').length ? true : false;
    }

    /**
     * Updates the top overlay position
     */
  }, {
    key: 'resetFixedPosition',
    value: function resetFixedPosition() {
      if (!this.needFullRender || !this.wot.wtTable.holder.parentNode) {
        // removed from DOM
        return;
      }
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      var headerPosition = 0;

      if (this.wot.wtOverlays.leftOverlay.trimmingContainer === window) {
        var box = this.wot.wtTable.hider.getBoundingClientRect();
        var _top = Math.ceil(box.top);
        var bottom = Math.ceil(box.bottom);
        var finalLeft = undefined;
        var finalTop = undefined;

        finalLeft = this.wot.wtTable.hider.style.left;
        finalLeft = finalLeft === '' ? 0 : finalLeft;

        if (_top < 0 && bottom - overlayRoot.offsetHeight > 0) {
          finalTop = -_top;
        } else {
          finalTop = 0;
        }
        headerPosition = finalTop;
        finalTop = finalTop + 'px';

        (0, _helpersDomElement.setOverlayPosition)(overlayRoot, finalLeft, finalTop);
      } else {
        headerPosition = this.getScrollPosition();
      }
      this.adjustHeaderBordersPosition(headerPosition);

      this.adjustElementsSize();
    }

    /**
     * Sets the main overlay's vertical scroll position
     *
     * @param {Number} pos
     */
  }, {
    key: 'setScrollPosition',
    value: function setScrollPosition(pos) {
      if (this.mainTableScrollableElement === window) {
        window.scrollTo((0, _helpersDomElement.getWindowScrollLeft)(), pos);
      } else {
        this.mainTableScrollableElement.scrollTop = pos;
      }
    }

    /**
     * Triggers onScroll hook callback
     */
  }, {
    key: 'onScroll',
    value: function onScroll() {
      this.wot.getSetting('onScrollVertically');
    }

    /**
     * Calculates total sum cells height
     *
     * @param {Number} from Row index which calculates started from
     * @param {Number} to Row index where calculation is finished
     * @returns {Number} Height sum
     */
  }, {
    key: 'sumCellSizes',
    value: function sumCellSizes(from, to) {
      var sum = 0;
      var defaultRowHeight = this.wot.wtSettings.settings.defaultRowHeight;

      while (from < to) {
        sum += this.wot.wtTable.getRowHeight(from) || defaultRowHeight;
        from++;
      }

      return sum;
    }

    /**
     * Adjust overlay root element, childs and master table element sizes (width, height).
     *
     * @param {Boolean} [force=false]
     */
  }, {
    key: 'adjustElementsSize',
    value: function adjustElementsSize() {
      var force = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

      if (this.needFullRender || force) {
        this.adjustRootElementSize();
        this.adjustRootChildsSize();

        if (!force) {
          this.areElementSizesAdjusted = true;
        }
      }
    }

    /**
     * Adjust overlay root element size (width and height).
     */
  }, {
    key: 'adjustRootElementSize',
    value: function adjustRootElementSize() {
      var masterHolder = this.wot.wtTable.holder;
      var scrollbarWidth = masterHolder.clientWidth !== masterHolder.offsetWidth ? (0, _helpersDomElement.getScrollbarWidth)() : 0;
      var overlayRoot = this.clone.wtTable.holder.parentNode;
      var overlayRootStyle = overlayRoot.style;
      var tableHeight = undefined;

      if (this.trimmingContainer !== window) {
        overlayRootStyle.width = this.wot.wtViewport.getWorkspaceWidth() - scrollbarWidth + 'px';
      }
      this.clone.wtTable.holder.style.width = overlayRootStyle.width;

      tableHeight = (0, _helpersDomElement.outerHeight)(this.clone.wtTable.TABLE);
      overlayRootStyle.height = (tableHeight === 0 ? tableHeight : tableHeight + 4) + 'px';
    }

    /**
     * Adjust overlay root childs size
     */
  }, {
    key: 'adjustRootChildsSize',
    value: function adjustRootChildsSize() {
      var scrollbarWidth = (0, _helpersDomElement.getScrollbarWidth)();

      this.clone.wtTable.hider.style.width = this.hider.style.width;
      this.clone.wtTable.holder.style.width = this.clone.wtTable.holder.parentNode.style.width;

      if (scrollbarWidth === 0) {
        scrollbarWidth = 30;
      }
      this.clone.wtTable.holder.style.height = parseInt(this.clone.wtTable.holder.parentNode.style.height, 10) + scrollbarWidth + 'px';
    }

    /**
     * Adjust the overlay dimensions and position
     */
  }, {
    key: 'applyToDOM',
    value: function applyToDOM() {
      var total = this.wot.getSetting('totalRows');

      if (!this.areElementSizesAdjusted) {
        this.adjustElementsSize();
      }
      if (typeof this.wot.wtViewport.rowsRenderCalculator.startPosition === 'number') {
        this.spreader.style.top = this.wot.wtViewport.rowsRenderCalculator.startPosition + 'px';
      } else if (total === 0) {
        // can happen if there are 0 rows
        this.spreader.style.top = '0';
      } else {
        throw new Error("Incorrect value of the rowsRenderCalculator");
      }
      this.spreader.style.bottom = '';

      if (this.needFullRender) {
        this.syncOverlayOffset();
      }
    }

    /**
     * Synchronize calculated left position to an element
     */
  }, {
    key: 'syncOverlayOffset',
    value: function syncOverlayOffset() {
      if (typeof this.wot.wtViewport.columnsRenderCalculator.startPosition === 'number') {
        this.clone.wtTable.spreader.style.left = this.wot.wtViewport.columnsRenderCalculator.startPosition + 'px';
      } else {
        this.clone.wtTable.spreader.style.left = '';
      }
    }

    /**
     * Scrolls vertically to a row
     *
     * @param sourceRow {Number} Row index which you want to scroll to
     * @param [bottomEdge=false] {Boolean} if `true`, scrolls according to the bottom edge (top edge is by default)
     */
  }, {
    key: 'scrollTo',
    value: function scrollTo(sourceRow, bottomEdge) {
      var newY = this.getTableParentOffset();
      var sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;
      var mainHolder = sourceInstance.wtTable.holder;
      var scrollbarCompensation = 0;

      if (bottomEdge && mainHolder.offsetHeight !== mainHolder.clientHeight) {
        scrollbarCompensation = (0, _helpersDomElement.getScrollbarWidth)();
      }

      if (bottomEdge) {
        newY += this.sumCellSizes(0, sourceRow + 1);
        newY -= this.wot.wtViewport.getViewportHeight();
        // Fix 1 pixel offset when cell is selected
        newY += 1;
      } else {
        newY += this.sumCellSizes(this.wot.getSetting('fixedRowsTop'), sourceRow);
      }
      newY += scrollbarCompensation;

      this.setScrollPosition(newY);
    }

    /**
     * Gets table parent top position
     *
     * @returns {Number}
     */
  }, {
    key: 'getTableParentOffset',
    value: function getTableParentOffset() {
      if (this.mainTableScrollableElement === window) {
        return this.wot.wtTable.holderOffset.top;
      } else {
        return 0;
      }
    }

    /**
     * Gets the main overlay's vertical scroll position
     *
     * @returns {Number} Main table's vertical scroll position
     */
  }, {
    key: 'getScrollPosition',
    value: function getScrollPosition() {
      return (0, _helpersDomElement.getScrollTop)(this.mainTableScrollableElement);
    }

    /**
     * Adds css classes to hide the header border's header (cell-selection border hiding issue)
     *
     * @param {Number} position Header Y position if trimming container is window or scroll top if not
     */
  }, {
    key: 'adjustHeaderBordersPosition',
    value: function adjustHeaderBordersPosition(position) {
      if (this.wot.getSetting('fixedRowsTop') === 0 && this.wot.getSetting('columnHeaders').length > 0) {
        var masterParent = this.wot.wtTable.holder.parentNode;
        var previousState = (0, _helpersDomElement.hasClass)(masterParent, 'innerBorderTop');

        if (position) {
          (0, _helpersDomElement.addClass)(masterParent, 'innerBorderTop');
        } else {
          (0, _helpersDomElement.removeClass)(masterParent, 'innerBorderTop');
        }
        if (!previousState && position || previousState && !position) {
          this.wot.wtOverlays.adjustElementsSize();
        }
      }
      // nasty workaround for double border in the header, TODO: find a pure-css solution
      if (this.wot.getSetting('rowHeaders').length === 0) {
        var secondHeaderCell = this.clone.wtTable.THEAD.querySelector('th:nth-of-type(2)');

        if (secondHeaderCell) {
          secondHeaderCell.style['border-left-width'] = 0;
        }
      }
    }
  }]);

  return WalkontableTopOverlay;
})(_base.WalkontableOverlay);

exports.WalkontableTopOverlay = WalkontableTopOverlay;

window.WalkontableTopOverlay = WalkontableTopOverlay;

},{"./../../../../helpers/dom/element":50,"./_base":17}],22:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _helpersDomElement = require('./../../../helpers/dom/element');

var _helpersUnicode = require('./../../../helpers/unicode');

var _eventManager = require('./../../../eventManager');

var _overlayCorner = require('./overlay/corner');

var _overlayDebug = require('./overlay/debug');

var _overlayLeft = require('./overlay/left');

var _overlayTop = require('./overlay/top');

/**
 * @class WalkontableOverlays
 */

var WalkontableOverlays = (function () {
  /**
   * @param {Walkontable} wotInstance
   */

  function WalkontableOverlays(wotInstance) {
    _classCallCheck(this, WalkontableOverlays);

    this.wot = wotInstance;

    // legacy support
    this.instance = this.wot;
    this.eventManager = new _eventManager.EventManager(this.wot);

    this.wot.update('scrollbarWidth', (0, _helpersDomElement.getScrollbarWidth)());
    this.wot.update('scrollbarHeight', (0, _helpersDomElement.getScrollbarWidth)());

    this.mainTableScrollableElement = (0, _helpersDomElement.getScrollableElement)(this.wot.wtTable.TABLE);

    this.topOverlay = new _overlayTop.WalkontableTopOverlay(this.wot);
    this.leftOverlay = new _overlayLeft.WalkontableLeftOverlay(this.wot);

    if (this.topOverlay.needFullRender && this.leftOverlay.needFullRender) {
      this.topLeftCornerOverlay = new _overlayCorner.WalkontableCornerOverlay(this.wot);
    }
    if (this.wot.getSetting('debug')) {
      this.debug = new _overlayDebug.WalkontableDebugOverlay(this.wot);
    }

    this.destroyed = false;
    this.keyPressed = false;
    this.spreaderLastSize = {
      width: null,
      height: null
    };
    this.overlayScrollPositions = {
      'master': {
        top: 0,
        left: 0
      },
      'top': {
        top: null,
        left: 0
      },
      'left': {
        top: 0,
        left: null
      }
    };
    this.registerListeners();
  }

  /**
   * Refresh and redraw table
   */

  _createClass(WalkontableOverlays, [{
    key: 'refreshAll',
    value: function refreshAll() {
      if (!this.wot.drawn) {
        return;
      }
      if (!this.wot.wtTable.holder.parentNode) {
        // Walkontable was detached from DOM, but this handler was not removed
        this.destroy();

        return;
      }
      this.wot.draw(true);

      this.topOverlay.onScroll();
      this.leftOverlay.onScroll();
    }

    /**
     * Register all necessary event listeners
     */
  }, {
    key: 'registerListeners',
    value: function registerListeners() {
      var _this = this;

      this.eventManager.addEventListener(document.documentElement, 'keydown', function (event) {
        return _this.onKeyDown(event);
      });
      this.eventManager.addEventListener(document.documentElement, 'keyup', function () {
        return _this.onKeyUp();
      });
      this.eventManager.addEventListener(document, 'visibilitychange', function () {
        return _this.onKeyUp();
      });

      this.eventManager.addEventListener(this.mainTableScrollableElement, 'scroll', function (event) {
        return _this.onTableScroll(event);
      });

      if (this.topOverlay.needFullRender) {
        this.eventManager.addEventListener(this.topOverlay.clone.wtTable.holder, 'scroll', function (event) {
          return _this.onTableScroll(event);
        });
        this.eventManager.addEventListener(this.topOverlay.clone.wtTable.holder, 'wheel', function (event) {
          return _this.onTableScroll(event);
        });
      }

      if (this.leftOverlay.needFullRender) {
        this.eventManager.addEventListener(this.leftOverlay.clone.wtTable.holder, 'scroll', function (event) {
          return _this.onTableScroll(event);
        });
        this.eventManager.addEventListener(this.leftOverlay.clone.wtTable.holder, 'wheel', function (event) {
          return _this.onTableScroll(event);
        });
      }

      if (this.topOverlay.trimmingContainer !== window && this.leftOverlay.trimmingContainer !== window) {
        // This is necessary?
        //eventManager.addEventListener(window, 'scroll', (event) => this.refreshAll(event));
        this.eventManager.addEventListener(window, 'wheel', function (event) {
          var overlay = undefined;
          var deltaY = event.wheelDeltaY || event.deltaY;
          var deltaX = event.wheelDeltaX || event.deltaX;

          if (_this.topOverlay.clone.wtTable.holder.contains(event.realTarget)) {
            overlay = 'top';
          } else if (_this.leftOverlay.clone.wtTable.holder.contains(event.realTarget)) {
            overlay = 'left';
          }

          if (overlay == 'top' && deltaY !== 0) {
            event.preventDefault();
          } else if (overlay == 'left' && deltaX !== 0) {
            event.preventDefault();
          }
        });
      }
    }

    /**
     * Scroll listener
     *
     * @param {Event} event
     */
  }, {
    key: 'onTableScroll',
    value: function onTableScroll(event) {
      // if mobile browser, do not update scroll positions, as the overlays are hidden during the scroll
      if (Handsontable.mobileBrowser) {
        return;
      }
      // For key press, sync only master -> overlay position because while pressing Walkontable.render is triggered
      // by hot.refreshBorder
      if (this.keyPressed && this.mainTableScrollableElement !== window && !event.target.contains(this.mainTableScrollableElement)) {
        return;
      }
      if (event.type === 'scroll') {
        this.syncScrollPositions(event);
      } else {
        this.translateMouseWheelToScroll(event);
      }
    }

    /**
     * Key down listener
     */
  }, {
    key: 'onKeyDown',
    value: function onKeyDown(event) {
      this.keyPressed = (0, _helpersUnicode.isKey)(event.keyCode, 'ARROW_UP|ARROW_RIGHT|ARROW_DOWN|ARROW_LEFT');
    }

    /**
     * Key up listener
     */
  }, {
    key: 'onKeyUp',
    value: function onKeyUp() {
      this.keyPressed = false;
    }

    /**
     * Translate wheel event into scroll event and sync scroll overlays position
     *
     * @param {Event} event
     * @returns {Boolean}
     */
  }, {
    key: 'translateMouseWheelToScroll',
    value: function translateMouseWheelToScroll(event) {
      var topOverlay = this.topOverlay.clone.wtTable.holder;
      var leftOverlay = this.leftOverlay.clone.wtTable.holder;
      var eventMockup = { type: 'wheel' };
      var tempElem = event.target;
      var deltaY = event.wheelDeltaY || -1 * event.deltaY;
      var deltaX = event.wheelDeltaX || -1 * event.deltaX;
      var parentHolder = undefined;

      while (tempElem != document && tempElem != null) {
        if (tempElem.className.indexOf('wtHolder') > -1) {
          parentHolder = tempElem;
          break;
        }
        tempElem = tempElem.parentNode;
      }
      eventMockup.target = parentHolder;

      if (parentHolder == topOverlay) {
        this.syncScrollPositions(eventMockup, -0.2 * deltaY);
      } else if (parentHolder == leftOverlay) {
        this.syncScrollPositions(eventMockup, -0.2 * deltaX);
      }

      return false;
    }

    /**
     * Synchronize scroll position between master table and overlay table
     *
     * @param {Event|Object} event
     * @param {Number} [fakeScrollValue=null]
     */
  }, {
    key: 'syncScrollPositions',
    value: function syncScrollPositions(event) {
      var fakeScrollValue = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

      if (this.destroyed) {
        return;
      }
      if (arguments.length === 0) {
        this.syncScrollWithMaster();

        return;
      }
      var master = this.mainTableScrollableElement;
      var target = event.target;
      var tempScrollValue = 0;
      var scrollValueChanged = false;
      var topOverlay = undefined;
      var leftOverlay = undefined;

      if (this.topOverlay.needFullRender) {
        topOverlay = this.topOverlay.clone.wtTable.holder;
      }
      if (this.leftOverlay.needFullRender) {
        leftOverlay = this.leftOverlay.clone.wtTable.holder;
      }

      if (target === document) {
        target = window;
      }

      if (target === master) {
        tempScrollValue = (0, _helpersDomElement.getScrollLeft)(target);

        // if scrolling the master table - populate the scroll values to both top and left overlays
        if (this.overlayScrollPositions.master.left !== tempScrollValue) {
          this.overlayScrollPositions.master.left = tempScrollValue;
          scrollValueChanged = true;

          if (topOverlay) {
            topOverlay.scrollLeft = tempScrollValue;
          }
        }
        tempScrollValue = (0, _helpersDomElement.getScrollTop)(target);

        if (this.overlayScrollPositions.master.top !== tempScrollValue) {
          this.overlayScrollPositions.master.top = tempScrollValue;
          scrollValueChanged = true;

          if (leftOverlay) {
            leftOverlay.scrollTop = tempScrollValue;
          }
        }
      } else if (target === topOverlay) {
        tempScrollValue = (0, _helpersDomElement.getScrollLeft)(target);

        // if scrolling the top overlay - populate the horizontal scroll to the master table
        if (this.overlayScrollPositions.top.left !== tempScrollValue) {
          this.overlayScrollPositions.top.left = tempScrollValue;
          scrollValueChanged = true;

          master.scrollLeft = tempScrollValue;
        }

        // "fake" scroll value calculated from the mousewheel event
        if (fakeScrollValue !== null) {
          scrollValueChanged = true;
          master.scrollTop += fakeScrollValue;
        }
      } else if (target === leftOverlay) {
        tempScrollValue = (0, _helpersDomElement.getScrollTop)(target);

        // if scrolling the left overlay - populate the vertical scroll to the master table
        if (this.overlayScrollPositions.left.top !== tempScrollValue) {
          this.overlayScrollPositions.left.top = tempScrollValue;
          scrollValueChanged = true;

          master.scrollTop = tempScrollValue;
        }

        // "fake" scroll value calculated from the mousewheel event
        if (fakeScrollValue !== null) {
          scrollValueChanged = true;
          master.scrollLeft += fakeScrollValue;
        }
      }

      if (!this.keyPressed && scrollValueChanged && event.type === 'scroll') {
        this.refreshAll();
      }
    }

    /**
     * Synchronize overlay scrollbars with the master scrollbar
     */
  }, {
    key: 'syncScrollWithMaster',
    value: function syncScrollWithMaster() {
      var master = this.topOverlay.mainTableScrollableElement;

      if (this.topOverlay.needFullRender) {
        this.topOverlay.clone.wtTable.holder.scrollLeft = master.scrollLeft;
      }
      if (this.leftOverlay.needFullRender) {
        this.leftOverlay.clone.wtTable.holder.scrollTop = master.scrollTop;
      }
    }

    /**
     *
     */
  }, {
    key: 'destroy',
    value: function destroy() {
      this.eventManager.destroy();
      this.topOverlay.destroy();
      this.leftOverlay.destroy();

      if (this.topLeftCornerOverlay) {
        this.topLeftCornerOverlay.destroy();
      }
      if (this.debug) {
        this.debug.destroy();
      }
      this.destroyed = true;
    }

    /**
     * @param {Boolean} [fastDraw=false]
     */
  }, {
    key: 'refresh',
    value: function refresh() {
      var fastDraw = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

      if (this.topOverlay.areElementSizesAdjusted && this.leftOverlay.areElementSizesAdjusted) {
        var container = this.wot.wtTable.wtRootElement.parentNode || this.wot.wtTable.wtRootElement;
        var width = container.clientWidth;
        var height = container.clientHeight;

        if (width !== this.spreaderLastSize.width || height !== this.spreaderLastSize.height) {
          this.spreaderLastSize.width = width;
          this.spreaderLastSize.height = height;
          this.adjustElementsSize();
        }
      }
      this.leftOverlay.refresh(fastDraw);
      this.topOverlay.refresh(fastDraw);

      if (this.topLeftCornerOverlay) {
        this.topLeftCornerOverlay.refresh(fastDraw);
      }
      if (this.debug) {
        this.debug.refresh(fastDraw);
      }
    }

    /**
     * Adjust overlays elements size and master table size
     *
     * @param {Boolean} [force=false]
     */
  }, {
    key: 'adjustElementsSize',
    value: function adjustElementsSize() {
      var force = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

      var totalColumns = this.wot.getSetting('totalColumns');
      var totalRows = this.wot.getSetting('totalRows');
      var headerRowSize = this.wot.wtViewport.getRowHeaderWidth();
      var headerColumnSize = this.wot.wtViewport.getColumnHeaderHeight();
      var hiderStyle = this.wot.wtTable.hider.style;

      hiderStyle.width = headerRowSize + this.leftOverlay.sumCellSizes(0, totalColumns) + 'px';
      hiderStyle.height = headerColumnSize + this.topOverlay.sumCellSizes(0, totalRows) + 1 + 'px';

      this.topOverlay.adjustElementsSize(force);
      this.leftOverlay.adjustElementsSize(force);
    }

    /**
     *
     */
  }, {
    key: 'applyToDOM',
    value: function applyToDOM() {
      if (!this.topOverlay.areElementSizesAdjusted || !this.leftOverlay.areElementSizesAdjusted) {
        this.adjustElementsSize();
      }
      this.topOverlay.applyToDOM();
      this.leftOverlay.applyToDOM();
    }
  }]);

  return WalkontableOverlays;
})();

exports.WalkontableOverlays = WalkontableOverlays;

window.WalkontableOverlays = WalkontableOverlays;

},{"./../../../eventManager":46,"./../../../helpers/dom/element":50,"./../../../helpers/unicode":58,"./overlay/corner":18,"./overlay/debug":19,"./overlay/left":20,"./overlay/top":21}],23:[function(require,module,exports){

/**
 * @class WalkontableScroll
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var WalkontableScroll = (function () {
  /**
   * @param {Walkontable} wotInstance
   */

  function WalkontableScroll(wotInstance) {
    _classCallCheck(this, WalkontableScroll);

    this.wot = wotInstance;

    // legacy support
    this.instance = wotInstance;
  }

  /**
   * Scrolls viewport to a cell by minimum number of cells
   *
   * @param {WalkontableCellCoords} coords
   */

  _createClass(WalkontableScroll, [{
    key: 'scrollViewport',
    value: function scrollViewport(coords) {
      if (!this.wot.drawn) {
        return;
      }
      var totalRows = this.wot.getSetting('totalRows');
      var totalColumns = this.wot.getSetting('totalColumns');

      if (coords.row < 0 || coords.row > totalRows - 1) {
        throw new Error('row ' + coords.row + ' does not exist');
      }

      if (coords.col < 0 || coords.col > totalColumns - 1) {
        throw new Error('column ' + coords.col + ' does not exist');
      }

      if (coords.row > this.instance.wtTable.getLastVisibleRow()) {
        this.wot.wtOverlays.topOverlay.scrollTo(coords.row, true);
      } else if (coords.row >= this.instance.getSetting('fixedRowsTop') && coords.row < this.instance.wtTable.getFirstVisibleRow()) {
        this.wot.wtOverlays.topOverlay.scrollTo(coords.row);
      }

      if (coords.col > this.instance.wtTable.getLastVisibleColumn()) {
        this.wot.wtOverlays.leftOverlay.scrollTo(coords.col, true);
      } else if (coords.col >= this.instance.getSetting('fixedColumnsLeft') && coords.col < this.instance.wtTable.getFirstVisibleColumn()) {
        this.wot.wtOverlays.leftOverlay.scrollTo(coords.col);
      }
    }
  }]);

  return WalkontableScroll;
})();

exports.WalkontableScroll = WalkontableScroll;

window.WalkontableScroll = WalkontableScroll;

},{}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _helpersDomElement = require('./../../../helpers/dom/element');

var _border = require('./border');

var _cellCoords = require('./cell/coords');

var _cellRange = require('./cell/range');

/**
 * @class WalkontableSelection
 */

var WalkontableSelection = (function () {
  /**
   * @param {Object} settings
   * @param {WalkontableCellRange} cellRange
   */

  function WalkontableSelection(settings, cellRange) {
    _classCallCheck(this, WalkontableSelection);

    this.settings = settings;
    this.cellRange = cellRange || null;
    this.instanceBorders = {};
  }

  /**
   * Each Walkontable clone requires it's own border for every selection. This method creates and returns selection
   * borders per instance
   *
   * @param {Walkontable} wotInstance
   * @returns {WalkontableBorder}
   */

  _createClass(WalkontableSelection, [{
    key: 'getBorder',
    value: function getBorder(wotInstance) {
      if (this.instanceBorders[wotInstance.guid]) {
        return this.instanceBorders[wotInstance.guid];
      }
      // where is this returned?
      this.instanceBorders[wotInstance.guid] = new _border.WalkontableBorder(wotInstance, this.settings);
    }

    /**
     * Checks if selection is empty
     *
     * @returns {Boolean}
     */
  }, {
    key: 'isEmpty',
    value: function isEmpty() {
      return this.cellRange === null;
    }

    /**
     * Adds a cell coords to the selection
     *
     * @param {WalkontableCellCoords} coords
     */
  }, {
    key: 'add',
    value: function add(coords) {
      if (this.isEmpty()) {
        this.cellRange = new _cellRange.WalkontableCellRange(coords, coords, coords);
      } else {
        this.cellRange.expand(coords);
      }
    }

    /**
     * If selection range from or to property equals oldCoords, replace it with newCoords. Return boolean
     * information about success
     *
     * @param {WalkontableCellCoords} oldCoords
     * @param {WalkontableCellCoords} newCoords
     * @returns {Boolean}
     */
  }, {
    key: 'replace',
    value: function replace(oldCoords, newCoords) {
      if (!this.isEmpty()) {
        if (this.cellRange.from.isEqual(oldCoords)) {
          this.cellRange.from = newCoords;

          return true;
        }
        if (this.cellRange.to.isEqual(oldCoords)) {
          this.cellRange.to = newCoords;

          return true;
        }
      }

      return false;
    }

    /**
     * Clears selection
     */
  }, {
    key: 'clear',
    value: function clear() {
      this.cellRange = null;
    }

    /**
     * Returns the top left (TL) and bottom right (BR) selection coordinates
     *
     * @returns {Array} Returns array of coordinates for example `[1, 1, 5, 5]`
     */
  }, {
    key: 'getCorners',
    value: function getCorners() {
      var topLeft = this.cellRange.getTopLeftCorner();
      var bottomRight = this.cellRange.getBottomRightCorner();

      return [topLeft.row, topLeft.col, bottomRight.row, bottomRight.col];
    }

    /**
     * Adds class name to cell element at given coords
     *
     * @param {Walkontable} wotInstance Walkontable instance
     * @param {Number} sourceRow Cell row coord
     * @param {Number} sourceColumn Cell column coord
     * @param {String} className Class name
     */
  }, {
    key: 'addClassAtCoords',
    value: function addClassAtCoords(wotInstance, sourceRow, sourceColumn, className) {
      var TD = wotInstance.wtTable.getCell(new _cellCoords.WalkontableCellCoords(sourceRow, sourceColumn));

      if (typeof TD === 'object') {
        (0, _helpersDomElement.addClass)(TD, className);
      }
    }

    /**
     * @param wotInstance
     */
  }, {
    key: 'draw',
    value: function draw(wotInstance) {
      if (this.isEmpty()) {
        if (this.settings.border) {
          var border = this.getBorder(wotInstance);

          if (border) {
            border.disappear();
          }
        }

        return;
      }
      var renderedRows = wotInstance.wtTable.getRenderedRowsCount();
      var renderedColumns = wotInstance.wtTable.getRenderedColumnsCount();
      var corners = this.getCorners();
      var sourceRow = undefined,
          sourceCol = undefined,
          TH = undefined;

      for (var column = 0; column < renderedColumns; column++) {
        sourceCol = wotInstance.wtTable.columnFilter.renderedToSource(column);

        if (sourceCol >= corners[1] && sourceCol <= corners[3]) {
          TH = wotInstance.wtTable.getColumnHeader(sourceCol);

          if (TH && this.settings.highlightColumnClassName) {
            (0, _helpersDomElement.addClass)(TH, this.settings.highlightColumnClassName);
          }
        }
      }

      for (var row = 0; row < renderedRows; row++) {
        sourceRow = wotInstance.wtTable.rowFilter.renderedToSource(row);

        if (sourceRow >= corners[0] && sourceRow <= corners[2]) {
          TH = wotInstance.wtTable.getRowHeader(sourceRow);

          if (TH && this.settings.highlightRowClassName) {
            (0, _helpersDomElement.addClass)(TH, this.settings.highlightRowClassName);
          }
        }

        for (var column = 0; column < renderedColumns; column++) {
          sourceCol = wotInstance.wtTable.columnFilter.renderedToSource(column);

          if (sourceRow >= corners[0] && sourceRow <= corners[2] && sourceCol >= corners[1] && sourceCol <= corners[3]) {
            // selected cell
            if (this.settings.className) {
              this.addClassAtCoords(wotInstance, sourceRow, sourceCol, this.settings.className);
            }
          } else if (sourceRow >= corners[0] && sourceRow <= corners[2]) {
            // selection is in this row
            if (this.settings.highlightRowClassName) {
              this.addClassAtCoords(wotInstance, sourceRow, sourceCol, this.settings.highlightRowClassName);
            }
          } else if (sourceCol >= corners[1] && sourceCol <= corners[3]) {
            // selection is in this column
            if (this.settings.highlightColumnClassName) {
              this.addClassAtCoords(wotInstance, sourceRow, sourceCol, this.settings.highlightColumnClassName);
            }
          }
        }
      }
      wotInstance.getSetting('onBeforeDrawBorders', corners, this.settings.className);

      if (this.settings.border) {
        var border = this.getBorder(wotInstance);

        if (border) {
          // warning! border.appear modifies corners!
          border.appear(corners);
        }
      }
    }
  }]);

  return WalkontableSelection;
})();

exports.WalkontableSelection = WalkontableSelection;

window.WalkontableSelection = WalkontableSelection;

},{"./../../../helpers/dom/element":50,"./border":8,"./cell/coords":11,"./cell/range":12}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _helpersDomElement = require('./../../../helpers/dom/element');

/**
 * @class WalkontableSettings
 */

var WalkontableSettings = (function () {
  /**
   * @param {Walkontable} wotInstance
   * @param {Object} settings
   */

  function WalkontableSettings(wotInstance, settings) {
    var _this = this;

    _classCallCheck(this, WalkontableSettings);

    this.wot = wotInstance;
    // legacy support
    this.instance = wotInstance;

    // default settings. void 0 means it is required, null means it can be empty
    this.defaults = {
      table: void 0,
      debug: false, // shows WalkontableDebugOverlay

      // presentation mode
      externalRowCalculator: false,
      stretchH: 'none', // values: all, last, none
      currentRowClassName: null,
      currentColumnClassName: null,

      //data source
      data: void 0,
      fixedColumnsLeft: 0,
      fixedRowsTop: 0,
      // this must be array of functions: [function (row, TH) {}]
      rowHeaders: function rowHeaders() {
        return [];
      },
      // this must be array of functions: [function (column, TH) {}]
      columnHeaders: function columnHeaders() {
        return [];
      },
      totalRows: void 0,
      totalColumns: void 0,
      cellRenderer: function cellRenderer(row, column, TD) {
        var cellData = _this.getSetting('data', row, column);

        (0, _helpersDomElement.fastInnerText)(TD, cellData === void 0 || cellData === null ? '' : cellData);
      },
      // columnWidth: 50,
      columnWidth: function columnWidth(col) {
        return; //return undefined means use default size for the rendered cell content
      },
      rowHeight: function rowHeight(row) {
        return; //return undefined means use default size for the rendered cell content
      },
      defaultRowHeight: 23,
      defaultColumnWidth: 50,
      selections: null,
      hideBorderOnMouseDownOver: false,
      viewportRowCalculatorOverride: null,
      viewportColumnCalculatorOverride: null,

      //callbacks
      onCellMouseDown: null,
      onCellMouseOver: null,
      //    onCellMouseOut: null,
      onCellDblClick: null,
      onCellCornerMouseDown: null,
      onCellCornerDblClick: null,
      beforeDraw: null,
      onDraw: null,
      onBeforeDrawBorders: null,
      onScrollVertically: null,
      onScrollHorizontally: null,
      onBeforeTouchScroll: null,
      onAfterMomentumScroll: null,

      //constants
      scrollbarWidth: 10,
      scrollbarHeight: 10,

      renderAllRows: false,
      groups: false
    };
    // reference to settings
    this.settings = {};

    for (var i in this.defaults) {
      if (this.defaults.hasOwnProperty(i)) {
        if (settings[i] !== void 0) {
          this.settings[i] = settings[i];
        } else if (this.defaults[i] === void 0) {
          throw new Error('A required setting "' + i + '" was not provided');
        } else {
          this.settings[i] = this.defaults[i];
        }
      }
    }
  }

  /**
   * Update settings
   *
   * @param {Object} settings
   * @param {*} value
   * @returns {Walkontable}
   */

  _createClass(WalkontableSettings, [{
    key: 'update',
    value: function update(settings, value) {
      if (value === void 0) {
        //settings is object
        for (var i in settings) {
          if (settings.hasOwnProperty(i)) {
            this.settings[i] = settings[i];
          }
        }
      } else {
        //if value is defined then settings is the key
        this.settings[settings] = value;
      }
      return this.wot;
    }

    /**
     * Get setting by name
     *
     * @param {String} key
     * @param {*} param1
     * @param {*} param2
     * @param {*} param3
     * @param {*} param4
     * @returns {*}
     */
  }, {
    key: 'getSetting',
    value: function getSetting(key, param1, param2, param3, param4) {
      if (typeof this.settings[key] === 'function') {
        // this is faster than .apply - https://github.com/handsontable/handsontable/wiki/JavaScript-&-DOM-performance-tips
        return this.settings[key](param1, param2, param3, param4);
      } else if (param1 !== void 0 && Array.isArray(this.settings[key])) {
        // perhaps this can be removed, it is only used in tests
        return this.settings[key][param1];
      } else {
        return this.settings[key];
      }
    }

    /**
     * Checks if setting exists
     *
     * @param {Boolean} key
     * @returns {Boolean}
     */
  }, {
    key: 'has',
    value: function has(key) {
      return !!this.settings[key];
    }
  }]);

  return WalkontableSettings;
})();

exports.WalkontableSettings = WalkontableSettings;

window.WalkontableSettings = WalkontableSettings;

},{"./../../../helpers/dom/element":50}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _helpersDomElement = require('./../../../helpers/dom/element');

var _cellCoords = require('./cell/coords');

var _cellRange = require('./cell/range');

var _filterColumn = require('./filter/column');

var _overlayCorner = require('./overlay/corner');

var _overlayDebug = require('./overlay/debug');

var _overlayLeft = require('./overlay/left');

var _filterRow = require('./filter/row');

var _tableRenderer = require('./tableRenderer');

var _overlayTop = require('./overlay/top');

var WalkontableTable = (function () {
  /**
   * @param {Walkontable} wotInstance
   * @param {HTMLTableElement} table
   */

  function WalkontableTable(wotInstance, table) {
    _classCallCheck(this, WalkontableTable);

    this.wot = wotInstance;
    // legacy support
    this.instance = this.wot;
    this.TABLE = table;
    this.TBODY = null;
    this.THEAD = null;
    this.COLGROUP = null;
    this.tableOffset = 0;
    this.holderOffset = 0;

    (0, _helpersDomElement.removeTextNodes)(this.TABLE);

    this.spreader = this.createSpreader(this.TABLE);
    this.hider = this.createHider(this.spreader);
    this.holder = this.createHolder(this.hider);

    this.wtRootElement = this.holder.parentNode;
    this.alignOverlaysWithTrimmingContainer();
    this.fixTableDomTree();

    this.colgroupChildrenLength = this.COLGROUP.childNodes.length;
    this.theadChildrenLength = this.THEAD.firstChild ? this.THEAD.firstChild.childNodes.length : 0;
    this.tbodyChildrenLength = this.TBODY.childNodes.length;

    this.rowFilter = null;
    this.columnFilter = null;
  }

  /**
   *
   */

  _createClass(WalkontableTable, [{
    key: 'fixTableDomTree',
    value: function fixTableDomTree() {
      this.TBODY = this.TABLE.querySelector('tbody');

      if (!this.TBODY) {
        this.TBODY = document.createElement('tbody');
        this.TABLE.appendChild(this.TBODY);
      }
      this.THEAD = this.TABLE.querySelector('thead');

      if (!this.THEAD) {
        this.THEAD = document.createElement('thead');
        this.TABLE.insertBefore(this.THEAD, this.TBODY);
      }
      this.COLGROUP = this.TABLE.querySelector('colgroup');

      if (!this.COLGROUP) {
        this.COLGROUP = document.createElement('colgroup');
        this.TABLE.insertBefore(this.COLGROUP, this.THEAD);
      }

      if (this.wot.getSetting('columnHeaders').length && !this.THEAD.childNodes.length) {
        this.THEAD.appendChild(document.createElement('TR'));
      }
    }

    /**
     * @param table
     * @returns {HTMLElement}
     */
  }, {
    key: 'createSpreader',
    value: function createSpreader(table) {
      var parent = table.parentNode;
      var spreader = undefined;

      if (!parent || parent.nodeType !== 1 || !(0, _helpersDomElement.hasClass)(parent, 'wtHolder')) {
        spreader = document.createElement('div');
        spreader.className = 'wtSpreader';

        if (parent) {
          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it
          parent.insertBefore(spreader, table);
        }
        spreader.appendChild(table);
      }
      spreader.style.position = 'relative';

      return spreader;
    }

    /**
     * @param spreader
     * @returns {HTMLElement}
     */
  }, {
    key: 'createHider',
    value: function createHider(spreader) {
      var parent = spreader.parentNode;
      var hider = undefined;

      if (!parent || parent.nodeType !== 1 || !(0, _helpersDomElement.hasClass)(parent, 'wtHolder')) {
        hider = document.createElement('div');
        hider.className = 'wtHider';

        if (parent) {
          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it
          parent.insertBefore(hider, spreader);
        }
        hider.appendChild(spreader);
      }

      return hider;
    }

    /**
     *
     * @param hider
     * @returns {HTMLElement}
     */
  }, {
    key: 'createHolder',
    value: function createHolder(hider) {
      var parent = hider.parentNode;
      var holder = undefined;

      if (!parent || parent.nodeType !== 1 || !(0, _helpersDomElement.hasClass)(parent, 'wtHolder')) {
        holder = document.createElement('div');
        holder.style.position = 'relative';
        holder.className = 'wtHolder';

        if (parent) {
          // if TABLE is detached (e.g. in Jasmine test), it has no parentNode so we cannot attach holder to it
          parent.insertBefore(holder, hider);
        }
        if (!this.isWorkingOnClone()) {
          holder.parentNode.className += 'ht_master handsontable';
        }
        holder.appendChild(hider);
      }

      return holder;
    }
  }, {
    key: 'alignOverlaysWithTrimmingContainer',
    value: function alignOverlaysWithTrimmingContainer() {
      var trimmingElement = (0, _helpersDomElement.getTrimmingContainer)(this.wtRootElement);

      if (!this.isWorkingOnClone()) {
        this.holder.parentNode.style.position = 'relative';

        if (trimmingElement === window) {
          this.holder.style.overflow = 'visible';
          this.wtRootElement.style.overflow = 'visible';
        } else {
          this.holder.style.width = (0, _helpersDomElement.getStyle)(trimmingElement, 'width');
          this.holder.style.height = (0, _helpersDomElement.getStyle)(trimmingElement, 'height');
          this.holder.style.overflow = '';
        }
      }
    }
  }, {
    key: 'isWorkingOnClone',
    value: function isWorkingOnClone() {
      return !!this.wot.cloneSource;
    }

    /**
     * Redraws the table
     *
     * @param fastDraw {Boolean} If TRUE, will try to avoid full redraw and only update the border positions. If FALSE or UNDEFINED, will perform a full redraw
     * @returns {WalkontableTable}
     */
  }, {
    key: 'draw',
    value: function draw(fastDraw) {
      if (!this.isWorkingOnClone()) {
        this.holderOffset = (0, _helpersDomElement.offset)(this.holder);
        fastDraw = this.wot.wtViewport.createRenderCalculators(fastDraw);
      }

      if (!fastDraw) {
        if (this.isWorkingOnClone()) {
          this.tableOffset = this.wot.cloneSource.wtTable.tableOffset;
        } else {
          this.tableOffset = (0, _helpersDomElement.offset)(this.TABLE);
        }
        var startRow = undefined;

        if (this.wot.cloneOverlay instanceof _overlayDebug.WalkontableDebugOverlay || this.wot.cloneOverlay instanceof _overlayTop.WalkontableTopOverlay || this.wot.cloneOverlay instanceof _overlayCorner.WalkontableCornerOverlay) {
          startRow = 0;
        } else {
          startRow = this.wot.wtViewport.rowsRenderCalculator.startRow;
        }
        var startColumn = undefined;

        if (this.wot.cloneOverlay instanceof _overlayDebug.WalkontableDebugOverlay || this.wot.cloneOverlay instanceof _overlayLeft.WalkontableLeftOverlay || this.wot.cloneOverlay instanceof _overlayCorner.WalkontableCornerOverlay) {
          startColumn = 0;
        } else {
          startColumn = this.wot.wtViewport.columnsRenderCalculator.startColumn;
        }
        this.rowFilter = new _filterRow.WalkontableRowFilter(startRow, this.wot.getSetting('totalRows'), this.wot.getSetting('columnHeaders').length);
        this.columnFilter = new _filterColumn.WalkontableColumnFilter(startColumn, this.wot.getSetting('totalColumns'), this.wot.getSetting('rowHeaders').length);
        this._doDraw(); //creates calculator after draw

        this.alignOverlaysWithTrimmingContainer();
      } else {
        if (!this.isWorkingOnClone()) {
          // in case we only scrolled without redraw, update visible rows information in oldRowsCalculator
          this.wot.wtViewport.createVisibleCalculators();
        }
        if (this.wot.wtOverlays) {
          this.wot.wtOverlays.refresh(true);
        }
      }
      this.refreshSelections(fastDraw);

      if (!this.isWorkingOnClone()) {
        this.wot.wtOverlays.topOverlay.resetFixedPosition();
        this.wot.wtOverlays.leftOverlay.resetFixedPosition();

        if (this.wot.wtOverlays.topLeftCornerOverlay) {
          this.wot.wtOverlays.topLeftCornerOverlay.resetFixedPosition();
        }
      }
      this.wot.drawn = true;

      return this;
    }
  }, {
    key: '_doDraw',
    value: function _doDraw() {
      var wtRenderer = new _tableRenderer.WalkontableTableRenderer(this);

      wtRenderer.render();
    }
  }, {
    key: 'removeClassFromCells',
    value: function removeClassFromCells(className) {
      var nodes = this.TABLE.querySelectorAll('.' + className);

      for (var i = 0, len = nodes.length; i < len; i++) {
        (0, _helpersDomElement.removeClass)(nodes[i], className);
      }
    }
  }, {
    key: 'refreshSelections',
    value: function refreshSelections(fastDraw) {
      if (!this.wot.selections) {
        return;
      }
      var len = this.wot.selections.length;

      if (fastDraw) {
        for (var i = 0; i < len; i++) {
          // there was no rerender, so we need to remove classNames by ourselves
          if (this.wot.selections[i].settings.className) {
            this.removeClassFromCells(this.wot.selections[i].settings.className);
          }
          if (this.wot.selections[i].settings.highlightRowClassName) {
            this.removeClassFromCells(this.wot.selections[i].settings.highlightRowClassName);
          }
          if (this.wot.selections[i].settings.highlightColumnClassName) {
            this.removeClassFromCells(this.wot.selections[i].settings.highlightColumnClassName);
          }
        }
      }
      for (var i = 0; i < len; i++) {
        this.wot.selections[i].draw(this.wot, fastDraw);
      }
    }

    /**
     * Get cell element at coords.
     *
     * @param {WalkontableCellCoords} coords
     * @returns {HTMLElement|Number} HTMLElement on success or Number one of the exit codes on error:
     *  -1 row before viewport
     *  -2 row after viewport
     */
  }, {
    key: 'getCell',
    value: function getCell(coords) {
      if (this.isRowBeforeRenderedRows(coords.row)) {
        // row before rendered rows
        return -1;
      } else if (this.isRowAfterRenderedRows(coords.row)) {
        // row after rendered rows
        return -2;
      }
      var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(coords.row)];

      if (TR) {
        return TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(coords.col)];
      }
    }

    /**
     * getColumnHeader
     *
     * @param {Number} col Column index
     * @param {Number} [level=0] Header level (0 = most distant to the table)
     * @returns {Object} HTMLElement on success or undefined on error
     */
  }, {
    key: 'getColumnHeader',
    value: function getColumnHeader(col) {
      var level = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

      var TR = this.THEAD.childNodes[level];

      if (TR) {
        return TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(col)];
      }
    }

    /**
     * getRowHeader
     *
     * @param {Number} row Row index
     * @returns {HTMLElement} HTMLElement on success or Number one of the exit codes on error: `null table doesn't have row headers`
     */
  }, {
    key: 'getRowHeader',
    value: function getRowHeader(row) {
      if (this.columnFilter.sourceColumnToVisibleRowHeadedColumn(0) === 0) {
        return null;
      }
      var TR = this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];

      if (TR) {
        return TR.childNodes[0];
      }
    }

    /**
     * Returns cell coords object for a given TD
     *
     * @param {HTMLTableCellElement} TD
     * @returns {WalkontableCellCoords}
     */
  }, {
    key: 'getCoords',
    value: function getCoords(TD) {
      var TR = TD.parentNode;
      var row = (0, _helpersDomElement.index)(TR);

      if (TR.parentNode === this.THEAD) {
        row = this.rowFilter.visibleColHeadedRowToSourceRow(row);
      } else {
        row = this.rowFilter.renderedToSource(row);
      }
      var col = this.columnFilter.visibleRowHeadedColumnToSourceColumn(TD.cellIndex);

      return new _cellCoords.WalkontableCellCoords(row, col);
    }
  }, {
    key: 'getTrForRow',
    value: function getTrForRow(row) {
      return this.TBODY.childNodes[this.rowFilter.sourceToRendered(row)];
    }
  }, {
    key: 'getFirstRenderedRow',
    value: function getFirstRenderedRow() {
      return this.wot.wtViewport.rowsRenderCalculator.startRow;
    }
  }, {
    key: 'getFirstVisibleRow',
    value: function getFirstVisibleRow() {
      return this.wot.wtViewport.rowsVisibleCalculator.startRow;
    }
  }, {
    key: 'getFirstRenderedColumn',
    value: function getFirstRenderedColumn() {
      return this.wot.wtViewport.columnsRenderCalculator.startColumn;
    }

    /**
     * @returns {Number} Returns -1 if no row is visible
     */
  }, {
    key: 'getFirstVisibleColumn',
    value: function getFirstVisibleColumn() {
      return this.wot.wtViewport.columnsVisibleCalculator.startColumn;
    }

    /**
     * @returns {Number} Returns -1 if no row is visible
     */
  }, {
    key: 'getLastRenderedRow',
    value: function getLastRenderedRow() {
      return this.wot.wtViewport.rowsRenderCalculator.endRow;
    }
  }, {
    key: 'getLastVisibleRow',
    value: function getLastVisibleRow() {
      return this.wot.wtViewport.rowsVisibleCalculator.endRow;
    }
  }, {
    key: 'getLastRenderedColumn',
    value: function getLastRenderedColumn() {
      return this.wot.wtViewport.columnsRenderCalculator.endColumn;
    }

    /**
     * @returns {Number} Returns -1 if no column is visible
     */
  }, {
    key: 'getLastVisibleColumn',
    value: function getLastVisibleColumn() {
      return this.wot.wtViewport.columnsVisibleCalculator.endColumn;
    }
  }, {
    key: 'isRowBeforeRenderedRows',
    value: function isRowBeforeRenderedRows(row) {
      return this.rowFilter.sourceToRendered(row) < 0 && row >= 0;
    }
  }, {
    key: 'isRowAfterViewport',
    value: function isRowAfterViewport(row) {
      return row > this.getLastVisibleRow();
    }
  }, {
    key: 'isRowAfterRenderedRows',
    value: function isRowAfterRenderedRows(row) {
      return row > this.getLastRenderedRow();
    }
  }, {
    key: 'isColumnBeforeViewport',
    value: function isColumnBeforeViewport(column) {
      return this.columnFilter.sourceToRendered(column) < 0 && column >= 0;
    }
  }, {
    key: 'isColumnAfterViewport',
    value: function isColumnAfterViewport(column) {
      return column > this.getLastVisibleColumn();
    }
  }, {
    key: 'isLastRowFullyVisible',
    value: function isLastRowFullyVisible() {
      return this.getLastVisibleRow() === this.getLastRenderedRow();
    }
  }, {
    key: 'isLastColumnFullyVisible',
    value: function isLastColumnFullyVisible() {
      return this.getLastVisibleColumn() === this.getLastRenderedColumn();
    }
  }, {
    key: 'getRenderedColumnsCount',
    value: function getRenderedColumnsCount() {
      if (this.wot.cloneOverlay instanceof _overlayDebug.WalkontableDebugOverlay) {
        return this.wot.getSetting('totalColumns');
      } else if (this.wot.cloneOverlay instanceof _overlayLeft.WalkontableLeftOverlay || this.wot.cloneOverlay instanceof _overlayCorner.WalkontableCornerOverlay) {
        return this.wot.getSetting('fixedColumnsLeft');
      } else {
        return this.wot.wtViewport.columnsRenderCalculator.count;
      }
    }
  }, {
    key: 'getRenderedRowsCount',
    value: function getRenderedRowsCount() {
      if (this.wot.cloneOverlay instanceof _overlayDebug.WalkontableDebugOverlay) {
        return this.wot.getSetting('totalRows');
      } else if (this.wot.cloneOverlay instanceof _overlayTop.WalkontableTopOverlay || this.wot.cloneOverlay instanceof _overlayCorner.WalkontableCornerOverlay) {
        return this.wot.getSetting('fixedRowsTop');
      }

      return this.wot.wtViewport.rowsRenderCalculator.count;
    }
  }, {
    key: 'getVisibleRowsCount',
    value: function getVisibleRowsCount() {
      return this.wot.wtViewport.rowsVisibleCalculator.count;
    }
  }, {
    key: 'allRowsInViewport',
    value: function allRowsInViewport() {
      return this.wot.getSetting('totalRows') == this.getVisibleRowsCount();
    }

    /**
     * Checks if any of the row's cells content exceeds its initial height, and if so, returns the oversized height
     *
     * @param {Number} sourceRow
     * @returns {Number}
     */
  }, {
    key: 'getRowHeight',
    value: function getRowHeight(sourceRow) {
      var height = this.wot.wtSettings.settings.rowHeight(sourceRow);
      var oversizedHeight = this.wot.wtViewport.oversizedRows[sourceRow];

      if (oversizedHeight !== void 0) {
        height = height ? Math.max(height, oversizedHeight) : oversizedHeight;
      }

      return height;
    }
  }, {
    key: 'getColumnHeaderHeight',
    value: function getColumnHeaderHeight(level) {
      var height = this.wot.wtSettings.settings.defaultRowHeight;
      var oversizedHeight = this.wot.wtViewport.oversizedColumnHeaders[level];

      if (oversizedHeight !== void 0) {
        height = height ? Math.max(height, oversizedHeight) : oversizedHeight;
      }

      return height;
    }
  }, {
    key: 'getVisibleColumnsCount',
    value: function getVisibleColumnsCount() {
      return this.wot.wtViewport.columnsVisibleCalculator.count;
    }
  }, {
    key: 'allColumnsInViewport',
    value: function allColumnsInViewport() {
      return this.wot.getSetting('totalColumns') == this.getVisibleColumnsCount();
    }
  }, {
    key: 'getColumnWidth',
    value: function getColumnWidth(sourceColumn) {
      var width = this.wot.wtSettings.settings.columnWidth;

      if (typeof width === 'function') {
        width = width(sourceColumn);
      } else if (typeof width === 'object') {
        width = width[sourceColumn];
      }

      return width || this.wot.wtSettings.settings.defaultColumnWidth;
    }
  }, {
    key: 'getStretchedColumnWidth',
    value: function getStretchedColumnWidth(sourceColumn) {
      var width = this.getColumnWidth(sourceColumn);
      var calculator = this.wot.wtViewport.columnsRenderCalculator;

      if (calculator) {
        var stretchedWidth = calculator.getStretchedColumnWidth(sourceColumn, width);

        if (stretchedWidth) {
          width = stretchedWidth;
        }
      }

      return width;
    }
  }]);

  return WalkontableTable;
})();

exports.WalkontableTable = WalkontableTable;

window.WalkontableTable = WalkontableTable;

},{"./../../../helpers/dom/element":50,"./cell/coords":11,"./cell/range":12,"./filter/column":15,"./filter/row":16,"./overlay/corner":18,"./overlay/debug":19,"./overlay/left":20,"./overlay/top":21,"./tableRenderer":27}],27:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _helpersDomElement = require('./../../../helpers/dom/element');

/**
 * @class WalkontableTableRenderer
 */

var WalkontableTableRenderer = (function () {
  /**
   * @param {WalkontableTable} wtTable
   */

  function WalkontableTableRenderer(wtTable) {
    _classCallCheck(this, WalkontableTableRenderer);

    this.wtTable = wtTable;
    this.wot = wtTable.instance;
    // legacy support
    this.instance = wtTable.instance;

    this.rowFilter = wtTable.rowFilter;
    this.columnFilter = wtTable.columnFilter;

    this.TABLE = wtTable.TABLE;
    this.THEAD = wtTable.THEAD;
    this.TBODY = wtTable.TBODY;
    this.COLGROUP = wtTable.COLGROUP;

    this.rowHeaders = [];
    this.rowHeaderCount = 0;
    this.columnHeaders = [];
    this.columnHeaderCount = 0;
    this.fixedRowsTop = 0;
  }

  /**
   *
   */

  _createClass(WalkontableTableRenderer, [{
    key: 'render',
    value: function render() {
      if (!this.wtTable.isWorkingOnClone()) {
        this.wot.getSetting('beforeDraw', true);
      }

      this.rowHeaders = this.wot.getSetting('rowHeaders');
      this.rowHeaderCount = this.rowHeaders.length;
      this.fixedRowsTop = this.wot.getSetting('fixedRowsTop');
      this.columnHeaders = this.wot.getSetting('columnHeaders');
      this.columnHeaderCount = this.columnHeaders.length;

      var columnsToRender = this.wtTable.getRenderedColumnsCount();
      var rowsToRender = this.wtTable.getRenderedRowsCount();
      var totalColumns = this.wot.getSetting('totalColumns');
      var totalRows = this.wot.getSetting('totalRows');
      var workspaceWidth = undefined;
      var adjusted = false;

      if (totalColumns > 0) {
        // prepare COL and TH elements for rendering
        this.adjustAvailableNodes();
        adjusted = true;

        // adjust column widths according to user widths settings
        this.renderColumnHeaders();

        //Render table rows
        this.renderRows(totalRows, rowsToRender, columnsToRender);

        if (!this.wtTable.isWorkingOnClone()) {
          workspaceWidth = this.wot.wtViewport.getWorkspaceWidth();
          this.wot.wtViewport.containerWidth = null;
        }
        this.adjustColumnHeaderHeights();
        this.adjustColumnWidths(columnsToRender);
        this.markOversizedColumns();
      }

      if (!adjusted) {
        this.adjustAvailableNodes();
      }
      this.removeRedundantRows(rowsToRender);

      if (!this.wtTable.isWorkingOnClone()) {
        this.markOversizedRows();

        this.wot.wtViewport.createVisibleCalculators();
        this.wot.wtOverlays.refresh(false);
        this.wot.wtOverlays.applyToDOM();

        if (workspaceWidth !== this.wot.wtViewport.getWorkspaceWidth()) {
          //workspace width changed though to shown/hidden vertical scrollbar. Let's reapply stretching
          this.wot.wtViewport.containerWidth = null;

          var firstRendered = this.wtTable.getFirstRenderedColumn();
          var lastRendered = this.wtTable.getLastRenderedColumn();

          for (var i = firstRendered; i < lastRendered; i++) {
            var width = this.wtTable.getStretchedColumnWidth(i);
            var renderedIndex = this.columnFilter.sourceToRendered(i);

            this.COLGROUP.childNodes[renderedIndex + this.rowHeaderCount].style.width = width + 'px';
          }
        }

        this.wot.getSetting('onDraw', true);
      }
    }

    /**
     * @param {Number} renderedRowsCount
     */
  }, {
    key: 'removeRedundantRows',
    value: function removeRedundantRows(renderedRowsCount) {
      while (this.wtTable.tbodyChildrenLength > renderedRowsCount) {
        this.TBODY.removeChild(this.TBODY.lastChild);
        this.wtTable.tbodyChildrenLength--;
      }
    }

    /**
     * @param {Number} totalRows
     * @param {Number} rowsToRender
     * @param {Number} columnsToRender
     */
  }, {
    key: 'renderRows',
    value: function renderRows(totalRows, rowsToRender, columnsToRender) {
      var lastTD = undefined,
          TR = undefined;
      var visibleRowIndex = 0;
      var sourceRowIndex = this.rowFilter.renderedToSource(visibleRowIndex);
      var isWorkingOnClone = this.wtTable.isWorkingOnClone();

      while (sourceRowIndex < totalRows && sourceRowIndex >= 0) {
        if (visibleRowIndex > 1000) {
          throw new Error('Security brake: Too much TRs. Please define height for your table, which will enforce scrollbars.');
        }
        if (rowsToRender !== void 0 && visibleRowIndex === rowsToRender) {
          // We have as much rows as needed for this clone
          break;
        }
        TR = this.getOrCreateTrForRow(visibleRowIndex, TR);

        // Render row headers
        this.renderRowHeaders(sourceRowIndex, TR);
        // Add and/or remove TDs to TR to match the desired number
        this.adjustColumns(TR, columnsToRender + this.rowHeaderCount);

        lastTD = this.renderCells(sourceRowIndex, TR, columnsToRender);

        if (!isWorkingOnClone) {
          // Reset the oversized row cache for this row
          this.resetOversizedRow(sourceRowIndex);
        }

        if (TR.firstChild) {
          // if I have 2 fixed columns with one-line content and the 3rd column has a multiline content, this is
          // the way to make sure that the overlay will has same row height
          var height = this.wot.wtTable.getRowHeight(sourceRowIndex);

          if (height) {
            // Decrease height. 1 pixel will be "replaced" by 1px border top
            height--;
            TR.firstChild.style.height = height + 'px';
          } else {
            TR.firstChild.style.height = '';
          }
        }
        visibleRowIndex++;
        sourceRowIndex = this.rowFilter.renderedToSource(visibleRowIndex);
      }
    }

    /**
     * Reset the oversized row cache for the provided index
     *
     * @param {Number} sourceRow Row index
     */
  }, {
    key: 'resetOversizedRow',
    value: function resetOversizedRow(sourceRow) {
      if (this.wot.getSetting('externalRowCalculator')) {
        return;
      }
      if (this.wot.wtViewport.oversizedRows && this.wot.wtViewport.oversizedRows[sourceRow]) {
        this.wot.wtViewport.oversizedRows[sourceRow] = void 0;
      }
    }

    /**
     * Check if any of the rendered rows is higher than expected, and if so, cache them
     */
  }, {
    key: 'markOversizedRows',
    value: function markOversizedRows() {
      if (this.wot.getSetting('externalRowCalculator')) {
        return;
      }
      var rowCount = this.instance.wtTable.TBODY.childNodes.length;
      var expectedTableHeight = rowCount * this.instance.wtSettings.settings.defaultRowHeight;
      var actualTableHeight = (0, _helpersDomElement.innerHeight)(this.instance.wtTable.TBODY) - 1;
      var previousRowHeight = undefined;
      var rowInnerHeight = undefined;
      var sourceRowIndex = undefined;
      var currentTr = undefined;
      var rowHeader = undefined;

      if (expectedTableHeight === actualTableHeight) {
        // If the actual table height equals rowCount * default single row height, no row is oversized -> no need to iterate over them
        return;
      }

      while (rowCount) {
        rowCount--;
        sourceRowIndex = this.instance.wtTable.rowFilter.renderedToSource(rowCount);
        previousRowHeight = this.instance.wtTable.getRowHeight(sourceRowIndex);
        currentTr = this.instance.wtTable.getTrForRow(sourceRowIndex);
        rowHeader = currentTr.querySelector('th');

        if (rowHeader) {
          rowInnerHeight = (0, _helpersDomElement.innerHeight)(rowHeader);
        } else {
          rowInnerHeight = (0, _helpersDomElement.innerHeight)(currentTr) - 1;
        }

        if (!previousRowHeight && this.instance.wtSettings.settings.defaultRowHeight < rowInnerHeight || previousRowHeight < rowInnerHeight) {
          this.instance.wtViewport.oversizedRows[sourceRowIndex] = ++rowInnerHeight;
        }
      }
    }

    /**
     * Check if any of the rendered columns is wider than expected, and if so, cache them.
     */
  }, {
    key: 'markOversizedColumns',
    value: function markOversizedColumns() {
      var overlayName = this.wot.getOverlayName();

      if (!this.columnHeaderCount || this.wot.wtViewport.isMarkedOversizedColumn[overlayName] || this.wtTable.isWorkingOnClone()) {
        return;
      }
      var columnCount = this.wtTable.getRenderedColumnsCount();

      for (var i = 0; i < this.columnHeaderCount; i++) {
        for (var renderedColumnIndex = -1 * this.rowHeaderCount; renderedColumnIndex < columnCount; renderedColumnIndex++) {
          this.markIfOversizedColumnHeader(renderedColumnIndex);
        }
      }
      this.wot.wtViewport.isMarkedOversizedColumn[overlayName] = true;
    }

    /**
     *
     */
  }, {
    key: 'adjustColumnHeaderHeights',
    value: function adjustColumnHeaderHeights() {
      var columnHeaders = this.wot.getSetting('columnHeaders');
      var childs = this.wot.wtTable.THEAD.childNodes;
      var oversizedCols = this.wot.wtViewport.oversizedColumnHeaders;

      for (var i = 0, len = columnHeaders.length; i < len; i++) {
        if (oversizedCols[i]) {
          if (childs[i].childNodes.length === 0) {
            return;
          }
          childs[i].childNodes[0].style.height = oversizedCols[i] + 'px';
        }
      }
    }

    /**
     * Check if column header for the specified column is higher than expected, and if so, cache it
     *
     * @param {Number} col Index of column
     */
  }, {
    key: 'markIfOversizedColumnHeader',
    value: function markIfOversizedColumnHeader(col) {
      var sourceColIndex = this.wot.wtTable.columnFilter.renderedToSource(col);
      var level = this.columnHeaderCount;
      var defaultRowHeight = this.wot.wtSettings.settings.defaultRowHeight;
      var previousColHeaderHeight = undefined;
      var currentHeader = undefined;
      var currentHeaderHeight = undefined;

      while (level) {
        level--;

        previousColHeaderHeight = this.wot.wtTable.getColumnHeaderHeight(level);
        currentHeader = this.wot.wtTable.getColumnHeader(sourceColIndex, level);

        if (!currentHeader) {
          continue;
        }
        //currentHeaderHeight = defaultRowHeight;
        currentHeaderHeight = (0, _helpersDomElement.innerHeight)(currentHeader);

        if (!previousColHeaderHeight && defaultRowHeight < currentHeaderHeight || previousColHeaderHeight < currentHeaderHeight) {
          this.wot.wtViewport.oversizedColumnHeaders[level] = currentHeaderHeight;
        }
      }
    }

    /**
     * @param {Number} sourceRowIndex
     * @param {HTMLTableRowElement} TR
     * @param {Number} columnsToRender
     * @returns {HTMLTableCellElement}
     */
  }, {
    key: 'renderCells',
    value: function renderCells(sourceRowIndex, TR, columnsToRender) {
      var TD = undefined;
      var sourceColIndex = undefined;

      for (var visibleColIndex = 0; visibleColIndex < columnsToRender; visibleColIndex++) {
        sourceColIndex = this.columnFilter.renderedToSource(visibleColIndex);

        if (visibleColIndex === 0) {
          TD = TR.childNodes[this.columnFilter.sourceColumnToVisibleRowHeadedColumn(sourceColIndex)];
        } else {
          TD = TD.nextSibling; //http://jsperf.com/nextsibling-vs-indexed-childnodes
        }
        // If the number of headers has been reduced, we need to replace excess TH with TD
        if (TD.nodeName == 'TH') {
          TD = replaceThWithTd(TD, TR);
        }
        if (!(0, _helpersDomElement.hasClass)(TD, 'hide')) {
          TD.className = '';
        }
        TD.removeAttribute('style');
        this.wot.wtSettings.settings.cellRenderer(sourceRowIndex, sourceColIndex, TD);
      }

      return TD;
    }

    /**
     * @param {Number} columnsToRender
     */
  }, {
    key: 'adjustColumnWidths',
    value: function adjustColumnWidths(columnsToRender) {
      var scrollbarCompensation = 0;
      var sourceInstance = this.wot.cloneSource ? this.wot.cloneSource : this.wot;
      var mainHolder = sourceInstance.wtTable.holder;

      if (mainHolder.offsetHeight < mainHolder.scrollHeight) {
        scrollbarCompensation = (0, _helpersDomElement.getScrollbarWidth)();
      }
      this.wot.wtViewport.columnsRenderCalculator.refreshStretching(this.wot.wtViewport.getViewportWidth() - scrollbarCompensation);

      for (var renderedColIndex = 0; renderedColIndex < columnsToRender; renderedColIndex++) {
        var width = this.wtTable.getStretchedColumnWidth(this.columnFilter.renderedToSource(renderedColIndex));
        this.COLGROUP.childNodes[renderedColIndex + this.rowHeaderCount].style.width = width + 'px';
      }
    }

    /**
     * @param {HTMLTableCellElement} TR
     */
  }, {
    key: 'appendToTbody',
    value: function appendToTbody(TR) {
      this.TBODY.appendChild(TR);
      this.wtTable.tbodyChildrenLength++;
    }

    /**
     * @param {Number} rowIndex
     * @param {HTMLTableRowElement} currentTr
     * @returns {HTMLTableCellElement}
     */
  }, {
    key: 'getOrCreateTrForRow',
    value: function getOrCreateTrForRow(rowIndex, currentTr) {
      var TR = undefined;

      if (rowIndex >= this.wtTable.tbodyChildrenLength) {
        TR = this.createRow();
        this.appendToTbody(TR);
      } else if (rowIndex === 0) {
        TR = this.TBODY.firstChild;
      } else {
        // http://jsperf.com/nextsibling-vs-indexed-childnodes
        TR = currentTr.nextSibling;
      }

      return TR;
    }

    /**
     * @returns {HTMLTableCellElement}
     */
  }, {
    key: 'createRow',
    value: function createRow() {
      var TR = document.createElement('TR');

      for (var visibleColIndex = 0; visibleColIndex < this.rowHeaderCount; visibleColIndex++) {
        TR.appendChild(document.createElement('TH'));
      }

      return TR;
    }

    /**
     * @param {Number} row
     * @param {Number} col
     * @param {HTMLTableCellElement} TH
     */
  }, {
    key: 'renderRowHeader',
    value: function renderRowHeader(row, col, TH) {
      TH.className = '';
      TH.removeAttribute('style');
      this.rowHeaders[col](row, TH, col);
    }

    /**
     * @param {Number} row
     * @param {HTMLTableCellElement} TR
     */
  }, {
    key: 'renderRowHeaders',
    value: function renderRowHeaders(row, TR) {
      for (var TH = TR.firstChild, visibleColIndex = 0; visibleColIndex < this.rowHeaderCount; visibleColIndex++) {
        // If the number of row headers increased we need to create TH or replace an existing TD node with TH
        if (!TH) {
          TH = document.createElement('TH');
          TR.appendChild(TH);
        } else if (TH.nodeName == 'TD') {
          TH = replaceTdWithTh(TH, TR);
        }
        this.renderRowHeader(row, visibleColIndex, TH);
        // http://jsperf.com/nextsibling-vs-indexed-childnodes
        TH = TH.nextSibling;
      }
    }

    /**
     * Adjust the number of COL and TH elements to match the number of columns and headers that need to be rendered
     */
  }, {
    key: 'adjustAvailableNodes',
    value: function adjustAvailableNodes() {
      this.adjustColGroups();
      this.adjustThead();
    }

    /**
     * Renders the column headers
     */
  }, {
    key: 'renderColumnHeaders',
    value: function renderColumnHeaders() {
      var overlayName = this.wot.getOverlayName();

      if (!this.columnHeaderCount) {
        return;
      }
      var columnCount = this.wtTable.getRenderedColumnsCount();

      for (var i = 0; i < this.columnHeaderCount; i++) {
        var TR = this.getTrForColumnHeaders(i);

        for (var renderedColumnIndex = -1 * this.rowHeaderCount; renderedColumnIndex < columnCount; renderedColumnIndex++) {
          var sourceCol = this.columnFilter.renderedToSource(renderedColumnIndex);

          this.renderColumnHeader(i, sourceCol, TR.childNodes[renderedColumnIndex + this.rowHeaderCount]);
        }
      }
    }

    /**
     * Adjusts the number of COL elements to match the number of columns that need to be rendered
     */
  }, {
    key: 'adjustColGroups',
    value: function adjustColGroups() {
      var columnCount = this.wtTable.getRenderedColumnsCount();

      while (this.wtTable.colgroupChildrenLength < columnCount + this.rowHeaderCount) {
        this.COLGROUP.appendChild(document.createElement('COL'));
        this.wtTable.colgroupChildrenLength++;
      }
      while (this.wtTable.colgroupChildrenLength > columnCount + this.rowHeaderCount) {
        this.COLGROUP.removeChild(this.COLGROUP.lastChild);
        this.wtTable.colgroupChildrenLength--;
      }
      if (this.rowHeaderCount) {
        (0, _helpersDomElement.addClass)(this.COLGROUP.childNodes[0], 'rowHeader');
      }
    }

    /**
     * Adjusts the number of TH elements in THEAD to match the number of headers and columns that need to be rendered
     */
  }, {
    key: 'adjustThead',
    value: function adjustThead() {
      var columnCount = this.wtTable.getRenderedColumnsCount();
      var TR = this.THEAD.firstChild;

      if (this.columnHeaders.length) {
        for (var i = 0, len = this.columnHeaders.length; i < len; i++) {
          TR = this.THEAD.childNodes[i];

          if (!TR) {
            TR = document.createElement('TR');
            this.THEAD.appendChild(TR);
          }
          this.theadChildrenLength = TR.childNodes.length;

          while (this.theadChildrenLength < columnCount + this.rowHeaderCount) {
            TR.appendChild(document.createElement('TH'));
            this.theadChildrenLength++;
          }
          while (this.theadChildrenLength > columnCount + this.rowHeaderCount) {
            TR.removeChild(TR.lastChild);
            this.theadChildrenLength--;
          }
        }
        var theadChildrenLength = this.THEAD.childNodes.length;

        if (theadChildrenLength > this.columnHeaders.length) {
          for (var i = this.columnHeaders.length; i < theadChildrenLength; i++) {
            this.THEAD.removeChild(this.THEAD.lastChild);
          }
        }
      } else if (TR) {
        (0, _helpersDomElement.empty)(TR);
      }
    }

    /**
     * @param {Number} index
     * @returns {HTMLTableCellElement}
     */
  }, {
    key: 'getTrForColumnHeaders',
    value: function getTrForColumnHeaders(index) {
      return this.THEAD.childNodes[index];
    }

    /**
     * @param {Number} row
     * @param {Number} col
     * @param {HTMLTableCellElement} TH
     * @returns {*}
     */
  }, {
    key: 'renderColumnHeader',
    value: function renderColumnHeader(row, col, TH) {
      TH.className = '';
      TH.removeAttribute('style');

      return this.columnHeaders[row](col, TH, row);
    }

    /**
     * Add and/or remove the TDs to match the desired number
     *
     * @param {HTMLTableCellElement} TR Table row in question
     * @param {Number} desiredCount The desired number of TDs in the TR
     */
  }, {
    key: 'adjustColumns',
    value: function adjustColumns(TR, desiredCount) {
      var count = TR.childNodes.length;

      while (count < desiredCount) {
        var TD = document.createElement('TD');

        TR.appendChild(TD);
        count++;
      }
      while (count > desiredCount) {
        TR.removeChild(TR.lastChild);
        count--;
      }
    }

    /**
     * @param {Number} columnsToRender
     */
  }, {
    key: 'removeRedundantColumns',
    value: function removeRedundantColumns(columnsToRender) {
      while (this.wtTable.tbodyChildrenLength > columnsToRender) {
        this.TBODY.removeChild(this.TBODY.lastChild);
        this.wtTable.tbodyChildrenLength--;
      }
    }
  }]);

  return WalkontableTableRenderer;
})();

function replaceTdWithTh(TD, TR) {
  var TH = document.createElement('TH');

  TR.insertBefore(TH, TD);
  TR.removeChild(TD);

  return TH;
}

function replaceThWithTd(TH, TR) {
  var TD = document.createElement('TD');

  TR.insertBefore(TD, TH);
  TR.removeChild(TH);

  return TD;
}

exports.WalkontableTableRenderer = WalkontableTableRenderer;

window.WalkontableTableRenderer = WalkontableTableRenderer;

},{"./../../../helpers/dom/element":50}],28:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _helpersDomElement = require('./../../../helpers/dom/element');

var _eventManager = require('./../../../eventManager');

var _calculatorViewportColumns = require('./calculator/viewportColumns');

var _calculatorViewportRows = require('./calculator/viewportRows');

/**
 * @class WalkontableViewport
 */

var WalkontableViewport = (function () {
  /**
   * @param wotInstance
   */

  function WalkontableViewport(wotInstance) {
    var _this = this;

    _classCallCheck(this, WalkontableViewport);

    this.wot = wotInstance;

    // legacy support
    this.instance = this.wot;

    this.oversizedRows = [];
    this.oversizedColumnHeaders = [];
    this.isMarkedOversizedColumn = {};
    this.clientHeight = 0;
    this.containerWidth = NaN;
    this.rowHeaderWidth = NaN;
    this.rowsVisibleCalculator = null;
    this.columnsVisibleCalculator = null;

    this.eventManager = new _eventManager.EventManager(this.wot);
    this.eventManager.addEventListener(window, 'resize', function () {
      _this.clientHeight = _this.getWorkspaceHeight();
    });
  }

  /**
   * @returns {number}
   */

  _createClass(WalkontableViewport, [{
    key: 'getWorkspaceHeight',
    value: function getWorkspaceHeight() {
      // var scrollHandler = this.instance.wtOverlays.topOverlay.scrollHandler;
      var trimmingContainer = this.instance.wtOverlays.topOverlay.trimmingContainer;
      var elemHeight = undefined;
      var height = 0;

      if (trimmingContainer === window) {
        height = document.documentElement.clientHeight;
      } else {
        elemHeight = (0, _helpersDomElement.outerHeight)(trimmingContainer);
        // returns height without DIV scrollbar
        height = elemHeight > 0 && trimmingContainer.clientHeight > 0 ? trimmingContainer.clientHeight : Infinity;
      }

      return height;
    }
  }, {
    key: 'getWorkspaceWidth',
    value: function getWorkspaceWidth() {
      var width = undefined;
      var totalColumns = this.instance.getSetting("totalColumns");
      var trimmingContainer = this.instance.wtOverlays.leftOverlay.trimmingContainer;
      var overflow = undefined;
      var stretchSetting = this.instance.getSetting('stretchH');
      var docOffsetWidth = document.documentElement.offsetWidth;

      if (Handsontable.freezeOverlays) {
        width = Math.min(docOffsetWidth - this.getWorkspaceOffset().left, docOffsetWidth);
      } else {
        width = Math.min(this.getContainerFillWidth(), docOffsetWidth - this.getWorkspaceOffset().left, docOffsetWidth);
      }

      if (trimmingContainer === window && totalColumns > 0 && this.sumColumnWidths(0, totalColumns - 1) > width) {
        // in case sum of column widths is higher than available stylesheet width, let's assume using the whole window
        // otherwise continue below, which will allow stretching
        // this is used in `scroll_window.html`
        // TODO test me
        return document.documentElement.clientWidth;
      }

      if (trimmingContainer !== window) {
        overflow = (0, _helpersDomElement.getStyle)(this.instance.wtOverlays.leftOverlay.trimmingContainer, 'overflow');

        if (overflow == "scroll" || overflow == "hidden" || overflow == "auto") {
          // this is used in `scroll.html`
          // TODO test me
          return Math.max(width, trimmingContainer.clientWidth);
        }
      }

      if (stretchSetting === 'none' || !stretchSetting) {
        // if no stretching is used, return the maximum used workspace width
        return Math.max(width, (0, _helpersDomElement.outerWidth)(this.instance.wtTable.TABLE));
      } else {
        // if stretching is used, return the actual container width, so the columns can fit inside it
        return width;
      }
    }

    /**
     * Checks if viewport has vertical scroll
     *
     * @returns {Boolean}
     */
  }, {
    key: 'hasVerticalScroll',
    value: function hasVerticalScroll() {
      return this.getWorkspaceActualHeight() > this.getWorkspaceHeight();
    }

    /**
     * Checks if viewport has horizontal scroll
     *
     * @returns {Boolean}
     */
  }, {
    key: 'hasHorizontalScroll',
    value: function hasHorizontalScroll() {
      return this.getWorkspaceActualWidth() > this.getWorkspaceWidth();
    }

    /**
     * @param from
     * @param length
     * @returns {Number}
     */
  }, {
    key: 'sumColumnWidths',
    value: function sumColumnWidths(from, length) {
      var sum = 0;

      while (from < length) {
        sum += this.wot.wtTable.getColumnWidth(from);
        from++;
      }

      return sum;
    }

    /**
     * @returns {Number}
     */
  }, {
    key: 'getContainerFillWidth',
    value: function getContainerFillWidth() {
      if (this.containerWidth) {
        return this.containerWidth;
      }
      var mainContainer = this.instance.wtTable.holder;
      var fillWidth = undefined;
      var dummyElement = undefined;

      dummyElement = document.createElement("DIV");
      dummyElement.style.width = "100%";
      dummyElement.style.height = "1px";
      mainContainer.appendChild(dummyElement);
      fillWidth = dummyElement.offsetWidth;

      this.containerWidth = fillWidth;
      mainContainer.removeChild(dummyElement);

      return fillWidth;
    }

    /**
     * @returns {Number}
     */
  }, {
    key: 'getWorkspaceOffset',
    value: function getWorkspaceOffset() {
      return (0, _helpersDomElement.offset)(this.wot.wtTable.TABLE);
    }

    /**
     * @returns {Number}
     */
  }, {
    key: 'getWorkspaceActualHeight',
    value: function getWorkspaceActualHeight() {
      return (0, _helpersDomElement.outerHeight)(this.wot.wtTable.TABLE);
    }

    /**
     * @returns {Number}
     */
  }, {
    key: 'getWorkspaceActualWidth',
    value: function getWorkspaceActualWidth() {
      return (0, _helpersDomElement.outerWidth)(this.wot.wtTable.TABLE) || (0, _helpersDomElement.outerWidth)(this.wot.wtTable.TBODY) || (0, _helpersDomElement.outerWidth)(this.wot.wtTable.THEAD); //IE8 reports 0 as <table> offsetWidth;
    }

    /**
     * @returns {Number}
     */
  }, {
    key: 'getColumnHeaderHeight',
    value: function getColumnHeaderHeight() {
      if (isNaN(this.columnHeaderHeight)) {
        this.columnHeaderHeight = (0, _helpersDomElement.outerHeight)(this.wot.wtTable.THEAD);
      }

      return this.columnHeaderHeight;
    }

    /**
     * @returns {Number}
     */
  }, {
    key: 'getViewportHeight',
    value: function getViewportHeight() {
      var containerHeight = this.getWorkspaceHeight();
      var columnHeaderHeight = undefined;

      if (containerHeight === Infinity) {
        return containerHeight;
      }
      columnHeaderHeight = this.getColumnHeaderHeight();

      if (columnHeaderHeight > 0) {
        containerHeight -= columnHeaderHeight;
      }

      return containerHeight;
    }

    /**
     * @returns {Number}
     */
  }, {
    key: 'getRowHeaderWidth',
    value: function getRowHeaderWidth() {
      if (this.wot.cloneSource) {
        return this.wot.cloneSource.wtViewport.getRowHeaderWidth();
      }
      if (isNaN(this.rowHeaderWidth)) {
        var rowHeaders = this.instance.getSetting('rowHeaders');

        if (rowHeaders.length) {
          var TH = this.instance.wtTable.TABLE.querySelector('TH');
          this.rowHeaderWidth = 0;

          for (var i = 0, len = rowHeaders.length; i < len; i++) {
            if (TH) {
              this.rowHeaderWidth += (0, _helpersDomElement.outerWidth)(TH);
              TH = TH.nextSibling;
            } else {
              // yes this is a cheat but it worked like that before, just taking assumption from CSS instead of measuring.
              // TODO: proper fix
              this.rowHeaderWidth += 50;
            }
          }
        } else {
          this.rowHeaderWidth = 0;
        }
      }

      return this.rowHeaderWidth;
    }

    /**
     * @returns {Number}
     */
  }, {
    key: 'getViewportWidth',
    value: function getViewportWidth() {
      var containerWidth = this.getWorkspaceWidth();
      var rowHeaderWidth = undefined;

      if (containerWidth === Infinity) {
        return containerWidth;
      }
      rowHeaderWidth = this.getRowHeaderWidth();

      if (rowHeaderWidth > 0) {
        return containerWidth - rowHeaderWidth;
      }

      return containerWidth;
    }

    /**
     * Creates:
     *  - rowsRenderCalculator (before draw, to qualify rows for rendering)
     *  - rowsVisibleCalculator (after draw, to measure which rows are actually visible)
     *
     * @returns {WalkontableViewportRowsCalculator}
     */
  }, {
    key: 'createRowsCalculator',
    value: function createRowsCalculator() {
      var _this2 = this;

      var visible = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

      var height = undefined;
      var pos = undefined;
      var fixedRowsTop = undefined;
      var scrollbarHeight = undefined;

      this.rowHeaderWidth = NaN;

      if (this.wot.wtSettings.settings.renderAllRows) {
        height = Infinity;
      } else {
        height = this.getViewportHeight();
      }
      pos = (0, _helpersDomElement.getScrollTop)(this.wot.wtOverlays.mainTableScrollableElement) - this.wot.wtOverlays.topOverlay.getTableParentOffset();

      if (pos < 0) {
        pos = 0;
      }
      fixedRowsTop = this.wot.getSetting('fixedRowsTop');

      if (fixedRowsTop) {
        var fixedRowsHeight = this.wot.wtOverlays.topOverlay.sumCellSizes(0, fixedRowsTop);
        pos += fixedRowsHeight;
        height -= fixedRowsHeight;
      }

      if (this.wot.wtTable.holder.clientHeight !== this.wot.wtTable.holder.offsetHeight) {
        scrollbarHeight = (0, _helpersDomElement.getScrollbarWidth)();
      } else {
        scrollbarHeight = 0;
      }

      return new _calculatorViewportRows.WalkontableViewportRowsCalculator(height, pos, this.wot.getSetting('totalRows'), function (sourceRow) {
        return _this2.wot.wtTable.getRowHeight(sourceRow);
      }, visible ? null : this.wot.wtSettings.settings.viewportRowCalculatorOverride, visible, scrollbarHeight);
    }

    /**
     * Creates:
     *  - columnsRenderCalculator (before draw, to qualify columns for rendering)
     *  - columnsVisibleCalculator (after draw, to measure which columns are actually visible)
     *
     * @returns {WalkontableViewportRowsCalculator}
     */
  }, {
    key: 'createColumnsCalculator',
    value: function createColumnsCalculator() {
      var _this3 = this;

      var visible = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

      var width = this.getViewportWidth();
      var pos = undefined;
      var fixedColumnsLeft = undefined;

      this.columnHeaderHeight = NaN;

      pos = this.wot.wtOverlays.leftOverlay.getScrollPosition() - this.wot.wtOverlays.leftOverlay.getTableParentOffset();

      if (pos < 0) {
        pos = 0;
      }
      fixedColumnsLeft = this.wot.getSetting('fixedColumnsLeft');

      if (fixedColumnsLeft) {
        var fixedColumnsWidth = this.wot.wtOverlays.leftOverlay.sumCellSizes(0, fixedColumnsLeft);
        pos += fixedColumnsWidth;
        width -= fixedColumnsWidth;
      }
      if (this.wot.wtTable.holder.clientWidth !== this.wot.wtTable.holder.offsetWidth) {
        width -= (0, _helpersDomElement.getScrollbarWidth)();
      }

      return new _calculatorViewportColumns.WalkontableViewportColumnsCalculator(width, pos, this.wot.getSetting('totalColumns'), function (sourceCol) {
        return _this3.wot.wtTable.getColumnWidth(sourceCol);
      }, visible ? null : this.wot.wtSettings.settings.viewportColumnCalculatorOverride, visible, this.wot.getSetting('stretchH'));
    }

    /**
     * Creates rowsRenderCalculator and columnsRenderCalculator (before draw, to determine what rows and
     * cols should be rendered)
     *
     * @param fastDraw {Boolean} If `true`, will try to avoid full redraw and only update the border positions.
     *                           If `false` or `undefined`, will perform a full redraw
     * @returns fastDraw {Boolean} The fastDraw value, possibly modified
     */
  }, {
    key: 'createRenderCalculators',
    value: function createRenderCalculators() {
      var fastDraw = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

      if (fastDraw) {
        var proposedRowsVisibleCalculator = this.createRowsCalculator(true);
        var proposedColumnsVisibleCalculator = this.createColumnsCalculator(true);

        if (!(this.areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) && this.areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator))) {
          fastDraw = false;
        }
      }

      if (!fastDraw) {
        this.rowsRenderCalculator = this.createRowsCalculator();
        this.columnsRenderCalculator = this.createColumnsCalculator();
      }
      // delete temporarily to make sure that renderers always use rowsRenderCalculator, not rowsVisibleCalculator
      this.rowsVisibleCalculator = null;
      this.columnsVisibleCalculator = null;

      return fastDraw;
    }

    /**
     * Creates rowsVisibleCalculator and columnsVisibleCalculator (after draw, to determine what are
     * the actually visible rows and columns)
     */
  }, {
    key: 'createVisibleCalculators',
    value: function createVisibleCalculators() {
      this.rowsVisibleCalculator = this.createRowsCalculator(true);
      this.columnsVisibleCalculator = this.createColumnsCalculator(true);
    }

    /**
     * Returns information whether proposedRowsVisibleCalculator viewport
     * is contained inside rows rendered in previous draw (cached in rowsRenderCalculator)
     *
     * @param {Object} proposedRowsVisibleCalculator
     * @returns {Boolean} Returns `true` if all proposed visible rows are already rendered (meaning: redraw is not needed).
     *                    Returns `false` if at least one proposed visible row is not already rendered (meaning: redraw is needed)
     */
  }, {
    key: 'areAllProposedVisibleRowsAlreadyRendered',
    value: function areAllProposedVisibleRowsAlreadyRendered(proposedRowsVisibleCalculator) {
      if (this.rowsVisibleCalculator) {
        if (proposedRowsVisibleCalculator.startRow < this.rowsRenderCalculator.startRow || proposedRowsVisibleCalculator.startRow === this.rowsRenderCalculator.startRow && proposedRowsVisibleCalculator.startRow > 0) {
          return false;
        } else if (proposedRowsVisibleCalculator.endRow > this.rowsRenderCalculator.endRow || proposedRowsVisibleCalculator.endRow === this.rowsRenderCalculator.endRow && proposedRowsVisibleCalculator.endRow < this.wot.getSetting('totalRows') - 1) {
          return false;
        } else {
          return true;
        }
      }

      return false;
    }

    /**
     * Returns information whether proposedColumnsVisibleCalculator viewport
     * is contained inside column rendered in previous draw (cached in columnsRenderCalculator)
     *
     * @param {Object} proposedColumnsVisibleCalculator
     * @returns {Boolean} Returns `true` if all proposed visible columns are already rendered (meaning: redraw is not needed).
     *                    Returns `false` if at least one proposed visible column is not already rendered (meaning: redraw is needed)
     */
  }, {
    key: 'areAllProposedVisibleColumnsAlreadyRendered',
    value: function areAllProposedVisibleColumnsAlreadyRendered(proposedColumnsVisibleCalculator) {
      if (this.columnsVisibleCalculator) {
        if (proposedColumnsVisibleCalculator.startColumn < this.columnsRenderCalculator.startColumn || proposedColumnsVisibleCalculator.startColumn === this.columnsRenderCalculator.startColumn && proposedColumnsVisibleCalculator.startColumn > 0) {
          return false;
        } else if (proposedColumnsVisibleCalculator.endColumn > this.columnsRenderCalculator.endColumn || proposedColumnsVisibleCalculator.endColumn === this.columnsRenderCalculator.endColumn && proposedColumnsVisibleCalculator.endColumn < this.wot.getSetting('totalColumns') - 1) {
          return false;
        } else {
          return true;
        }
      }

      return false;
    }
  }]);

  return WalkontableViewport;
})();

exports.WalkontableViewport = WalkontableViewport;

window.WalkontableViewport = WalkontableViewport;

},{"./../../../eventManager":46,"./../../../helpers/dom/element":50,"./calculator/viewportColumns":9,"./calculator/viewportRows":10}],29:[function(require,module,exports){
'use strict';

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

require('./shims/classes');

require('es6collections');

var _pluginHooks = require('./pluginHooks');

require('./core');

require('./renderers/_cellDecorator');

require('./cellTypes');

require('./../plugins/jqueryHandsontable');

// export helpers

var _helpersArray = require('./helpers/array');

var arrayHelpers = _interopRequireWildcard(_helpersArray);

var _helpersBrowser = require('./helpers/browser');

var browserHelpers = _interopRequireWildcard(_helpersBrowser);

var _helpersData = require('./helpers/data');

var dataHelpers = _interopRequireWildcard(_helpersData);

var _helpersFunction = require('./helpers/function');

var functionHelpers = _interopRequireWildcard(_helpersFunction);

var _helpersMixed = require('./helpers/mixed');

var mixedHelpers = _interopRequireWildcard(_helpersMixed);

var _helpersNumber = require('./helpers/number');

var numberHelpers = _interopRequireWildcard(_helpersNumber);

var _helpersObject = require('./helpers/object');

var objectHelpers = _interopRequireWildcard(_helpersObject);

var _helpersSetting = require('./helpers/setting');

var settingHelpers = _interopRequireWildcard(_helpersSetting);

var _helpersString = require('./helpers/string');

var stringHelpers = _interopRequireWildcard(_helpersString);

var _helpersUnicode = require('./helpers/unicode');

var unicodeHelpers = _interopRequireWildcard(_helpersUnicode);

// export helpers

var _helpersDomElement = require('./helpers/dom/element');

var domHelpers = _interopRequireWildcard(_helpersDomElement);

var _helpersDomEvent = require('./helpers/dom/event');

var domEventHelpers = _interopRequireWildcard(_helpersDomEvent);

var version = Handsontable.version;
var buildDate = Handsontable.buildDate;

window.Handsontable = function Handsontable(rootElement, userSettings) {
  var instance = new Handsontable.Core(rootElement, userSettings || {});

  instance.init();

  return instance;
};

Handsontable.version = version;
Handsontable.buildDate = buildDate;

Handsontable.plugins = {};

if (!Handsontable.hooks) {
  Handsontable.hooks = new _pluginHooks.Hooks();
}

var helpers = [arrayHelpers, browserHelpers, dataHelpers, functionHelpers, mixedHelpers, numberHelpers, objectHelpers, settingHelpers, stringHelpers, unicodeHelpers];

Handsontable.helper = {};

arrayHelpers.arrayEach(helpers, function (helper) {
  arrayHelpers.arrayEach(Object.getOwnPropertyNames(helper), function (key) {
    if (key.charAt(0) !== '_') {
      Handsontable.helper[key] = helper[key];
    }
  });
});

Handsontable.dom = {};
Handsontable.Dom = Handsontable.dom; // legacy support

arrayHelpers.arrayEach([domHelpers, domEventHelpers], function (helper) {
  arrayHelpers.arrayEach(Object.getOwnPropertyNames(helper), function (key) {
    if (key.charAt(0) !== '_') {
      Handsontable.dom[key] = helper[key];
    }
  });
});

},{"./../plugins/jqueryHandsontable":7,"./cellTypes":30,"./core":31,"./helpers/array":47,"./helpers/browser":48,"./helpers/data":49,"./helpers/dom/element":50,"./helpers/dom/event":51,"./helpers/function":52,"./helpers/mixed":53,"./helpers/number":54,"./helpers/object":55,"./helpers/setting":56,"./helpers/string":57,"./helpers/unicode":58,"./pluginHooks":60,"./renderers/_cellDecorator":63,"./shims/classes":70,"es6collections":3}],30:[function(require,module,exports){
/**
 * Cell type is just a shortcut for setting bunch of cellProperties (used in getCellMeta)
 */

'use strict';

var _helpersBrowser = require('./helpers/browser');

var _editors = require('./editors');

var _renderers = require('./renderers');

var _editorsAutocompleteEditor = require('./editors/autocompleteEditor');

var _editorsCheckboxEditor = require('./editors/checkboxEditor');

var _editorsDateEditor = require('./editors/dateEditor');

var _editorsDropdownEditor = require('./editors/dropdownEditor');

var _editorsHandsontableEditor = require('./editors/handsontableEditor');

var _editorsMobileTextEditor = require('./editors/mobileTextEditor');

var _editorsNumericEditor = require('./editors/numericEditor');

var _editorsPasswordEditor = require('./editors/passwordEditor');

var _editorsSelectEditor = require('./editors/selectEditor');

var _editorsTextEditor = require('./editors/textEditor');

var _renderersAutocompleteRenderer = require('./renderers/autocompleteRenderer');

var _renderersCheckboxRenderer = require('./renderers/checkboxRenderer');

var _renderersHtmlRenderer = require('./renderers/htmlRenderer');

var _renderersNumericRenderer = require('./renderers/numericRenderer');

var _renderersPasswordRenderer = require('./renderers/passwordRenderer');

var _renderersTextRenderer = require('./renderers/textRenderer');

var _validatorsAutocompleteValidator = require('./validators/autocompleteValidator');

var _validatorsDateValidator = require('./validators/dateValidator');

var _validatorsNumericValidator = require('./validators/numericValidator');

Handsontable.mobileBrowser = (0, _helpersBrowser.isMobileBrowser)();

Handsontable.AutocompleteCell = {
  editor: (0, _editors.getEditorConstructor)('autocomplete'),
  renderer: (0, _renderers.getRenderer)('autocomplete'),
  validator: Handsontable.AutocompleteValidator
};

Handsontable.CheckboxCell = {
  editor: (0, _editors.getEditorConstructor)('checkbox'),
  renderer: (0, _renderers.getRenderer)('checkbox')
};

Handsontable.TextCell = {
  editor: Handsontable.mobileBrowser ? (0, _editors.getEditorConstructor)('mobile') : (0, _editors.getEditorConstructor)('text'),
  renderer: (0, _renderers.getRenderer)('text')
};

Handsontable.NumericCell = {
  editor: (0, _editors.getEditorConstructor)('numeric'),
  renderer: (0, _renderers.getRenderer)('numeric'),
  validator: Handsontable.NumericValidator,
  dataType: 'number'
};

Handsontable.DateCell = {
  editor: (0, _editors.getEditorConstructor)('date'),
  validator: Handsontable.DateValidator,
  // displays small gray arrow on right side of the cell
  renderer: (0, _renderers.getRenderer)('autocomplete')
};

Handsontable.HandsontableCell = {
  editor: (0, _editors.getEditorConstructor)('handsontable'),
  //displays small gray arrow on right side of the cell
  renderer: (0, _renderers.getRenderer)('autocomplete')
};

Handsontable.PasswordCell = {
  editor: (0, _editors.getEditorConstructor)('password'),
  renderer: (0, _renderers.getRenderer)('password'),
  copyable: false
};

Handsontable.DropdownCell = {
  editor: (0, _editors.getEditorConstructor)('dropdown'),
  //displays small gray arrow on right side of the cell
  renderer: (0, _renderers.getRenderer)('autocomplete'),
  validator: Handsontable.AutocompleteValidator
};

//here setup the friendly aliases that are used by cellProperties.type
Handsontable.cellTypes = {
  text: Handsontable.TextCell,
  date: Handsontable.DateCell,
  numeric: Handsontable.NumericCell,
  checkbox: Handsontable.CheckboxCell,
  autocomplete: Handsontable.AutocompleteCell,
  handsontable: Handsontable.HandsontableCell,
  password: Handsontable.PasswordCell,
  dropdown: Handsontable.DropdownCell
};

//here setup the friendly aliases that are used by cellProperties.renderer and cellProperties.editor
Handsontable.cellLookup = {
  validator: {
    numeric: Handsontable.NumericValidator,
    autocomplete: Handsontable.AutocompleteValidator
  }
};

},{"./editors":34,"./editors/autocompleteEditor":36,"./editors/checkboxEditor":37,"./editors/dateEditor":38,"./editors/dropdownEditor":39,"./editors/handsontableEditor":40,"./editors/mobileTextEditor":41,"./editors/numericEditor":42,"./editors/passwordEditor":43,"./editors/selectEditor":44,"./editors/textEditor":45,"./helpers/browser":48,"./renderers":62,"./renderers/autocompleteRenderer":64,"./renderers/checkboxRenderer":65,"./renderers/htmlRenderer":66,"./renderers/numericRenderer":67,"./renderers/passwordRenderer":68,"./renderers/textRenderer":69,"./validators/autocompleteValidator":72,"./validators/dateValidator":73,"./validators/numericValidator":74}],31:[function(require,module,exports){
'use strict';function _interopRequireDefault(obj){return obj && obj.__esModule?obj:{'default':obj};}var _numeral=require('numeral');var _numeral2=_interopRequireDefault(_numeral);var _helpersDomElement=require('./helpers/dom/element');var _helpersSetting=require('./helpers/setting');var _dataMap=require('./dataMap');var _editorManager=require('./editorManager');var _eventManager=require('./eventManager');var _helpersObject=require('./helpers/object');var _plugins=require('./plugins');var _renderers=require('./renderers');var _helpersString=require('./helpers/string');var _tableView=require('./tableView');var _helpersData=require('./helpers/data');var _rdpartyWalkontableSrcCellCoords=require('./3rdparty/walkontable/src/cell/coords');var _rdpartyWalkontableSrcCellRange=require('./3rdparty/walkontable/src/cell/range');var _rdpartyWalkontableSrcSelection=require('./3rdparty/walkontable/src/selection');var _rdpartyWalkontableSrcCalculatorViewportColumns=require('./3rdparty/walkontable/src/calculator/viewportColumns');Handsontable.activeGuid = null; /**
 * Handsontable constructor
 *
 * @core
 * @dependencies numeral
 * @constructor Core
 * @description
 *
 * After Handsontable is constructed, you can modify the grid behavior using the available public methods.
 *
 * ---
 * ## How to call methods
 *
 * These are 2 equal ways to call a Handsontable method:
 *
 * ```js
 * // all following examples assume that you constructed Handsontable like this
 * var ht = new Handsontable(document.getElementById('example1'), options);
 *
 * // now, to use setDataAtCell method, you can either:
 * ht.setDataAtCell(0, 0, 'new value');
 * ```
 *
 * Alternatively, you can call the method using jQuery wrapper (__obsolete__, requires initialization using our jQuery guide
 * ```js
 *   $('#example1').handsontable('setDataAtCell', 0, 0, 'new value');
 * ```
 * ---
 */Handsontable.Core = function Core(rootElement,userSettings){var priv,datamap,grid,selection,editorManager,instance=this,GridSettings=function GridSettings(){},eventManager=(0,_eventManager.eventManager)(instance);(0,_helpersObject.extend)(GridSettings.prototype,DefaultSettings.prototype); //create grid settings as a copy of default settings
(0,_helpersObject.extend)(GridSettings.prototype,userSettings); //overwrite defaults with user settings
(0,_helpersObject.extend)(GridSettings.prototype,expandType(userSettings));this.rootElement = rootElement;this.isHotTableEnv = (0,_helpersDomElement.isChildOfWebComponentTable)(this.rootElement);Handsontable.eventManager.isHotTableEnv = this.isHotTableEnv;this.container = document.createElement('DIV');this.renderCall = false;rootElement.insertBefore(this.container,rootElement.firstChild);this.guid = 'ht_' + (0,_helpersString.randomString)(); //this is the namespace for global events
if(!this.rootElement.id || this.rootElement.id.substring(0,3) === "ht_"){this.rootElement.id = this.guid; //if root element does not have an id, assign a random id
}priv = {cellSettings:[],columnSettings:[],columnsSettingConflicts:['data','width'],settings:new GridSettings(), // current settings instance
selRange:null, //exposed by public method `getSelectedRange`
isPopulated:null,scrollable:null,firstRun:true};grid = { /**
     * Inserts or removes rows and columns
     *
     * @memberof Core#
     * @function alter
     * @private
     * @param {String} action Possible values: "insert_row", "insert_col", "remove_row", "remove_col"
     * @param {Number} index
     * @param {Number} amount
     * @param {String} [source] Optional. Source of hook runner.
     * @param {Boolean} [keepEmptyRows] Optional. Flag for preventing deletion of empty rows.
     */alter:function alter(action,index,amount,source,keepEmptyRows){var delta;amount = amount || 1;switch(action){case "insert_row":if(instance.getSettings().maxRows === instance.countRows()){return;}delta = datamap.createRow(index,amount);if(delta){if(selection.isSelected() && priv.selRange.from.row >= index){priv.selRange.from.row = priv.selRange.from.row + delta;selection.transformEnd(delta,0); //will call render() internally
}else {selection.refreshBorders(); //it will call render and prepare methods
}}break;case "insert_col": // //column order may have changes, so we need to translate the selection column index -> source array index
// index = instance.runHooksAndReturn('modifyCol', index);
delta = datamap.createCol(index,amount);if(delta){if(Array.isArray(instance.getSettings().colHeaders)){var spliceArray=[index,0];spliceArray.length += delta; //inserts empty (undefined) elements at the end of an array
Array.prototype.splice.apply(instance.getSettings().colHeaders,spliceArray); //inserts empty (undefined) elements into the colHeader array
}if(selection.isSelected() && priv.selRange.from.col >= index){priv.selRange.from.col = priv.selRange.from.col + delta;selection.transformEnd(0,delta); //will call render() internally
}else {selection.refreshBorders(); //it will call render and prepare methods
}}break;case "remove_row": //column order may have changes, so we need to translate the selection column index -> source array index
index = instance.runHooks('modifyCol',index);datamap.removeRow(index,amount);priv.cellSettings.splice(index,amount);var fixedRowsTop=instance.getSettings().fixedRowsTop;if(fixedRowsTop >= index + 1){instance.getSettings().fixedRowsTop -= Math.min(amount,fixedRowsTop - index);}grid.adjustRowsAndCols();selection.refreshBorders(); //it will call render and prepare methods
break;case "remove_col":datamap.removeCol(index,amount);for(var row=0,len=datamap.getAll().length;row < len;row++) {if(row in priv.cellSettings){ //if row hasn't been rendered it wouldn't have cellSettings
priv.cellSettings[row].splice(index,amount);}}var fixedColumnsLeft=instance.getSettings().fixedColumnsLeft;if(fixedColumnsLeft >= index + 1){instance.getSettings().fixedColumnsLeft -= Math.min(amount,fixedColumnsLeft - index);}if(Array.isArray(instance.getSettings().colHeaders)){if(typeof index == 'undefined'){index = -1;}instance.getSettings().colHeaders.splice(index,amount);} //priv.columnSettings.splice(index, amount);
grid.adjustRowsAndCols();selection.refreshBorders(); //it will call render and prepare methods
break; /* jshint ignore:start */default:throw new Error('There is no such action "' + action + '"');break; /* jshint ignore:end */}if(!keepEmptyRows){grid.adjustRowsAndCols(); //makes sure that we did not add rows that will be removed in next refresh
}}, /**
     * Makes sure there are empty rows at the bottom of the table
     */adjustRowsAndCols:function adjustRowsAndCols(){if(priv.settings.minRows){ // should I add empty rows to data source to meet minRows?
var rows=instance.countRows();if(rows < priv.settings.minRows){for(var r=0,minRows=priv.settings.minRows;r < minRows - rows;r++) {datamap.createRow(instance.countRows(),1,true);}}}if(priv.settings.minSpareRows){var emptyRows=instance.countEmptyRows(true); // should I add empty rows to meet minSpareRows?
if(emptyRows < priv.settings.minSpareRows){for(;emptyRows < priv.settings.minSpareRows && instance.countRows() < priv.settings.maxRows;emptyRows++) {datamap.createRow(instance.countRows(),1,true);}}}{var emptyCols=undefined; // count currently empty cols
if(priv.settings.minCols || priv.settings.minSpareCols){emptyCols = instance.countEmptyCols(true);} // should I add empty cols to meet minCols?
if(priv.settings.minCols && !priv.settings.columns && instance.countCols() < priv.settings.minCols){for(;instance.countCols() < priv.settings.minCols;emptyCols++) {datamap.createCol(instance.countCols(),1,true);}} // should I add empty cols to meet minSpareCols?
if(priv.settings.minSpareCols && !priv.settings.columns && instance.dataType === 'array' && emptyCols < priv.settings.minSpareCols){for(;emptyCols < priv.settings.minSpareCols && instance.countCols() < priv.settings.maxCols;emptyCols++) {datamap.createCol(instance.countCols(),1,true);}}}var rowCount=instance.countRows();var colCount=instance.countCols();if(rowCount === 0 || colCount === 0){selection.deselect();}if(selection.isSelected()){var selectionChanged=false;var fromRow=priv.selRange.from.row;var fromCol=priv.selRange.from.col;var toRow=priv.selRange.to.row;var toCol=priv.selRange.to.col; // if selection is outside, move selection to last row
if(fromRow > rowCount - 1){fromRow = rowCount - 1;selectionChanged = true;if(toRow > fromRow){toRow = fromRow;}}else if(toRow > rowCount - 1){toRow = rowCount - 1;selectionChanged = true;if(fromRow > toRow){fromRow = toRow;}} // if selection is outside, move selection to last row
if(fromCol > colCount - 1){fromCol = colCount - 1;selectionChanged = true;if(toCol > fromCol){toCol = fromCol;}}else if(toCol > colCount - 1){toCol = colCount - 1;selectionChanged = true;if(fromCol > toCol){fromCol = toCol;}}if(selectionChanged){instance.selectCell(fromRow,fromCol,toRow,toCol);}}if(instance.view){instance.view.wt.wtOverlays.adjustElementsSize();}}, /**
     * Populate cells at position with 2d array
     *
     * @private
     * @param {Object} start Start selection position
     * @param {Array} input 2d array
     * @param {Object} [end] End selection position (only for drag-down mode)
     * @param {String} [source="populateFromArray"]
     * @param {String} [method="overwrite"]
     * @param {String} direction (left|right|up|down)
     * @param {Array} deltas array
     * @returns {Object|undefined} ending td in pasted area (only if any cell was changed)
     */populateFromArray:function populateFromArray(start,input,end,source,method,direction,deltas){var r,rlen,c,clen,setData=[],current={};rlen = input.length;if(rlen === 0){return false;}var repeatCol,repeatRow,cmax,rmax; // insert data with specified pasteMode method
switch(method){case 'shift_down':repeatCol = end?end.col - start.col + 1:0;repeatRow = end?end.row - start.row + 1:0;input = (0,_helpersData.translateRowsToColumns)(input);for(c = 0,clen = input.length,cmax = Math.max(clen,repeatCol);c < cmax;c++) {if(c < clen){for(r = 0,rlen = input[c].length;r < repeatRow - rlen;r++) {input[c].push(input[c][r % rlen]);}input[c].unshift(start.col + c,start.row,0);instance.spliceCol.apply(instance,input[c]);}else {input[c % clen][0] = start.col + c;instance.spliceCol.apply(instance,input[c % clen]);}}break;case 'shift_right':repeatCol = end?end.col - start.col + 1:0;repeatRow = end?end.row - start.row + 1:0;for(r = 0,rlen = input.length,rmax = Math.max(rlen,repeatRow);r < rmax;r++) {if(r < rlen){for(c = 0,clen = input[r].length;c < repeatCol - clen;c++) {input[r].push(input[r][c % clen]);}input[r].unshift(start.row + r,start.col,0);instance.spliceRow.apply(instance,input[r]);}else {input[r % rlen][0] = start.row + r;instance.spliceRow.apply(instance,input[r % rlen]);}}break; /* jshint ignore:start */case 'overwrite':default: /* jshint ignore:end */ // overwrite and other not specified options
current.row = start.row;current.col = start.col;var iterators={row:0,col:0}, // number of packages
selected={ // selected range
row:end && start?end.row - start.row + 1:1,col:end && start?end.col - start.col + 1:1},pushData=true;if(['up','left'].indexOf(direction) !== -1){iterators = {row:Math.ceil(selected.row / rlen) || 1,col:Math.ceil(selected.col / input[0].length) || 1};}else if(['down','right'].indexOf(direction) !== -1){iterators = {row:1,col:1};}for(r = 0;r < rlen;r++) {if(end && current.row > end.row || !priv.settings.allowInsertRow && current.row > instance.countRows() - 1 || current.row >= priv.settings.maxRows){break;}current.col = start.col;clen = input[r]?input[r].length:0;for(c = 0;c < clen;c++) {if(end && current.col > end.col || !priv.settings.allowInsertColumn && current.col > instance.countCols() - 1 || current.col >= priv.settings.maxCols){break;}if(!instance.getCellMeta(current.row,current.col).readOnly){var result,value=input[r][c],orgValue=instance.getDataAtCell(current.row,current.col),index={row:r,col:c},valueSchema,orgValueSchema;if(source === 'autofill'){result = instance.runHooks('beforeAutofillInsidePopulate',index,direction,input,deltas,iterators,selected);if(result){iterators = typeof result.iterators !== 'undefined'?result.iterators:iterators;value = typeof result.value !== 'undefined'?result.value:value;}}if(value !== null && typeof value === 'object'){if(orgValue === null || typeof orgValue !== 'object'){pushData = false;}else {orgValueSchema = (0,_helpersObject.duckSchema)(orgValue[0] || orgValue);valueSchema = (0,_helpersObject.duckSchema)(value[0] || value); /* jshint -W073 */if((0,_helpersObject.isObjectEquals)(orgValueSchema,valueSchema)){value = (0,_helpersObject.deepClone)(value);}else {pushData = false;}}}else if(orgValue !== null && typeof orgValue === 'object'){pushData = false;}if(pushData){setData.push([current.row,current.col,value]);}pushData = true;}current.col++;if(end && c === clen - 1){c = -1;if(['down','right'].indexOf(direction) !== -1){iterators.col++;}else if(['up','left'].indexOf(direction) !== -1){if(iterators.col > 1){iterators.col--;}}}}current.row++;iterators.col = 1;if(end && r === rlen - 1){r = -1;if(['down','right'].indexOf(direction) !== -1){iterators.row++;}else if(['up','left'].indexOf(direction) !== -1){if(iterators.row > 1){iterators.row--;}}}}instance.setDataAtCell(setData,null,null,source || 'populateFromArray');break;}}};this.selection = selection = { //this public assignment is only temporary
inProgress:false,selectedHeader:{cols:false,rows:false}, /**
     * @param {Boolean} rows
     * @param {Boolean} cols
     */setSelectedHeaders:function setSelectedHeaders(rows,cols){instance.selection.selectedHeader.rows = rows;instance.selection.selectedHeader.cols = cols;}, /**
     * Sets inProgress to `true`. This enables onSelectionEnd and onSelectionEndByProp to function as desired.
     */begin:function begin(){instance.selection.inProgress = true;}, /**
     * Sets inProgress to `false`. Triggers onSelectionEnd and onSelectionEndByProp.
     */finish:function finish(){var sel=instance.getSelected();Handsontable.hooks.run(instance,"afterSelectionEnd",sel[0],sel[1],sel[2],sel[3]);Handsontable.hooks.run(instance,"afterSelectionEndByProp",sel[0],instance.colToProp(sel[1]),sel[2],instance.colToProp(sel[3]));instance.selection.inProgress = false;}, /**
     * @returns {Boolean}
     */isInProgress:function isInProgress(){return instance.selection.inProgress;}, /**
     * Starts selection range on given td object.
     *
     * @param {WalkontableCellCoords} coords
     * @param keepEditorOpened
     */setRangeStart:function setRangeStart(coords,keepEditorOpened){Handsontable.hooks.run(instance,"beforeSetRangeStart",coords);priv.selRange = new _rdpartyWalkontableSrcCellRange.WalkontableCellRange(coords,coords,coords);selection.setRangeEnd(coords,null,keepEditorOpened);}, /**
     * Ends selection range on given td object.
     *
     * @param {WalkontableCellCoords} coords
     * @param {Boolean} [scrollToCell=true] If `true`, viewport will be scrolled to range end
     * @param {Boolean} [keepEditorOpened] If `true`, cell editor will be still opened after changing selection range
     */setRangeEnd:function setRangeEnd(coords,scrollToCell,keepEditorOpened){if(priv.selRange === null){return;}var disableVisualSelection,isHeaderSelected=false,areCoordsPositive=true;var firstVisibleRow=instance.view.wt.wtTable.getFirstVisibleRow();var firstVisibleColumn=instance.view.wt.wtTable.getFirstVisibleColumn();var newRangeCoords={row:null,col:null}; //trigger handlers
Handsontable.hooks.run(instance,"beforeSetRangeEnd",coords);instance.selection.begin();newRangeCoords.row = coords.row < 0?firstVisibleRow:coords.row;newRangeCoords.col = coords.col < 0?firstVisibleColumn:coords.col;priv.selRange.to = new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(newRangeCoords.row,newRangeCoords.col);if(!priv.settings.multiSelect){priv.selRange.from = coords;} // set up current selection
instance.view.wt.selections.current.clear();disableVisualSelection = instance.getCellMeta(priv.selRange.highlight.row,priv.selRange.highlight.col).disableVisualSelection;if(typeof disableVisualSelection === 'string'){disableVisualSelection = [disableVisualSelection];}if(disableVisualSelection === false || Array.isArray(disableVisualSelection) && disableVisualSelection.indexOf('current') === -1){instance.view.wt.selections.current.add(priv.selRange.highlight);} // set up area selection
instance.view.wt.selections.area.clear();if((disableVisualSelection === false || Array.isArray(disableVisualSelection) && disableVisualSelection.indexOf('area') === -1) && selection.isMultiple()){instance.view.wt.selections.area.add(priv.selRange.from);instance.view.wt.selections.area.add(priv.selRange.to);} // set up highlight
if(priv.settings.currentRowClassName || priv.settings.currentColClassName){instance.view.wt.selections.highlight.clear();instance.view.wt.selections.highlight.add(priv.selRange.from);instance.view.wt.selections.highlight.add(priv.selRange.to);} // trigger handlers
Handsontable.hooks.run(instance,"afterSelection",priv.selRange.from.row,priv.selRange.from.col,priv.selRange.to.row,priv.selRange.to.col);Handsontable.hooks.run(instance,"afterSelectionByProp",priv.selRange.from.row,datamap.colToProp(priv.selRange.from.col),priv.selRange.to.row,datamap.colToProp(priv.selRange.to.col));if(priv.selRange.from.row === 0 && priv.selRange.to.row === instance.countRows() - 1 && instance.countRows() > 1 || priv.selRange.from.col === 0 && priv.selRange.to.col === instance.countCols() - 1 && instance.countCols() > 1){isHeaderSelected = true;}if(coords.row < 0 || coords.col < 0){areCoordsPositive = false;}if(scrollToCell !== false && !isHeaderSelected && areCoordsPositive){if(priv.selRange.from && !selection.isMultiple()){instance.view.scrollViewport(priv.selRange.from);}else {instance.view.scrollViewport(coords);}}selection.refreshBorders(null,keepEditorOpened);}, /**
     * Destroys editor, redraws borders around cells, prepares editor.
     *
     * @param {Boolean} [revertOriginal]
     * @param {Boolean} [keepEditor]
     */refreshBorders:function refreshBorders(revertOriginal,keepEditor){if(!keepEditor){editorManager.destroyEditor(revertOriginal);}instance.view.render();if(selection.isSelected() && !keepEditor){editorManager.prepareEditor();}}, /**
     * Returns information if we have a multiselection.
     *
     * @returns {Boolean}
     */isMultiple:function isMultiple(){var isMultiple=!(priv.selRange.to.col === priv.selRange.from.col && priv.selRange.to.row === priv.selRange.from.row),modifier=Handsontable.hooks.run(instance,'afterIsMultipleSelection',isMultiple);if(isMultiple){return modifier;}}, /**
     * Selects cell relative to current cell (if possible).
     */transformStart:function transformStart(rowDelta,colDelta,force,keepEditorOpened){var delta=new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(rowDelta,colDelta),rowTransformDir=0,colTransformDir=0,totalRows,totalCols,coords;instance.runHooks('modifyTransformStart',delta);totalRows = instance.countRows();totalCols = instance.countCols(); /* jshint ignore:start */if(priv.selRange.highlight.row + rowDelta > totalRows - 1){if(force && priv.settings.minSpareRows > 0){instance.alter("insert_row",totalRows);totalRows = instance.countRows();}else if(priv.settings.autoWrapCol){delta.row = 1 - totalRows;delta.col = priv.selRange.highlight.col + delta.col == totalCols - 1?1 - totalCols:1;}}else if(priv.settings.autoWrapCol && priv.selRange.highlight.row + delta.row < 0 && priv.selRange.highlight.col + delta.col >= 0){delta.row = totalRows - 1;delta.col = priv.selRange.highlight.col + delta.col == 0?totalCols - 1:-1;}if(priv.selRange.highlight.col + delta.col > totalCols - 1){if(force && priv.settings.minSpareCols > 0){instance.alter("insert_col",totalCols);totalCols = instance.countCols();}else if(priv.settings.autoWrapRow){delta.row = priv.selRange.highlight.row + delta.row == totalRows - 1?1 - totalRows:1;delta.col = 1 - totalCols;}}else if(priv.settings.autoWrapRow && priv.selRange.highlight.col + delta.col < 0 && priv.selRange.highlight.row + delta.row >= 0){delta.row = priv.selRange.highlight.row + delta.row == 0?totalRows - 1:-1;delta.col = totalCols - 1;} /* jshint ignore:end */coords = new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(priv.selRange.highlight.row + delta.row,priv.selRange.highlight.col + delta.col);if(coords.row < 0){rowTransformDir = -1;coords.row = 0;}else if(coords.row > 0 && coords.row >= totalRows){rowTransformDir = 1;coords.row = totalRows - 1;}if(coords.col < 0){colTransformDir = -1;coords.col = 0;}else if(coords.col > 0 && coords.col >= totalCols){colTransformDir = 1;coords.col = totalCols - 1;}instance.runHooks('afterModifyTransformStart',coords,rowTransformDir,colTransformDir);selection.setRangeStart(coords,keepEditorOpened);}, /**
     * Sets selection end cell relative to current selection end cell (if possible).
     */transformEnd:function transformEnd(rowDelta,colDelta){var delta=new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(rowDelta,colDelta),rowTransformDir=0,colTransformDir=0,totalRows,totalCols,coords;instance.runHooks('modifyTransformEnd',delta);totalRows = instance.countRows();totalCols = instance.countCols();coords = new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(priv.selRange.to.row + delta.row,priv.selRange.to.col + delta.col);if(coords.row < 0){rowTransformDir = -1;coords.row = 0;}else if(coords.row > 0 && coords.row >= totalRows){rowTransformDir = 1;coords.row = totalRows - 1;}if(coords.col < 0){colTransformDir = -1;coords.col = 0;}else if(coords.col > 0 && coords.col >= totalCols){colTransformDir = 1;coords.col = totalCols - 1;}instance.runHooks('afterModifyTransformEnd',coords,rowTransformDir,colTransformDir);selection.setRangeEnd(coords,true);}, /**
     * Returns `true` if currently there is a selection on screen, `false` otherwise.
     *
     * @returns {Boolean}
     */isSelected:function isSelected(){return priv.selRange !== null;}, /**
     * Returns `true` if coords is within current selection coords.
     *
     * @param {WalkontableCellCoords} coords
     * @returns {Boolean}
     */inInSelection:function inInSelection(coords){if(!selection.isSelected()){return false;}return priv.selRange.includes(coords);}, /**
     * Deselects all selected cells
     */deselect:function deselect(){if(!selection.isSelected()){return;}instance.selection.inProgress = false; //needed by HT inception
priv.selRange = null;instance.view.wt.selections.current.clear();instance.view.wt.selections.area.clear();if(priv.settings.currentRowClassName || priv.settings.currentColClassName){instance.view.wt.selections.highlight.clear();}editorManager.destroyEditor();selection.refreshBorders();Handsontable.hooks.run(instance,'afterDeselect');}, /**
     * Select all cells
     */selectAll:function selectAll(){if(!priv.settings.multiSelect){return;}selection.setRangeStart(new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(0,0));selection.setRangeEnd(new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(instance.countRows() - 1,instance.countCols() - 1),false);}, /**
     * Deletes data from selected cells
     */empty:function empty(){if(!selection.isSelected()){return;}var topLeft=priv.selRange.getTopLeftCorner();var bottomRight=priv.selRange.getBottomRightCorner();var r,c,changes=[];for(r = topLeft.row;r <= bottomRight.row;r++) {for(c = topLeft.col;c <= bottomRight.col;c++) {if(!instance.getCellMeta(r,c).readOnly){changes.push([r,c,'']);}}}instance.setDataAtCell(changes);}};this.init = function(){Handsontable.hooks.run(instance,'beforeInit');if(Handsontable.mobileBrowser){(0,_helpersDomElement.addClass)(instance.rootElement,'mobile');}this.updateSettings(priv.settings,true);this.view = new _tableView.TableView(this);editorManager = new _editorManager.EditorManager(instance,priv,selection,datamap);this.forceFullRender = true; //used when data was changed
Handsontable.hooks.run(instance,'init');this.view.render();if(typeof priv.firstRun === 'object'){Handsontable.hooks.run(instance,'afterChange',priv.firstRun[0],priv.firstRun[1]);priv.firstRun = false;}Handsontable.hooks.run(instance,'afterInit');};function ValidatorsQueue(){ //moved this one level up so it can be used in any function here. Probably this should be moved to a separate file
var resolved=false;return {validatorsInQueue:0,valid:true,addValidatorToQueue:function addValidatorToQueue(){this.validatorsInQueue++;resolved = false;},removeValidatorFormQueue:function removeValidatorFormQueue(){this.validatorsInQueue = this.validatorsInQueue - 1 < 0?0:this.validatorsInQueue - 1;this.checkIfQueueIsEmpty();},onQueueEmpty:function onQueueEmpty(valid){},checkIfQueueIsEmpty:function checkIfQueueIsEmpty(){ /* jshint ignore:start */if(this.validatorsInQueue == 0 && resolved == false){resolved = true;this.onQueueEmpty(this.valid);} /* jshint ignore:end */}};}function validateChanges(changes,source,callback){var waitingForValidator=new ValidatorsQueue();waitingForValidator.onQueueEmpty = resolve;for(var i=changes.length - 1;i >= 0;i--) {if(changes[i] === null){changes.splice(i,1);}else {var row=changes[i][0];var col=datamap.propToCol(changes[i][1]); //column order may have changes, so we need to translate physical col index (stored in datasource) to logical (displayed to user)
var logicalCol=instance.runHooks('modifyCol',col);var cellProperties=instance.getCellMeta(row,logicalCol);if(cellProperties.type === 'numeric' && typeof changes[i][3] === 'string'){if(changes[i][3].length > 0 && (/^-?[\d\s]*(\.|\,)?\d*$/.test(changes[i][3]) || cellProperties.format)){var len=changes[i][3].length;if(typeof cellProperties.language == 'undefined'){_numeral2['default'].language('en');} //this input in format XXXX.XX is likely to come from paste. Let's parse it using international rules
else if(changes[i][3].indexOf(".") === len - 3 && changes[i][3].indexOf(",") === -1){_numeral2['default'].language('en');}else {_numeral2['default'].language(cellProperties.language);}if(_numeral2['default'].validate(changes[i][3])){changes[i][3] = (0,_numeral2['default'])().unformat(changes[i][3]);}}} /* jshint ignore:start */if(instance.getCellValidator(cellProperties)){waitingForValidator.addValidatorToQueue();instance.validateCell(changes[i][3],cellProperties,(function(i,cellProperties){return function(result){if(typeof result !== 'boolean'){throw new Error("Validation error: result is not boolean");}if(result === false && cellProperties.allowInvalid === false){changes.splice(i,1); // cancel the change
cellProperties.valid = true; // we cancelled the change, so cell value is still valid
--i;}waitingForValidator.removeValidatorFormQueue();};})(i,cellProperties),source);} /* jshint ignore:end */}}waitingForValidator.checkIfQueueIsEmpty();function resolve(){var beforeChangeResult;if(changes.length){beforeChangeResult = Handsontable.hooks.run(instance,"beforeChange",changes,source);if(typeof beforeChangeResult === 'function'){console.warn("Your beforeChange callback returns a function. It's not supported since Handsontable 0.12.1 (and the returned function will not be executed).");}else if(beforeChangeResult === false){changes.splice(0,changes.length); //invalidate all changes (remove everything from array)
}}callback(); //called when async validators are resolved and beforeChange was not async
}} /**
   * Internal function to apply changes. Called after validateChanges
   *
   * @private
   * @param {Array} changes Array in form of [row, prop, oldValue, newValue]
   * @param {String} source String that identifies how this change will be described in changes array (useful in onChange callback)
   * @fires Hooks#beforeChangeRender
   * @fires Hooks#afterChange
   */function applyChanges(changes,source){var i=changes.length - 1;if(i < 0){return;}for(;0 <= i;i--) {if(changes[i] === null){changes.splice(i,1);continue;}if(changes[i][2] == null && changes[i][3] == null){continue;}if(priv.settings.allowInsertRow){while(changes[i][0] > instance.countRows() - 1) {datamap.createRow();}}if(instance.dataType === 'array' && priv.settings.allowInsertColumn){while(datamap.propToCol(changes[i][1]) > instance.countCols() - 1) {datamap.createCol();}}datamap.set(changes[i][0],changes[i][1],changes[i][3]);}instance.forceFullRender = true; //used when data was changed
grid.adjustRowsAndCols();Handsontable.hooks.run(instance,'beforeChangeRender',changes,source);selection.refreshBorders(null,true);instance.view.wt.wtOverlays.adjustElementsSize();Handsontable.hooks.run(instance,'afterChange',changes,source || 'edit');}this.validateCell = function(value,cellProperties,callback,source){var validator=instance.getCellValidator(cellProperties);function done(valid){var col=cellProperties.col,row=cellProperties.row,td=instance.getCell(row,col,true);if(td){instance.view.wt.wtSettings.settings.cellRenderer(row,col,td);}callback(valid);}if(Object.prototype.toString.call(validator) === '[object RegExp]'){validator = (function(validator){return function(value,callback){callback(validator.test(value));};})(validator);}if(typeof validator == 'function'){value = Handsontable.hooks.run(instance,"beforeValidate",value,cellProperties.row,cellProperties.prop,source); // To provide consistent behaviour, validation should be always asynchronous
instance._registerTimeout(setTimeout(function(){validator.call(cellProperties,value,function(valid){valid = Handsontable.hooks.run(instance,"afterValidate",valid,value,cellProperties.row,cellProperties.prop,source);cellProperties.valid = valid;done(valid);Handsontable.hooks.run(instance,"postAfterValidate",valid,value,cellProperties.row,cellProperties.prop,source);});},0));}else { //resolve callback even if validator function was not found
cellProperties.valid = true;done(cellProperties.valid);}};function setDataInputToArray(row,propOrCol,value){if(typeof row === "object"){ //is it an array of changes
return row;}else {return [[row,propOrCol,value]];}} /**
   * @description
   * Set new value to a cell. To change many cells at once, pass an array of `changes` in format `[[row, col, value], ...]` as
   * the only parameter. `col` is the index of __visible__ column (note that if columns were reordered,
   * the current order will be used). `source` is a flag for before/afterChange events. If you pass only array of
   * changes then `source` could be set as second parameter.
   *
   * @memberof Core#
   * @function setDataAtCell
   * @param {Number|Array} row or array of changes in format `[[row, col, value], ...]`
   * @param {Number|String} col or source String
   * @param {String} value
   * @param {String} [source] String that identifies how this change will be described in changes array (useful in onChange callback)
   */this.setDataAtCell = function(row,col,value,source){var input=setDataInputToArray(row,col,value),i,ilen,changes=[],prop;for(i = 0,ilen = input.length;i < ilen;i++) {if(typeof input[i] !== 'object'){throw new Error('Method `setDataAtCell` accepts row number or changes array of arrays as its first parameter');}if(typeof input[i][1] !== 'number'){throw new Error('Method `setDataAtCell` accepts row and column number as its parameters. If you want to use object property name, use method `setDataAtRowProp`');}prop = datamap.colToProp(input[i][1]);changes.push([input[i][0],prop,datamap.get(input[i][0],prop),input[i][2]]);}if(!source && typeof row === "object"){source = col;}validateChanges(changes,source,function(){applyChanges(changes,source);});}; /**
   * Same as above, except instead of `col`, you provide name of the object property (e.g. `[0, 'first.name', 'Jennifer']`).
   *
   * @memberof Core#
   * @function setDataAtRowProp
   * @param {Number|Array} row or array of changes in format `[[row, prop, value], ...]`
   * @param {String} prop or source String
   * @param {String} value
   * @param {String} [source] String that identifies how this change will be described in changes array (useful in onChange callback)
   */this.setDataAtRowProp = function(row,prop,value,source){var input=setDataInputToArray(row,prop,value),i,ilen,changes=[];for(i = 0,ilen = input.length;i < ilen;i++) {changes.push([input[i][0],input[i][1],datamap.get(input[i][0],input[i][1]),input[i][2]]);}if(!source && typeof row === "object"){source = prop;}validateChanges(changes,source,function(){applyChanges(changes,source);});}; /**
   * Listen to keyboard input on document body.
   *
   * @memberof Core#
   * @function listen
   * @since 0.11
   */this.listen = function(){Handsontable.activeGuid = instance.guid;if(document.activeElement && document.activeElement !== document.body){document.activeElement.blur();}else if(!document.activeElement){ //IE
document.body.focus();}}; /**
   * Stop listening to keyboard input on document body.
   *
   * @memberof Core#
   * @function unlisten
   * @since 0.11
   */this.unlisten = function(){Handsontable.activeGuid = null;}; /**
   * Returns `true` if current Handsontable instance is listening to keyboard input on document body.
   *
   * @memberof Core#
   * @function isListening
   * @since 0.11
   * @returns {Boolean}
   */this.isListening = function(){return Handsontable.activeGuid === instance.guid;}; /**
   * Destroys current editor, renders and selects current cell.
   *
   * @memberof Core#
   * @function destroyEditor
   * @param {Boolean} [revertOriginal] If != `true`, edited data is saved. Otherwise previous value is restored
   */this.destroyEditor = function(revertOriginal){selection.refreshBorders(revertOriginal);}; /**
   * Populate cells at position with 2D input array (e.g. `[[1, 2], [3, 4]]`).
   * Use `endRow`, `endCol` when you want to cut input when certain row is reached.
   * Optional `source` parameter (default value "populateFromArray") is used to identify this call in the resulting events (beforeChange, afterChange).
   * Optional `populateMethod` parameter (default value "overwrite", possible values "shift_down" and "shift_right")
   * has the same effect as pasteMethod option (see Options page)
   *
   * @memberof Core#
   * @function populateFromArray
   * @since 0.9.0
   * @param {Number} row Start row
   * @param {Number} col Start column
   * @param {Array} input 2d array
   * @param {Number} [endRow] End row (use when you want to cut input when certain row is reached)
   * @param {Number} [endCol] End column (use when you want to cut input when certain column is reached)
   * @param {String} [source="populateFromArray"]
   * @param {String} [method="overwrite"]
   * @param {String} direction edit (left|right|up|down)
   * @param {Array} deltas array
   * @returns {Object|undefined} ending td in pasted area (only if any cell was changed)
   */this.populateFromArray = function(row,col,input,endRow,endCol,source,method,direction,deltas){var c;if(!(typeof input === 'object' && typeof input[0] === 'object')){throw new Error("populateFromArray parameter `input` must be an array of arrays"); //API changed in 0.9-beta2, let's check if you use it correctly
}c = typeof endRow === 'number'?new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(endRow,endCol):null;return grid.populateFromArray(new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(row,col),input,c,source,method,direction,deltas);}; /**
   * Adds/removes data from the column. This function works is modelled after Array.splice.
   * Parameter `col` is the index of column in which do you want to do splice.
   * Parameter `index` is the row index at which to start changing the array.
   * If negative, will begin that many elements from the end. Parameter `amount`, is the number of old array elements to remove.
   * If the amount is 0, no elements are removed. Fourth and further parameters are the `elements` to add to the array.
   * If you don't specify any elements, spliceCol simply removes elements from the array.
   * {@link DataMap#spliceCol}
   *
   * @memberof Core#
   * @function spliceCol
   * @since 0.9-beta2
   * @param {Number} col Index of column in which do you want to do splice.
   * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end
   * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed
   * @param {*} [elements] The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array
   */this.spliceCol = function(col,index,amount /*, elements... */){return datamap.spliceCol.apply(datamap,arguments);}; /**
   * Adds/removes data from the row. This function works is modelled after Array.splice.
   * Parameter `row` is the index of row in which do you want to do splice.
   * Parameter `index` is the column index at which to start changing the array.
   * If negative, will begin that many elements from the end. Parameter `amount`, is the number of old array elements to remove.
   * If the amount is 0, no elements are removed. Fourth and further parameters are the `elements` to add to the array.
   * If you don't specify any elements, spliceCol simply removes elements from the array.
   * {@link DataMap#spliceRow}
   *
   * @memberof Core#
   * @function spliceRow
   * @since 0.11
   * @param {Number} row Index of column in which do you want to do splice.
   * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end
   * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed
   * @param {*} [elements] The elements to add to the array. If you don't specify any elements, spliceCol simply removes elements from the array
   */this.spliceRow = function(row,index,amount /*, elements... */){return datamap.spliceRow.apply(datamap,arguments);}; /**
   * Return index of the currently selected cells as an array `[startRow, startCol, endRow, endCol]`.
   *
   * Start row and start col are the coordinates of the active cell (where the selection was started).
   *
   * @memberof Core#
   * @function getSelected
   * @returns {Array}
   */this.getSelected = function(){ //https://github.com/handsontable/handsontable/issues/44  //cjl
if(selection.isSelected()){return [priv.selRange.from.row,priv.selRange.from.col,priv.selRange.to.row,priv.selRange.to.col];}}; /**
   * Returns current selection as a WalkontableCellRange object.
   *
   * @memberof Core#
   * @function getSelectedRange
   * @since 0.11
   * @returns {WalkontableCellRange} Returns `undefined` if there is no selection.
   */this.getSelectedRange = function(){ //https://github.com/handsontable/handsontable/issues/44  //cjl
if(selection.isSelected()){return priv.selRange;}}; /**
   * Rerender the table.
   *
   * @memberof Core#
   * @function render
   */this.render = function(){if(instance.view){instance.renderCall = true;instance.forceFullRender = true; //used when data was changed
selection.refreshBorders(null,true);}}; /**
   * Reset all cells in the grid to contain data from the data array.
   *
   * @memberof Core#
   * @function loadData
   * @param {Array} data
   * @fires Hooks#afterLoadData
   * @fires Hooks#afterChange
   */this.loadData = function(data){if(typeof data === 'object' && data !== null){if(!(data.push && data.splice)){ //check if data is array. Must use duck-type check so Backbone Collections also pass it
//when data is not an array, attempt to make a single-row array of it
data = [data];}}else if(data === null){data = [];var row;for(var r=0,rlen=priv.settings.startRows;r < rlen;r++) {row = [];for(var c=0,clen=priv.settings.startCols;c < clen;c++) {row.push(null);}data.push(row);}}else {throw new Error("loadData only accepts array of objects or array of arrays (" + typeof data + " given)");}priv.isPopulated = false;GridSettings.prototype.data = data;if(Array.isArray(priv.settings.dataSchema) || Array.isArray(data[0])){instance.dataType = 'array';}else if(typeof priv.settings.dataSchema === 'function'){instance.dataType = 'function';}else {instance.dataType = 'object';}datamap = new _dataMap.DataMap(instance,priv,GridSettings);clearCellSettingCache();grid.adjustRowsAndCols();Handsontable.hooks.run(instance,'afterLoadData');if(priv.firstRun){priv.firstRun = [null,'loadData'];}else {Handsontable.hooks.run(instance,'afterChange',null,'loadData');instance.render();}priv.isPopulated = true;function clearCellSettingCache(){priv.cellSettings.length = 0;}}; /**
   * Return the current data object (the same that was passed by `data` configuration option or `loadData` method).
   * Optionally you can provide cell range `row`, `col`, `row2`, `col2` to get only a fragment of grid data.
   *
   * @memberof Core#
   * @function getData
   * @param {Number} [r] From row
   * @param {Number} [c] From col
   * @param {Number} [r2] To row
   * @param {Number} [c2] To col
   * @returns {Array|Object}
   */this.getData = function(r,c,r2,c2){if(typeof r === 'undefined'){return datamap.getAll();}else {return datamap.getRange(new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(r,c),new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(r2,c2),datamap.DESTINATION_RENDERER);}}; /**
   * Get value of selected range. Each column is separated by tab, each row is separated by new line character.
   * {@link DataMap#getCopyableText}
   *
   * @memberof Core#
   * @function getCopyableData
   * @since 0.11
   * @param {Number} startRow From row
   * @param {Number} startCol From col
   * @param {Number} endRow To row
   * @param {Number} endCol To col
   * @returns {Array|Object}
   */this.getCopyableData = function(startRow,startCol,endRow,endCol){return datamap.getCopyableText(new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(startRow,startCol),new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(endRow,endCol));}; /**
   * Get schema provided by constructor settings or if it doesn't exist return schema based on data
   * structure on the first row.
   *
   * @memberof Core#
   * @function getSchema
   * @since 0.13.2
   * @returns {Object}
   */this.getSchema = function(){return datamap.getSchema();}; /**
   * Use it if you need to change configuration after initialization.
   *
   * @memberof Core#
   * @function updateSettings
   * @param {Object} settings Settings to update
   * @param {Boolean} init
   * @fires Hooks#afterCellMetaReset
   * @fires Hooks#afterUpdateSettings
   */this.updateSettings = function(settings,init){var i,clen;if(typeof settings.rows !== "undefined"){throw new Error("'rows' setting is no longer supported. do you mean startRows, minRows or maxRows?");}if(typeof settings.cols !== "undefined"){throw new Error("'cols' setting is no longer supported. do you mean startCols, minCols or maxCols?");}for(i in settings) {if(i === 'data'){continue; //loadData will be triggered later
}else {if(Handsontable.hooks.getRegistered().indexOf(i) > -1){if(typeof settings[i] === 'function' || Array.isArray(settings[i])){instance.addHook(i,settings[i]);}}else { // Update settings
if(!init && settings.hasOwnProperty(i)){GridSettings.prototype[i] = settings[i];}}}} // Load data or create data map
if(settings.data === void 0 && priv.settings.data === void 0){instance.loadData(null); //data source created just now
}else if(settings.data !== void 0){instance.loadData(settings.data); //data source given as option
}else if(settings.columns !== void 0){datamap.createMap();} // Init columns constructors configuration
clen = instance.countCols(); //Clear cellSettings cache
priv.cellSettings.length = 0;if(clen > 0){var proto,column;for(i = 0;i < clen;i++) {priv.columnSettings[i] = (0,_helpersSetting.columnFactory)(GridSettings,priv.columnsSettingConflicts); // shortcut for prototype
proto = priv.columnSettings[i].prototype; // Use settings provided by user
if(GridSettings.prototype.columns){column = GridSettings.prototype.columns[i];(0,_helpersObject.extend)(proto,column);(0,_helpersObject.extend)(proto,expandType(column));}}}if(typeof settings.cell !== 'undefined'){for(i in settings.cell) {if(settings.cell.hasOwnProperty(i)){var cell=settings.cell[i];instance.setCellMetaObject(cell.row,cell.col,cell);}}}Handsontable.hooks.run(instance,'afterCellMetaReset');if(typeof settings.className !== "undefined"){if(GridSettings.prototype.className){(0,_helpersDomElement.removeClass)(instance.rootElement,GridSettings.prototype.className); //        instance.rootElement.removeClass(GridSettings.prototype.className);
}if(settings.className){(0,_helpersDomElement.addClass)(instance.rootElement,settings.className); //        instance.rootElement.addClass(settings.className);
}}if(typeof settings.height != 'undefined'){var height=settings.height;if(typeof height == 'function'){height = height();}instance.rootElement.style.height = height + 'px';}if(typeof settings.width != 'undefined'){var width=settings.width;if(typeof width == 'function'){width = width();}instance.rootElement.style.width = width + 'px';} /* jshint ignore:start */if(height){instance.rootElement.style.overflow = 'hidden';} /* jshint ignore:end */if(!init){Handsontable.hooks.run(instance,'afterUpdateSettings');}grid.adjustRowsAndCols();if(instance.view && !priv.firstRun){instance.forceFullRender = true; //used when data was changed
selection.refreshBorders(null,true);}}; /**
   * Get value from selected cell.
   *
   * @memberof Core#
   * @function getValue
   * @since 0.11
   * @returns {*} Returns value of selected cell
   */this.getValue = function(){var sel=instance.getSelected();if(GridSettings.prototype.getValue){if(typeof GridSettings.prototype.getValue === 'function'){return GridSettings.prototype.getValue.call(instance);}else if(sel){return instance.getData()[sel[0]][GridSettings.prototype.getValue];}}else if(sel){return instance.getDataAtCell(sel[0],sel[1]);}};function expandType(obj){if(!obj.hasOwnProperty('type')){ //ignore obj.prototype.type
return;}var type,expandedType={};if(typeof obj.type === 'object'){type = obj.type;}else if(typeof obj.type === 'string'){type = Handsontable.cellTypes[obj.type];if(type === void 0){throw new Error('You declared cell type "' + obj.type + '" as a string that is not mapped to a known object. Cell type must be an object or a string mapped to an object in Handsontable.cellTypes');}}for(var i in type) {if(type.hasOwnProperty(i) && !obj.hasOwnProperty(i)){expandedType[i] = type[i];}}return expandedType;} /**
   * Get object settings.
   *
   * @memberof Core#
   * @function getSettings
   * @returns {Object} Returns an object containing the current grid settings
   */this.getSettings = function(){return priv.settings;}; /**
   * Clears grid.
   *
   * @memberof Core#
   * @function clear
   * @since 0.11
   */this.clear = function(){selection.selectAll();selection.empty();}; /**
   * @memberof Core#
   * @function alter
   * @param {String} action See grid.alter for possible values: `"insert_row"`, `"insert_col"`, `"remove_row"`, `"remove_col"`
   * @param {Number} index
   * @param {Number} amount
   * @param {String} [source] Source of hook runner
   * @param {Boolean} [keepEmptyRows] Flag for preventing deletion of empty rows
   * @description
   *
   * Insert new row(s) above the row at given `index`. If index is `null` or `undefined`, the new row will be
   * added after the current last row. Default `amount` equals 1.
   * ```js
   * var hot = new Handsontable(document.getElementById('example'));
   * hot.alter('insert_row', 10);
   * ```
   *
   * Insert new column(s) before the column at given `index`. If index is `null` or `undefined`, the new column
   * will be added after the current last column. Default `amount` equals 1
   * ```js
   * var hot = new Handsontable(document.getElementById('example'));
   * hot.alter('insert_col', 10);
   * ```
   *
   * Remove the row(s) at given `index`. Default `amount` equals 1
   * ```js
   * var hot = new Handsontable(document.getElementById('example'));
   * hot.alter('remove_row', 10);
   * ```
   *
   * Remove the column(s) at given `index`. Default `amount` equals 1
   * ```js
   * var hot = new Handsontable(document.getElementById('example'));
   * hot.alter('remove_col', 10);
   * ```
   */this.alter = function(action,index,amount,source,keepEmptyRows){grid.alter(action,index,amount,source,keepEmptyRows);}; /**
   * Returns TD element for given `row`, `col` if it is rendered on screen.
   * Returns `null` if the TD is not rendered on screen (probably because that part of table is not visible).
   *
   * @memberof Core#
   * @function getCell
   * @param {Number} row
   * @param {Number} col
   * @param {Boolean} topmost
   * @returns {Element}
   */this.getCell = function(row,col,topmost){return instance.view.getCellAtCoords(new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(row,col),topmost);}; /**
   * Returns coordinates for the provided element.
   *
   * @memberof Core#
   * @function getCoords
   * @param {Element} elem
   * @returns {WalkontableCellCoords}
   */this.getCoords = function(elem){return this.view.wt.wtTable.getCoords.call(this.view.wt.wtTable,elem);}; /**
   * Returns property name that corresponds with the given column index. {@link DataMap#colToProp}
   *
   * @memberof Core#
   * @function colToProp
   * @param {Number} col Column index
   * @returns {String}
   */this.colToProp = function(col){return datamap.colToProp(col);}; /**
   * Returns column index that corresponds with the given property. {@link DataMap#propToCol}
   *
   * @memberof Core#
   * @function propToCol
   * @param {String} prop
   * @returns {Number}
   */this.propToCol = function(prop){return datamap.propToCol(prop);}; /**
   * @description
   * Return cell value at `row`, `col`. `row` and `col` are the __visible__ indexes (note that if columns were reordered or sorted,
   * the current order will be used).
   *
   * @memberof Core#
   * @function getDataAtCell
   * @param {Number} row
   * @param {Number} col
   * @returns {*}
   */this.getDataAtCell = function(row,col){return datamap.get(row,datamap.colToProp(col));}; /**
   * Return value at `row`, `prop`. {@link DataMap#get}
   *
   * @memberof Core#
   * @function getDataAtRowProp
   * @param {Number} row
   * @param {String} prop
   * @returns {*}
   */this.getDataAtRowProp = function(row,prop){return datamap.get(row,prop);}; /**
   * @description
   * Returns array of column values from the data source. `col` is the __visible__ index of the column.
   *
   * @memberof Core#
   * @function getDataAtCol
   * @since 0.9-beta2
   * @param {Number} col
   * @returns {Array}
   */this.getDataAtCol = function(col){var out=[];return out.concat.apply(out,datamap.getRange(new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(0,col),new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(priv.settings.data.length - 1,col),datamap.DESTINATION_RENDERER));}; /**
   * Given the object property name (e.g. `'first.name'`), returns array of column values from the data source.
   *
   * @memberof Core#
   * @function getDataAtProp
   * @since 0.9-beta2
   * @param {String} prop
   * @returns {*}
   */this.getDataAtProp = function(prop){var out=[],range;range = datamap.getRange(new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(0,datamap.propToCol(prop)),new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(priv.settings.data.length - 1,datamap.propToCol(prop)),datamap.DESTINATION_RENDERER);return out.concat.apply(out,range);}; /**
   * Returns array of column values from the data source. `col` is the index of the row in the data source.
   *
   * @memberof Core#
   * @function getSourceDataAtCol
   * @since 0.11.0-beta3
   * @param {Number} col
   * @returns {Array}
   */this.getSourceDataAtCol = function(col){var out=[],data=priv.settings.data;for(var i=0;i < data.length;i++) {out.push(data[i][col]);}return out;}; /**
   * Returns a single row of the data (array or object, depending on what you have). `row` is the index of the row in the data source.
   *
   * @memberof Core#
   * @function getSourceDataAtRow
   * @since 0.11.0-beta3
   * @param {Number} row
   * @returns {Array|Object}
   */this.getSourceDataAtRow = function(row){return priv.settings.data[row];}; /**
   * @description
   * Returns a single row of the data (array or object, depending on what you have). `row` is the __visible__ index of the row.
   *
   * @memberof Core#
   * @function getDataAtRow
   * @param {Number} row
   * @returns {*}
   * @since 0.9-beta2
   */this.getDataAtRow = function(row){var data=datamap.getRange(new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(row,0),new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(row,this.countCols() - 1),datamap.DESTINATION_RENDERER);return data[0];}; /**
   * Remove `key` property object from cell meta data corresponding to params `row`, `col`.
   *
   * @memberof Core#
   * @function removeCellMeta
   * @param {Number} row
   * @param {Number} col
   * @param {String} key
   */this.removeCellMeta = function(row,col,key){var cellMeta=instance.getCellMeta(row,col); /* jshint ignore:start */if(cellMeta[key] != undefined){delete priv.cellSettings[row][col][key];} /* jshint ignore:end */}; /**
   * Set cell meta data object `prop` to corresponding params `row`, `col`
   *
   * @memberof Core#
   * @function setCellMetaObject
   * @since 0.11
   * @param {Number} row
   * @param {Number} col
   * @param {Object} prop
   */this.setCellMetaObject = function(row,col,prop){if(typeof prop === 'object'){for(var key in prop) {if(prop.hasOwnProperty(key)){var value=prop[key];this.setCellMeta(row,col,key,value);}}}}; /**
   * Sets cell meta data object `key` corresponding to params `row`, `col`.
   *
   * @memberof Core#
   * @function setCellMeta
   * @since 0.11
   * @param {Number} row
   * @param {Number} col
   * @param {String} key
   * @param {String} val
   * @fires Hooks#afterSetCellMeta
   */this.setCellMeta = function(row,col,key,val){if(!priv.cellSettings[row]){priv.cellSettings[row] = [];}if(!priv.cellSettings[row][col]){priv.cellSettings[row][col] = new priv.columnSettings[col]();}priv.cellSettings[row][col][key] = val;Handsontable.hooks.run(instance,'afterSetCellMeta',row,col,key,val);}; /**
   * Return cell properties for given `row`, `col` coordinates.
   *
   * @memberof Core#
   * @function getCellMeta
   * @param {Number} row
   * @param {Number} col
   * @returns {Object}
   * @fires Hooks#beforeGetCellMeta
   * @fires Hooks#afterGetCellMeta
   */this.getCellMeta = function(row,col){var prop=datamap.colToProp(col),cellProperties;row = translateRowIndex(row);col = translateColIndex(col);if(!priv.columnSettings[col]){priv.columnSettings[col] = (0,_helpersSetting.columnFactory)(GridSettings,priv.columnsSettingConflicts);}if(!priv.cellSettings[row]){priv.cellSettings[row] = [];}if(!priv.cellSettings[row][col]){priv.cellSettings[row][col] = new priv.columnSettings[col]();}cellProperties = priv.cellSettings[row][col]; //retrieve cellProperties from cache
cellProperties.row = row;cellProperties.col = col;cellProperties.prop = prop;cellProperties.instance = instance;Handsontable.hooks.run(instance,'beforeGetCellMeta',row,col,cellProperties);(0,_helpersObject.extend)(cellProperties,expandType(cellProperties)); //for `type` added in beforeGetCellMeta
if(cellProperties.cells){var settings=cellProperties.cells.call(cellProperties,row,col,prop);if(settings){(0,_helpersObject.extend)(cellProperties,settings);(0,_helpersObject.extend)(cellProperties,expandType(settings)); //for `type` added in cells
}}Handsontable.hooks.run(instance,'afterGetCellMeta',row,col,cellProperties);return cellProperties;}; /**
   * Checks if the data format and config allows user to modify the column structure.
   * @returns {boolean}
   */this.isColumnModificationAllowed = function(){return !(instance.dataType === 'object' || instance.getSettings().columns);}; /**
   * If displayed rows order is different than the order of rows stored in memory (i.e. sorting is applied)
   * we need to translate logical (stored) row index to physical (displayed) index.
   *
   * @memberof Core#
   * @function translateRowIndex
   * @param {Number} row Original row index
   * @returns {Number} Translated row index
   * @fires Hooks#modifyRow
   */function translateRowIndex(row){return Handsontable.hooks.run(instance,'modifyRow',row);} /**
   * If displayed columns order is different than the order of columns stored in memory (i.e. column were moved using manualColumnMove plugin)
   * we need to translate logical (stored) column index to physical (displayed) index.
   *
   * @memberof Core#
   * @function translateColIndex
   * @param {Number} col Original column index
   * @returns {Number} Translated column index
   * @fires Hooks#modifyCol
   */function translateColIndex(col){ // warning: this must be done after datamap.colToProp
return Handsontable.hooks.run(instance,'modifyCol',col);}var rendererLookup=(0,_helpersData.cellMethodLookupFactory)('renderer'); /**
   * Get cell renderer type by `row` and `col`.
   *
   * @memberof Core#
   * @function getCellRenderer
   * @since 0.11
   * @param {Number} row
   * @param {Number} col
   * @returns {Function} Returns rederer type
   */this.getCellRenderer = function(row,col){var renderer=rendererLookup.call(this,row,col);return (0,_renderers.getRenderer)(renderer);}; /**
   * Get cell editor by `row` and `col`.
   *
   * @memberof Core#
   * @function getCellEditor
   * @returns {*}
   */this.getCellEditor = (0,_helpersData.cellMethodLookupFactory)('editor'); /**
   * Get cell validator by `row` and `col`
   *
   * @memberof Core#
   * @function getCellValidator
   * @returns {*}
   */this.getCellValidator = (0,_helpersData.cellMethodLookupFactory)('validator'); /**
   * Validates all cells using their validator functions and calls callback when finished. Does not render the view.
   *
   * If one of cells is invalid callback will be fired with `'valid'` arguments as `false` otherwise `true`.
   *
   * @memberof Core#
   * @function validateCells
   * @param {Function} callback
   */this.validateCells = function(callback){var waitingForValidator=new ValidatorsQueue();waitingForValidator.onQueueEmpty = callback; /* jshint ignore:start */var i=instance.countRows() - 1;while(i >= 0) {var j=instance.countCols() - 1;while(j >= 0) {waitingForValidator.addValidatorToQueue();instance.validateCell(instance.getDataAtCell(i,j),instance.getCellMeta(i,j),function(result){if(typeof result !== 'boolean'){throw new Error("Validation error: result is not boolean");}if(result === false){waitingForValidator.valid = false;}waitingForValidator.removeValidatorFormQueue();},'validateCells');j--;}i--;} /* jshint ignore:end */waitingForValidator.checkIfQueueIsEmpty();}; /**
   * Returns array of row headers (if they are enabled). If param `row` given, return header at given row as string.
   *
   * @memberof Core#
   * @function getRowHeader
   * @param {Number} [row]
   * @returns {Array|String}
   */this.getRowHeader = function(row){if(row === void 0){var out=[];for(var i=0,ilen=instance.countRows();i < ilen;i++) {out.push(instance.getRowHeader(i));}return out;}else if(Array.isArray(priv.settings.rowHeaders) && priv.settings.rowHeaders[row] !== void 0){return priv.settings.rowHeaders[row];}else if(typeof priv.settings.rowHeaders === 'function'){return priv.settings.rowHeaders(row);}else if(priv.settings.rowHeaders && typeof priv.settings.rowHeaders !== 'string' && typeof priv.settings.rowHeaders !== 'number'){return row + 1;}else {return priv.settings.rowHeaders;}}; /**
   * Returns information of this table is configured to display row headers.
   *
   * @memberof Core#
   * @function hasRowHeaders
   * @returns {Boolean}
   * @since 0.11
   */this.hasRowHeaders = function(){return !!priv.settings.rowHeaders;}; /**
   * Returns information of this table is configured to display column headers.
   *
   * @memberof Core#
   * @function hasColHeaders
   * @since 0.11
   * @returns {Boolean}
   */this.hasColHeaders = function(){if(priv.settings.colHeaders !== void 0 && priv.settings.colHeaders !== null){ //Polymer has empty value = null
return !!priv.settings.colHeaders;}for(var i=0,ilen=instance.countCols();i < ilen;i++) {if(instance.getColHeader(i)){return true;}}return false;}; /**
   * Return array of column headers (if they are enabled). If param `col` given, return header at given column as string
   *
   * @memberof Core#
   * @function getColHeader
   * @param {Number} [col] Column index
   * @returns {Array|String}
   */this.getColHeader = function(col){if(col === void 0){var out=[];for(var i=0,ilen=instance.countCols();i < ilen;i++) {out.push(instance.getColHeader(i));}return out;}else {var baseCol=col;col = Handsontable.hooks.run(instance,'modifyCol',col);if(priv.settings.columns && priv.settings.columns[col] && priv.settings.columns[col].title){return priv.settings.columns[col].title;}else if(Array.isArray(priv.settings.colHeaders) && priv.settings.colHeaders[col] !== void 0){return priv.settings.colHeaders[col];}else if(typeof priv.settings.colHeaders === 'function'){return priv.settings.colHeaders(col);}else if(priv.settings.colHeaders && typeof priv.settings.colHeaders !== 'string' && typeof priv.settings.colHeaders !== 'number'){return (0,_helpersData.spreadsheetColumnLabel)(baseCol); //see #1458
}else {return priv.settings.colHeaders;}}}; /**
   * Return column width from settings (no guessing). Private use intended.
   *
   * @private
   * @memberof Core#
   * @function _getColWidthFromSettings
   * @param {Number} col
   * @returns {Number}
   */this._getColWidthFromSettings = function(col){var cellProperties=instance.getCellMeta(0,col);var width=cellProperties.width;if(width === void 0 || width === priv.settings.width){width = cellProperties.colWidths;}if(width !== void 0 && width !== null){switch(typeof width){case 'object': // array
width = width[col];break;case 'function':width = width(col);break;}if(typeof width === 'string'){width = parseInt(width,10);}}return width;}; /**
   * Return column width
   *
   * @memberof Core#
   * @function getColWidth
   * @since 0.11
   * @param {Number} col
   * @returns {Number}
   * @fires Hooks#modifyColWidth
   */this.getColWidth = function(col){var width=instance._getColWidthFromSettings(col);width = Handsontable.hooks.run(instance,'modifyColWidth',width,col);if(width === void 0){width = _rdpartyWalkontableSrcCalculatorViewportColumns.WalkontableViewportColumnsCalculator.DEFAULT_WIDTH;}return width;}; /**
   * Return row height from settings (no guessing). Private use intended.
   *
   * @private
   * @memberof Core#
   * @function _getRowHeightFromSettings
   * @param {Number} row
   * @returns {Number}
   */this._getRowHeightFromSettings = function(row){ //let cellProperties = instance.getCellMeta(row, 0);
//let height = cellProperties.height;
//
//if (height === void 0 || height === priv.settings.height) {
//  height = cellProperties.rowHeights;
//}
var height=priv.settings.rowHeights;if(height !== void 0 && height !== null){switch(typeof height){case 'object': // array
height = height[row];break;case 'function':height = height(row);break;}if(typeof height === 'string'){height = parseInt(height,10);}}return height;}; /**
   * Return row height.
   *
   * @memberof Core#
   * @function getRowHeight
   * @since 0.11
   * @param {Number} row
   * @returns {Number}
   * @fires Hooks#modifyRowHeight
   */this.getRowHeight = function(row){var height=instance._getRowHeightFromSettings(row);height = Handsontable.hooks.run(instance,'modifyRowHeight',height,row);return height;}; /**
   * Returns total number of rows in the grid.
   *
   * @memberof Core#
   * @function countRows
   * @returns {Number} Total number in rows the grid
   */this.countRows = function(){return priv.settings.data.length;}; /**
   * Returns total number of columns in the grid.
   *
   * @memberof Core#
   * @function countCols
   * @returns {Number} Total number of columns
   */this.countCols = function(){if(instance.dataType === 'object' || instance.dataType === 'function'){if(priv.settings.columns && priv.settings.columns.length){return priv.settings.columns.length;}else {return datamap.colToPropCache.length;}}else if(instance.dataType === 'array'){if(priv.settings.columns && priv.settings.columns.length){return priv.settings.columns.length;}else if(priv.settings.data && priv.settings.data[0] && priv.settings.data[0].length){return priv.settings.data[0].length;}else {return 0;}}}; /**
   * Get index of first visible row.
   *
   * @memberof Core#
   * @function rowOffset
   * @returns {Number} Returns index of first visible row
   */this.rowOffset = function(){return instance.view.wt.wtTable.getFirstRenderedRow();}; /**
   * Get index of first visible column.
   *
   * @memberof Core#
   * @function colOffset
   * @returns {Number} Return index of first visible column.
   */this.colOffset = function(){return instance.view.wt.wtTable.getFirstRenderedColumn();}; /**
   * Return number of rendered rows (including rows partially or fully rendered outside viewport).
   *
   * @memberof Core#
   * @function countRenderedRows
   * @returns {Number} Returns -1 if table is not visible
   */this.countRenderedRows = function(){return instance.view.wt.drawn?instance.view.wt.wtTable.getRenderedRowsCount():-1;}; /**
   * Return number of visible rows (rendered rows that fully fit inside viewport).
   *
   * @memberof Core#
   * @function countVisibleRows
   * @returns {Number} Returns -1 if table is not visible
   */this.countVisibleRows = function(){return instance.view.wt.drawn?instance.view.wt.wtTable.getVisibleRowsCount():-1;}; /**
   * Return number of visible columns.
   *
   * @memberof Core#
   * @function countRenderedCols
   * @returns {Number} Returns -1 if table is not visible
   */this.countRenderedCols = function(){return instance.view.wt.drawn?instance.view.wt.wtTable.getRenderedColumnsCount():-1;}; /**
   * Return number of visible columns. Returns -1 if table is not visible
   *
   * @memberof Core#
   * @function countVisibleCols
   * @return {Number}
   */this.countVisibleCols = function(){return instance.view.wt.drawn?instance.view.wt.wtTable.getVisibleColumnsCount():-1;}; /**
   * Returns number of empty rows. If the optional ending parameter is `true`, returns
   * number of empty rows at the bottom of the table.
   *
   * @memberof Core#
   * @function countEmptyRows
   * @param {Boolean} [ending] If `true`, will only count empty rows at the end of the data source
   * @returns {Number} Count empty rows
   * @fires Hooks#modifyRow
   */this.countEmptyRows = function(ending){var i=instance.countRows() - 1,empty=0,row;while(i >= 0) {row = Handsontable.hooks.run(this,'modifyRow',i);if(instance.isEmptyRow(row)){empty++;}else if(ending){break;}i--;}return empty;}; /**
   * Returns number of empty columns. If the optional ending parameter is `true`, returns number of empty
   * columns at right hand edge of the table.
   *
   * @memberof Core#
   * @function countEmptyCols
   * @param {Boolean} [ending] If `true`, will only count empty columns at the end of the data source row
   * @returns {Number} Count empty cols
   */this.countEmptyCols = function(ending){if(instance.countRows() < 1){return 0;}var i=instance.countCols() - 1,empty=0;while(i >= 0) {if(instance.isEmptyCol(i)){empty++;}else if(ending){break;}i--;}return empty;}; /**
   * Check is `row` is empty.
   *
   * @memberof Core#
   * @function isEmptyRow
   * @param {Number} row Row index
   * @returns {Boolean} Return `true` if the row at the given `row` is empty, `false` otherwise.
   */this.isEmptyRow = function(row){return priv.settings.isEmptyRow.call(instance,row);}; /**
   * Check is `col` is empty.
   *
   * @memberof Core#
   * @function isEmptyCol
   * @param {Number} col Column index
   * @returns {Boolean} Return `true` if the column at the given `col` is empty, `false` otherwise.
   */this.isEmptyCol = function(col){return priv.settings.isEmptyCol.call(instance,col);}; /**
   * Select cell `row`, `col` or range of cells finishing at `endRow`, `endCol`.
   * By default, viewport will be scrolled to selection and after `selectCell` call instance will be listening
   * to keyboard input on document.
   *
   * @memberof Core#
   * @function selectCell
   * @param {Number} row
   * @param {Number} col
   * @param {Number} [endRow]
   * @param {Number} [endCol]
   * @param {Boolean} [scrollToCell=true] If `true`, viewport will be scrolled to the selection
   * @param {Boolean} [changeListener=true] If `false`, Handsontable will not change keyboard events listener to
   *                                        himself (default `true`)
   * @returns {Boolean}
   */this.selectCell = function(row,col,endRow,endCol,scrollToCell,changeListener){var coords;changeListener = typeof changeListener === 'undefined' || changeListener === true;if(typeof row !== 'number' || row < 0 || row >= instance.countRows()){return false;}if(typeof col !== 'number' || col < 0 || col >= instance.countCols()){return false;}if(typeof endRow !== 'undefined'){if(typeof endRow !== 'number' || endRow < 0 || endRow >= instance.countRows()){return false;}if(typeof endCol !== 'number' || endCol < 0 || endCol >= instance.countCols()){return false;}}coords = new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(row,col);priv.selRange = new _rdpartyWalkontableSrcCellRange.WalkontableCellRange(coords,coords,coords);if(document.activeElement && document.activeElement !== document.documentElement && document.activeElement !== document.body){ // needed or otherwise prepare won't focus the cell. selectionSpec tests this (should move focus to selected cell)
document.activeElement.blur();}if(changeListener){instance.listen();}if(typeof endRow === 'undefined'){selection.setRangeEnd(priv.selRange.from,scrollToCell);}else {selection.setRangeEnd(new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(endRow,endCol),scrollToCell);}instance.selection.finish();return true;}; /**
   * Select cell `row`, `prop` or range finishing at `endRow`, `endProp`. By default, viewport will be scrolled to selection.
   *
   * @memberof Core#
   * @function selectCellByProp
   * @param {Number} row
   * @param {Object} prop
   * @param {Number} [endRow]
   * @param {Object} [endProp]
   * @param {Boolean} [scrollToCell=true] If `true`, viewport will be scrolled to the selection
   * @returns {Boolean}
   */this.selectCellByProp = function(row,prop,endRow,endProp,scrollToCell){ /* jshint ignore:start */arguments[1] = datamap.propToCol(arguments[1]);if(typeof arguments[3] !== "undefined"){arguments[3] = datamap.propToCol(arguments[3]);}return instance.selectCell.apply(instance,arguments); /* jshint ignore:end */}; /**
   * Deselects current cell selection on grid.
   *
   * @memberof Core#
   * @function deselectCell
   */this.deselectCell = function(){selection.deselect();}; /**
   * Remove grid from DOM.
   *
   * @memberof Core#
   * @function destroy
   * @fires Hooks#afterDestroy
   */this.destroy = function(){instance._clearTimeouts();if(instance.view){ //in case HT is destroyed before initialization has finished
instance.view.destroy();}(0,_helpersDomElement.empty)(instance.rootElement);eventManager.destroy();Handsontable.hooks.run(instance,'afterDestroy');Handsontable.hooks.destroy(instance);for(var i in instance) {if(instance.hasOwnProperty(i)){ //replace instance methods with post mortem
if(typeof instance[i] === "function"){instance[i] = postMortem;} //replace instance properties with null (restores memory)
//it should not be necessary but this prevents a memory leak side effects that show itself in Jasmine tests
else if(i !== "guid"){instance[i] = null;}}} //replace private properties with null (restores memory)
//it should not be necessary but this prevents a memory leak side effects that show itself in Jasmine tests
priv = null;datamap = null;grid = null;selection = null;editorManager = null;instance = null;GridSettings = null;}; /**
   * Replacement for all methods after Handsotnable was destroyed.
   *
   * @private
   */function postMortem(){throw new Error("This method cannot be called because this Handsontable instance has been destroyed");} /**
   * Returns active editor object. {@link Handsontable.EditorManager#getActiveEditor}
   *
   * @memberof Core#
   * @function getActiveEditor
   * @returns {Object}
   */this.getActiveEditor = function(){return editorManager.getActiveEditor();}; /**
   * Returns plugin instance by plugin name
   *
   * @memberof Core#
   * @function getPlugin
   * @param {String} pluginName
   * @returns {*}
   * @since 0.15.0
   */this.getPlugin = function(pluginName){return (0,_plugins.getPlugin)(this,pluginName);}; /**
   * Return Handsontable instance.
   *
   * @memberof Core#
   * @function getInstance
   * @returns {Handsontable}
   */this.getInstance = function(){return instance;}; /**
   * Adds listener to specified hook name and only for this Handsontable instance.
   *
   * @memberof Core#
   * @function addHook
   * @see Hooks#add
   * @param {String} key Hook name
   * @param {Function|Array} callback Function or array of Functions
   *
   * @example
   * ```js
   * hot.addHook('beforeInit', myCallback);
   * ```
   */this.addHook = function(key,callback){Handsontable.hooks.add(key,callback,instance);}; /**
   * Adds listener to specified hook name and only for this Handsontable instance. After hook runs this
   * listener will be automatically removed.
   *
   * @memberof Core#
   * @function addHookOnce
   * @see Hooks#once
   * @param {String} key Hook name
   * @param {Function|Array} callback Function or array of Functions
   *
   * @example
   * ```js
   * hot.addHookOnce('beforeInit', myCallback);
   * ```
   */this.addHookOnce = function(key,callback){Handsontable.hooks.once(key,callback,instance);}; /**
   * Removes the hook listener previously registered with {@link Core#addHook}.
   *
   * @memberof Core#
   * @function removeHook
   * @see Hooks#remove
   * @param {String} key Hook name
   * @param {Function} callback Function which have been registered via {@link Core#addHook}
   *
   * @example
   * ```js
   * hot.removeHook('beforeInit', myCallback);
   * ```
   */this.removeHook = function(key,callback){Handsontable.hooks.remove(key,callback,instance);}; /**
   * @memberof Core#
   * @function runHooks
   * @see Hooks#run
   * @param {String} key Hook name
   * @param {*} [p1]
   * @param {*} [p2]
   * @param {*} [p3]
   * @param {*} [p4]
   * @param {*} [p5]
   * @param {*} [p6]
   * @returns {*}
   *
   * @example
   * ```js
   * hot.runHooks('beforeInit');
   * ```
   */this.runHooks = function(key,p1,p2,p3,p4,p5,p6){return Handsontable.hooks.run(instance,key,p1,p2,p3,p4,p5,p6);};this.timeouts = []; /**
   * Sets timeout. Purpose of this method is to clear all known timeouts when `destroy` method is called.
   *
   * @param {*} handle
   * @private
   */this._registerTimeout = function(handle){this.timeouts.push(handle);}; /**
   * Clears all known timeouts.
   *
   * @private
   */this._clearTimeouts = function(){for(var i=0,ilen=this.timeouts.length;i < ilen;i++) {clearTimeout(this.timeouts[i]);}}; /**
   * Handsontable version
   *
   * @type {String}
   */this.version = Handsontable.version;Handsontable.hooks.run(instance,'construct');}; /**
 * @alias Options
 * @constructor
 * @description

 * ## Constructor options
 *
 * Constructor options are applied using an object literal passed as a first argument to the Handsontable constructor.
 *
 * ```js
 * var hot = new Handsontable(document.getElementById('example1'), {
 *   data: myArray,
 *   width: 400,
 *   height: 300
 * })
 * ```
 *
 * ---
 * ## Cascading configuration
 *
 * Handsontable 0.9 and newer is using *Cascading Configuration*, which is fast way to provide configuration options
 * for whole table, its columns and particular cells.
 *
 * Consider the following example:
 * ```js
 * var hot = new Handsontable(document.getElementById('example'), {
 *   readOnly: true,
 *   columns: [
 *     {readOnly: false},
 *     {},
 *     {}
 *   ],
 *   cells: function (row, col, prop) {
 *     var cellProperties = {};
 *
 *     if (row === 0 && col === 0) {
 *       cellProperties.readOnly = true;
 *     }
 *
 *     return cellProperties;
 *   }
 * });
 * ```
 *
 * The above notation will result in all TDs being *read only*, except for first column TDs which will be *editable*, except for the TD in top left corner which will still be *read only*.
 *
 * ### The Cascading Configuration model
 *
 * ##### 1. Constructor
 *
 * Configuration options that are provided using first-level `handsontable(container, {option: "value"})` and `updateSettings` method.
 *
 * ##### 2. Columns
 *
 * Configuration options that are provided using second-level object `handsontable(container, {columns: {option: "value"}]})`
 *
 * ##### 3. Cells
 *
 * Configuration options that are provided using second-level function `handsontable(container, {cells: function: (row, col, prop){ }})`
 *
 * ---
 * ## Architecture performance
 *
 * The Cascading Configuration model is based on prototypical inheritance. It is much faster and memory efficient compared
 * to the previous model that used jQuery extend. See: [http://jsperf.com/extending-settings](http://jsperf.com/extending-settings).
 *
 * ---
 * __Important notice:__ In order for the data separation to work properly, make sure that each instance of Handsontable has a unique `id`.
 */var DefaultSettings=function DefaultSettings(){};DefaultSettings.prototype = { /**
   * @description
   * Initial data source that will be bound to the data grid __by reference__ (editing data grid alters the data source).
   * Can be Array of Array, Array of Objects or Function.
   *
   * See [Understanding binding as reference](http://handsontable.com/demo/understanding_reference.html).
   *
   * @type {Array|Function}
   * @default undefined
   */data:void 0, /**
   * @description
   * Defines the structure of a new row when data source is an object.
   * Default like the first data row Array or Object.
   *
   *  See [demo/datasources.html](http://handsontable.com/demo/datasources.html) for examples.
   *
   * @type {Object}
   * @default undefined
   */dataSchema:void 0, /**
   * Width of the grid. Can be a number or a function that returns a number.
   *
   * @type {Number|Function}
   * @default undefined
   */width:void 0, /**
   * Height of the grid. Can be a number or a function that returns a number.
   *
   * @type {Number|Function}
   * @default undefined
   */height:void 0, /**
   * @description
   * Initial number of rows.
   *
   * __Notice:__ This option only has effect in Handsontable constructor and only if `data` option is not provided
   *
   * @type {Number}
   * @default 5
   */startRows:5, /**
   * @description
   * Initial number of columns.
   *
   * __Notice:__ This option only has effect in Handsontable constructor and only if `data` option is not provided
   *
   * @type {Number}
   * @default 5
   */startCols:5, /**
   * Setting `true` or `false` will enable or disable the default row headers (1, 2, 3).
   * You can also define an array `['One', 'Two', 'Three', ...]` or a function to define the headers.
   * If a function is set the index of the row is passed as a parameter.
   *
   * @type {Boolean|Array|Function}
   * @default null
   * @example
   * ```js
   * ...
   * // as boolean
   * rowHeaders: true,
   * ...
   *
   * ...
   * // as array
   * rowHeaders: [1, 2, 3],
   * ...
   *
   * ...
   * // as function
   * rowHeaders: function(index) {
   *   return index + ': AB';
   * },
   * ...
   * ```
   */rowHeaders:null, /**
   * Setting `true` or `false` will enable or disable the default column headers (A, B, C).
   * You can also define an array `['One', 'Two', 'Three', ...]` or a function to define the headers.
   * If a function is set the index of the column is passed as a parameter.
   *
   * @type {Boolean|Array|Function}
   * @default null
   * @example
   * ```js
   * ...
   * // as boolean
   * colHeaders: true,
   * ...
   *
   * ...
   * // as array
   * colHeaders: ['A', 'B', 'C'],
   * ...
   *
   * ...
   * // as function
   * colHeaders: function(index) {
   *   return index + ': AB';
   * },
   * ...
   * ```
   */colHeaders:null, /**
   * Defines column widths in pixels. Accepts number, string (that will be converted to number),
   * array of numbers (if you want to define column width separately for each column) or a
   * function (if you want to set column width dynamically on each render).
   *
   * @type {Array|Function|Number|String}
   * @default undefined
   */colWidths:void 0, /**
   * @description
   * Defines the cell properties and data binding for certain columns.
   *
   * __Notice:__ Using this option sets a fixed number of columns (options `startCols`, `minCols`, `maxCols` will be ignored).
   *
   * See [demo/datasources.html](http://handsontable.com/demo/datasources.html) for examples.
   *
   * @type {Array}
   * @default undefined
   * @example
   * ```js
   * ...
   * var exampleContainer = document.getElementById('example');
   * var hot = new Handsontable(exampleContainer, {
   *   columns: [
   *     {
   *       // column options for the first column
   *       type: 'numeric',
   *       format: '0,0.00 $'
   *     },
   *     {
   *       // column options for the second column
   *       type: 'text',
   *       readOnly: true
   *     }
   *   ]
   * });
   * ...
   * ```
   */columns:void 0, /**
   * @description
   * Defines the cell properties for given `row`, `col`, `prop` coordinates.
   * Any constructor or column option may be overwritten for a particular cell (row/column combination), using `cell`
   * array passed to the Handsontable constructor. Or using `cells` function property to the Handsontable constructor.
   *
   * @type {Function}
   * @default undefined
   * @example
   * ```js
   * ...
   * var hot = new Handsontable(document.getElementById('example'), {
   *   cells: function (row, col, prop) {
   *     var cellProperties = {};
   *
   *     if (row === 0 && col === 0) {
   *       cellProperties.readOnly = true;
   *     }
   *
   *     return cellProperties;
   *   }
   * });
   * ...
   * ```
   */cells:void 0, /**
   * Any constructor or column option may be overwritten for a particular cell (row/column combination), using `cell`
   * array passed to the Handsontable constructor.
   *
   * @type {Array}
   * @default []
   * @example
   * ```js
   * ...
   * var hot = new Handsontable(document.getElementById('example'), {
   *   cell: [
   *     {row: 0, col: 0, readOnly: true}
   *   ]
   * });
   * ...
   * ```
   */cell:[], /**
   * @description
   * If `true`, enables {@link Comments} plugin, which enables applying cell comments through the context menu
   * (configurable with context menu keys commentsAddEdit, commentsRemove).
   *
   * To initialize Handsontable with predefined comments, provide cell coordinates and comment texts in form of an array.
   *
   * See [Comments](http://handsontable.com/demo/comments.html) demo for examples.
   *
   * @since 0.11.0
   * @type {Boolean|Array}
   * @default false
   * @example
   * ```js
   * ...
   * var hot = new Handsontable(document.getElementById('example'), {
   *   comments: [{row: 1, col: 1, comment: "Test comment"}]
   * });
   * ...
   * ```
   */comments:false, /**
   * @description
   * If `true`, enables Custom Borders plugin, which enables applying custom borders through the context menu (configurable with context menu key borders).
   *
   * To initialize Handsontable with predefined custom borders, provide cell coordinates and border styles in form of an array.
   *
   * See [Custom Borders](http://handsontable.com/demo/custom_borders.html) demo for examples.
   *
   * @since 0.11.0
   * @type {Boolean|Array}
   * @default false
   * @example
   * ```js
   * ...
   * var hot = new Handsontable(document.getElementById('example'), {
   *   customBorders: [
   *     {range: {
   *       from: {row: 1, col: 1},
   *       to: {row: 3, col: 4}},
   *       left: {},
   *       right: {},
   *       top: {},
   *       bottom: {}
   *     }
   *   ],
   * });
   * ...
   *
   * // or
   * ...
   * var hot = new Handsontable(document.getElementById('example'), {
   *   customBorders: [
   *     {row: 2, col: 2, left: {width: 2, color: 'red'},
   *       right: {width: 1, color: 'green'}, top: '', bottom: ''}
   *   ],
   * });
   * ...
   * ```
   */customBorders:false, /**
   * Minimum number of rows. At least that amount of rows will be created during initialization.
   *
   * @type {Number}
   * @default 0
   */minRows:0, /**
   * Minimum number of columns. At least that many of columns will be created during initialization.
   *
   * @type {Number}
   * @default 0
   */minCols:0, /**
   * Maximum number of rows.
   *
   * @type {Number}
   * @default Infinity
   */maxRows:Infinity, /**
   * Maximum number of cols.
   *
   * @type {Number}
   * @default Infinity
   */maxCols:Infinity, /**
   * When set to 1 (or more), Handsontable will add a new row at the end of grid if there are no more empty rows.
   *
   * @type {Number}
   * @default 0
   */minSpareRows:0, /**
   * When set to 1 (or more), Handsontable will add a new column at the end of grid if there are no more empty columns.
   *
   * @type {Number}
   * @default 0
   */minSpareCols:0, /**
   * @type {Boolean}
   * @default true
   */allowInsertRow:true, /**
   * @type {Boolean}
   * @default true
   */allowInsertColumn:true, /**
   * @type {Boolean}
   * @default true
   */allowRemoveRow:true, /**
   * @type {Boolean}
   * @default true
   */allowRemoveColumn:true, /**
   * If true, selection of multiple cells using keyboard or mouse is allowed.
   *
   * @type {Boolean}
   * @default true
   */multiSelect:true, /**
   * Enables the fill handle (drag-down and copy-down) functionality, which shows the small rectangle in bottom
   * right corner of the selected area, that let's you expand values to the adjacent cells.
   *
   * Possible values: `true` (to enable in all directions), `"vertical"` or `"horizontal"` (to enable in one direction),
   * `false` (to disable completely). Setting to `true` enables the fillHandle plugin.
   *
   * @type {Boolean|String}
   * @default true
   */fillHandle:true, /**
   * Allows to specify the number of rows fixed (aka freezed) on the top of the table.
   *
   * @type {Number}
   * @default 0
   */fixedRowsTop:0, /**
   * Allows to specify the number of columns fixed (aka freezed) on the left side of the table.
   *
   * @type {Number}
   * @default 0
   */fixedColumnsLeft:0, /**
   * If `true`, mouse click outside the grid will deselect the current selection.
   *
   * @type {Boolean}
   * @default true
   */outsideClickDeselects:true, /**
   * If `true`, <kbd>ENTER</kbd> begins editing mode (like Google Docs). If `false`, <kbd>ENTER</kbd> moves to next
   * row (like Excel) and adds new row if necessary. <kbd>TAB</kbd> adds new column if necessary.
   *
   * @type {Boolean}
   * @default true
   */enterBeginsEditing:true, /**
   * Defines cursor move after <kbd>ENTER</kbd> is pressed (<kbd>SHIFT</kbd> + <kbd>ENTER</kbd> uses negative vector).
   * Can be an object or a function that returns an object. The event argument passed to the function
   * is a DOM Event object received after a <kbd>ENTER</kbd> key has been pressed. This event object can be used to check
   * whether user pressed <kbd>ENTER</kbd> or <kbd>SHIFT</kbd> + <kbd>ENTER</kbd>.
   *
   * @type {Object|Function}
   * @default {row: 1, col: 0}
   */enterMoves:{row:1,col:0}, /**
   * Defines cursor move after <kbd>TAB</kbd> is pressed (<kbd>SHIFT</kbd> + <kbd>TAB</kbd> uses negative vector).
   * Can be an object or a function that returns an object. The event argument passed to the function
   * is a DOM Event object received after a <kbd>TAB</kbd> key has been pressed. This event object can be used to check
   * whether user pressed <kbd>TAB</kbd> or <kbd>SHIFT</kbd> + <kbd>TAB</kbd>.
   *
   * @type {Object}
   * @default {row: 0, col: 1}
   */tabMoves:{row:0,col:1}, /**
   * If `true`, pressing <kbd>TAB</kbd> or right arrow in the last column will move to first column in next row
   *
   * @type {Boolean}
   * @default false
   */autoWrapRow:false, /**
   * If `true`, pressing <kbd>ENTER</kbd> or down arrow in the last row will move to first row in next column
   *
   * @type {Boolean}
   * @default false
   */autoWrapCol:false, /**
   * Maximum number of rows than can be copied to clipboard using <kbd>CTRL</kbd> + <kbd>C</kbd>.
   *
   * @type {Number}
   * @default 1000
   */copyRowsLimit:1000, /**
   * Maximum number of columns than can be copied to clipboard using <kbd>CTRL</kbd> + <kbd>C</kbd>.
   *
   * @type {Number}
   * @default 1000
   */copyColsLimit:1000, /**
   * Defines paste (<kbd>CTRL</kbd> + <kbd>V</kbd>) behavior. Default value `"overwrite"` will paste clipboard value over current selection.
   * When set to `"shift_down"`, clipboard data will be pasted in place of current selection, while all selected cells are moved down.
   * When set to `"shift_right"`, clipboard data will be pasted in place of current selection, while all selected cells are moved right.
   *
   * @type {String}
   * @default 'overwrite'
   */pasteMode:'overwrite', /**
   * @description
   * Turn on saving the state of column sorting, columns positions and columns sizes in local storage.
   *
   * You can save any sort of data in local storage in to preserve table state between page reloads.
   * In order to enable data storage mechanism, `persistentState` option must be set to `true` (you can set it
   * either during Handsontable initialization or using the `updateSettings` method). When `persistentState` is enabled it exposes 3 hooks:
   *
   * __persistentStateSave__ (key: String, value: Mixed)
   *
   *   * Saves value under given key in browser local storage.
   *
   * __persistentStateLoad__ (key: String, valuePlaceholder: Object)
   *
   *   * Loads `value`, saved under given key, form browser local storage. The loaded `value` will be saved in `valuePlaceholder.value`
   *     (this is due to specific behaviour of `Hooks.run()` method). If no value have been saved under key `valuePlaceholder.value`
   *     will be `undefined`.
   *
   * __persistentStateReset__ (key: String)
   *
   *   * Clears the value saved under `key`. If no `key` is given, all values associated with table will be cleared.
   *
   * __Note:__ The main reason behind using `persistentState` hooks rather than regular LocalStorage API is that it
   * ensures separation of data stored by multiple Handsontable instances. In other words, if you have two (or more)
   * instances of Handsontable on one page, data saved by one instance won't be accessible by the second instance.
   * Those two instances can store data under the same key and no data would be overwritten.
   *
   * __Important:__ In order for the data separation to work properly, make sure that each instance of Handsontable has a unique `id`.
   *
   * @type {Boolean}
   * @default false
   */persistentState:false, /**
   * Class name for all visible rows in current selection.
   *
   * @type {String}
   * @default undefined
   */currentRowClassName:void 0, /**
   * Class name for all visible columns in current selection.
   *
   * @type {String}
   * @default undefined
   */currentColClassName:void 0, /**
   * Class name for all handsontable container element.
   *
   * @type {String|Array}
   * @default undefined
   */className:void 0, /**
   * Class name for all tables inside container element.
   *
   * @since 0.17.0
   * @type {String|Array}
   * @default undefined
   */tableClassName:void 0, /**
   * @description
   * [Column stretching](http://handsontable.com/demo/scroll.html) mode. Possible values: `"none"`, `"last"`, `"all"`.
   *
   * @type {String}
   * @default 'none'
   */stretchH:'none', /**
   * Lets you overwrite the default `isEmptyRow` method.
   *
   * @type {Function}
   * @param {Number} row
   * @returns {Boolean}
   */isEmptyRow:function isEmptyRow(row){var col,colLen,value,meta;for(col = 0,colLen = this.countCols();col < colLen;col++) {value = this.getDataAtCell(row,col);if(value !== '' && value !== null && typeof value !== 'undefined'){if(typeof value === 'object'){meta = this.getCellMeta(row,col);return (0,_helpersObject.isObjectEquals)(this.getSchema()[meta.prop],value);}return false;}}return true;}, /**
   * Lets you overwrite the default `isEmptyCol` method.
   *
   * @type {Function}
   * @param {Number} col
   * @returns {Boolean}
   */isEmptyCol:function isEmptyCol(col){var row,rowLen,value;for(row = 0,rowLen = this.countRows();row < rowLen;row++) {value = this.getDataAtCell(row,col);if(value !== '' && value !== null && typeof value !== 'undefined'){return false;}}return true;}, /**
   * When set to `true`, the table is rerendered when it is detected that it was made visible in DOM.
   *
   * @type {Boolean}
   * @default true
   */observeDOMVisibility:true, /**
   * If set to `true`, cells will accept value that is marked as invalid by cell `validator`, with a background color
   * automatically applied using CSS class `htInvalid`. If set to `false`, cells will not accept invalid value.
   *
   * @type {Boolean}
   * @default true
   * @since 0.9.5
   */allowInvalid:true, /**
   * CSS class name for cells that did not pass validation.
   *
   * @type {String}
   * @default 'htInvalid'
   */invalidCellClassName:'htInvalid', /**
   * When set to an non-empty string, displayed as the cell content for empty cells.
   *
   * @type {Boolean|String}
   * @default false
   */placeholder:false, /**
   * CSS class name for cells that have a placeholder in use.
   *
   * @type {String}
   * @default 'htPlaceholder'
   */placeholderCellClassName:'htPlaceholder', /**
   * CSS class name for read-only cells.
   *
   * @type {String}
   * @default 'htDimmed'
   */readOnlyCellClassName:'htDimmed', /**
   * String may be one of the following predefined values: `autocomplete`, `checkbox`, `text`, `numeric`. Function will
   * receive the following arguments: `function(instance, TD, row, col, prop, value, cellProperties) {}`.
   * You can map your own function to a string like this: `Handsontable.cellLookup.renderer.myRenderer = myRenderer;`
   *
   * @type {String|Function}
   * @default undefined
   */renderer:void 0, /**
   * @type {String}
   * @default 'htCommentCell'
   */commentedCellClassName:'htCommentCell', /**
   * Setting to `true` enables selecting just a fragment of the text within a single cell or between adjacent cells.
   *
   * @type {Boolean}
   * @default false
   */fragmentSelection:false, /**
   * @description
   * Make cell [read only](http://handsontable.com/demo/readonly.html).
   *
   * @type {Boolean}
   * @default false
   */readOnly:false, /**
   * @description
   * Setting to true enables the search plugin (see [demo](http://handsontable.com/demo/search.html)).
   *
   * @type {Boolean}
   * @default false
   */search:false, /**
   * @description
   * Shortcut to define combination of cell renderer and editor for the column.
   *
   * Possible values:
   *  * text
   *  * [numeric](http://handsontable.com/demo/numeric.html)
   *  * [date](http://handsontable.com/demo/date.html)
   *  * [checkbox](http://handsontable.com/demo/checkbox.html)
   *  * [autocomplete](http://handsontable.com/demo/autocomplete.html)
   *  * [handsontable](http://handsontable.com/demo/handsontable.html)
   *
   * @type {String}
   * @default 'text'
   */type:'text', /**
   * @description
   * Make cell copyable (pressing <kbd>CTRL</kbd> + <kbd>C</kbd> on your keyboard moves its value to system clipboard).
   *
   * __Note:__ this setting is `false` by default for cells with type `password`.
   *
   * @type {Boolean}
   * @default true
   * @since 0.10.2
   */copyable:true, /**
   * String, rendering function or boolean.
   *
   * String may be one of the following predefined values:
   *  * [autocomplete](http://handsontable.com/demo/autocomplete.html)
   *  * [checkbox](http://handsontable.com/demo/checkbox.html)
   *  * [date](http://handsontable.com/demo/date.html)
   *  * [dropdown](http://handsontable.com/demo/dropdown.html)
   *  * [handsontable](http://handsontable.com/demo/handsontable.html)
   *  * [mobile](http://docs.handsontable.com/demo-mobiles-and-tablets.html)
   *  * [password](http://handsontable.com/demo/password.html)
   *  * [select](http://handsontable.com/demo/selectEditor.html)
   *  * text
   *
   * Or you can disable cell editing passing `false`.
   *
   * @type {String|Function|Boolean}
   * @default 'text'
   */editor:void 0, /**
   * @description
   * Autocomplete definitions. See [demo/autocomplete.html](http://handsontable.com/demo/autocomplete.html) for examples and definitions.
   *
   * @type {Array}
   * @default undefined
   */autoComplete:void 0, /**
   * Control number of choices for autocomplete (or dropdown) cells. After exceeding it scrollbar for dropdown list of choices will be visible.
   *
   * @since 0.18.0
   * @type {Number}
   * @default 10
   */visibleRows:10, /**
   * Makes autocomplete or dropdown width the same as the edited cell width. If `false` then editor will be scaled
   * according to its content.
   *
   * @since 0.17.0
   * @type {Boolean}
   * @default true
   */trimDropdown:true, /**
   * Setting to true enables the debug mode, currently used to test the correctness of the row and column
   * header fixed positioning on a layer above the master table.
   *
   * @type {Boolean}
   * @default false
   */debug:false, /**
   * When set to `true`, the text of the cell content is wrapped if it does not fit in the fixed column width.
   *
   * @type {Boolean}
   * @default true
   * @since 0.11.0
   */wordWrap:true, /**
   * CSS class name added to cells with cell meta `wordWrap: false`.
   *
   * @type {String}
   * @default 'htNoWrap'
   * @since 0.11.0
   */noWordWrapClassName:'htNoWrap', /**
   * @description
   * Defines if the right-click context menu should be enabled. Context menu allows to create new row or
   * column at any place in the grid. Possible values: `true` (to enable basic options), `false` (to disable completely)
   * or array of any available strings: `["row_above", "row_below", "col_left", "col_right",
   * "remove_row", "remove_col", "undo", "redo", "sep1", "sep2", "sep3"]`.
   *
   * See [demo/contextmenu.html](http://handsontable.com/demo/contextmenu.html) for examples.
   *
   * @type {Boolean|Array|Object}
   * @default undefined
   */contextMenu:void 0, /**
   * @description
   * Defines if the dropdown menu in headers should be enabled. Dropdown menu allows to put custom or predefined actions
   * which can intreact with selected column.
   * Possible values: `true` (to enable basic options), `false` (to disable completely)
   * or array of any available strings: `["row_above", "row_below", "col_left", "col_right",
   * "remove_row", "remove_col", "undo", "redo", "clear_column", "sep1", "sep2", "sep3"]`.
   *
   * See [demo/dropdownmenu.html](http://handsontable.com/demo/dropdownmenu.html) for examples.
   *
   * @type {Boolean|Array|Object}
   * @default undefined
   */dropdownMenu:void 0, /**
   * If `true`, undo/redo functionality is enabled.
   *
   * @type {Boolean}
   * @default undefined
   */undo:void 0, /**
   * @description
   * Turn on [Column sorting](http://handsontable.com/demo/sorting.html).
   *
   * @type {Boolean|Object}
   * @default undefined
   */columnSorting:void 0, /**
   * @description
   * Turn on [Manual column move](http://docs.handsontable.com/demo-resizing.html), if set to a boolean or define initial
   * column order, if set to an array of column indexes.
   *
   * @type {Boolean|Array}
   * @default undefined
   */manualColumnMove:void 0, /**
   * @description
   * Turn on [Manual column resize](http://docs.handsontable.com/demo-resizing.html), if set to a boolean or define initial
   * column resized widths, if set to an array of numbers.
   *
   * @type {Boolean|Array}
   * @default undefined
   */manualColumnResize:void 0, /**
   * @description
   * Turn on [Manual row move](http://docs.handsontable.com/demo-resizing.html), if set to a boolean or define initial
   * row order, if set to an array of row indexes.
   *
   * @type {Boolean|Array}
   * @default undefined
   * @since 0.11.0
   */manualRowMove:void 0, /**
   * @description
   * Turn on [Manual row resize](http://docs.handsontable.com/demo-resizing.html), if set to a boolean or define initial
   * row resized heights, if set to an array of numbers.
   *
   * @type {Boolean|Array}
   * @default undefined
   * @since 0.11.0
   */manualRowResize:void 0, /**
   * @description
   * Setting to true or array enables the mergeCells plugin, which enables the merging of the cells. (see [demo](http://handsontable.com/demo/merge_cells.html)).
   * You can provide the merged cells on the pageload if you feed the mergeCells option with an array.
   *
   * @type {Boolean|Array}
   * @default false
   */mergeCells:false, /**
   * Number of rows to be prerendered before and after the viewport is changed. Default value is `'auto'` which means
   * that Handsontable tries to calculates offset for best performance.
   *
   * @type {Number|String}
   * @default 'auto'
   */viewportRowRenderingOffset:'auto', /**
   * Number of columns to be prerendered before and after the viewport is changed. Default value is `'auto'` which means
   * that Handsontable tries to calculates offset for best performance.
   *
   * @type {Number|String}
   * @default 'auto'
   */viewportColumnRenderingOffset:'auto', /**
   * @description
   * If `true`, enables Grouping plugin, which enables applying expandable row and column groups.
   * To initialize Handsontable with predefined groups, provide row or column group start and end coordinates in form of an array.
   *
   * See [Grouping](http://handsontable.com/demo/grouping.html) demo for examples.
   *
   * @type {Boolean|Array}
   * @default undefined
   * @since 0.11.4
   * @example
   * ```js
   * ...
   * // as boolean
   * groups: true,
   * ...
   *
   * ...
   * // as array
   * groups: [{cols: [0, 2]}, {cols: [5, 15], rows: [0, 5]}],
   * ...
   * ```
   */groups:void 0, /**
   * A usually small function or regular expression that validates the input.
   * After you determine if the input is valid, execute `callback(true)` or `callback(false)` to proceed with the execution.
   * In function, `this` binds to cellProperties.
   *
   * @type {Function|RegExp}
   * @default undefined
   * @since 0.9.5
   */validator:void 0, /**
   * @description
   * Disable visual cells selection.
   *
   * Possible values:
   *  * `true` - Disables any type of visual selection (current and area selection),
   *  * `false` - Enables any type of visual selection. This is default value.
   *  * `current` - Disables to appear only current selected cell.
   *  * `area` - Disables to appear only multiple selected cells.
   *
   * @type {Boolean|String|Array}
   * @default false
   * @since 0.13.2
   * @example
   * ```js
   * ...
   * // as boolean
   * disableVisualSelection: true,
   * ...
   *
   * ...
   * // as string ('current' or 'area')
   * disableVisualSelection: 'current',
   * ...
   *
   * ...
   * // as array
   * disableVisualSelection: ['current', 'area'],
   * ...
   * ```
   */disableVisualSelection:false, /**
   * @description
   * Set whether to display the current sorting indicator (a triangle icon in the column header, specifying the sorting order).
   *
   * @type {Boolean}
   * @default false
   * @since 0.15.0-beta3
   */sortIndicator:false,manualColumnFreeze:void 0, /**
   * @description
   * Defines whether Handsontable should trim the whitespace at the begging and the end of the cell contents
   *
   * @type {Boolean}
   * @default true
   */trimWhitespace:true,settings:void 0,source:void 0,title:void 0, /**
   * Data template for `'checkbox'` type when checkbox is checked.
   *
   * Option desired for cell which `'checkbox'` type.
   *
   * @type {Boolean|String}
   * @default true
   */checkedTemplate:void 0, /**
   * Data template for `'checkbox'` type when checkbox is unchecked.
   *
   * Option desired for cell which `'checkbox'` type.
   *
   * @type {Boolean|String}
   * @default false
   */uncheckedTemplate:void 0, /**
   * Display format. See http://numeric.com.
   *
   * Option desired for cell which `'numeric'` type.
   */format:void 0, /**
   * Language display format. See http://numeric.com.
   *
   * Option desired for cell which `'numeric'` type.
   *
   * @type {String}
   * @default 'en'
   */language:void 0, /**
   * Data source for cell with `'select'` type.
   *
   * @type {Array}
   */selectOptions:void 0, /**
   * Enables or disables autoColumnSize plugin. Default value is `undefined` which is the same effect as `true`.
   * Disable this plugin can increase performance.
   *
   * Column width calculations are divided into sync and async part. Each of this part has own advantages and
   * disadvantages. Synchronous counting is faster but it blocks browser UI and asynchronous is slower but it does not
   * block Browser UI.
   *
   * To configure this sync/async line you can pass absolute value (columns) or percentage.
   * @example
   * ```js
   * ...
   * // as number (300 columns in sync, rest async)
   * autoColumnSize: {syncLimit: 300},
   * ...
   *
   * ...
   * // as string (percent)
   * autoColumnSize: {syncLimit: '40%'},
   * ...
   * ```
   *
   * `syncLimit` options is available since 0.16.0.
   *
   * @type {Object|Boolean}
   * @default {syncLimit: 50}
   */autoColumnSize:void 0, /**
   * Enables or disables autoRowSize plugin. Default value is `undefined` which is the same effect as `true`.
   * Disable this plugin can increase performance.
   *
   * Row height calculations are divided into sync and async part. Each of this part has own advantages and
   * disadvantages. Synchronous counting is faster but it blocks browser UI and asynchronous is slower but it does not
   * block Browser UI.
   *
   * To configure this sync/async line you can pass absolute value (rows) or percentage.
   * @example
   * ```js
   * ...
   * // as number (300 columns in sync, rest async)
   * autoRowSize: {syncLimit: 300},
   * ...
   *
   * ...
   * // as string (percent)
   * autoRowSize: {syncLimit: '40%'},
   * ...
   * ```
   *
   * `syncLimit` options is available since 0.16.0.
   *
   * @type {Object|Boolean}
   * @default {syncLimit: 1000}
   */autoRowSize:void 0, /**
   * Date validation format.
   *
   * Option desired for cell which `'date'` type.
   *
   * @type {String}
   * @default 'DD/MM/YYYY'
   */dateFormat:void 0, /**
   * If `true` then dates will be automatically formatted to match the desired format.
   *
   * Option desired for cell which `'date'` type.
   *
   * @type {Boolean}
   * @default false
   */correctFormat:false, /**
   * Definition of default value which will fill empty cells.
   *
   * Option desired for cell which `'date'` type.
   *
   * @type {String}
   */defaultDate:void 0, /**
   * If typed `true` value entered into cell must match to the autocomplete source. Otherwise cell will be invalid.
   *
   * Option desired for cell which `'autocomplete'` type.
   *
   * @type {Boolean}
   */strict:void 0};Handsontable.DefaultSettings = DefaultSettings;

},{"./3rdparty/walkontable/src/calculator/viewportColumns":9,"./3rdparty/walkontable/src/cell/coords":11,"./3rdparty/walkontable/src/cell/range":12,"./3rdparty/walkontable/src/selection":24,"./dataMap":32,"./editorManager":33,"./eventManager":46,"./helpers/data":49,"./helpers/dom/element":50,"./helpers/object":55,"./helpers/setting":56,"./helpers/string":57,"./plugins":61,"./renderers":62,"./tableView":71,"numeral":5}],32:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _SheetClip = require('SheetClip');

var _SheetClip2 = _interopRequireDefault(_SheetClip);

var _helpersData = require('./helpers/data');

var _helpersSetting = require('./helpers/setting');

var _helpersObject = require('./helpers/object');

var _helpersArray = require('./helpers/array');

var _multiMap = require('./multiMap');

/**
 * Utility class that gets and saves data from/to the data source using mapping of columns numbers to object property names
 * @todo refactor arguments of methods getRange, getText to be numbers (not objects)
 * @todo remove priv, GridSettings from object constructor
 *
 * @param {Object} instance Instance of Handsontable
 * @param {*} priv
 * @param {*} GridSettings Grid settings
 * @util
 * @class DataMap
 * @dependencies SheetClip
 */
function DataMap(instance, priv, GridSettings) {
  this.instance = instance;
  this.priv = priv;
  this.GridSettings = GridSettings;
  this.dataSource = this.instance.getSettings().data;

  if (this.dataSource[0]) {
    this.duckSchema = this.recursiveDuckSchema(this.dataSource[0]);
  } else {
    this.duckSchema = {};
  }
  this.createMap();
}

DataMap.prototype.DESTINATION_RENDERER = 1;
DataMap.prototype.DESTINATION_CLIPBOARD_GENERATOR = 2;

/**
 * @param {Object|Array} object
 * @returns {Object|Array}
 */
DataMap.prototype.recursiveDuckSchema = function (object) {
  return (0, _helpersObject.duckSchema)(object);
};

/**
 * @param {Object} schema
 * @param {Number} lastCol
 * @param {Number} parent
 * @returns {Number}
 */
DataMap.prototype.recursiveDuckColumns = function (schema, lastCol, parent) {
  var prop, i;
  if (typeof lastCol === 'undefined') {
    lastCol = 0;
    parent = '';
  }
  if (typeof schema === "object" && !Array.isArray(schema)) {
    for (i in schema) {
      if (schema.hasOwnProperty(i)) {
        if (schema[i] === null) {
          prop = parent + i;
          this.colToPropCache.push(prop);
          this.propToColCache.set(prop, lastCol);

          lastCol++;
        } else {
          lastCol = this.recursiveDuckColumns(schema[i], lastCol, i + '.');
        }
      }
    }
  }
  return lastCol;
};

DataMap.prototype.createMap = function () {
  var i,
      ilen,
      schema = this.getSchema();
  if (typeof schema === "undefined") {
    throw new Error("trying to create `columns` definition but you didnt' provide `schema` nor `data`");
  }
  this.colToPropCache = [];
  this.propToColCache = new _multiMap.MultiMap();
  var columns = this.instance.getSettings().columns;
  if (columns) {
    for (i = 0, ilen = columns.length; i < ilen; i++) {

      if (typeof columns[i].data != 'undefined') {
        this.colToPropCache[i] = columns[i].data;
        this.propToColCache.set(columns[i].data, i);
      }
    }
  } else {
    this.recursiveDuckColumns(schema);
  }
};

/**
 * Returns property name that corresponds with the given column index.
 *
 * @param {Number} col
 * @returns {Number}
 */
DataMap.prototype.colToProp = function (col) {
  col = Handsontable.hooks.run(this.instance, 'modifyCol', col);

  if (this.colToPropCache && typeof this.colToPropCache[col] !== 'undefined') {
    return this.colToPropCache[col];
  }

  return col;
};

/**
 * @param {Object} prop
 * @fires Hooks#modifyCol
 * @returns {*}
 */
DataMap.prototype.propToCol = function (prop) {
  var col;

  if (typeof this.propToColCache.get(prop) !== 'undefined') {
    col = this.propToColCache.get(prop);
  } else {
    col = prop;
  }
  col = Handsontable.hooks.run(this.instance, 'modifyCol', col);

  return col;
};

/**
 * @returns {Object}
 */
DataMap.prototype.getSchema = function () {
  var schema = this.instance.getSettings().dataSchema;
  if (schema) {
    if (typeof schema === 'function') {
      return schema();
    }
    return schema;
  }

  return this.duckSchema;
};

/**
 * Creates row at the bottom of the data array.
 *
 * @param {Number} [index] Index of the row before which the new row will be inserted
 * @fires Hooks#afterCreateRow
 * @returns {Number} Returns number of created rows
 */
DataMap.prototype.createRow = function (index, amount, createdAutomatically) {
  var row,
      colCount = this.instance.countCols(),
      numberOfCreatedRows = 0,
      currentIndex;

  if (!amount) {
    amount = 1;
  }

  if (typeof index !== 'number' || index >= this.instance.countRows()) {
    index = this.instance.countRows();
  }

  currentIndex = index;
  var maxRows = this.instance.getSettings().maxRows;
  while (numberOfCreatedRows < amount && this.instance.countRows() < maxRows) {

    if (this.instance.dataType === 'array') {
      row = [];
      for (var c = 0; c < colCount; c++) {
        row.push(null);
      }
    } else if (this.instance.dataType === 'function') {
      row = this.instance.getSettings().dataSchema(index);
    } else {
      row = {};
      (0, _helpersObject.deepExtend)(row, this.getSchema());
    }

    if (index === this.instance.countRows()) {
      this.dataSource.push(row);
    } else {
      this.dataSource.splice(index, 0, row);
    }

    numberOfCreatedRows++;
    currentIndex++;
  }

  Handsontable.hooks.run(this.instance, 'afterCreateRow', index, numberOfCreatedRows, createdAutomatically);
  this.instance.forceFullRender = true; //used when data was changed

  return numberOfCreatedRows;
};

/**
 * Creates col at the right of the data array.
 *
 * @param {Number} [index] Index of the column before which the new column will be inserted
 * @param {Number} [amount]
 * @param {Number} [createdAutomatically]
 * @fires Hooks#afterCreateCol
 * @returns {Number} Returns number of created columns
 */
DataMap.prototype.createCol = function (index, amount, createdAutomatically) {
  if (!this.instance.isColumnModificationAllowed()) {
    throw new Error("Cannot create new column. When data source in an object, " + "you can only have as much columns as defined in first data row, data schema or in the 'columns' setting." + "If you want to be able to add new columns, you have to use array datasource.");
  }
  var rlen = this.instance.countRows(),
      data = this.dataSource,
      constructor,
      numberOfCreatedCols = 0,
      currentIndex;

  if (!amount) {
    amount = 1;
  }

  currentIndex = index;

  var maxCols = this.instance.getSettings().maxCols;
  while (numberOfCreatedCols < amount && this.instance.countCols() < maxCols) {
    constructor = (0, _helpersSetting.columnFactory)(this.GridSettings, this.priv.columnsSettingConflicts);
    if (typeof index !== 'number' || index >= this.instance.countCols()) {
      for (var r = 0; r < rlen; r++) {
        if (typeof data[r] === 'undefined') {
          data[r] = [];
        }
        data[r].push(null);
      }
      // Add new column constructor
      this.priv.columnSettings.push(constructor);
    } else {
      for (var r = 0; r < rlen; r++) {
        data[r].splice(currentIndex, 0, null);
      }
      // Add new column constructor at given index
      this.priv.columnSettings.splice(currentIndex, 0, constructor);
    }

    numberOfCreatedCols++;
    currentIndex++;
  }

  Handsontable.hooks.run(this.instance, 'afterCreateCol', index, numberOfCreatedCols, createdAutomatically);
  this.instance.forceFullRender = true; //used when data was changed

  return numberOfCreatedCols;
};

/**
 * Removes row from the data array.
 *
 * @param {Number} [index] Index of the row to be removed. If not provided, the last row will be removed
 * @param {Number} [amount] Amount of the rows to be removed. If not provided, one row will be removed
 * @fires Hooks#beforeRemoveRow
 * @fires Hooks#afterRemoveRow
 */
DataMap.prototype.removeRow = function (index, amount) {
  if (!amount) {
    amount = 1;
  }
  if (typeof index !== 'number') {
    index = -amount;
  }

  index = (this.instance.countRows() + index) % this.instance.countRows();

  // We have to map the physical row ids to logical and than perform removing with (possibly) new row id
  var logicRows = this.physicalRowsToLogical(index, amount);

  var actionWasNotCancelled = Handsontable.hooks.run(this.instance, 'beforeRemoveRow', index, amount);

  if (actionWasNotCancelled === false) {
    return;
  }

  var data = this.dataSource;
  var newData = data.filter(function (row, index) {
    return logicRows.indexOf(index) == -1;
  });

  data.length = 0;
  Array.prototype.push.apply(data, newData);

  Handsontable.hooks.run(this.instance, 'afterRemoveRow', index, amount);

  this.instance.forceFullRender = true; //used when data was changed
};

/**
 * Removes column from the data array.
 *
 * @param {Number} [index] Index of the column to be removed. If not provided, the last column will be removed
 * @param {Number} [amount] Amount of the columns to be removed. If not provided, one column will be removed
 * @fires Hooks#beforeRemoveCol
 * @fires Hooks#afterRemoveCol
 */
DataMap.prototype.removeCol = function (index, amount) {
  if (this.instance.dataType === 'object' || this.instance.getSettings().columns) {
    throw new Error("cannot remove column with object data source or columns option specified");
  }
  if (!amount) {
    amount = 1;
  }
  if (typeof index !== 'number') {
    index = -amount;
  }

  index = (this.instance.countCols() + index) % this.instance.countCols();

  var actionWasNotCancelled = Handsontable.hooks.run(this.instance, 'beforeRemoveCol', index, amount);

  if (actionWasNotCancelled === false) {
    return;
  }

  var data = this.dataSource;
  for (var r = 0, rlen = this.instance.countRows(); r < rlen; r++) {
    data[r].splice(index, amount);
  }
  this.priv.columnSettings.splice(index, amount);

  Handsontable.hooks.run(this.instance, 'afterRemoveCol', index, amount);
  this.instance.forceFullRender = true; //used when data was changed
};

/**
 * Add/Removes data from the column.
 *
 * @param {Number} col Index of column in which do you want to do splice
 * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end
 * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed
 * @returns {Array} Returns removed portion of columns
 */
DataMap.prototype.spliceCol = function (col, index, amount /*, elements...*/) {
  var elements = 4 <= arguments.length ? [].slice.call(arguments, 3) : [];

  var colData = this.instance.getDataAtCol(col);
  var removed = colData.slice(index, index + amount);
  var after = colData.slice(index + amount);

  (0, _helpersArray.extendArray)(elements, after);
  var i = 0;
  while (i < amount) {
    elements.push(null); //add null in place of removed elements
    i++;
  }
  (0, _helpersArray.to2dArray)(elements);
  this.instance.populateFromArray(index, col, elements, null, null, 'spliceCol');

  return removed;
};

/**
 * Add/Removes data from the row.
 *
 * @param {Number} row Index of row in which do you want to do splice
 * @param {Number} index Index at which to start changing the array. If negative, will begin that many elements from the end
 * @param {Number} amount An integer indicating the number of old array elements to remove. If amount is 0, no elements are removed
 * @returns {Array} Returns removed portion of rows
 */
DataMap.prototype.spliceRow = function (row, index, amount /*, elements...*/) {
  var elements = 4 <= arguments.length ? [].slice.call(arguments, 3) : [];

  var rowData = this.instance.getSourceDataAtRow(row);
  var removed = rowData.slice(index, index + amount);
  var after = rowData.slice(index + amount);

  (0, _helpersArray.extendArray)(elements, after);
  var i = 0;
  while (i < amount) {
    elements.push(null); //add null in place of removed elements
    i++;
  }
  this.instance.populateFromArray(row, index, [elements], null, null, 'spliceRow');

  return removed;
};

/**
 * Returns single value from the data array.
 *
 * @param {Number} row
 * @param {Number} prop
 */
DataMap.prototype.get = function (row, prop) {
  row = Handsontable.hooks.run(this.instance, 'modifyRow', row);

  if (typeof prop === 'string' && prop.indexOf('.') > -1) {
    var sliced = prop.split(".");
    var out = this.dataSource[row];
    if (!out) {
      return null;
    }
    for (var i = 0, ilen = sliced.length; i < ilen; i++) {
      out = out[sliced[i]];
      if (typeof out === 'undefined') {
        return null;
      }
    }
    return out;
  } else if (typeof prop === 'function') {
    /**
     *  allows for interacting with complex structures, for example
     *  d3/jQuery getter/setter properties:
     *
     *    {columns: [{
     *      data: function(row, value){
     *        if(arguments.length === 1){
     *          return row.property();
     *        }
     *        row.property(value);
     *      }
     *    }]}
     */
    return prop(this.dataSource.slice(row, row + 1)[0]);
  } else {
    return this.dataSource[row] ? this.dataSource[row][prop] : null;
  }
};

var copyableLookup = (0, _helpersData.cellMethodLookupFactory)('copyable', false);

/**
 * Returns single value from the data array (intended for clipboard copy to an external application).
 *
 * @param {Number} row
 * @param {Number} prop
 * @returns {String}
 */
DataMap.prototype.getCopyable = function (row, prop) {
  if (copyableLookup.call(this.instance, row, this.propToCol(prop))) {
    return this.get(row, prop);
  }
  return '';
};

/**
 * Saves single value to the data array.
 *
 * @param {Number} row
 * @param {Number} prop
 * @param {String} value
 * @param {String} [source] Source of hook runner.
 */
DataMap.prototype.set = function (row, prop, value, source) {
  row = Handsontable.hooks.run(this.instance, 'modifyRow', row, source || "datamapGet");

  if (typeof prop === 'string' && prop.indexOf('.') > -1) {
    var sliced = prop.split(".");
    var out = this.dataSource[row];
    for (var i = 0, ilen = sliced.length - 1; i < ilen; i++) {

      if (typeof out[sliced[i]] === 'undefined') {
        out[sliced[i]] = {};
      }
      out = out[sliced[i]];
    }
    out[sliced[i]] = value;
  } else if (typeof prop === 'function') {
    /* see the `function` handler in `get` */
    prop(this.dataSource.slice(row, row + 1)[0], value);
  } else {
    this.dataSource[row][prop] = value;
  }
};

/**
 * This ridiculous piece of code maps rows Id that are present in table data to those displayed for user.
 * The trick is, the physical row id (stored in settings.data) is not necessary the same
 * as the logical (displayed) row id (e.g. when sorting is applied).
 *
 * @param {Number} index
 * @param {Number} amount
 * @fires Hooks#modifyRow
 * @returns {Number}
 */
DataMap.prototype.physicalRowsToLogical = function (index, amount) {
  var totalRows = this.instance.countRows();
  var physicRow = (totalRows + index) % totalRows;
  var logicRows = [];
  var rowsToRemove = amount;
  var row;

  while (physicRow < totalRows && rowsToRemove) {
    row = Handsontable.hooks.run(this.instance, 'modifyRow', physicRow);
    logicRows.push(row);

    rowsToRemove--;
    physicRow++;
  }

  return logicRows;
};

/**
 * Clears the data array.
 */
DataMap.prototype.clear = function () {
  for (var r = 0; r < this.instance.countRows(); r++) {
    for (var c = 0; c < this.instance.countCols(); c++) {
      this.set(r, this.colToProp(c), '');
    }
  }
};

/**
 * Returns the data array.
 *
 * @returns {Array}
 */
DataMap.prototype.getAll = function () {
  return this.dataSource;
};

/**
 * Returns data range as array.
 *
 * @param {Object} [start] Start selection position
 * @param {Object} [end] End selection position
 * @param {Number} destination Destination of datamap.get
 * @returns {Array}
 */
DataMap.prototype.getRange = function (start, end, destination) {
  var r,
      rlen,
      c,
      clen,
      output = [],
      row;

  var getFn = destination === this.DESTINATION_CLIPBOARD_GENERATOR ? this.getCopyable : this.get;

  rlen = Math.max(start.row, end.row);
  clen = Math.max(start.col, end.col);

  for (r = Math.min(start.row, end.row); r <= rlen; r++) {
    row = [];
    for (c = Math.min(start.col, end.col); c <= clen; c++) {
      row.push(getFn.call(this, r, this.colToProp(c)));
    }
    output.push(row);
  }

  return output;
};

/**
 * Return data as text (tab separated columns).
 *
 * @param {Object} [start] Start selection position
 * @param {Object} [end] End selection position
 * @returns {String}
 */
DataMap.prototype.getText = function (start, end) {
  return _SheetClip2['default'].stringify(this.getRange(start, end, this.DESTINATION_RENDERER));
};

/**
 * Return data as copyable text (tab separated columns intended for clipboard copy to an external application).
 *
 * @param {Object} [start] Start selection position
 * @param {Object} [end] End selection position
 * @returns {String}
 */
DataMap.prototype.getCopyableText = function (start, end) {
  return _SheetClip2['default'].stringify(this.getRange(start, end, this.DESTINATION_CLIPBOARD_GENERATOR));
};

exports.DataMap = DataMap;

// Support for older hot versions
Handsontable.DataMap = DataMap;

},{"./helpers/array":47,"./helpers/data":49,"./helpers/object":55,"./helpers/setting":56,"./multiMap":59,"SheetClip":1}],33:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _rdpartyWalkontableSrcCellCoords = require('./3rdparty/walkontable/src/cell/coords');

var _helpersUnicode = require('./helpers/unicode');

var _helpersDomEvent = require('./helpers/dom/event');

var _editors = require('./editors');

var _eventManager = require('./eventManager');

exports.EditorManager = EditorManager;

// support for older versions of Handsontable
Handsontable.EditorManager = EditorManager;

function EditorManager(instance, priv, selection) {
  var _this = this,
      destroyed = false,
      eventManager,
      activeEditor;

  eventManager = (0, _eventManager.eventManager)(instance);

  function moveSelectionAfterEnter(shiftKey) {
    var enterMoves = typeof priv.settings.enterMoves === 'function' ? priv.settings.enterMoves(event) : priv.settings.enterMoves;

    if (shiftKey) {
      // move selection up
      selection.transformStart(-enterMoves.row, -enterMoves.col);
    } else {
      // move selection down (add a new row if needed)
      selection.transformStart(enterMoves.row, enterMoves.col, true);
    }
  }

  function moveSelectionUp(shiftKey) {
    if (shiftKey) {
      selection.transformEnd(-1, 0);
    } else {
      selection.transformStart(-1, 0);
    }
  }

  function moveSelectionDown(shiftKey) {
    if (shiftKey) {
      // expanding selection down with shift
      selection.transformEnd(1, 0);
    } else {
      // move selection down
      selection.transformStart(1, 0);
    }
  }

  function moveSelectionRight(shiftKey) {
    if (shiftKey) {
      selection.transformEnd(0, 1);
    } else {
      selection.transformStart(0, 1);
    }
  }

  function moveSelectionLeft(shiftKey) {
    if (shiftKey) {
      selection.transformEnd(0, -1);
    } else {
      selection.transformStart(0, -1);
    }
  }

  function onKeyDown(event) {
    var ctrlDown, rangeModifier;

    if (!instance.isListening()) {
      return;
    }
    Handsontable.hooks.run(instance, 'beforeKeyDown', event);

    if (destroyed) {
      return;
    }
    if ((0, _helpersDomEvent.isImmediatePropagationStopped)(event)) {
      return;
    }
    priv.lastKeyCode = event.keyCode;

    if (!selection.isSelected()) {
      return;
    }
    // catch CTRL but not right ALT (which in some systems triggers ALT+CTRL)
    ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;

    if (activeEditor && !activeEditor.isWaiting()) {
      if (!(0, _helpersUnicode.isMetaKey)(event.keyCode) && !(0, _helpersUnicode.isCtrlKey)(event.keyCode) && !ctrlDown && !_this.isEditorOpened()) {
        _this.openEditor("", event);

        return;
      }
    }
    rangeModifier = event.shiftKey ? selection.setRangeEnd : selection.setRangeStart;

    switch (event.keyCode) {

      case _helpersUnicode.KEY_CODES.A:
        if (!_this.isEditorOpened() && ctrlDown) {
          selection.selectAll();

          event.preventDefault();
          (0, _helpersDomEvent.stopPropagation)(event);
        }
        break;

      case _helpersUnicode.KEY_CODES.ARROW_UP:
        if (_this.isEditorOpened() && !activeEditor.isWaiting()) {
          _this.closeEditorAndSaveChanges(ctrlDown);
        }
        moveSelectionUp(event.shiftKey);

        event.preventDefault();
        (0, _helpersDomEvent.stopPropagation)(event);
        break;

      case _helpersUnicode.KEY_CODES.ARROW_DOWN:
        if (_this.isEditorOpened() && !activeEditor.isWaiting()) {
          _this.closeEditorAndSaveChanges(ctrlDown);
        }
        moveSelectionDown(event.shiftKey);

        event.preventDefault();
        (0, _helpersDomEvent.stopPropagation)(event);
        break;

      case _helpersUnicode.KEY_CODES.ARROW_RIGHT:
        if (_this.isEditorOpened() && !activeEditor.isWaiting()) {
          _this.closeEditorAndSaveChanges(ctrlDown);
        }
        moveSelectionRight(event.shiftKey);

        event.preventDefault();
        (0, _helpersDomEvent.stopPropagation)(event);
        break;

      case _helpersUnicode.KEY_CODES.ARROW_LEFT:
        if (_this.isEditorOpened() && !activeEditor.isWaiting()) {
          _this.closeEditorAndSaveChanges(ctrlDown);
        }
        moveSelectionLeft(event.shiftKey);

        event.preventDefault();
        (0, _helpersDomEvent.stopPropagation)(event);
        break;

      case _helpersUnicode.KEY_CODES.TAB:
        var tabMoves = typeof priv.settings.tabMoves === 'function' ? priv.settings.tabMoves(event) : priv.settings.tabMoves;

        if (event.shiftKey) {
          // move selection left
          selection.transformStart(-tabMoves.row, -tabMoves.col);
        } else {
          // move selection right (add a new column if needed)
          selection.transformStart(tabMoves.row, tabMoves.col, true);
        }
        event.preventDefault();
        (0, _helpersDomEvent.stopPropagation)(event);
        break;

      case _helpersUnicode.KEY_CODES.BACKSPACE:
      case _helpersUnicode.KEY_CODES.DELETE:
        selection.empty(event);
        _this.prepareEditor();
        event.preventDefault();
        break;

      case _helpersUnicode.KEY_CODES.F2:
        /* F2 */
        _this.openEditor(null, event);

        if (activeEditor) {
          activeEditor.enableFullEditMode();
        }
        event.preventDefault(); //prevent Opera from opening 'Go to Page dialog'
        break;

      case _helpersUnicode.KEY_CODES.ENTER:
        /* return/enter */
        if (_this.isEditorOpened()) {

          if (activeEditor && activeEditor.state !== Handsontable.EditorState.WAITING) {
            _this.closeEditorAndSaveChanges(ctrlDown);
          }
          moveSelectionAfterEnter(event.shiftKey);
        } else {
          if (instance.getSettings().enterBeginsEditing) {
            _this.openEditor(null, event);

            if (activeEditor) {
              activeEditor.enableFullEditMode();
            }
          } else {
            moveSelectionAfterEnter(event.shiftKey);
          }
        }
        event.preventDefault(); //don't add newline to field
        (0, _helpersDomEvent.stopImmediatePropagation)(event); //required by HandsontableEditor
        break;

      case _helpersUnicode.KEY_CODES.ESCAPE:
        if (_this.isEditorOpened()) {
          _this.closeEditorAndRestoreOriginalValue(ctrlDown);
        }
        event.preventDefault();
        break;

      case _helpersUnicode.KEY_CODES.HOME:
        if (event.ctrlKey || event.metaKey) {
          rangeModifier(new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(0, priv.selRange.from.col));
        } else {
          rangeModifier(new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(priv.selRange.from.row, 0));
        }
        event.preventDefault(); //don't scroll the window
        (0, _helpersDomEvent.stopPropagation)(event);
        break;

      case _helpersUnicode.KEY_CODES.END:
        if (event.ctrlKey || event.metaKey) {
          rangeModifier(new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(instance.countRows() - 1, priv.selRange.from.col));
        } else {
          rangeModifier(new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(priv.selRange.from.row, instance.countCols() - 1));
        }
        event.preventDefault(); //don't scroll the window
        (0, _helpersDomEvent.stopPropagation)(event);
        break;

      case _helpersUnicode.KEY_CODES.PAGE_UP:
        selection.transformStart(-instance.countVisibleRows(), 0);
        event.preventDefault(); //don't page up the window
        (0, _helpersDomEvent.stopPropagation)(event);
        break;

      case _helpersUnicode.KEY_CODES.PAGE_DOWN:
        selection.transformStart(instance.countVisibleRows(), 0);
        event.preventDefault(); //don't page down the window
        (0, _helpersDomEvent.stopPropagation)(event);
        break;
    }
  }

  function init() {
    instance.addHook('afterDocumentKeyDown', onKeyDown);

    eventManager.addEventListener(document.documentElement, 'keydown', function (event) {
      instance.runHooks('afterDocumentKeyDown', event);
    });

    function onDblClick(event, coords, elem) {
      // may be TD or TH
      if (elem.nodeName == "TD") {
        _this.openEditor();

        if (activeEditor) {
          activeEditor.enableFullEditMode();
        }
      }
    }
    instance.view.wt.update('onCellDblClick', onDblClick);

    instance.addHook('afterDestroy', function () {
      destroyed = true;
    });
  }

  /**
   * Destroy current editor, if exists.
   *
   * @function destroyEditor
   * @memberof! Handsontable.EditorManager#
   * @param {Boolean} revertOriginal
   */
  this.destroyEditor = function (revertOriginal) {
    this.closeEditor(revertOriginal);
  };

  /**
   * Get active editor.
   *
   * @function getActiveEditor
   * @memberof! Handsontable.EditorManager#
   * @returns {*}
   */
  this.getActiveEditor = function () {
    return activeEditor;
  };

  /**
   * Prepare text input to be displayed at given grid cell.
   *
   * @function prepareEditor
   * @memberof! Handsontable.EditorManager#
   */
  this.prepareEditor = function () {
    var row, col, prop, td, originalValue, cellProperties, editorClass;

    if (activeEditor && activeEditor.isWaiting()) {
      this.closeEditor(false, false, function (dataSaved) {
        if (dataSaved) {
          _this.prepareEditor();
        }
      });

      return;
    }
    row = priv.selRange.highlight.row;
    col = priv.selRange.highlight.col;
    prop = instance.colToProp(col);
    td = instance.getCell(row, col);
    originalValue = instance.getDataAtCell(row, col);
    cellProperties = instance.getCellMeta(row, col);
    editorClass = instance.getCellEditor(cellProperties);

    if (editorClass) {
      activeEditor = Handsontable.editors.getEditor(editorClass, instance);
      activeEditor.prepare(row, col, prop, td, originalValue, cellProperties);
    } else {
      activeEditor = void 0;
    }
  };

  /**
   * Check is editor is opened/showed.
   *
   * @function isEditorOpened
   * @memberof! Handsontable.EditorManager#
   * @returns {Boolean}
   */
  this.isEditorOpened = function () {
    return activeEditor && activeEditor.isOpened();
  };

  /**
   * Open editor with initial value.
   *
   * @function openEditor
   * @memberof! Handsontable.EditorManager#
   * @param {String} initialValue
   * @param {DOMEvent} event
   */
  this.openEditor = function (initialValue, event) {
    if (activeEditor && !activeEditor.cellProperties.readOnly) {
      activeEditor.beginEditing(initialValue, event);
    } else if (activeEditor && activeEditor.cellProperties.readOnly) {

      // move the selection after opening the editor with ENTER key
      if (event && event.keyCode === _helpersUnicode.KEY_CODES.ENTER) {
        moveSelectionAfterEnter();
      }
    }
  };

  /**
   * Close editor, finish editing cell.
   *
   * @function closeEditor
   * @memberof! Handsontable.EditorManager#
   * @param {Boolean} restoreOriginalValue
   * @param {Boolean} [ctrlDown]
   * @param {Function} [callback]
   */
  this.closeEditor = function (restoreOriginalValue, ctrlDown, callback) {
    if (!activeEditor) {
      if (callback) {
        callback(false);
      }
    } else {
      activeEditor.finishEditing(restoreOriginalValue, ctrlDown, callback);
    }
  };

  /**
   * Close editor and save changes.
   *
   * @function closeEditorAndSaveChanges
   * @memberof! Handsontable.EditorManager#
   * @param {Boolean} ctrlDown
   */
  this.closeEditorAndSaveChanges = function (ctrlDown) {
    return this.closeEditor(false, ctrlDown);
  };

  /**
   * Close editor and restore original value.
   *
   * @function closeEditorAndRestoreOriginalValue
   * @memberof! Handsontable.EditorManager#
   * @param {Boolean} ctrlDown
   */
  this.closeEditorAndRestoreOriginalValue = function (ctrlDown) {
    return this.closeEditor(true, ctrlDown);
  };

  init();
}

},{"./3rdparty/walkontable/src/cell/coords":11,"./editors":34,"./eventManager":46,"./helpers/dom/event":51,"./helpers/unicode":58}],34:[function(require,module,exports){
/**
 * Utility to register editors and common namespace for keeping reference to all editor classes
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _helpersString = require('./helpers/string');

exports.registerEditor = registerEditor;
exports.getEditor = getEditor;
exports.hasEditor = hasEditor;
exports.getEditorConstructor = getEditorConstructor;

var registeredEditorNames = {},
    registeredEditorClasses = new WeakMap();

// support for older versions of Handsontable
Handsontable.editors = Handsontable.editors || {};
Handsontable.editors.registerEditor = registerEditor;
Handsontable.editors.getEditor = getEditor;

function RegisteredEditor(editorClass) {
  var Clazz, instances;

  instances = {};
  Clazz = editorClass;

  this.getConstructor = function () {
    return editorClass;
  };

  this.getInstance = function (hotInstance) {
    if (!(hotInstance.guid in instances)) {
      instances[hotInstance.guid] = new Clazz(hotInstance);
    }

    return instances[hotInstance.guid];
  };
}

/**
 * Registers editor under given name
 * @param {String} editorName
 * @param {Function} editorClass
 */
function registerEditor(editorName, editorClass) {
  var editor = new RegisteredEditor(editorClass);

  if (typeof editorName === 'string') {
    registeredEditorNames[editorName] = editor;
    Handsontable.editors[(0, _helpersString.toUpperCaseFirst)(editorName) + 'Editor'] = editorClass;
  }
  registeredEditorClasses.set(editorClass, editor);
}

/**
 * Returns instance (singleton) of editor class
 *
 * @param {String} editorName
 * @param {Object} hotInstance
 * @returns {Function} editorClass
 */
function getEditor(editorName, hotInstance) {
  var editor;

  if (typeof editorName == 'function') {
    if (!registeredEditorClasses.get(editorName)) {
      registerEditor(null, editorName);
    }
    editor = registeredEditorClasses.get(editorName);
  } else if (typeof editorName == 'string') {
    editor = registeredEditorNames[editorName];
  } else {
    throw Error('Only strings and functions can be passed as "editor" parameter ');
  }

  if (!editor) {
    throw Error('No editor registered under name "' + editorName + '"');
  }

  return editor.getInstance(hotInstance);
}

/**
 * Get editor constructor class
 *
 * @param {String} editorName
 * @returns {Function}
 */
function getEditorConstructor(editorName) {
  var editor;

  if (typeof editorName == 'string') {
    editor = registeredEditorNames[editorName];
  } else {
    throw Error('Only strings and functions can be passed as "editor" parameter ');
  }

  if (!editor) {
    throw Error('No editor registered under name "' + editorName + '"');
  }

  return editor.getConstructor();
}

/**
 * @param editorName
 * @returns {Boolean}
 */
function hasEditor(editorName) {
  return registeredEditorNames[editorName] ? true : false;
}

},{"./helpers/string":57}],35:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _helpersMixed = require('./../helpers/mixed');

var _rdpartyWalkontableSrcCellCoords = require('./../3rdparty/walkontable/src/cell/coords');

exports.BaseEditor = BaseEditor;

Handsontable.editors = Handsontable.editors || {};
Handsontable.editors.BaseEditor = BaseEditor;

Handsontable.EditorState = {
  VIRGIN: 'STATE_VIRGIN', //before editing
  EDITING: 'STATE_EDITING',
  WAITING: 'STATE_WAITING', //waiting for async validation
  FINISHED: 'STATE_FINISHED'
};

function BaseEditor(instance) {
  this.instance = instance;
  this.state = Handsontable.EditorState.VIRGIN;

  this._opened = false;
  this._fullEditMode = false;
  this._closeCallback = null;

  this.init();
}

BaseEditor.prototype._fireCallbacks = function (result) {
  if (this._closeCallback) {
    this._closeCallback(result);
    this._closeCallback = null;
  }
};

BaseEditor.prototype.init = function () {};

BaseEditor.prototype.getValue = function () {
  throw Error('Editor getValue() method unimplemented');
};

BaseEditor.prototype.setValue = function (newValue) {
  throw Error('Editor setValue() method unimplemented');
};

BaseEditor.prototype.open = function () {
  throw Error('Editor open() method unimplemented');
};

BaseEditor.prototype.close = function () {
  throw Error('Editor close() method unimplemented');
};

BaseEditor.prototype.prepare = function (row, col, prop, td, originalValue, cellProperties) {
  this.TD = td;
  this.row = row;
  this.col = col;
  this.prop = prop;
  this.originalValue = originalValue;
  this.cellProperties = cellProperties;

  this.state = Handsontable.EditorState.VIRGIN;
};

BaseEditor.prototype.extend = function () {
  var baseClass = this.constructor;

  function Editor() {
    baseClass.apply(this, arguments);
  }

  function inherit(Child, Parent) {
    function Bridge() {}
    Bridge.prototype = Parent.prototype;
    Child.prototype = new Bridge();
    Child.prototype.constructor = Child;

    return Child;
  }

  return inherit(Editor, baseClass);
};

BaseEditor.prototype.saveValue = function (val, ctrlDown) {
  var sel, tmp;

  // if ctrl+enter and multiple cells selected, behave like Excel (finish editing and apply to all cells)
  if (ctrlDown) {
    sel = this.instance.getSelected();

    if (sel[0] > sel[2]) {
      tmp = sel[0];
      sel[0] = sel[2];
      sel[2] = tmp;
    }
    if (sel[1] > sel[3]) {
      tmp = sel[1];
      sel[1] = sel[3];
      sel[3] = tmp;
    }

    this.instance.populateFromArray(sel[0], sel[1], val, sel[2], sel[3], 'edit');
  } else {
    this.instance.populateFromArray(this.row, this.col, val, null, null, 'edit');
  }
};

BaseEditor.prototype.beginEditing = function (initialValue, event) {
  if (this.state != Handsontable.EditorState.VIRGIN) {
    return;
  }
  this.instance.view.scrollViewport(new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(this.row, this.col));
  this.instance.view.render();
  this.state = Handsontable.EditorState.EDITING;

  initialValue = typeof initialValue == 'string' ? initialValue : this.originalValue;
  this.setValue((0, _helpersMixed.stringify)(initialValue));

  this.open(event);
  this._opened = true;
  this.focus();

  // only rerender the selections (FillHandle should disappear when beginediting is triggered)
  this.instance.view.render();
};

BaseEditor.prototype.finishEditing = function (restoreOriginalValue, ctrlDown, callback) {
  var _this = this,
      val;

  if (callback) {
    var previousCloseCallback = this._closeCallback;

    this._closeCallback = function (result) {
      if (previousCloseCallback) {
        previousCloseCallback(result);
      }
      callback(result);
    };
  }

  if (this.isWaiting()) {
    return;
  }

  if (this.state == Handsontable.EditorState.VIRGIN) {
    this.instance._registerTimeout(setTimeout(function () {
      _this._fireCallbacks(true);
    }, 0));

    return;
  }

  if (this.state == Handsontable.EditorState.EDITING) {
    if (restoreOriginalValue) {
      this.cancelChanges();
      this.instance.view.render();

      return;
    }

    if (this.instance.getSettings().trimWhitespace) {
      // String.prototype.trim is defined in Walkontable polyfill.js
      val = [
      // We trim only string values
      [typeof this.getValue() === 'string' ? String.prototype.trim.call(this.getValue() || '') : this.getValue()]];
    } else {
      val = [[this.getValue()]];
    }

    this.state = Handsontable.EditorState.WAITING;
    this.saveValue(val, ctrlDown);

    if (this.instance.getCellValidator(this.cellProperties)) {
      this.instance.addHookOnce('postAfterValidate', function (result) {
        _this.state = Handsontable.EditorState.FINISHED;
        _this.discardEditor(result);
      });
    } else {
      this.state = Handsontable.EditorState.FINISHED;
      this.discardEditor(true);
    }
  }
};

BaseEditor.prototype.cancelChanges = function () {
  this.state = Handsontable.EditorState.FINISHED;
  this.discardEditor();
};

BaseEditor.prototype.discardEditor = function (result) {
  if (this.state !== Handsontable.EditorState.FINISHED) {
    return;
  }
  // validator was defined and failed
  if (result === false && this.cellProperties.allowInvalid !== true) {
    this.instance.selectCell(this.row, this.col);
    this.focus();
    this.state = Handsontable.EditorState.EDITING;
    this._fireCallbacks(false);
  } else {
    this.close();
    this._opened = false;
    this._fullEditMode = false;
    this.state = Handsontable.EditorState.VIRGIN;
    this._fireCallbacks(true);
  }
};

/**
 * Switch editor into full edit mode. In this state navigation keys don't close editor. This mode is activated
 * automatically after hit ENTER or F2 key on the cell or while editing cell press F2 key.
 */
BaseEditor.prototype.enableFullEditMode = function () {
  this._fullEditMode = true;
};

/**
 * Checks if editor is in full edit mode.
 *
 * @returns {Boolean}
 */
BaseEditor.prototype.isInFullEditMode = function () {
  return this._fullEditMode;
};

BaseEditor.prototype.isOpened = function () {
  return this._opened;
};

BaseEditor.prototype.isWaiting = function () {
  return this.state === Handsontable.EditorState.WAITING;
};

},{"./../3rdparty/walkontable/src/cell/coords":11,"./../helpers/mixed":53}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _helpersUnicode = require('./../helpers/unicode');

var _helpersMixed = require('./../helpers/mixed');

var _helpersArray = require('./../helpers/array');

var _helpersDomElement = require('./../helpers/dom/element');

var _editors = require('./../editors');

var _handsontableEditor = require('./handsontableEditor');

var AutocompleteEditor = _handsontableEditor.HandsontableEditor.prototype.extend();

/**
 * @private
 * @editor AutocompleteEditor
 * @class AutocompleteEditor
 * @dependencies HandsontableEditor
 */
AutocompleteEditor.prototype.init = function () {
  _handsontableEditor.HandsontableEditor.prototype.init.apply(this, arguments);

  this.query = null;
  this.choices = [];
};

AutocompleteEditor.prototype.createElements = function () {
  _handsontableEditor.HandsontableEditor.prototype.createElements.apply(this, arguments);

  (0, _helpersDomElement.addClass)(this.htContainer, 'autocompleteEditor');
  (0, _helpersDomElement.addClass)(this.htContainer, window.navigator.platform.indexOf('Mac') !== -1 ? 'htMacScroll' : '');
};

var skipOne = false;
function onBeforeKeyDown(event) {
  skipOne = false;
  var editor = this.getActiveEditor();

  if ((0, _helpersUnicode.isPrintableChar)(event.keyCode) || event.keyCode === _helpersUnicode.KEY_CODES.BACKSPACE || event.keyCode === _helpersUnicode.KEY_CODES.DELETE || event.keyCode === _helpersUnicode.KEY_CODES.INSERT) {
    var timeOffset = 0;

    // on ctl+c / cmd+c don't update suggestion list
    if (event.keyCode === _helpersUnicode.KEY_CODES.C && (event.ctrlKey || event.metaKey)) {
      return;
    }
    if (!editor.isOpened()) {
      timeOffset += 10;
    }

    if (editor.htEditor) {
      editor.instance._registerTimeout(setTimeout(function () {
        editor.queryChoices(editor.TEXTAREA.value);
        skipOne = true;
      }, timeOffset));
    }
  }
}

AutocompleteEditor.prototype.prepare = function () {
  this.instance.addHook('beforeKeyDown', onBeforeKeyDown);
  _handsontableEditor.HandsontableEditor.prototype.prepare.apply(this, arguments);
};

AutocompleteEditor.prototype.open = function () {
  // Ugly fix for handsontable which grab window object for autocomplete scroll listener instead table element.
  this.TEXTAREA_PARENT.style.overflow = 'auto';
  _handsontableEditor.HandsontableEditor.prototype.open.apply(this, arguments);
  this.TEXTAREA_PARENT.style.overflow = '';

  var choicesListHot = this.htEditor.getInstance();
  var that = this;
  var trimDropdown = this.cellProperties.trimDropdown === void 0 ? true : this.cellProperties.trimDropdown;

  this.TEXTAREA.style.visibility = 'visible';
  this.focus();

  choicesListHot.updateSettings({
    colWidths: trimDropdown ? [(0, _helpersDomElement.outerWidth)(this.TEXTAREA) - 2] : void 0,
    width: trimDropdown ? (0, _helpersDomElement.outerWidth)(this.TEXTAREA) + (0, _helpersDomElement.getScrollbarWidth)() + 2 : void 0,
    afterRenderer: function afterRenderer(TD, row, col, prop, value) {
      var caseSensitive = this.getCellMeta(row, col).filteringCaseSensitive === true,
          indexOfMatch,
          match,
          value = (0, _helpersMixed.stringify)(value);

      if (value) {
        indexOfMatch = caseSensitive ? value.indexOf(this.query) : value.toLowerCase().indexOf(that.query.toLowerCase());

        if (indexOfMatch != -1) {
          match = value.substr(indexOfMatch, that.query.length);
          TD.innerHTML = value.replace(match, '<strong>' + match + '</strong>');
        }
      }
    },
    autoColumnSize: true,
    modifyColWidth: function modifyColWidth(width, col) {
      // workaround for <strong> text overlapping the dropdown, not really accurate
      var autoWidths = this.getPlugin('autoColumnSize').widths;

      if (autoWidths[col]) {
        width = autoWidths[col];
      }

      return trimDropdown ? width : width + 15;
    }
  });

  // Add additional space for autocomplete holder
  this.htEditor.view.wt.wtTable.holder.parentNode.style['padding-right'] = (0, _helpersDomElement.getScrollbarWidth)() + 2 + 'px';

  if (skipOne) {
    skipOne = false;
  }

  that.instance._registerTimeout(setTimeout(function () {
    that.queryChoices(that.TEXTAREA.value);
  }, 0));
};

AutocompleteEditor.prototype.close = function () {
  _handsontableEditor.HandsontableEditor.prototype.close.apply(this, arguments);
};
AutocompleteEditor.prototype.queryChoices = function (query) {
  this.query = query;

  if (typeof this.cellProperties.source == 'function') {
    var that = this;

    this.cellProperties.source(query, function (choices) {
      that.updateChoicesList(choices);
    });
  } else if (Array.isArray(this.cellProperties.source)) {

    var choices;

    if (!query || this.cellProperties.filter === false) {
      choices = this.cellProperties.source;
    } else {

      var filteringCaseSensitive = this.cellProperties.filteringCaseSensitive === true;
      var lowerCaseQuery = query.toLowerCase();

      choices = this.cellProperties.source.filter(function (choice) {

        if (filteringCaseSensitive) {
          return choice.indexOf(query) != -1;
        } else {
          return choice.toLowerCase().indexOf(lowerCaseQuery) != -1;
        }
      });
    }

    this.updateChoicesList(choices);
  } else {
    this.updateChoicesList([]);
  }
};

AutocompleteEditor.prototype.updateChoicesList = function (choices) {
  var pos = (0, _helpersDomElement.getCaretPosition)(this.TEXTAREA),
      endPos = (0, _helpersDomElement.getSelectionEndPosition)(this.TEXTAREA);

  var orderByRelevance = AutocompleteEditor.sortByRelevance(this.getValue(), choices, this.cellProperties.filteringCaseSensitive);
  var highlightIndex;

  /* jshint ignore:start */
  if (this.cellProperties.filter != false) {
    var sorted = [];
    for (var i = 0, choicesCount = orderByRelevance.length; i < choicesCount; i++) {
      sorted.push(choices[orderByRelevance[i]]);
    }
    highlightIndex = 0;
    choices = sorted;
  } else {
    highlightIndex = orderByRelevance[0];
  }
  /* jshint ignore:end */

  this.choices = choices;
  this.htEditor.loadData((0, _helpersArray.pivot)([choices]));

  this.updateDropdownHeight();

  if (this.cellProperties.strict === true) {
    this.highlightBestMatchingChoice(highlightIndex);
  }

  this.instance.listen();
  this.TEXTAREA.focus();
  (0, _helpersDomElement.setCaretPosition)(this.TEXTAREA, pos, pos != endPos ? endPos : void 0);
};

AutocompleteEditor.prototype.updateDropdownHeight = function () {
  var currentDropdownWidth = this.htEditor.getColWidth(0) + (0, _helpersDomElement.getScrollbarWidth)() + 2;
  var trimDropdown = this.cellProperties.trimDropdown === void 0 ? true : this.cellProperties.trimDropdown;

  this.htEditor.updateSettings({
    height: this.getDropdownHeight(),
    width: trimDropdown ? void 0 : currentDropdownWidth
  });

  this.htEditor.view.wt.wtTable.alignOverlaysWithTrimmingContainer();
};

AutocompleteEditor.prototype.finishEditing = function (restoreOriginalValue) {
  if (!restoreOriginalValue) {
    this.instance.removeHook('beforeKeyDown', onBeforeKeyDown);
  }
  _handsontableEditor.HandsontableEditor.prototype.finishEditing.apply(this, arguments);
};

AutocompleteEditor.prototype.highlightBestMatchingChoice = function (index) {
  if (typeof index === "number") {
    this.htEditor.selectCell(index, 0);
  } else {
    this.htEditor.deselectCell();
  }
};

/**
 * Filters and sorts by relevance
 * @param value
 * @param choices
 * @param caseSensitive
 * @returns {Array} array of indexes in original choices array
 */
AutocompleteEditor.sortByRelevance = function (value, choices, caseSensitive) {

  var choicesRelevance = [],
      currentItem,
      valueLength = value.length,
      valueIndex,
      charsLeft,
      result = [],
      i,
      choicesCount;

  if (valueLength === 0) {
    for (i = 0, choicesCount = choices.length; i < choicesCount; i++) {
      result.push(i);
    }
    return result;
  }

  for (i = 0, choicesCount = choices.length; i < choicesCount; i++) {
    currentItem = (0, _helpersMixed.stringify)(choices[i]);

    if (caseSensitive) {
      valueIndex = currentItem.indexOf(value);
    } else {
      valueIndex = currentItem.toLowerCase().indexOf(value.toLowerCase());
    }

    if (valueIndex == -1) {
      continue;
    }
    charsLeft = currentItem.length - valueIndex - valueLength;

    choicesRelevance.push({
      baseIndex: i,
      index: valueIndex,
      charsLeft: charsLeft,
      value: currentItem
    });
  }

  choicesRelevance.sort(function (a, b) {

    if (b.index === -1) {
      return -1;
    }
    if (a.index === -1) {
      return 1;
    }

    if (a.index < b.index) {
      return -1;
    } else if (b.index < a.index) {
      return 1;
    } else if (a.index === b.index) {
      if (a.charsLeft < b.charsLeft) {
        return -1;
      } else if (a.charsLeft > b.charsLeft) {
        return 1;
      } else {
        return 0;
      }
    }
  });

  for (i = 0, choicesCount = choicesRelevance.length; i < choicesCount; i++) {
    result.push(choicesRelevance[i].baseIndex);
  }

  return result;
};

AutocompleteEditor.prototype.getDropdownHeight = function () {
  var firstRowHeight = this.htEditor.getInstance().getRowHeight(0) || 23;
  var _visibleRows = this.cellProperties.visibleRows;

  return this.choices.length >= _visibleRows ? _visibleRows * firstRowHeight : this.choices.length * firstRowHeight + 8;
};

AutocompleteEditor.prototype.allowKeyEventPropagation = function (keyCode) {
  var selected = { row: this.htEditor.getSelectedRange() ? this.htEditor.getSelectedRange().from.row : -1 };
  var allowed = false;

  if (keyCode === _helpersUnicode.KEY_CODES.ARROW_DOWN && selected.row < this.htEditor.countRows() - 1) {
    allowed = true;
  }
  if (keyCode === _helpersUnicode.KEY_CODES.ARROW_UP && selected.row > -1) {
    allowed = true;
  }

  return allowed;
};

exports.AutocompleteEditor = AutocompleteEditor;

(0, _editors.registerEditor)('autocomplete', AutocompleteEditor);

},{"./../editors":34,"./../helpers/array":47,"./../helpers/dom/element":50,"./../helpers/mixed":53,"./../helpers/unicode":58,"./handsontableEditor":40}],37:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _editors = require('./../editors');

var _baseEditor = require('./_baseEditor');

var _helpersDomElement = require('./../helpers/dom/element');

/**
 * @private
 * @editor CheckboxEditor
 * @class CheckboxEditor
 */

var CheckboxEditor = (function (_BaseEditor) {
  _inherits(CheckboxEditor, _BaseEditor);

  function CheckboxEditor() {
    _classCallCheck(this, CheckboxEditor);

    _get(Object.getPrototypeOf(CheckboxEditor.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(CheckboxEditor, [{
    key: 'beginEditing',
    value: function beginEditing() {
      var checkbox = this.TD.querySelector('input[type="checkbox"]');

      if (!(0, _helpersDomElement.hasClass)(checkbox, 'htBadValue')) {
        checkbox.click();
      }
    }
  }, {
    key: 'finishEditing',
    value: function finishEditing() {}
  }, {
    key: 'init',
    value: function init() {}
  }, {
    key: 'open',
    value: function open() {}
  }, {
    key: 'close',
    value: function close() {}
  }, {
    key: 'getValue',
    value: function getValue() {}
  }, {
    key: 'setValue',
    value: function setValue() {}
  }, {
    key: 'focus',
    value: function focus() {}
  }]);

  return CheckboxEditor;
})(_baseEditor.BaseEditor);

exports.CheckboxEditor = CheckboxEditor;

(0, _editors.registerEditor)('checkbox', CheckboxEditor);

},{"./../editors":34,"./../helpers/dom/element":50,"./_baseEditor":35}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x4, _x5, _x6) { var _again = true; _function: while (_again) { var object = _x4, property = _x5, receiver = _x6; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x4 = parent; _x5 = property; _x6 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _helpersDomElement = require('./../helpers/dom/element');

var _helpersObject = require('./../helpers/object');

var _eventManager = require('./../eventManager');

var _editors = require('./../editors');

var _helpersUnicode = require('./../helpers/unicode');

var _helpersDomEvent = require('./../helpers/dom/event');

var _textEditor = require('./textEditor');

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

var _pikaday = require('pikaday');

var _pikaday2 = _interopRequireDefault(_pikaday);

Handsontable.editors = Handsontable.editors || {};
Handsontable.editors.DateEditor = DateEditor;

/**
 * @private
 * @editor DateEditor
 * @class DateEditor
 * @dependencies TextEditor moment pikaday
 */

var DateEditor = (function (_TextEditor) {
  _inherits(DateEditor, _TextEditor);

  /**
   * @param {Core} hotInstance Handsontable instance
   */

  function DateEditor(hotInstance) {
    _classCallCheck(this, DateEditor);

    _get(Object.getPrototypeOf(DateEditor.prototype), 'constructor', this).call(this, hotInstance);

    this.$datePicker = null;
    this.datePicker = null;
    this.datePickerStyle = null;
    this.defaultDateFormat = 'DD/MM/YYYY';
    this.isCellEdited = false;
    this.parentDestroyed = false;
  }

  _createClass(DateEditor, [{
    key: 'init',
    value: function init() {
      var _this = this;

      if (typeof _moment2['default'] !== 'function') {
        throw new Error("You need to include moment.js to your project.");
      }

      if (typeof _pikaday2['default'] !== 'function') {
        throw new Error("You need to include Pikaday to your project.");
      }
      _get(Object.getPrototypeOf(DateEditor.prototype), 'init', this).call(this);
      this.instance.addHook('afterDestroy', function () {
        _this.parentDestroyed = true;
        _this.destroyElements();
      });
    }

    /**
     * Create data picker instance
     */
  }, {
    key: 'createElements',
    value: function createElements() {
      _get(Object.getPrototypeOf(DateEditor.prototype), 'createElements', this).call(this);

      this.datePicker = document.createElement('DIV');
      this.datePickerStyle = this.datePicker.style;
      this.datePickerStyle.position = 'absolute';
      this.datePickerStyle.top = 0;
      this.datePickerStyle.left = 0;
      this.datePickerStyle.zIndex = 9999;

      (0, _helpersDomElement.addClass)(this.datePicker, 'htDatepickerHolder');
      document.body.appendChild(this.datePicker);

      this.$datePicker = new _pikaday2['default'](this.getDatePickerConfig());
      var eventManager = new _eventManager.EventManager(this);

      /**
       * Prevent recognizing clicking on datepicker as clicking outside of table
       */
      eventManager.addEventListener(this.datePicker, 'mousedown', function (event) {
        return (0, _helpersDomEvent.stopPropagation)(event);
      });
      this.hideDatepicker();
    }

    /**
     * Destroy data picker instance
     */
  }, {
    key: 'destroyElements',
    value: function destroyElements() {
      this.$datePicker.destroy();
    }

    /**
     * Prepare editor to appear
     *
     * @param {Number} row Row index
     * @param {Number} col Column index
     * @param {String} prop Property name (passed when datasource is an array of objects)
     * @param {HTMLTableCellElement} td Table cell element
     * @param {*} originalValue Original value
     * @param {Object} cellProperties Object with cell properties ({@see Core#getCellMeta})
     */
  }, {
    key: 'prepare',
    value: function prepare(row, col, prop, td, originalValue, cellProperties) {
      this._opened = false;
      _get(Object.getPrototypeOf(DateEditor.prototype), 'prepare', this).call(this, row, col, prop, td, originalValue, cellProperties);
    }

    /**
     * Open editor
     *
     * @param {Event} [event=null]
     */
  }, {
    key: 'open',
    value: function open() {
      var event = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      _get(Object.getPrototypeOf(DateEditor.prototype), 'open', this).call(this);
      this.showDatepicker(event);
    }

    /**
     * Close editor
     */
  }, {
    key: 'close',
    value: function close() {
      var _this2 = this;

      this._opened = false;
      this.instance._registerTimeout(setTimeout(function () {
        _this2.instance.selection.refreshBorders();
      }, 0));

      _get(Object.getPrototypeOf(DateEditor.prototype), 'close', this).call(this);
    }

    /**
     * @param {Boolean} [isCancelled=false]
     * @param {Boolean} [ctrlDown=false]
     */
  }, {
    key: 'finishEditing',
    value: function finishEditing() {
      var isCancelled = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
      var ctrlDown = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

      if (isCancelled) {
        // pressed ESC, restore original value
        // var value = this.instance.getDataAtCell(this.row, this.col);
        var value = this.originalValue;

        if (value !== void 0) {
          this.setValue(value);
        }
      }
      this.hideDatepicker();
      _get(Object.getPrototypeOf(DateEditor.prototype), 'finishEditing', this).call(this, isCancelled, ctrlDown);
    }

    /**
     * Show data picker
     *
     * @param {Event} event
     */
  }, {
    key: 'showDatepicker',
    value: function showDatepicker(event) {
      this.$datePicker.config(this.getDatePickerConfig());

      var offset = this.TD.getBoundingClientRect();
      var dateFormat = this.cellProperties.dateFormat || this.defaultDateFormat;
      var datePickerConfig = this.$datePicker.config();
      var dateStr = undefined;
      var isMouseDown = this.instance.view.isMouseDown();
      var isMeta = event ? (0, _helpersUnicode.isMetaKey)(event.keyCode) : false;

      this.datePickerStyle.top = window.pageYOffset + offset.top + (0, _helpersDomElement.outerHeight)(this.TD) + 'px';
      this.datePickerStyle.left = window.pageXOffset + offset.left + 'px';

      this.$datePicker._onInputFocus = function () {};
      datePickerConfig.format = dateFormat;

      if (this.originalValue) {
        dateStr = this.originalValue;

        if ((0, _moment2['default'])(dateStr, dateFormat, true).isValid()) {
          this.$datePicker.setMoment((0, _moment2['default'])(dateStr, dateFormat), true);
        }
        if (!isMeta && !isMouseDown) {
          this.setValue('');
        }
      } else {
        if (this.cellProperties.defaultDate) {
          dateStr = this.cellProperties.defaultDate;

          datePickerConfig.defaultDate = dateStr;

          if ((0, _moment2['default'])(dateStr, dateFormat, true).isValid()) {
            this.$datePicker.setMoment((0, _moment2['default'])(dateStr, dateFormat), true);
          }

          if (!isMeta && !isMouseDown) {
            this.setValue('');
          }
        } else {
          // if a default date is not defined, set a soft-default-date: display the current day and month in the
          // datepicker, but don't fill the editor input
          this.$datePicker.gotoToday();
        }
      }

      this.datePickerStyle.display = 'block';
      this.$datePicker.show();
    }

    /**
     * Hide data picker
     */
  }, {
    key: 'hideDatepicker',
    value: function hideDatepicker() {
      this.datePickerStyle.display = 'none';
      this.$datePicker.hide();
    }

    /**
     * Get date picker options.
     *
     * @returns {Object}
     */
  }, {
    key: 'getDatePickerConfig',
    value: function getDatePickerConfig() {
      var _this3 = this;

      var htInput = this.TEXTAREA;
      var options = {};

      if (this.cellProperties && this.cellProperties.datePickerConfig) {
        (0, _helpersObject.deepExtend)(options, this.cellProperties.datePickerConfig);
      }
      var origOnSelect = options.onSelect;
      var origOnClose = options.onClose;

      options.field = htInput;
      options.trigger = htInput;
      options.container = this.datePicker;
      options.bound = false;
      options.format = options.format || this.defaultDateFormat;
      options.reposition = options.reposition || false;
      options.onSelect = function (dateStr) {
        if (!isNaN(dateStr.getTime())) {
          dateStr = (0, _moment2['default'])(dateStr).format(_this3.cellProperties.dateFormat || _this3.defaultDateFormat);
        }
        _this3.setValue(dateStr);
        _this3.hideDatepicker();

        if (origOnSelect) {
          origOnSelect();
        }
      };
      options.onClose = function () {
        if (!_this3.parentDestroyed) {
          _this3.finishEditing(false);
        }
        if (origOnClose) {
          origOnClose();
        }
      };

      return options;
    }
  }]);

  return DateEditor;
})(_textEditor.TextEditor);

exports.DateEditor = DateEditor;

(0, _editors.registerEditor)('date', DateEditor);

},{"./../editors":34,"./../eventManager":46,"./../helpers/dom/element":50,"./../helpers/dom/event":51,"./../helpers/object":55,"./../helpers/unicode":58,"./textEditor":45,"moment":4,"pikaday":6}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _editors = require('./../editors');

var _autocompleteEditor = require('./autocompleteEditor');

/**
 * @private
 * @editor DropdownEditor
 * @class DropdownEditor
 * @dependencies AutocompleteEditor
 */

var DropdownEditor = (function (_AutocompleteEditor) {
  _inherits(DropdownEditor, _AutocompleteEditor);

  function DropdownEditor() {
    _classCallCheck(this, DropdownEditor);

    _get(Object.getPrototypeOf(DropdownEditor.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(DropdownEditor, [{
    key: 'prepare',
    value: function prepare(row, col, prop, td, originalValue, cellProperties) {
      _get(Object.getPrototypeOf(DropdownEditor.prototype), 'prepare', this).call(this, row, col, prop, td, originalValue, cellProperties);
      this.cellProperties.filter = false;
      this.cellProperties.strict = true;
    }
  }]);

  return DropdownEditor;
})(_autocompleteEditor.AutocompleteEditor);

Handsontable.hooks.add('beforeValidate', function (value, row, col, source) {
  var cellMeta = this.getCellMeta(row, col);

  if (cellMeta.editor === Handsontable.editors.DropdownEditor) {
    if (cellMeta.strict === void 0) {
      cellMeta.filter = false;
      cellMeta.strict = true;
    }
  }
});

exports.DropdownEditor = DropdownEditor;

(0, _editors.registerEditor)('dropdown', DropdownEditor);

},{"./../editors":34,"./autocompleteEditor":36}],40:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _helpersUnicode = require('./../helpers/unicode');

var _helpersObject = require('./../helpers/object');

var _helpersDomElement = require('./../helpers/dom/element');

var _helpersDomEvent = require('./../helpers/dom/event');

var _editors = require('./../editors');

var _textEditor = require('./textEditor');

var HandsontableEditor = _textEditor.TextEditor.prototype.extend();

/**
 * @private
 * @editor HandsontableEditor
 * @class HandsontableEditor
 * @dependencies TextEditor
 */
HandsontableEditor.prototype.createElements = function () {
  _textEditor.TextEditor.prototype.createElements.apply(this, arguments);

  var DIV = document.createElement('DIV');
  DIV.className = 'handsontableEditor';
  this.TEXTAREA_PARENT.appendChild(DIV);

  this.htContainer = DIV;
  this.assignHooks();
};

HandsontableEditor.prototype.prepare = function (td, row, col, prop, value, cellProperties) {

  _textEditor.TextEditor.prototype.prepare.apply(this, arguments);

  var parent = this;
  var options = {
    startRows: 0,
    startCols: 0,
    minRows: 0,
    minCols: 0,
    className: 'listbox',
    copyPaste: false,
    autoColumnSize: false,
    autoRowSize: false,
    readOnly: true,
    fillHandle: false,
    afterOnCellMouseDown: function afterOnCellMouseDown() {
      var value = this.getValue();

      // if the value is undefined then it means we don't want to set the value
      if (value !== void 0) {
        parent.setValue(value);
      }
      parent.instance.destroyEditor();
    }
  };

  if (this.cellProperties.handsontable) {
    (0, _helpersObject.extend)(options, cellProperties.handsontable);
  }
  this.htOptions = options;
};

var onBeforeKeyDown = function onBeforeKeyDown(event) {
  if ((0, _helpersDomEvent.isImmediatePropagationStopped)(event)) {
    return;
  }
  var editor = this.getActiveEditor();

  var innerHOT = editor.htEditor.getInstance(); //Handsontable.tmpHandsontable(editor.htContainer, 'getInstance');

  var rowToSelect;

  if (event.keyCode == _helpersUnicode.KEY_CODES.ARROW_DOWN) {
    if (!innerHOT.getSelected()) {
      rowToSelect = 0;
    } else {
      var selectedRow = innerHOT.getSelected()[0];
      var lastRow = innerHOT.countRows() - 1;
      rowToSelect = Math.min(lastRow, selectedRow + 1);
    }
  } else if (event.keyCode == _helpersUnicode.KEY_CODES.ARROW_UP) {
    if (innerHOT.getSelected()) {
      var selectedRow = innerHOT.getSelected()[0];
      rowToSelect = selectedRow - 1;
    }
  }

  if (rowToSelect !== void 0) {
    if (rowToSelect < 0) {
      innerHOT.deselectCell();
    } else {
      innerHOT.selectCell(rowToSelect, 0);
    }
    if (innerHOT.getData().length) {
      event.preventDefault();
      (0, _helpersDomEvent.stopImmediatePropagation)(event);

      editor.instance.listen();
      editor.TEXTAREA.focus();
    }
  }
};

HandsontableEditor.prototype.open = function () {

  this.instance.addHook('beforeKeyDown', onBeforeKeyDown);

  _textEditor.TextEditor.prototype.open.apply(this, arguments);

  if (this.htEditor) {
    this.htEditor.destroy();
  }
  this.htEditor = new Handsontable(this.htContainer, this.htOptions);

  if (this.cellProperties.strict) {
    this.htEditor.selectCell(0, 0);
    this.TEXTAREA.style.visibility = 'hidden';
  } else {
    this.htEditor.deselectCell();
    this.TEXTAREA.style.visibility = 'visible';
  }

  (0, _helpersDomElement.setCaretPosition)(this.TEXTAREA, 0, this.TEXTAREA.value.length);
};

HandsontableEditor.prototype.close = function () {
  this.instance.removeHook('beforeKeyDown', onBeforeKeyDown);
  this.instance.listen();

  _textEditor.TextEditor.prototype.close.apply(this, arguments);
};

HandsontableEditor.prototype.focus = function () {
  this.instance.listen();
  _textEditor.TextEditor.prototype.focus.apply(this, arguments);
};

HandsontableEditor.prototype.beginEditing = function (initialValue) {
  var onBeginEditing = this.instance.getSettings().onBeginEditing;

  if (onBeginEditing && onBeginEditing() === false) {
    return;
  }
  _textEditor.TextEditor.prototype.beginEditing.apply(this, arguments);
};

HandsontableEditor.prototype.finishEditing = function (isCancelled, ctrlDown) {
  if (this.htEditor && this.htEditor.isListening()) {
    //if focus is still in the HOT editor

    //if (Handsontable.tmpHandsontable(this.htContainer,'isListening')) { //if focus is still in the HOT editor
    //if (this.$htContainer.handsontable('isListening')) { //if focus is still in the HOT editor
    this.instance.listen(); //return the focus to the parent HOT instance
  }

  if (this.htEditor && this.htEditor.getSelected()) {
    //if (Handsontable.tmpHandsontable(this.htContainer,'getSelected')) {
    //if (this.$htContainer.handsontable('getSelected')) {
    //  var value = this.$htContainer.handsontable('getInstance').getValue();
    var value = this.htEditor.getInstance().getValue();
    //var value = Handsontable.tmpHandsontable(this.htContainer,'getInstance').getValue();
    if (value !== void 0) {
      //if the value is undefined then it means we don't want to set the value
      this.setValue(value);
    }
  }

  return _textEditor.TextEditor.prototype.finishEditing.apply(this, arguments);
};

HandsontableEditor.prototype.assignHooks = function () {
  var _this = this;

  this.instance.addHook('afterDestroy', function () {
    if (_this.htEditor) {
      _this.htEditor.destroy();
    }
  });
};

exports.HandsontableEditor = HandsontableEditor;

(0, _editors.registerEditor)('handsontable', HandsontableEditor);

},{"./../editors":34,"./../helpers/dom/element":50,"./../helpers/dom/event":51,"./../helpers/object":55,"./../helpers/unicode":58,"./textEditor":45}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _helpersUnicode = require('./../helpers/unicode');

var _helpersDomEvent = require('./../helpers/dom/event');

var _helpersDomElement = require('./../helpers/dom/element');

var _editors = require('./../editors');

var _baseEditor = require('./_baseEditor');

var _eventManager = require('./../eventManager');

var MobileTextEditor = _baseEditor.BaseEditor.prototype.extend(),
    domDimensionsCache = {};

/**
 * @private
 * @editor MobileTextEditor
 * @class MobileTextEditor
 */
var createControls = function createControls() {
  this.controls = {};

  this.controls.leftButton = document.createElement('DIV');
  this.controls.leftButton.className = 'leftButton';
  this.controls.rightButton = document.createElement('DIV');
  this.controls.rightButton.className = 'rightButton';
  this.controls.upButton = document.createElement('DIV');
  this.controls.upButton.className = 'upButton';
  this.controls.downButton = document.createElement('DIV');
  this.controls.downButton.className = 'downButton';

  for (var button in this.controls) {
    if (this.controls.hasOwnProperty(button)) {
      this.positionControls.appendChild(this.controls[button]);
    }
  }
};

MobileTextEditor.prototype.valueChanged = function () {
  return this.initValue != this.getValue();
};

MobileTextEditor.prototype.init = function () {
  var that = this;
  this.eventManager = (0, _eventManager.eventManager)(this.instance);

  this.createElements();
  this.bindEvents();

  this.instance.addHook('afterDestroy', function () {
    that.destroy();
  });
};

MobileTextEditor.prototype.getValue = function () {
  return this.TEXTAREA.value;
};

MobileTextEditor.prototype.setValue = function (newValue) {
  this.initValue = newValue;

  this.TEXTAREA.value = newValue;
};

MobileTextEditor.prototype.createElements = function () {
  this.editorContainer = document.createElement('DIV');
  this.editorContainer.className = "htMobileEditorContainer";

  this.cellPointer = document.createElement('DIV');
  this.cellPointer.className = "cellPointer";

  this.moveHandle = document.createElement('DIV');
  this.moveHandle.className = "moveHandle";

  this.inputPane = document.createElement('DIV');
  this.inputPane.className = "inputs";

  this.positionControls = document.createElement('DIV');
  this.positionControls.className = "positionControls";

  this.TEXTAREA = document.createElement('TEXTAREA');
  (0, _helpersDomElement.addClass)(this.TEXTAREA, 'handsontableInput');

  this.inputPane.appendChild(this.TEXTAREA);

  this.editorContainer.appendChild(this.cellPointer);
  this.editorContainer.appendChild(this.moveHandle);
  this.editorContainer.appendChild(this.inputPane);
  this.editorContainer.appendChild(this.positionControls);

  createControls.call(this);

  document.body.appendChild(this.editorContainer);
};

MobileTextEditor.prototype.onBeforeKeyDown = function (event) {
  var instance = this;
  var that = instance.getActiveEditor();

  if (event.target !== that.TEXTAREA || (0, _helpersDomEvent.isImmediatePropagationStopped)(event)) {
    return;
  }

  switch (event.keyCode) {
    case _helpersUnicode.KEY_CODES.ENTER:
      that.close();
      event.preventDefault(); //don't add newline to field
      break;
    case _helpersUnicode.KEY_CODES.BACKSPACE:
      (0, _helpersDomEvent.stopImmediatePropagation)(event); //backspace, delete, home, end should only work locally when cell is edited (not in table context)
      break;
  }
};

MobileTextEditor.prototype.open = function () {
  this.instance.addHook('beforeKeyDown', this.onBeforeKeyDown);

  (0, _helpersDomElement.addClass)(this.editorContainer, 'active');
  (0, _helpersDomElement.removeClass)(this.cellPointer, 'hidden');

  this.updateEditorPosition();
};

MobileTextEditor.prototype.focus = function () {
  this.TEXTAREA.focus();
  (0, _helpersDomElement.setCaretPosition)(this.TEXTAREA, this.TEXTAREA.value.length);
};

MobileTextEditor.prototype.close = function () {
  this.TEXTAREA.blur();
  this.instance.removeHook('beforeKeyDown', this.onBeforeKeyDown);

  (0, _helpersDomElement.removeClass)(this.editorContainer, 'active');
};

MobileTextEditor.prototype.scrollToView = function () {
  var coords = this.instance.getSelectedRange().highlight;
  this.instance.view.scrollViewport(coords);
};

MobileTextEditor.prototype.hideCellPointer = function () {
  if (!(0, _helpersDomElement.hasClass)(this.cellPointer, 'hidden')) {
    (0, _helpersDomElement.addClass)(this.cellPointer, 'hidden');
  }
};

MobileTextEditor.prototype.updateEditorPosition = function (x, y) {
  if (x && y) {
    x = parseInt(x, 10);
    y = parseInt(y, 10);

    this.editorContainer.style.top = y + "px";
    this.editorContainer.style.left = x + "px";
  } else {
    var selection = this.instance.getSelected(),
        selectedCell = this.instance.getCell(selection[0], selection[1]);

    //cache sizes
    if (!domDimensionsCache.cellPointer) {
      domDimensionsCache.cellPointer = {
        height: (0, _helpersDomElement.outerHeight)(this.cellPointer),
        width: (0, _helpersDomElement.outerWidth)(this.cellPointer)
      };
    }
    if (!domDimensionsCache.editorContainer) {
      domDimensionsCache.editorContainer = {
        width: (0, _helpersDomElement.outerWidth)(this.editorContainer)
      };
    }

    if (selectedCell !== undefined) {
      var scrollLeft = this.instance.view.wt.wtOverlays.leftOverlay.trimmingContainer == window ? 0 : (0, _helpersDomElement.getScrollLeft)(this.instance.view.wt.wtOverlays.leftOverlay.holder);
      var scrollTop = this.instance.view.wt.wtOverlays.topOverlay.trimmingContainer == window ? 0 : (0, _helpersDomElement.getScrollTop)(this.instance.view.wt.wtOverlays.topOverlay.holder);

      var selectedCellOffset = (0, _helpersDomElement.offset)(selectedCell),
          selectedCellWidth = (0, _helpersDomElement.outerWidth)(selectedCell),
          currentScrollPosition = {
        x: scrollLeft,
        y: scrollTop
      };

      this.editorContainer.style.top = parseInt(selectedCellOffset.top + (0, _helpersDomElement.outerHeight)(selectedCell) - currentScrollPosition.y + domDimensionsCache.cellPointer.height, 10) + "px";
      this.editorContainer.style.left = parseInt(window.innerWidth / 2 - domDimensionsCache.editorContainer.width / 2, 10) + "px";

      if (selectedCellOffset.left + selectedCellWidth / 2 > parseInt(this.editorContainer.style.left, 10) + domDimensionsCache.editorContainer.width) {
        this.editorContainer.style.left = window.innerWidth - domDimensionsCache.editorContainer.width + "px";
      } else if (selectedCellOffset.left + selectedCellWidth / 2 < parseInt(this.editorContainer.style.left, 10) + 20) {
        this.editorContainer.style.left = 0 + "px";
      }

      this.cellPointer.style.left = parseInt(selectedCellOffset.left - domDimensionsCache.cellPointer.width / 2 - (0, _helpersDomElement.offset)(this.editorContainer).left + selectedCellWidth / 2 - currentScrollPosition.x, 10) + "px";
    }
  }
};

// For the optional dont-affect-editor-by-zooming feature:

//MobileTextEditor.prototype.updateEditorDimensions = function () {
//  if(!this.beginningWindowWidth) {
//    this.beginningWindowWidth = window.innerWidth;
//    this.beginningEditorWidth = Handsontable.outerWidth(this.editorContainer);
//    this.scaleRatio = this.beginningEditorWidth / this.beginningWindowWidth;
//
//    this.editorContainer.style.width = this.beginningEditorWidth + "px";
//    return;
//  }
//
//  var currentScaleRatio = this.beginningEditorWidth / window.innerWidth;
//  //if(currentScaleRatio > this.scaleRatio + 0.2 || currentScaleRatio < this.scaleRatio - 0.2) {
//  if(currentScaleRatio != this.scaleRatio) {
//    this.editorContainer.style["zoom"] = (1 - ((currentScaleRatio * this.scaleRatio) - this.scaleRatio)) * 100 + "%";
//  }
//
//};

MobileTextEditor.prototype.updateEditorData = function () {
  var selected = this.instance.getSelected(),
      selectedValue = this.instance.getDataAtCell(selected[0], selected[1]);

  this.row = selected[0];
  this.col = selected[1];
  this.setValue(selectedValue);
  this.updateEditorPosition();
};

MobileTextEditor.prototype.prepareAndSave = function () {
  var val;

  if (!this.valueChanged()) {
    return true;
  }

  if (this.instance.getSettings().trimWhitespace) {
    val = [[String.prototype.trim.call(this.getValue())]];
  } else {
    val = [[this.getValue()]];
  }

  this.saveValue(val);
};

MobileTextEditor.prototype.bindEvents = function () {
  var that = this;

  this.eventManager.addEventListener(this.controls.leftButton, "touchend", function (event) {
    that.prepareAndSave();
    that.instance.selection.transformStart(0, -1, null, true);
    that.updateEditorData();
    event.preventDefault();
  });
  this.eventManager.addEventListener(this.controls.rightButton, "touchend", function (event) {
    that.prepareAndSave();
    that.instance.selection.transformStart(0, 1, null, true);
    that.updateEditorData();
    event.preventDefault();
  });
  this.eventManager.addEventListener(this.controls.upButton, "touchend", function (event) {
    that.prepareAndSave();
    that.instance.selection.transformStart(-1, 0, null, true);
    that.updateEditorData();
    event.preventDefault();
  });
  this.eventManager.addEventListener(this.controls.downButton, "touchend", function (event) {
    that.prepareAndSave();
    that.instance.selection.transformStart(1, 0, null, true);
    that.updateEditorData();
    event.preventDefault();
  });

  this.eventManager.addEventListener(this.moveHandle, "touchstart", function (event) {
    if (event.touches.length == 1) {
      var touch = event.touches[0],
          onTouchPosition = {
        x: that.editorContainer.offsetLeft,
        y: that.editorContainer.offsetTop
      },
          onTouchOffset = {
        x: touch.pageX - onTouchPosition.x,
        y: touch.pageY - onTouchPosition.y
      };

      that.eventManager.addEventListener(this, "touchmove", function (event) {
        var touch = event.touches[0];
        that.updateEditorPosition(touch.pageX - onTouchOffset.x, touch.pageY - onTouchOffset.y);
        that.hideCellPointer();
        event.preventDefault();
      });
    }
  });

  this.eventManager.addEventListener(document.body, "touchend", function (event) {
    if (!(0, _helpersDomElement.isChildOf)(event.target, that.editorContainer) && !(0, _helpersDomElement.isChildOf)(event.target, that.instance.rootElement)) {
      that.close();
    }
  });

  this.eventManager.addEventListener(this.instance.view.wt.wtOverlays.leftOverlay.holder, "scroll", function (event) {
    if (that.instance.view.wt.wtOverlays.leftOverlay.trimmingContainer != window) {
      that.hideCellPointer();
    }
  });

  this.eventManager.addEventListener(this.instance.view.wt.wtOverlays.topOverlay.holder, "scroll", function (event) {
    if (that.instance.view.wt.wtOverlays.topOverlay.trimmingContainer != window) {
      that.hideCellPointer();
    }
  });
};

MobileTextEditor.prototype.destroy = function () {
  this.eventManager.clear();

  this.editorContainer.parentNode.removeChild(this.editorContainer);
};

exports.MobileTextEditor = MobileTextEditor;

(0, _editors.registerEditor)('mobile', MobileTextEditor);

},{"./../editors":34,"./../eventManager":46,"./../helpers/dom/element":50,"./../helpers/dom/event":51,"./../helpers/unicode":58,"./_baseEditor":35}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _numeral = require('numeral');

var _numeral2 = _interopRequireDefault(_numeral);

var _editors = require('./../editors');

var _textEditor = require('./textEditor');

/**
 * @private
 * @editor NumericEditor
 * @class NumericEditor
 * @dependencies TextEditor numeral
 */

var NumericEditor = (function (_TextEditor) {
  _inherits(NumericEditor, _TextEditor);

  function NumericEditor() {
    _classCallCheck(this, NumericEditor);

    _get(Object.getPrototypeOf(NumericEditor.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(NumericEditor, [{
    key: 'beginEditing',

    /**
     * @param {*} initialValue
     */
    value: function beginEditing(initialValue) {
      if (typeof initialValue === 'undefined' && this.originalValue) {
        if (typeof this.cellProperties.language !== 'undefined') {
          _numeral2['default'].language(this.cellProperties.language);
        }
        var decimalDelimiter = _numeral2['default'].languageData().delimiters.decimal;
        initialValue = ('' + this.originalValue).replace('.', decimalDelimiter);
      }
      _get(Object.getPrototypeOf(NumericEditor.prototype), 'beginEditing', this).call(this, initialValue);
    }
  }]);

  return NumericEditor;
})(_textEditor.TextEditor);

exports.NumericEditor = NumericEditor;

(0, _editors.registerEditor)('numeric', NumericEditor);

},{"./../editors":34,"./textEditor":45,"numeral":5}],43:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _helpersDomElement = require('./../helpers/dom/element');

var _editors = require('./../editors');

var _textEditor = require('./textEditor');

/**
 * @private
 * @editor PasswordEditor
 * @class PasswordEditor
 * @dependencies TextEditor
 */

var PasswordEditor = (function (_TextEditor) {
  _inherits(PasswordEditor, _TextEditor);

  function PasswordEditor() {
    _classCallCheck(this, PasswordEditor);

    _get(Object.getPrototypeOf(PasswordEditor.prototype), 'constructor', this).apply(this, arguments);
  }

  _createClass(PasswordEditor, [{
    key: 'createElements',
    value: function createElements() {
      _get(Object.getPrototypeOf(PasswordEditor.prototype), 'createElements', this).call(this);

      this.TEXTAREA = document.createElement('input');
      this.TEXTAREA.setAttribute('type', 'password');
      this.TEXTAREA.className = 'handsontableInput';
      this.textareaStyle = this.TEXTAREA.style;
      this.textareaStyle.width = 0;
      this.textareaStyle.height = 0;

      (0, _helpersDomElement.empty)(this.TEXTAREA_PARENT);
      this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);
    }
  }]);

  return PasswordEditor;
})(_textEditor.TextEditor);

exports.PasswordEditor = PasswordEditor;

(0, _editors.registerEditor)('password', PasswordEditor);

},{"./../editors":34,"./../helpers/dom/element":50,"./textEditor":45}],44:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _helpersDomElement = require('./../helpers/dom/element');

var _helpersDomEvent = require('./../helpers/dom/event');

var _helpersUnicode = require('./../helpers/unicode');

var _editors = require('./../editors');

var _baseEditor = require('./_baseEditor');

var SelectEditor = _baseEditor.BaseEditor.prototype.extend();

/**
 * @private
 * @editor SelectEditor
 * @class SelectEditor
 */
SelectEditor.prototype.init = function () {
  this.select = document.createElement('SELECT');
  (0, _helpersDomElement.addClass)(this.select, 'htSelectEditor');
  this.select.style.display = 'none';
  this.instance.rootElement.appendChild(this.select);
  this.registerHooks();
};

SelectEditor.prototype.registerHooks = function () {
  var _this = this;

  this.instance.addHook('afterScrollVertically', function () {
    return _this.refreshDimensions();
  });
  this.instance.addHook('afterColumnResize', function () {
    return _this.refreshDimensions();
  });
  this.instance.addHook('afterRowResize', function () {
    return _this.refreshDimensions();
  });
};

SelectEditor.prototype.prepare = function () {
  _baseEditor.BaseEditor.prototype.prepare.apply(this, arguments);

  var selectOptions = this.cellProperties.selectOptions;
  var options;

  if (typeof selectOptions == 'function') {
    options = this.prepareOptions(selectOptions(this.row, this.col, this.prop));
  } else {
    options = this.prepareOptions(selectOptions);
  }

  (0, _helpersDomElement.empty)(this.select);

  for (var option in options) {
    if (options.hasOwnProperty(option)) {
      var optionElement = document.createElement('OPTION');
      optionElement.value = option;
      (0, _helpersDomElement.fastInnerHTML)(optionElement, options[option]);
      this.select.appendChild(optionElement);
    }
  }
};

SelectEditor.prototype.prepareOptions = function (optionsToPrepare) {
  var preparedOptions = {};

  if (Array.isArray(optionsToPrepare)) {
    for (var i = 0, len = optionsToPrepare.length; i < len; i++) {
      preparedOptions[optionsToPrepare[i]] = optionsToPrepare[i];
    }
  } else if (typeof optionsToPrepare == 'object') {
    preparedOptions = optionsToPrepare;
  }

  return preparedOptions;
};

SelectEditor.prototype.getValue = function () {
  return this.select.value;
};

SelectEditor.prototype.setValue = function (value) {
  this.select.value = value;
};

var onBeforeKeyDown = function onBeforeKeyDown(event) {
  var instance = this;
  var editor = instance.getActiveEditor();

  switch (event.keyCode) {
    case _helpersUnicode.KEY_CODES.ARROW_UP:
      var previousOptionIndex = editor.select.selectedIndex - 1;
      if (previousOptionIndex >= 0) {
        editor.select[previousOptionIndex].selected = true;
      }

      (0, _helpersDomEvent.stopImmediatePropagation)(event);
      event.preventDefault();
      break;

    case _helpersUnicode.KEY_CODES.ARROW_DOWN:
      var nextOptionIndex = editor.select.selectedIndex + 1;
      if (nextOptionIndex <= editor.select.length - 1) {
        editor.select[nextOptionIndex].selected = true;
      }

      (0, _helpersDomEvent.stopImmediatePropagation)(event);
      event.preventDefault();
      break;
  }
};

// TODO: Refactor this with the use of new getCell() after 0.12.1
SelectEditor.prototype.checkEditorSection = function () {
  if (this.row < this.instance.getSettings().fixedRowsTop) {
    if (this.col < this.instance.getSettings().fixedColumnsLeft) {
      return 'corner';
    } else {
      return 'top';
    }
  } else {
    if (this.col < this.instance.getSettings().fixedColumnsLeft) {
      return 'left';
    }
  }
};

SelectEditor.prototype.open = function () {
  this._opened = true;
  this.refreshDimensions();
  this.select.style.display = '';
  this.instance.addHook('beforeKeyDown', onBeforeKeyDown);
};

SelectEditor.prototype.close = function () {
  this._opened = false;
  this.select.style.display = 'none';
  this.instance.removeHook('beforeKeyDown', onBeforeKeyDown);
};

SelectEditor.prototype.focus = function () {
  this.select.focus();
};

SelectEditor.prototype.refreshDimensions = function () {
  if (this.state !== Handsontable.EditorState.EDITING) {
    return;
  }
  this.TD = this.getEditedCell();

  // TD is outside of the viewport.
  if (!this.TD) {
    this.close();

    return;
  }
  var width = (0, _helpersDomElement.outerWidth)(this.TD) + 1,
      height = (0, _helpersDomElement.outerHeight)(this.TD) + 1,
      currentOffset = (0, _helpersDomElement.offset)(this.TD),
      containerOffset = (0, _helpersDomElement.offset)(this.instance.rootElement),
      scrollableContainer = (0, _helpersDomElement.getScrollableElement)(this.TD),
      editTop = currentOffset.top - containerOffset.top - 1 - (scrollableContainer.scrollTop || 0),
      editLeft = currentOffset.left - containerOffset.left - 1 - (scrollableContainer.scrollLeft || 0),
      editorSection = this.checkEditorSection(),
      cssTransformOffset;

  var settings = this.instance.getSettings();
  var rowHeadersCount = settings.rowHeaders ? 1 : 0;
  var colHeadersCount = settings.colHeaders ? 1 : 0;

  switch (editorSection) {
    case 'top':
      cssTransformOffset = (0, _helpersDomElement.getCssTransform)(this.instance.view.wt.wtOverlays.topOverlay.clone.wtTable.holder.parentNode);
      break;
    case 'left':
      cssTransformOffset = (0, _helpersDomElement.getCssTransform)(this.instance.view.wt.wtOverlays.leftOverlay.clone.wtTable.holder.parentNode);
      break;
    case 'corner':
      cssTransformOffset = (0, _helpersDomElement.getCssTransform)(this.instance.view.wt.wtOverlays.topLeftCornerOverlay.clone.wtTable.holder.parentNode);
      break;
  }
  if (this.instance.getSelected()[0] === 0) {
    editTop += 1;
  }

  if (this.instance.getSelected()[1] === 0) {
    editLeft += 1;
  }

  var selectStyle = this.select.style;

  if (cssTransformOffset && cssTransformOffset != -1) {
    selectStyle[cssTransformOffset[0]] = cssTransformOffset[1];
  } else {
    (0, _helpersDomElement.resetCssTransform)(this.select);
  }
  var cellComputedStyle = (0, _helpersDomElement.getComputedStyle)(this.TD);

  if (parseInt(cellComputedStyle.borderTopWidth, 10) > 0) {
    height -= 1;
  }
  if (parseInt(cellComputedStyle.borderLeftWidth, 10) > 0) {
    width -= 1;
  }

  selectStyle.height = height + 'px';
  selectStyle.minWidth = width + 'px';
  selectStyle.top = editTop + 'px';
  selectStyle.left = editLeft + 'px';
  selectStyle.margin = '0px';
};

SelectEditor.prototype.getEditedCell = function () {
  var editorSection = this.checkEditorSection(),
      editedCell;

  switch (editorSection) {
    case 'top':
      editedCell = this.instance.view.wt.wtOverlays.topOverlay.clone.wtTable.getCell({
        row: this.row,
        col: this.col
      });
      this.select.style.zIndex = 101;
      break;
    case 'corner':
      editedCell = this.instance.view.wt.wtOverlays.topLeftCornerOverlay.clone.wtTable.getCell({
        row: this.row,
        col: this.col
      });
      this.select.style.zIndex = 103;
      break;
    case 'left':
      editedCell = this.instance.view.wt.wtOverlays.leftOverlay.clone.wtTable.getCell({
        row: this.row,
        col: this.col
      });
      this.select.style.zIndex = 102;
      break;
    default:
      editedCell = this.instance.getCell(this.row, this.col);
      this.select.style.zIndex = '';
      break;
  }

  return editedCell != -1 && editedCell != -2 ? editedCell : void 0;
};

exports.SelectEditor = SelectEditor;

(0, _editors.registerEditor)('select', SelectEditor);

},{"./../editors":34,"./../helpers/dom/element":50,"./../helpers/dom/event":51,"./../helpers/unicode":58,"./_baseEditor":35}],45:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _helpersDomElement = require('./../helpers/dom/element');

var _autoResize = require('autoResize');

var _autoResize2 = _interopRequireDefault(_autoResize);

var _baseEditor = require('./_baseEditor');

var _eventManager = require('./../eventManager');

var _editors = require('./../editors');

var _helpersUnicode = require('./../helpers/unicode');

var _helpersDomEvent = require('./../helpers/dom/event');

var TextEditor = _baseEditor.BaseEditor.prototype.extend();

/**
 * @private
 * @editor TextEditor
 * @class TextEditor
 * @dependencies autoResize
 */
TextEditor.prototype.init = function () {
  var that = this;
  this.createElements();
  this.eventManager = (0, _eventManager.eventManager)(this);
  this.bindEvents();
  this.autoResize = (0, _autoResize2['default'])();

  this.instance.addHook('afterDestroy', function () {
    that.destroy();
  });
};

TextEditor.prototype.getValue = function () {
  return this.TEXTAREA.value;
};

TextEditor.prototype.setValue = function (newValue) {
  this.TEXTAREA.value = newValue;
};

var onBeforeKeyDown = function onBeforeKeyDown(event) {
  var instance = this,
      that = instance.getActiveEditor(),
      ctrlDown;

  // catch CTRL but not right ALT (which in some systems triggers ALT+CTRL)
  ctrlDown = (event.ctrlKey || event.metaKey) && !event.altKey;

  // Process only events that have been fired in the editor
  if (event.target !== that.TEXTAREA || (0, _helpersDomEvent.isImmediatePropagationStopped)(event)) {
    return;
  }

  if (event.keyCode === 17 || event.keyCode === 224 || event.keyCode === 91 || event.keyCode === 93) {
    // when CTRL or its equivalent is pressed and cell is edited, don't prepare selectable text in textarea
    (0, _helpersDomEvent.stopImmediatePropagation)(event);
    return;
  }

  switch (event.keyCode) {
    case _helpersUnicode.KEY_CODES.ARROW_RIGHT:
      if (that.isInFullEditMode()) {
        if (!that.isWaiting() && !that.allowKeyEventPropagation || !that.isWaiting() && that.allowKeyEventPropagation && !that.allowKeyEventPropagation(event.keyCode)) {
          (0, _helpersDomEvent.stopImmediatePropagation)(event);
        }
      }
      break;
    case _helpersUnicode.KEY_CODES.ARROW_LEFT:
      if (that.isInFullEditMode()) {
        if (!that.isWaiting() && !that.allowKeyEventPropagation || !that.isWaiting() && that.allowKeyEventPropagation && !that.allowKeyEventPropagation(event.keyCode)) {
          (0, _helpersDomEvent.stopImmediatePropagation)(event);
        }
      }
      break;
    case _helpersUnicode.KEY_CODES.ARROW_UP:
    case _helpersUnicode.KEY_CODES.ARROW_DOWN:
      if (that.isInFullEditMode()) {
        if (!that.isWaiting() && !that.allowKeyEventPropagation || !that.isWaiting() && that.allowKeyEventPropagation && !that.allowKeyEventPropagation(event.keyCode)) {
          (0, _helpersDomEvent.stopImmediatePropagation)(event);
        }
      }
      break;

    case _helpersUnicode.KEY_CODES.ENTER:
      var selected = that.instance.getSelected();
      var isMultipleSelection = !(selected[0] === selected[2] && selected[1] === selected[3]);
      if (ctrlDown && !isMultipleSelection || event.altKey) {
        //if ctrl+enter or alt+enter, add new line
        if (that.isOpened()) {
          var caretPosition = (0, _helpersDomElement.getCaretPosition)(that.TEXTAREA),
              value = that.getValue();

          var newValue = value.slice(0, caretPosition) + '\n' + value.slice(caretPosition);

          that.setValue(newValue);

          (0, _helpersDomElement.setCaretPosition)(that.TEXTAREA, caretPosition + 1);
        } else {
          that.beginEditing(that.originalValue + '\n');
        }
        (0, _helpersDomEvent.stopImmediatePropagation)(event);
      }
      event.preventDefault(); //don't add newline to field
      break;

    case _helpersUnicode.KEY_CODES.A:
    case _helpersUnicode.KEY_CODES.X:
    case _helpersUnicode.KEY_CODES.C:
    case _helpersUnicode.KEY_CODES.V:
      if (ctrlDown) {
        (0, _helpersDomEvent.stopImmediatePropagation)(event); //CTRL+A, CTRL+C, CTRL+V, CTRL+X should only work locally when cell is edited (not in table context)
      }
      break;

    case _helpersUnicode.KEY_CODES.BACKSPACE:
    case _helpersUnicode.KEY_CODES.DELETE:
    case _helpersUnicode.KEY_CODES.HOME:
    case _helpersUnicode.KEY_CODES.END:
      (0, _helpersDomEvent.stopImmediatePropagation)(event); //backspace, delete, home, end should only work locally when cell is edited (not in table context)
      break;
  }

  if ([_helpersUnicode.KEY_CODES.ARROW_UP, _helpersUnicode.KEY_CODES.ARROW_RIGHT, _helpersUnicode.KEY_CODES.ARROW_DOWN, _helpersUnicode.KEY_CODES.ARROW_LEFT].indexOf(event.keyCode) === -1) {
    that.autoResize.resize(String.fromCharCode(event.keyCode));
  }
};

TextEditor.prototype.open = function () {
  this.refreshDimensions(); //need it instantly, to prevent https://github.com/handsontable/handsontable/issues/348

  this.instance.addHook('beforeKeyDown', onBeforeKeyDown);
};

TextEditor.prototype.close = function () {
  this.textareaParentStyle.display = 'none';

  this.autoResize.unObserve();

  if (document.activeElement === this.TEXTAREA) {
    this.instance.listen(); //don't refocus the table if user focused some cell outside of HT on purpose
  }
  this.instance.removeHook('beforeKeyDown', onBeforeKeyDown);
};

TextEditor.prototype.focus = function () {
  this.TEXTAREA.focus();
  (0, _helpersDomElement.setCaretPosition)(this.TEXTAREA, this.TEXTAREA.value.length);
};

TextEditor.prototype.createElements = function () {
  //    this.$body = $(document.body);

  this.TEXTAREA = document.createElement('TEXTAREA');

  (0, _helpersDomElement.addClass)(this.TEXTAREA, 'handsontableInput');

  this.textareaStyle = this.TEXTAREA.style;
  this.textareaStyle.width = 0;
  this.textareaStyle.height = 0;

  this.TEXTAREA_PARENT = document.createElement('DIV');
  (0, _helpersDomElement.addClass)(this.TEXTAREA_PARENT, 'handsontableInputHolder');

  this.textareaParentStyle = this.TEXTAREA_PARENT.style;
  this.textareaParentStyle.top = 0;
  this.textareaParentStyle.left = 0;
  this.textareaParentStyle.display = 'none';

  this.TEXTAREA_PARENT.appendChild(this.TEXTAREA);

  this.instance.rootElement.appendChild(this.TEXTAREA_PARENT);

  var that = this;
  this.instance._registerTimeout(setTimeout(function () {
    that.refreshDimensions();
  }, 0));
};

TextEditor.prototype.checkEditorSection = function () {
  if (this.row < this.instance.getSettings().fixedRowsTop) {
    if (this.col < this.instance.getSettings().fixedColumnsLeft) {
      return 'corner';
    } else {
      return 'top';
    }
  } else {
    if (this.col < this.instance.getSettings().fixedColumnsLeft) {
      return 'left';
    }
  }
};

TextEditor.prototype.getEditedCell = function () {
  var editorSection = this.checkEditorSection(),
      editedCell;

  switch (editorSection) {
    case 'top':
      editedCell = this.instance.view.wt.wtOverlays.topOverlay.clone.wtTable.getCell({
        row: this.row,
        col: this.col
      });
      this.textareaParentStyle.zIndex = 101;
      break;
    case 'corner':
      editedCell = this.instance.view.wt.wtOverlays.topLeftCornerOverlay.clone.wtTable.getCell({
        row: this.row,
        col: this.col
      });
      this.textareaParentStyle.zIndex = 103;
      break;
    case 'left':
      editedCell = this.instance.view.wt.wtOverlays.leftOverlay.clone.wtTable.getCell({
        row: this.row,
        col: this.col
      });
      this.textareaParentStyle.zIndex = 102;
      break;
    default:
      editedCell = this.instance.getCell(this.row, this.col);
      this.textareaParentStyle.zIndex = "";
      break;
  }

  return editedCell != -1 && editedCell != -2 ? editedCell : void 0;
};

TextEditor.prototype.refreshDimensions = function () {
  if (this.state !== Handsontable.EditorState.EDITING) {
    return;
  }
  this.TD = this.getEditedCell();

  // TD is outside of the viewport.
  if (!this.TD) {
    this.close();

    return;
  }
  var currentOffset = (0, _helpersDomElement.offset)(this.TD),
      containerOffset = (0, _helpersDomElement.offset)(this.instance.rootElement),
      scrollableContainer = (0, _helpersDomElement.getScrollableElement)(this.TD),
      editTop = currentOffset.top - containerOffset.top - 1 - (scrollableContainer.scrollTop || 0),
      editLeft = currentOffset.left - containerOffset.left - 1 - (scrollableContainer.scrollLeft || 0),
      settings = this.instance.getSettings(),
      rowHeadersCount = settings.rowHeaders ? 1 : 0,
      colHeadersCount = settings.colHeaders ? 1 : 0,
      editorSection = this.checkEditorSection(),
      backgroundColor = this.TD.style.backgroundColor,
      cssTransformOffset;

  // TODO: Refactor this to the new instance.getCell method (from #ply-59), after 0.12.1 is released
  switch (editorSection) {
    case 'top':
      cssTransformOffset = (0, _helpersDomElement.getCssTransform)(this.instance.view.wt.wtOverlays.topOverlay.clone.wtTable.holder.parentNode);
      break;
    case 'left':
      cssTransformOffset = (0, _helpersDomElement.getCssTransform)(this.instance.view.wt.wtOverlays.leftOverlay.clone.wtTable.holder.parentNode);
      break;
    case 'corner':
      cssTransformOffset = (0, _helpersDomElement.getCssTransform)(this.instance.view.wt.wtOverlays.topLeftCornerOverlay.clone.wtTable.holder.parentNode);
      break;
  }

  if (this.instance.getSelected()[0] === 0) {
    editTop += 1;
  }

  if (this.instance.getSelected()[1] === 0) {
    editLeft += 1;
  }

  if (cssTransformOffset && cssTransformOffset != -1) {
    this.textareaParentStyle[cssTransformOffset[0]] = cssTransformOffset[1];
  } else {
    (0, _helpersDomElement.resetCssTransform)(this.textareaParentStyle);
  }

  this.textareaParentStyle.top = editTop + 'px';
  this.textareaParentStyle.left = editLeft + 'px';
  ///end prepare textarea position

  var cellTopOffset = this.TD.offsetTop - this.instance.view.wt.wtOverlays.topOverlay.getScrollPosition(),
      cellLeftOffset = this.TD.offsetLeft - this.instance.view.wt.wtOverlays.leftOverlay.getScrollPosition();

  var width = (0, _helpersDomElement.innerWidth)(this.TD) - 8;
  // 10 is TEXTAREAs padding
  var maxWidth = this.instance.view.maximumVisibleElementWidth(cellLeftOffset) - 9;
  var height = this.TD.scrollHeight + 1;
  // 10 is TEXTAREAs border and padding
  var maxHeight = Math.max(this.instance.view.maximumVisibleElementHeight(cellTopOffset) - 2, 23);

  var cellComputedStyle = (0, _helpersDomElement.getComputedStyle)(this.TD);

  this.TEXTAREA.style.fontSize = cellComputedStyle.fontSize;
  this.TEXTAREA.style.fontFamily = cellComputedStyle.fontFamily;

  this.TEXTAREA.style.backgroundColor = ''; //RESET STYLE

  this.TEXTAREA.style.backgroundColor = backgroundColor ? backgroundColor : (0, _helpersDomElement.getComputedStyle)(this.TEXTAREA).backgroundColor;

  this.autoResize.init(this.TEXTAREA, {
    minHeight: Math.min(height, maxHeight),
    maxHeight: maxHeight, //TEXTAREA should never be wider than visible part of the viewport (should not cover the scrollbar)
    minWidth: Math.min(width, maxWidth),
    maxWidth: maxWidth //TEXTAREA should never be wider than visible part of the viewport (should not cover the scrollbar)
  }, true);

  this.textareaParentStyle.display = 'block';
};

TextEditor.prototype.bindEvents = function () {
  var editor = this;

  this.eventManager.addEventListener(this.TEXTAREA, 'cut', function (event) {
    (0, _helpersDomEvent.stopPropagation)(event);
  });

  this.eventManager.addEventListener(this.TEXTAREA, 'paste', function (event) {
    (0, _helpersDomEvent.stopPropagation)(event);
  });

  this.instance.addHook('afterScrollVertically', function () {
    editor.refreshDimensions();
  });

  this.instance.addHook('afterColumnResize', function () {
    editor.refreshDimensions();
    editor.focus();
  });

  this.instance.addHook('afterRowResize', function () {
    editor.refreshDimensions();
    editor.focus();
  });

  this.instance.addHook('afterDestroy', function () {
    editor.eventManager.destroy();
  });
};

TextEditor.prototype.destroy = function () {
  this.eventManager.destroy();
};

exports.TextEditor = TextEditor;

(0, _editors.registerEditor)('text', TextEditor);

},{"./../editors":34,"./../eventManager":46,"./../helpers/dom/element":50,"./../helpers/dom/event":51,"./../helpers/unicode":58,"./_baseEditor":35,"autoResize":2}],46:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _helpersDomElement = require('./helpers/dom/element');

var _helpersBrowser = require('./helpers/browser');

/**
 * Event DOM manager for internal use in Handsontable.
 *
 * @class EventManager
 * @private
 * @util
 */

var EventManager = (function () {
  /**
   * @param {Object} [context=null]
   */

  function EventManager() {
    var context = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

    _classCallCheck(this, EventManager);

    this.context = context || this;

    if (!this.context.eventListeners) {
      this.context.eventListeners = [];
    }
  }

  /**
   * @param {Object} context
   * @param {Event} event
   * @private
   * @returns {*}
   */

  /**
   * Add event
   *
   * @param {Element} element
   * @param {String} eventName
   * @param {Function} callback
   * @returns {Function} Returns function which you can easily call to remove that event
   */

  _createClass(EventManager, [{
    key: 'addEventListener',
    value: function addEventListener(element, eventName, callback) {
      var _this = this;

      var context = this.context;

      function callbackProxy(event) {
        if (event.target == void 0 && event.srcElement != void 0) {
          if (event.definePoperty) {
            event.definePoperty('target', {
              value: event.srcElement
            });
          } else {
            event.target = event.srcElement;
          }
        }
        if (event.preventDefault == void 0) {
          if (event.definePoperty) {
            event.definePoperty('preventDefault', {
              value: function value() {
                this.returnValue = false;
              }
            });
          } else {
            event.preventDefault = function () {
              this.returnValue = false;
            };
          }
        }
        event = extendEvent(context, event);

        /* jshint validthis:true */
        callback.call(this, event);
      }
      this.context.eventListeners.push({
        element: element,
        event: eventName,
        callback: callback,
        callbackProxy: callbackProxy
      });

      if (window.addEventListener) {
        element.addEventListener(eventName, callbackProxy, false);
      } else {
        element.attachEvent('on' + eventName, callbackProxy);
      }
      Handsontable.countEventManagerListeners++;

      return function () {
        _this.removeEventListener(element, eventName, callback);
      };
    }

    /**
     * Remove event
     *
     * @param {Element} element
     * @param {String} eventName
     * @param {Function} callback
     */
  }, {
    key: 'removeEventListener',
    value: function removeEventListener(element, eventName, callback) {
      var len = this.context.eventListeners.length;
      var tmpEvent = undefined;

      while (len--) {
        tmpEvent = this.context.eventListeners[len];

        if (tmpEvent.event == eventName && tmpEvent.element == element) {
          if (callback && callback != tmpEvent.callback) {
            continue;
          }
          this.context.eventListeners.splice(len, 1);

          if (tmpEvent.element.removeEventListener) {
            tmpEvent.element.removeEventListener(tmpEvent.event, tmpEvent.callbackProxy, false);
          } else {
            tmpEvent.element.detachEvent('on' + tmpEvent.event, tmpEvent.callbackProxy);
          }
          Handsontable.countEventManagerListeners--;
        }
      }
    }

    /**
     * Clear all events
     *
     * @since 0.15.0-beta3
     */
  }, {
    key: 'clearEvents',
    value: function clearEvents() {
      if (!this.context) {
        return;
      }
      var len = this.context.eventListeners.length;

      while (len--) {
        var _event = this.context.eventListeners[len];

        if (_event) {
          this.removeEventListener(_event.element, _event.event, _event.callback);
        }
      }
    }

    /**
     * Clear all events
     */
  }, {
    key: 'clear',
    value: function clear() {
      this.clearEvents();
    }

    /**
     * Destroy instance
     */
  }, {
    key: 'destroy',
    value: function destroy() {
      this.clearEvents();
      this.context = null;
    }

    /**
     * Trigger event
     *
     * @param {Element} element
     * @param {String} eventName
     */
  }, {
    key: 'fireEvent',
    value: function fireEvent(element, eventName) {
      var options = {
        bubbles: true,
        cancelable: eventName !== 'mousemove',
        view: window,
        detail: 0,
        screenX: 0,
        screenY: 0,
        clientX: 1,
        clientY: 1,
        ctrlKey: false,
        altKey: false,
        shiftKey: false,
        metaKey: false,
        button: 0,
        relatedTarget: undefined
      };
      var event;

      if (document.createEvent) {
        event = document.createEvent('MouseEvents');
        event.initMouseEvent(eventName, options.bubbles, options.cancelable, options.view, options.detail, options.screenX, options.screenY, options.clientX, options.clientY, options.ctrlKey, options.altKey, options.shiftKey, options.metaKey, options.button, options.relatedTarget || document.body.parentNode);
      } else {
        event = document.createEventObject();
      }

      if (element.dispatchEvent) {
        element.dispatchEvent(event);
      } else {
        element.fireEvent('on' + eventName, event);
      }
    }
  }]);

  return EventManager;
})();

function extendEvent(context, event) {
  var componentName = 'HOT-TABLE';
  var isHotTableSpotted = undefined;
  var fromElement = undefined;
  var realTarget = undefined;
  var target = undefined;
  var len = undefined;

  event.isTargetWebComponent = false;
  event.realTarget = event.target;

  if (!Handsontable.eventManager.isHotTableEnv) {
    return event;
  }
  event = (0, _helpersDomElement.polymerWrap)(event);
  len = event.path ? event.path.length : 0;

  while (len--) {
    if (event.path[len].nodeName === componentName) {
      isHotTableSpotted = true;
    } else if (isHotTableSpotted && event.path[len].shadowRoot) {
      target = event.path[len];

      break;
    }
    if (len === 0 && !target) {
      target = event.path[len];
    }
  }
  if (!target) {
    target = event.target;
  }
  event.isTargetWebComponent = true;

  if ((0, _helpersBrowser.isWebComponentSupportedNatively)()) {
    event.realTarget = event.srcElement || event.toElement;
  } else if (context instanceof Handsontable.Core || context instanceof Walkontable) {
    // Polymer doesn't support `event.target` property properly we must emulate it ourselves
    if (context instanceof Handsontable.Core) {
      fromElement = context.view ? context.view.wt.wtTable.TABLE : null;
    } else if (context instanceof Walkontable) {
      // .wtHider
      fromElement = context.wtTable.TABLE.parentNode.parentNode;
    }
    realTarget = (0, _helpersDomElement.closest)(event.target, [componentName], fromElement);

    if (realTarget) {
      event.realTarget = fromElement.querySelector(componentName) || event.target;
    } else {
      event.realTarget = event.target;
    }
  }

  Object.defineProperty(event, 'target', {
    get: function get() {
      return (0, _helpersDomElement.polymerWrap)(target);
    },
    enumerable: true,
    configurable: true
  });

  return event;
}

exports.EventManager = EventManager;
exports.eventManager = eventManager;

window.Handsontable = window.Handsontable || {};
// used to debug memory leaks
Handsontable.countEventManagerListeners = 0;
// support for older versions of Handsontable, deprecated
Handsontable.eventManager = eventManager;

function eventManager(context) {
  return new EventManager(context);
}

},{"./helpers/browser":48,"./helpers/dom/element":50}],47:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.to2dArray = to2dArray;
exports.extendArray = extendArray;
exports.pivot = pivot;
exports.arrayFilter = arrayFilter;
exports.arrayEach = arrayEach;
exports.arraySum = arraySum;
exports.arrayAvg = arrayAvg;

function to2dArray(arr) {
  var i = 0,
      ilen = arr.length;
  while (i < ilen) {
    arr[i] = [arr[i]];
    i++;
  }
}

function extendArray(arr, extension) {
  var i = 0,
      ilen = extension.length;
  while (i < ilen) {
    arr.push(extension[i]);
    i++;
  }
}

function pivot(arr) {
  var pivotedArr = [];

  if (!arr || arr.length === 0 || !arr[0] || arr[0].length === 0) {
    return pivotedArr;
  }

  var rowCount = arr.length;
  var colCount = arr[0].length;

  for (var i = 0; i < rowCount; i++) {
    for (var j = 0; j < colCount; j++) {
      if (!pivotedArr[j]) {
        pivotedArr[j] = [];
      }

      pivotedArr[j][i] = arr[i][j];
    }
  }

  return pivotedArr;
}

/**
 * A specialized version of `.reduce` for arrays without support for callback
 * shorthands and `this` binding.
 *
 * {@link https://github.com/lodash/lodash/blob/master/lodash.js}
 *
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {Boolean} [initFromArray] Specify using the first element of `array` as the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initFromArray) {
  var index = -1,
      length = array.length;

  if (initFromArray && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }

  return accumulator;
}

/**
 * A specialized version of `.filter` for arrays without support for callback
 * shorthands and `this` binding.
 *
 * {@link https://github.com/lodash/lodash/blob/master/lodash.js}
 *
 * @param {Array} array The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */

function arrayFilter(array, predicate) {
  var index = -1,
      length = array.length,
      resIndex = -1,
      result = [];

  while (++index < length) {
    var value = array[index];

    if (predicate(value, index, array)) {
      result[++resIndex] = value;
    }
  }

  return result;
}

/**
 * A specialized version of `.forEach` for arrays without support for callback
 * shorthands and `this` binding.
 *
 * {@link https://github.com/lodash/lodash/blob/master/lodash.js}
 *
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */

function arrayEach(array, iteratee) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }

  return array;
}

/**
 * Calculate sum value for each item of the array.
 *
 * @param {Array} array The array to process.
 * @returns {Number} Returns calculated sum value.
 */

function arraySum(array) {
  return arrayReduce(array, function (a, b) {
    return a + b;
  }, 0);
}

/**
 * Calculate average value for each item of the array.
 *
 * @param {Array} array The array to process.
 * @returns {Number} Returns calculated average value.
 */

function arrayAvg(array) {
  if (!array.length) {
    return 0;
  }

  return arraySum(array) / array.length;
}

},{}],48:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.isIE8 = isIE8;
exports.isIE9 = isIE9;
exports.isSafari = isSafari;
exports.isChrome = isChrome;
exports.isMobileBrowser = isMobileBrowser;
exports.isTouchSupported = isTouchSupported;
exports.isWebComponentSupportedNatively = isWebComponentSupportedNatively;
exports.hasCaptionProblem = hasCaptionProblem;

var _isIE8 = !document.createTextNode('test').textContent;

function isIE8() {
  return _isIE8;
}

var _isIE9 = !!document.documentMode;

function isIE9() {
  return _isIE9;
}

var _isSafari = /Safari/.test(navigator.userAgent) && /Apple Computer/.test(navigator.vendor);

function isSafari() {
  return _isSafari;
}

var _isChrome = /Chrome/.test(navigator.userAgent) && /Google/.test(navigator.vendor);

function isChrome() {
  return _isChrome;
}

function isMobileBrowser(userAgent) {
  if (!userAgent) {
    userAgent = navigator.userAgent;
  }

  return (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)
  );
}

function isTouchSupported() {
  return 'ontouchstart' in window;
}

/**
 * Checks if browser is support web components natively
 *
 * @returns {Boolean}
 */

function isWebComponentSupportedNatively() {
  var test = document.createElement('div');

  return test.createShadowRoot && test.createShadowRoot.toString().match(/\[native code\]/) ? true : false;
}

var _hasCaptionProblem;

function detectCaptionProblem() {
  var TABLE = document.createElement('TABLE');
  TABLE.style.borderSpacing = 0;
  TABLE.style.borderWidth = 0;
  TABLE.style.padding = 0;
  var TBODY = document.createElement('TBODY');
  TABLE.appendChild(TBODY);
  TBODY.appendChild(document.createElement('TR'));
  TBODY.firstChild.appendChild(document.createElement('TD'));
  TBODY.firstChild.firstChild.innerHTML = '<tr><td>t<br>t</td></tr>';

  var CAPTION = document.createElement('CAPTION');
  CAPTION.innerHTML = 'c<br>c<br>c<br>c';
  CAPTION.style.padding = 0;
  CAPTION.style.margin = 0;
  TABLE.insertBefore(CAPTION, TBODY);

  document.body.appendChild(TABLE);
  _hasCaptionProblem = TABLE.offsetHeight < 2 * TABLE.lastChild.offsetHeight; //boolean
  document.body.removeChild(TABLE);
}

function hasCaptionProblem() {
  if (_hasCaptionProblem === void 0) {
    detectCaptionProblem();
  }

  return _hasCaptionProblem;
}

},{}],49:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.spreadsheetColumnLabel = spreadsheetColumnLabel;
exports.createSpreadsheetData = createSpreadsheetData;
exports.createSpreadsheetObjectData = createSpreadsheetObjectData;
exports.translateRowsToColumns = translateRowsToColumns;
exports.cellMethodLookupFactory = cellMethodLookupFactory;

var _object = require('./object');

/**
 * Generates spreadsheet-like column names: A, B, C, ..., Z, AA, AB, etc
 * @param index
 * @returns {String}
 */

function spreadsheetColumnLabel(index) {
  var dividend = index + 1;
  var columnLabel = '';
  var modulo;
  while (dividend > 0) {
    modulo = (dividend - 1) % 26;
    columnLabel = String.fromCharCode(65 + modulo) + columnLabel;
    dividend = parseInt((dividend - modulo) / 26, 10);
  }
  return columnLabel;
}

/**
 * Creates 2D array of Excel-like values "A1", "A2", ...
 * @param rowCount
 * @param colCount
 * @returns {Array}
 */

function createSpreadsheetData(rowCount, colCount) {
  rowCount = typeof rowCount === 'number' ? rowCount : 100;
  colCount = typeof colCount === 'number' ? colCount : 4;

  var rows = [],
      i,
      j;

  for (i = 0; i < rowCount; i++) {
    var row = [];
    for (j = 0; j < colCount; j++) {
      row.push(spreadsheetColumnLabel(j) + (i + 1));
    }
    rows.push(row);
  }
  return rows;
}

function createSpreadsheetObjectData(rowCount, colCount) {
  rowCount = typeof rowCount === 'number' ? rowCount : 100;
  colCount = typeof colCount === 'number' ? colCount : 4;

  var rows = [],
      i,
      j;

  for (i = 0; i < rowCount; i++) {
    var row = {};
    for (j = 0; j < colCount; j++) {
      row['prop' + j] = spreadsheetColumnLabel(j) + (i + 1);
    }
    rows.push(row);
  }
  return rows;
}

function translateRowsToColumns(input) {
  var i,
      ilen,
      j,
      jlen,
      output = [],
      olen = 0;

  for (i = 0, ilen = input.length; i < ilen; i++) {
    for (j = 0, jlen = input[i].length; j < jlen; j++) {
      if (j == olen) {
        output.push([]);
        olen++;
      }
      output[j].push(input[i][j]);
    }
  }
  return output;
}

/**
 * Factory that produces a function for searching methods (or any properties) which could be defined directly in
 * table configuration or implicitly, within cell type definition.
 *
 * For example: renderer can be defined explicitly using "renderer" property in column configuration or it can be
 * defined implicitly using "type" property.
 *
 * Methods/properties defined explicitly always takes precedence over those defined through "type".
 *
 * If the method/property is not found in an object, searching is continued recursively through prototype chain, until
 * it reaches the Object.prototype.
 *
 *
 * @param methodName {String} name of the method/property to search (i.e. 'renderer', 'validator', 'copyable')
 * @param allowUndefined {Boolean} [optional] if false, the search is continued if methodName has not been found in cell "type"
 * @returns {Function}
 */

function cellMethodLookupFactory(methodName, allowUndefined) {

  allowUndefined = typeof allowUndefined == 'undefined' ? true : allowUndefined;

  return function cellMethodLookup(row, col) {

    return (function getMethodFromProperties(_x) {
      var _again = true;

      _function: while (_again) {
        var properties = _x;
        type = undefined;
        _again = false;

        if (!properties) {

          return; //method not found
        } else if (properties.hasOwnProperty(methodName) && properties[methodName] !== void 0) {
            //check if it is own and is not empty

            return properties[methodName]; //method defined directly
          } else if (properties.hasOwnProperty('type') && properties.type) {
              //check if it is own and is not empty

              var type;

              if (typeof properties.type != 'string') {
                throw new Error('Cell type must be a string ');
              }

              type = translateTypeNameToObject(properties.type);

              if (type.hasOwnProperty(methodName)) {
                return type[methodName]; //method defined in type.
              } else if (allowUndefined) {
                  return; //method does not defined in type (eg. validator), returns undefined
                }
            }

        _x = (0, _object.getPrototypeOf)(properties);
        _again = true;
        continue _function;
      }
    })(typeof row == 'number' ? this.getCellMeta(row, col) : row);
  };

  function translateTypeNameToObject(typeName) {
    var type = Handsontable.cellTypes[typeName];

    if (typeof type == 'undefined') {
      throw new Error('You declared cell type "' + typeName + '" as a string that is not mapped to a known object. ' + 'Cell type must be an object or a string mapped to an object in Handsontable.cellTypes');
    }

    return type;
  }
}

},{"./object":55}],50:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.closest = closest;
exports.isChildOf = isChildOf;
exports.isChildOfWebComponentTable = isChildOfWebComponentTable;
exports.polymerWrap = polymerWrap;
exports.polymerUnwrap = polymerUnwrap;
exports.index = index;
exports.overlayContainsElement = overlayContainsElement;
exports.hasClass = hasClass;
exports.addClass = addClass;
exports.removeClass = removeClass;
exports.removeTextNodes = removeTextNodes;
exports.empty = empty;
exports.fastInnerHTML = fastInnerHTML;
exports.fastInnerText = fastInnerText;
exports.isVisible = isVisible;
exports.offset = offset;
exports.getWindowScrollTop = getWindowScrollTop;
exports.getWindowScrollLeft = getWindowScrollLeft;
exports.getScrollTop = getScrollTop;
exports.getScrollLeft = getScrollLeft;
exports.getScrollableElement = getScrollableElement;
exports.getTrimmingContainer = getTrimmingContainer;
exports.getStyle = getStyle;
exports.getComputedStyle = getComputedStyle;
exports.outerWidth = outerWidth;
exports.outerHeight = outerHeight;
exports.innerHeight = innerHeight;
exports.innerWidth = innerWidth;
exports.addEvent = addEvent;
exports.removeEvent = removeEvent;
exports.getCaretPosition = getCaretPosition;
exports.getSelectionEndPosition = getSelectionEndPosition;
exports.setCaretPosition = setCaretPosition;
exports.getScrollbarWidth = getScrollbarWidth;
exports.setOverlayPosition = setOverlayPosition;
exports.getCssTransform = getCssTransform;
exports.resetCssTransform = resetCssTransform;
exports.isInput = isInput;
exports.isOutsideInput = isOutsideInput;
exports.requestAnimationFrame = requestAnimationFrame;
exports.cancelAnimationFrame = cancelAnimationFrame;

var _browser = require('../browser');

/**
 * Goes up the DOM tree (including given element) until it finds an element that matches the nodes or nodes name.
 * This method goes up through web components.
 *
 * @param {HTMLElement} element Element from which traversing is started
 * @param {Array} nodes Array of elements or Array of elements name
 * @param {HTMLElement} [until]
 * @returns {HTMLElement|null}
 */

function closest(element, nodes, until) {
  while (element != null && element !== until) {
    if (element.nodeType === Node.ELEMENT_NODE && (nodes.indexOf(element.nodeName) > -1 || nodes.indexOf(element) > -1)) {
      return element;
    }
    if (element.host && element.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      element = element.host;
    } else {
      element = element.parentNode;
    }
  }

  return null;
}

/**
 * Goes up the DOM tree and checks if element is child of another element.
 *
 * @param child Child element
 * @param {Object|String} parent Parent element OR selector of the parent element.
 *                               If string provided, function returns `true` for the first occurance of element with that class.
 * @returns {Boolean}
 */

function isChildOf(child, parent) {
  var node = child.parentNode;
  var queriedParents = [];

  if (typeof parent === "string") {
    queriedParents = Array.prototype.slice.call(document.querySelectorAll(parent), 0);
  } else {
    queriedParents.push(parent);
  }

  while (node != null) {
    if (queriedParents.indexOf(node) > -1) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
}

/**
 * Check if an element is part of `hot-table` web component.
 *
 * @param {Element} element
 * @returns {Boolean}
 */

function isChildOfWebComponentTable(element) {
  var hotTableName = 'hot-table',
      result = false,
      parentNode;

  parentNode = polymerWrap(element);

  function isHotTable(element) {
    return element.nodeType === Node.ELEMENT_NODE && element.nodeName === hotTableName.toUpperCase();
  }

  while (parentNode != null) {
    if (isHotTable(parentNode)) {
      result = true;
      break;
    } else if (parentNode.host && parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      result = isHotTable(parentNode.host);

      if (result) {
        break;
      }
      parentNode = parentNode.host;
    }
    parentNode = parentNode.parentNode;
  }

  return result;
}

/**
 * Wrap element into polymer/webcomponent container if exists
 *
 * @param element
 * @returns {*}
 */

function polymerWrap(element) {
  /* global Polymer */
  return typeof Polymer !== 'undefined' && typeof wrap === 'function' ? wrap(element) : element;
}

/**
 * Unwrap element from polymer/webcomponent container if exists
 *
 * @param element
 * @returns {*}
 */

function polymerUnwrap(element) {
  /* global Polymer */
  return typeof Polymer !== 'undefined' && typeof unwrap === 'function' ? unwrap(element) : element;
}

/**
 * Counts index of element within its parent
 * WARNING: for performance reasons, assumes there are only element nodes (no text nodes). This is true for Walkotnable
 * Otherwise would need to check for nodeType or use previousElementSibling
 *
 * @see http://jsperf.com/sibling-index/10
 * @param {Element} element
 * @return {Number}
 */

function index(element) {
  var i = 0;

  if (element.previousSibling) {
    /* jshint ignore:start */
    while (element = element.previousSibling) {
      ++i;
    }
    /* jshint ignore:end */
  }

  return i;
}

/**
 * Check if the provided overlay contains the provided element
 *
 * @param {String} overlay
 * @param {HTMLElement} element
 * @returns {boolean}
 */

function overlayContainsElement(overlayType, element) {
  var overlayElement = document.querySelector('.ht_clone_' + overlayType);
  return overlayElement ? overlayElement.contains(element) : null;
}

var classListSupport = document.documentElement.classList ? true : false;
var _hasClass, _addClass, _removeClass;

function filterEmptyClassNames(classNames) {
  var len = 0,
      result = [];

  if (!classNames || !classNames.length) {
    return result;
  }
  while (classNames[len]) {
    result.push(classNames[len]);
    len++;
  }

  return result;
}

if (classListSupport) {
  var isSupportMultipleClassesArg = (function () {
    var element = document.createElement('div');

    element.classList.add('test', 'test2');

    return element.classList.contains('test2');
  })();

  _hasClass = function _hasClass(element, className) {
    if (className === '') {
      return false;
    }

    return element.classList.contains(className);
  };

  _addClass = function _addClass(element, className) {
    var len = 0;

    if (typeof className === 'string') {
      className = className.split(' ');
    }
    className = filterEmptyClassNames(className);

    if (isSupportMultipleClassesArg) {
      element.classList.add.apply(element.classList, className);
    } else {
      while (className && className[len]) {
        element.classList.add(className[len]);
        len++;
      }
    }
  };

  _removeClass = function _removeClass(element, className) {
    var len = 0;

    if (typeof className === 'string') {
      className = className.split(' ');
    }
    className = filterEmptyClassNames(className);

    if (isSupportMultipleClassesArg) {
      element.classList.remove.apply(element.classList, className);
    } else {
      while (className && className[len]) {
        element.classList.remove(className[len]);
        len++;
      }
    }
  };
} else {
  var createClassNameRegExp = function createClassNameRegExp(className) {
    return new RegExp('(\\s|^)' + className + '(\\s|$)');
  };

  _hasClass = function _hasClass(element, className) {
    // http://snipplr.com/view/3561/addclass-removeclass-hasclass/
    return element.className.match(createClassNameRegExp(className)) ? true : false;
  };

  _addClass = function _addClass(element, className) {
    var len = 0,
        _className = element.className;

    if (typeof className === 'string') {
      className = className.split(' ');
    }
    if (_className === '') {
      _className = className.join(' ');
    } else {
      while (className && className[len]) {
        if (!createClassNameRegExp(className[len]).test(_className)) {
          _className += ' ' + className[len];
        }
        len++;
      }
    }
    element.className = _className;
  };

  _removeClass = function _removeClass(element, className) {
    var len = 0,
        _className = element.className;

    if (typeof className === 'string') {
      className = className.split(' ');
    }
    while (className && className[len]) {
      // String.prototype.trim is defined in polyfill.js
      _className = _className.replace(createClassNameRegExp(className[len]), ' ').trim();
      len++;
    }
    if (element.className !== _className) {
      element.className = _className;
    }
  };
}

/**
 * Checks if element has class name
 *
 * @param {HTMLElement} element
 * @param {String} className Class name to check
 * @returns {Boolean}
 */

function hasClass(element, className) {
  return _hasClass(element, className);
}

/**
 * Add class name to an element
 *
 * @param {HTMLElement} element
 * @param {String|Array} className Class name as string or array of strings
 */

function addClass(element, className) {
  return _addClass(element, className);
}

/**
 * Remove class name from an element
 *
 * @param {HTMLElement} element
 * @param {String|Array} className Class name as string or array of strings
 */

function removeClass(element, className) {
  return _removeClass(element, className);
}

function removeTextNodes(element, parent) {
  if (element.nodeType === 3) {
    parent.removeChild(element); //bye text nodes!
  } else if (['TABLE', 'THEAD', 'TBODY', 'TFOOT', 'TR'].indexOf(element.nodeName) > -1) {
      var childs = element.childNodes;
      for (var i = childs.length - 1; i >= 0; i--) {
        removeTextNodes(childs[i], element);
      }
    }
}

/**
 * Remove childs function
 * WARNING - this doesn't unload events and data attached by jQuery
 * http://jsperf.com/jquery-html-vs-empty-vs-innerhtml/9
 * http://jsperf.com/jquery-html-vs-empty-vs-innerhtml/11 - no siginificant improvement with Chrome remove() method
 *
 * @param element
 * @returns {void}
 */
//

function empty(element) {
  var child;
  /* jshint ignore:start */
  while (child = element.lastChild) {
    element.removeChild(child);
  }
  /* jshint ignore:end */
}

var HTML_CHARACTERS = /(<(.*)>|&(.*);)/;

exports.HTML_CHARACTERS = HTML_CHARACTERS;
/**
 * Insert content into element trying avoid innerHTML method.
 * @return {void}
 */

function fastInnerHTML(element, content) {
  if (HTML_CHARACTERS.test(content)) {
    element.innerHTML = content;
  } else {
    fastInnerText(element, content);
  }
}

/**
 * Insert text content into element
 * @return {void}
 */

var textContextSupport = document.createTextNode('test').textContent ? true : false;

function fastInnerText(element, content) {
  var child = element.firstChild;

  if (child && child.nodeType === 3 && child.nextSibling === null) {
    // fast lane - replace existing text node

    if (textContextSupport) {
      // http://jsperf.com/replace-text-vs-reuse
      child.textContent = content;
    } else {
      // http://jsperf.com/replace-text-vs-reuse
      child.data = content;
    }
  } else {
    //slow lane - empty element and insert a text node
    empty(element);
    element.appendChild(document.createTextNode(content));
  }
}

/**
 * Returns true if element is attached to the DOM and visible, false otherwise
 * @param elem
 * @returns {boolean}
 */

function isVisible(_x) {
  var _again = true;

  _function: while (_again) {
    var elem = _x;
    next = undefined;
    _again = false;

    var next = elem;

    while (polymerUnwrap(next) !== document.documentElement) {
      //until <html> reached
      if (next === null) {
        //parent detached from DOM
        return false;
      } else if (next.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        if (next.host) {
          //this is Web Components Shadow DOM
          //see: http://w3c.github.io/webcomponents/spec/shadow/#encapsulation
          //according to spec, should be if (next.ownerDocument !== window.document), but that doesn't work yet
          if (next.host.impl) {
            //Chrome 33.0.1723.0 canary (2013-11-29) Web Platform features disabled
            _x = next.host.impl;
            _again = true;
            continue _function;
          } else if (next.host) {
            //Chrome 33.0.1723.0 canary (2013-11-29) Web Platform features enabled
            _x = next.host;
            _again = true;
            continue _function;
          } else {
            throw new Error("Lost in Web Components world");
          }
        } else {
          return false; //this is a node detached from document in IE8
        }
      } else if (next.style.display === 'none') {
          return false;
        }
      next = next.parentNode;
    }

    return true;
  }
}

/**
 * Returns elements top and left offset relative to the document. Function is not compatible with jQuery offset.
 *
 * @param {HTMLElement} elem
 * @return {Object} Returns object with `top` and `left` props
 */

function offset(elem) {
  var offsetLeft, offsetTop, lastElem, docElem, box;

  docElem = document.documentElement;

  if ((0, _browser.hasCaptionProblem)() && elem.firstChild && elem.firstChild.nodeName === 'CAPTION') {
    // fixes problem with Firefox ignoring <caption> in TABLE offset (see also export outerHeight)
    // http://jsperf.com/offset-vs-getboundingclientrect/8
    box = elem.getBoundingClientRect();

    return {
      top: box.top + (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
      left: box.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
    };
  }
  offsetLeft = elem.offsetLeft;
  offsetTop = elem.offsetTop;
  lastElem = elem;

  /* jshint ignore:start */
  while (elem = elem.offsetParent) {
    // from my observation, document.body always has scrollLeft/scrollTop == 0
    if (elem === document.body) {
      break;
    }
    offsetLeft += elem.offsetLeft;
    offsetTop += elem.offsetTop;
    lastElem = elem;
  }
  /* jshint ignore:end */

  //slow - http://jsperf.com/offset-vs-getboundingclientrect/6
  if (lastElem && lastElem.style.position === 'fixed') {
    //if(lastElem !== document.body) { //faster but does gives false positive in Firefox
    offsetLeft += window.pageXOffset || docElem.scrollLeft;
    offsetTop += window.pageYOffset || docElem.scrollTop;
  }

  return {
    left: offsetLeft,
    top: offsetTop
  };
}

/**
 * Returns the document's scrollTop property.
 *
 * @returns {Number}
 */

function getWindowScrollTop() {
  var res = window.scrollY;

  if (res === void 0) {
    //IE8-11
    res = document.documentElement.scrollTop;
  }

  return res;
}

/**
 * Returns the document's scrollLeft property.
 *
 * @returns {Number}
 */

function getWindowScrollLeft() {
  var res = window.scrollX;

  if (res === void 0) {
    //IE8-11
    res = document.documentElement.scrollLeft;
  }

  return res;
}

/**
 * Returns the provided element's scrollTop property.
 *
 * @param element
 * @returns {Number}
 */

function getScrollTop(element) {
  if (element === window) {
    return getWindowScrollTop();
  } else {
    return element.scrollTop;
  }
}

/**
 * Returns the provided element's scrollLeft property.
 *
 * @param element
 * @returns {Number}
 */

function getScrollLeft(element) {
  if (element === window) {
    return getWindowScrollLeft();
  } else {
    return element.scrollLeft;
  }
}

/**
 * Returns a DOM element responsible for scrolling of the provided element.
 *
 * @param {HTMLElement} element
 * @returns {HTMLElement} Element's scrollable parent
 */

function getScrollableElement(element) {
  var el = element.parentNode,
      props = ['auto', 'scroll'],
      overflow,
      overflowX,
      overflowY,
      computedStyle = '',
      computedOverflow = '',
      computedOverflowY = '',
      computedOverflowX = '';

  while (el && el.style && document.body !== el) {
    overflow = el.style.overflow;
    overflowX = el.style.overflowX;
    overflowY = el.style.overflowY;

    if (overflow == 'scroll' || overflowX == 'scroll' || overflowY == 'scroll') {
      return el;
    } else if (window.getComputedStyle) {
      computedStyle = window.getComputedStyle(el);
      computedOverflow = computedStyle.getPropertyValue('overflow');
      computedOverflowY = computedStyle.getPropertyValue('overflow-y');
      computedOverflowX = computedStyle.getPropertyValue('overflow-x');

      if (computedOverflow === 'scroll' || computedOverflowX === 'scroll' || computedOverflowY === 'scroll') {
        return el;
      }
    }

    if (el.clientHeight <= el.scrollHeight && (props.indexOf(overflowY) !== -1 || props.indexOf(overflow) !== -1 || props.indexOf(computedOverflow) !== -1 || props.indexOf(computedOverflowY) !== -1)) {
      return el;
    }
    if (el.clientWidth <= el.scrollWidth && (props.indexOf(overflowX) !== -1 || props.indexOf(overflow) !== -1 || props.indexOf(computedOverflow) !== -1 || props.indexOf(computedOverflowX) !== -1)) {
      return el;
    }
    el = el.parentNode;
  }

  return window;
}

/**
 * Returns a DOM element responsible for trimming the provided element.
 *
 * @param {HTMLElement} base Base element
 * @returns {HTMLElement} Base element's trimming parent
 */

function getTrimmingContainer(base) {
  var el = base.parentNode;

  while (el && el.style && document.body !== el) {
    if (el.style.overflow !== 'visible' && el.style.overflow !== '') {
      return el;
    } else if (window.getComputedStyle) {
      var computedStyle = window.getComputedStyle(el);

      if (computedStyle.getPropertyValue('overflow') !== 'visible' && computedStyle.getPropertyValue('overflow') !== '') {
        return el;
      }
    }

    el = el.parentNode;
  }

  return window;
}

/**
 * Returns a style property for the provided element. (Be it an inline or external style).
 *
 * @param {HTMLElement} element
 * @param {string} prop Wanted property
 * @returns {string} Element's style property
 */

function getStyle(element, prop) {
  if (!element) {
    return;
  } else if (element === window) {
    if (prop === 'width') {
      return window.innerWidth + 'px';
    } else if (prop === 'height') {
      return window.innerHeight + 'px';
    }
    return;
  }

  var styleProp = element.style[prop],
      computedStyle;
  if (styleProp !== "" && styleProp !== void 0) {
    return styleProp;
  } else {
    computedStyle = getComputedStyle(element);
    if (computedStyle[prop] !== "" && computedStyle[prop] !== void 0) {
      return computedStyle[prop];
    }
    return void 0;
  }
}

/**
 * Returns a computed style object for the provided element. (Needed if style is declared in external stylesheet).
 *
 * @param element
 * @returns {IEElementStyle|CssStyle} Elements computed style object
 */

function getComputedStyle(element) {
  return element.currentStyle || document.defaultView.getComputedStyle(element);
}

/**
 * Returns the element's outer width.
 *
 * @param element
 * @returns {number} Element's outer width
 */

function outerWidth(element) {
  return element.offsetWidth;
}

/**
 * Returns the element's outer height
 * @param elem
 * @returns {number} Element's outer height
 */

function outerHeight(elem) {
  if ((0, _browser.hasCaptionProblem)() && elem.firstChild && elem.firstChild.nodeName === 'CAPTION') {
    //fixes problem with Firefox ignoring <caption> in TABLE.offsetHeight
    //jQuery (1.10.1) still has this unsolved
    //may be better to just switch to getBoundingClientRect
    //http://bililite.com/blog/2009/03/27/finding-the-size-of-a-table/
    //http://lists.w3.org/Archives/Public/www-style/2009Oct/0089.html
    //http://bugs.jquery.com/ticket/2196
    //http://lists.w3.org/Archives/Public/www-style/2009Oct/0140.html#start140
    return elem.offsetHeight + elem.firstChild.offsetHeight;
  } else {
    return elem.offsetHeight;
  }
}

/**
 * Returns the element's inner height.
 *
 * @param element
 * @returns {number} Element's inner height
 */

function innerHeight(element) {
  return element.clientHeight || element.innerHeight;
}

/**
 * Returns the element's inner width.
 *
 * @param element
 * @returns {number} Element's inner width
 */

function innerWidth(element) {
  return element.clientWidth || element.innerWidth;
}

function addEvent(element, event, callback) {
  if (window.addEventListener) {
    element.addEventListener(event, callback, false);
  } else {
    element.attachEvent('on' + event, callback);
  }
}

function removeEvent(element, event, callback) {
  if (window.removeEventListener) {
    element.removeEventListener(event, callback, false);
  } else {
    element.detachEvent('on' + event, callback);
  }
}

/**
 * Returns caret position in text input
 *
 * @author http://stackoverflow.com/questions/263743/how-to-get-caret-position-in-textarea
 * @return {Number}
 */

function getCaretPosition(el) {
  if (el.selectionStart) {
    return el.selectionStart;
  } else if (document.selection) {
    // IE8
    el.focus();

    var r = document.selection.createRange();

    if (r == null) {
      return 0;
    }
    var re = el.createTextRange();
    var rc = re.duplicate();

    re.moveToBookmark(r.getBookmark());
    rc.setEndPoint('EndToStart', re);

    return rc.text.length;
  }

  return 0;
}

/**
 * Returns end of the selection in text input
 *
 * @return {Number}
 */

function getSelectionEndPosition(el) {
  if (el.selectionEnd) {
    return el.selectionEnd;
  } else if (document.selection) {
    //IE8
    var r = document.selection.createRange();

    if (r == null) {
      return 0;
    }
    var re = el.createTextRange();

    return re.text.indexOf(r.text) + r.text.length;
  }
}

/**
 * Sets caret position in text input.
 *
 * @author http://blog.vishalon.net/index.php/javascript-getting-and-setting-caret-position-in-textarea/
 * @param {Element} element
 * @param {Number} pos
 * @param {Number} endPos
 */

function setCaretPosition(element, pos, endPos) {
  if (endPos === void 0) {
    endPos = pos;
  }
  if (element.setSelectionRange) {
    element.focus();

    try {
      element.setSelectionRange(pos, endPos);
    } catch (err) {
      var elementParent = element.parentNode;
      var parentDisplayValue = elementParent.style.display;
      elementParent.style.display = 'block';
      element.setSelectionRange(pos, endPos);
      elementParent.style.display = parentDisplayValue;
    }
  } else if (element.createTextRange) {
    //IE8
    var range = element.createTextRange();
    range.collapse(true);
    range.moveEnd('character', endPos);
    range.moveStart('character', pos);
    range.select();
  }
}

var cachedScrollbarWidth;

//http://stackoverflow.com/questions/986937/how-can-i-get-the-browsers-scrollbar-sizes
function walkontableCalculateScrollbarWidth() {
  var inner = document.createElement('p');
  inner.style.width = "100%";
  inner.style.height = "200px";

  var outer = document.createElement('div');
  outer.style.position = "absolute";
  outer.style.top = "0px";
  outer.style.left = "0px";
  outer.style.visibility = "hidden";
  outer.style.width = "200px";
  outer.style.height = "150px";
  outer.style.overflow = "hidden";
  outer.appendChild(inner);

  (document.body || document.documentElement).appendChild(outer);
  var w1 = inner.offsetWidth;
  outer.style.overflow = 'scroll';
  var w2 = inner.offsetWidth;
  if (w1 == w2) {
    w2 = outer.clientWidth;
  }

  (document.body || document.documentElement).removeChild(outer);

  return w1 - w2;
}

/**
 * Returns the computed width of the native browser scroll bar.
 *
 * @return {Number} width
 */

function getScrollbarWidth() {
  if (cachedScrollbarWidth === void 0) {
    cachedScrollbarWidth = walkontableCalculateScrollbarWidth();
  }

  return cachedScrollbarWidth;
}

/**
 * Sets overlay position depending on it's type and used browser
 */

function setOverlayPosition(overlayElem, left, top) {
  if ((0, _browser.isIE8)() || (0, _browser.isIE9)()) {
    overlayElem.style.top = top;
    overlayElem.style.left = left;
  } else if ((0, _browser.isSafari)()) {
    /* jshint sub:true */
    overlayElem.style['-webkit-transform'] = 'translate3d(' + left + ',' + top + ',0)';
  } else {
    overlayElem.style.transform = 'translate3d(' + left + ',' + top + ',0)';
  }
}

function getCssTransform(element) {
  var transform;

  /* jshint sub:true */
  if (element.style['transform'] && (transform = element.style['transform']) !== '') {
    return ['transform', transform];
  } else if (element.style['-webkit-transform'] && (transform = element.style['-webkit-transform']) !== '') {

    return ['-webkit-transform', transform];
  }

  return -1;
}

function resetCssTransform(element) {
  /* jshint sub:true */
  if (element['transform'] && element['transform'] !== '') {
    element['transform'] = '';
  } else if (element['-webkit-transform'] && element['-webkit-transform'] !== '') {
    element['-webkit-transform'] = '';
  }
}

/**
 * Determines if the given DOM element is an input field.
 * Notice: By 'input' we mean input, textarea and select nodes
 * @param element - DOM element
 * @returns {boolean}
 */

function isInput(element) {
  var inputs = ['INPUT', 'SELECT', 'TEXTAREA'];

  return inputs.indexOf(element.nodeName) > -1 || element.contentEditable === 'true';
}

/**
 * Determines if the given DOM element is an input field placed OUTSIDE of HOT.
 * Notice: By 'input' we mean input, textarea and select nodes
 * @param element - DOM element
 * @returns {boolean}
 */

function isOutsideInput(element) {
  return isInput(element) && element.className.indexOf('handsontableInput') == -1 && element.className.indexOf('copyPaste') == -1;
}

// https://gist.github.com/paulirish/1579671
var lastTime = 0;
var vendors = ['ms', 'moz', 'webkit', 'o'];
var _requestAnimationFrame = window.requestAnimationFrame;
var _cancelAnimationFrame = window.cancelAnimationFrame;

for (var x = 0; x < vendors.length && !_requestAnimationFrame; ++x) {
  _requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
  _cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
}

if (!_requestAnimationFrame) {
  _requestAnimationFrame = function (callback) {
    var currTime = new Date().getTime();
    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
    var id = window.setTimeout(function () {
      callback(currTime + timeToCall);
    }, timeToCall);
    lastTime = currTime + timeToCall;

    return id;
  };
}

if (!_cancelAnimationFrame) {
  _cancelAnimationFrame = function (id) {
    clearTimeout(id);
  };
}

/**
 * Polyfill for requestAnimationFrame
 *
 * @param {Function} callback
 * @returns {Number}
 */

function requestAnimationFrame(callback) {
  return _requestAnimationFrame.call(window, callback);
}

/**
 * Polyfill for cancelAnimationFrame
 *
 * @param {Number} id
 */

function cancelAnimationFrame(id) {
  _cancelAnimationFrame.call(window, id);
}

},{"../browser":48}],51:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.stopImmediatePropagation = stopImmediatePropagation;
exports.isImmediatePropagationStopped = isImmediatePropagationStopped;
exports.stopPropagation = stopPropagation;
exports.pageX = pageX;
exports.pageY = pageY;

function stopImmediatePropagation(event) {
  event.isImmediatePropagationEnabled = false;
  event.cancelBubble = true;
}

function isImmediatePropagationStopped(event) {
  return event.isImmediatePropagationEnabled === false;
}

function stopPropagation(event) {
  // ie8
  //http://msdn.microsoft.com/en-us/library/ie/ff975462(v=vs.85).aspx
  if (typeof event.stopPropagation === 'function') {
    event.stopPropagation();
  } else {
    event.cancelBubble = true;
  }
}

function pageX(event) {
  if (event.pageX) {
    return event.pageX;
  }

  var scrollLeft = getWindowScrollLeft();
  var cursorX = event.clientX + scrollLeft;

  return cursorX;
}

function pageY(event) {
  if (event.pageY) {
    return event.pageY;
  }

  var scrollTop = getWindowScrollTop();
  var cursorY = event.clientY + scrollTop;

  return cursorY;
}

},{}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.proxy = proxy;
exports.throttle = throttle;
exports.throttleAfterHits = throttleAfterHits;

function proxy(fun, context) {
  return function () {
    return fun.apply(context, arguments);
  };
}

/**
 * Creates throttle function that invokes `func` only once per `wait` (in miliseconds).
 *
 * @param {Function} func
 * @param {Number} wait
 * @returns {Function}
 */

function throttle(func) {
  var wait = arguments.length <= 1 || arguments[1] === undefined ? 200 : arguments[1];

  var lastCalled = 0;
  var result = {
    lastCallThrottled: true
  };
  var lastTimer = null;

  function _throttle() {
    var _this = this;

    var args = arguments;
    var stamp = Date.now();
    var needCall = false;

    result.lastCallThrottled = true;

    if (!lastCalled) {
      lastCalled = stamp;
      needCall = true;
    }
    var remaining = wait - (stamp - lastCalled);

    if (needCall) {
      result.lastCallThrottled = false;
      func.apply(this, args);
    } else {
      if (lastTimer) {
        clearTimeout(lastTimer);
      }
      lastTimer = setTimeout(function () {
        result.lastCallThrottled = false;
        func.apply(_this, args);
        lastCalled = 0;
        lastTimer = void 0;
      }, remaining);
    }

    return result;
  }

  return _throttle;
}

/**
 * Creates throttle function that invokes `func` only once per `wait` (in miliseconds) after hits.
 *
 * @param {Function} func
 * @param {Number} wait
 * @param {Number} hits
 * @returns {Function}
 */

function throttleAfterHits(func) {
  var wait = arguments.length <= 1 || arguments[1] === undefined ? 200 : arguments[1];
  var hits = arguments.length <= 2 || arguments[2] === undefined ? 10 : arguments[2];

  var funcThrottle = throttle(func, wait);
  var remainHits = hits;

  function _clearHits() {
    remainHits = hits;
  }
  function _throttleAfterHits() {
    if (remainHits) {
      remainHits--;

      return func.apply(this, arguments);
    }

    return funcThrottle.apply(this, arguments);
  }
  _throttleAfterHits.clearHits = _clearHits;

  return _throttleAfterHits;
}

},{}],53:[function(require,module,exports){

/**
 * Converts any value to string.
 *
 * @param {*} value
 * @returns {String}
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.stringify = stringify;

function stringify(value) {
  switch (typeof value) {
    case 'string':
    case 'number':
      return value + '';

    case 'object':
      if (value === null) {
        return '';
      } else {
        return value.toString();
      }
      break;
    case 'undefined':
      return '';

    default:
      return value.toString();
  }
}

},{}],54:[function(require,module,exports){

/**
 * Checks if value of n is a numeric one
 * http://jsperf.com/isnan-vs-isnumeric/4
 * @param n
 * @returns {boolean}
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.isNumeric = isNumeric;
exports.rangeEach = rangeEach;
exports.valueAccordingPercent = valueAccordingPercent;

function isNumeric(n) {
  var t = typeof n;
  return t == 'number' ? !isNaN(n) && isFinite(n) : t == 'string' ? !n.length ? false : n.length == 1 ? /\d/.test(n) : /^\s*[+-]?\s*(?:(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?)|(?:0x[a-f\d]+))\s*$/i.test(n) : t == 'object' ? !!n && typeof n.valueOf() == "number" && !(n instanceof Date) : false;
}

/**
 * A specialized version of `.forEach` defined by ranges.
 *
 * @param {Number} rangeFrom The number from start iterate.
 * @param {Number} rangeTo The number where finish iterate.
 * @param {Function} iteratee The function invoked per iteration.
 */

function rangeEach(rangeFrom, rangeTo, iteratee) {
  var index = -1;

  if (typeof rangeTo === 'function') {
    iteratee = rangeTo;
    rangeTo = rangeFrom;
  } else {
    index = rangeFrom - 1;
  }
  while (++index <= rangeTo) {
    if (iteratee(index) === false) {
      break;
    }
  }
}

/**
 * Calculate value from percent.
 *
 * @param {Number} value Base value from percent will be calculated.
 * @param {String|Number} percent Can be Number or String (eq. `'33%'`).
 * @returns {Number}
 */

function valueAccordingPercent(value, percent) {
  percent = parseInt(percent.toString().replace('%', ''), 10);
  percent = parseInt(value * percent / 100);

  return percent;
}

},{}],55:[function(require,module,exports){

/**
 * Generate schema for passed object.
 *
 * @param {Array|Object} object
 * @returns {Array|Object}
 */
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.duckSchema = duckSchema;
exports.inherit = inherit;
exports.extend = extend;
exports.deepExtend = deepExtend;
exports.deepClone = deepClone;
exports.clone = clone;
exports.isObjectEquals = isObjectEquals;
exports.isObject = isObject;
exports.getPrototypeOf = getPrototypeOf;
exports.defineGetter = defineGetter;
exports.objectEach = objectEach;

function duckSchema(object) {
  var schema;

  if (Array.isArray(object)) {
    schema = [];
  } else {
    schema = {};

    objectEach(object, function (value, key) {
      if (value && typeof value === 'object' && !Array.isArray(value)) {
        schema[key] = duckSchema(value);
      } else if (Array.isArray(value)) {
        if (value.length && typeof value[0] === 'object' && !Array.isArray(value[0])) {
          schema[key] = [duckSchema(value[0])];
        } else {
          schema[key] = [];
        }
      } else {
        schema[key] = null;
      }
    });
  }

  return schema;
}

/**
 * Inherit without without calling parent constructor, and setting `Child.prototype.constructor` to `Child` instead of `Parent`.
 * Creates temporary dummy function to call it as constructor.
 * Described in ticket: https://github.com/handsontable/handsontable/pull/516
 *
 * @param  {Object} Child  child class
 * @param  {Object} Parent parent class
 * @return {Object}        extended Child
 */

function inherit(Child, Parent) {
  Parent.prototype.constructor = Parent;
  Child.prototype = new Parent();
  Child.prototype.constructor = Child;

  return Child;
}

/**
 * Perform shallow extend of a target object with extension's own properties
 * @param {Object} target An object that will receive the new properties
 * @param {Object} extension An object containing additional properties to merge into the target
 */

function extend(target, extension) {
  objectEach(extension, function (value, key) {
    target[key] = value;
  });
}

/**
 * Perform deep extend of a target object with extension's own properties
 * @param {Object} target An object that will receive the new properties
 * @param {Object} extension An object containing additional properties to merge into the target
 */

function deepExtend(target, extension) {
  objectEach(extension, function (value, key) {
    if (extension[key] && typeof extension[key] === 'object') {
      if (!target[key]) {
        if (Array.isArray(extension[key])) {
          target[key] = [];
        } else {
          target[key] = {};
        }
      }
      deepExtend(target[key], extension[key]);
    } else {
      target[key] = extension[key];
    }
  });
}

/**
 * Perform deep clone of an object.
 * WARNING! Only clones JSON properties. Will cause error when `obj` contains a function, Date, etc.
 *
 * @param {Object} obj An object that will be cloned
 * @return {Object}
 */

function deepClone(obj) {
  if (typeof obj === "object") {
    return JSON.parse(JSON.stringify(obj));
  }

  return obj;
}

/**
 * Shallow clone object.
 *
 * @param {Object} object
 * @returns {Object}
 */

function clone(object) {
  var result = {};

  objectEach(object, function (value, key) {
    return result[key] = value;
  });

  return result;
}

/**
 * Checks if two objects or arrays are (deep) equal
 *
 * @param {Object|Array} object1
 * @param {Object|Array} object2
 * @returns {Boolean}
 */

function isObjectEquals(object1, object2) {
  return JSON.stringify(object1) === JSON.stringify(object2);
}

/**
 * Determines whether given object is a plain Object.
 * Note: String and Array are not plain Objects
 * @param {*} obj
 * @returns {boolean}
 */

function isObject(obj) {
  return Object.prototype.toString.call(obj) == '[object Object]';
}

function getPrototypeOf(obj) {
  var prototype;

  /* jshint ignore:start */
  if (typeof obj.__proto__ == "object") {
    prototype = obj.__proto__;
  } else {
    var oldConstructor,
        constructor = obj.constructor;

    if (typeof obj.constructor == "function") {
      oldConstructor = constructor;

      if (delete obj.constructor) {
        constructor = obj.constructor; // get real constructor
        obj.constructor = oldConstructor; // restore constructor
      }
    }

    prototype = constructor ? constructor.prototype : null; // needed for IE
  }
  /* jshint ignore:end */

  return prototype;
}

function defineGetter(object, property, value, options) {
  options.value = value;
  options.writable = options.writable === false ? false : true;
  options.enumerable = options.enumerable === false ? false : true;
  options.configurable = options.configurable === false ? false : true;

  Object.defineProperty(object, property, options);
}

/**
 * A specialized version of `.forEach` for objects.
 *
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */

function objectEach(object, iteratee) {
  for (var key in object) {
    if (!object.hasOwnProperty || object.hasOwnProperty && object.hasOwnProperty(key)) {
      if (iteratee(object[key], key, object) === false) {
        break;
      }
    }
  }

  return object;
}

},{}],56:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.columnFactory = columnFactory;

var _object = require('./object');

/**
 * Factory for columns constructors.
 *
 * @param {Object} GridSettings
 * @param {Array} conflictList
 * @return {Object} ColumnSettings
 */

function columnFactory(GridSettings, conflictList) {
  function ColumnSettings() {};

  (0, _object.inherit)(ColumnSettings, GridSettings);

  // Clear conflict settings
  for (var i = 0, len = conflictList.length; i < len; i++) {
    ColumnSettings.prototype[conflictList[i]] = void 0;
  }

  return ColumnSettings;
}

},{"./object":55}],57:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.toUpperCaseFirst = toUpperCaseFirst;
exports.equalsIgnoreCase = equalsIgnoreCase;
exports.randomString = randomString;
exports.isPercentValue = isPercentValue;

var _mixed = require('./mixed');

/**
 * Convert string to upper case first letter.
 *
 * @param {String} string String to convert.
 * @returns {String}
 */

function toUpperCaseFirst(string) {
  return string[0].toUpperCase() + string.substr(1);
}

/**
 * Compare strings case insensitively.
 *
 * @param {...String} strings Strings to compare.
 * @returns {Boolean}
 */

function equalsIgnoreCase() {
  var unique = [];

  for (var _len = arguments.length, strings = Array(_len), _key = 0; _key < _len; _key++) {
    strings[_key] = arguments[_key];
  }

  var length = strings.length;

  while (length--) {
    var string = (0, _mixed.stringify)(strings[length]).toLowerCase();

    if (unique.indexOf(string) === -1) {
      unique.push(string);
    }
  }

  return unique.length === 1;
}

/**
 * Generates a random hex string. Used as namespace for Handsontable instance events.
 * @return {String} - 16 character random string: "92b1bfc74ec4"
 */

function randomString() {
  function s4() {
    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
  }

  return s4() + s4() + s4() + s4();
}

/**
 * Checks if value is valid percent.
 *
 * @param {String} value
 * @returns {Boolean}
 */

function isPercentValue(value) {
  return (/^([0-9][0-9]?\%$)|(^100\%$)/.test(value)
  );
}

},{"./mixed":53}],58:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.isPrintableChar = isPrintableChar;
exports.isMetaKey = isMetaKey;
exports.isCtrlKey = isCtrlKey;
exports.isKey = isKey;

var _array = require('./array');

var KEY_CODES = {
  MOUSE_LEFT: 1,
  MOUSE_RIGHT: 3,
  MOUSE_MIDDLE: 2,
  BACKSPACE: 8,
  COMMA: 188,
  INSERT: 45,
  DELETE: 46,
  END: 35,
  ENTER: 13,
  ESCAPE: 27,
  CONTROL_LEFT: 91,
  COMMAND_LEFT: 17,
  COMMAND_RIGHT: 93,
  ALT: 18,
  HOME: 36,
  PAGE_DOWN: 34,
  PAGE_UP: 33,
  PERIOD: 190,
  SPACE: 32,
  SHIFT: 16,
  CAPS_LOCK: 20,
  TAB: 9,
  ARROW_RIGHT: 39,
  ARROW_LEFT: 37,
  ARROW_UP: 38,
  ARROW_DOWN: 40,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  A: 65,
  X: 88,
  C: 67,
  V: 86
};

exports.KEY_CODES = KEY_CODES;
/**
 * Returns true if keyCode represents a printable character.
 *
 * @param {Number} keyCode
 * @returns {Boolean}
 */

function isPrintableChar(keyCode) {
  return keyCode == 32 || //space
  keyCode >= 48 && keyCode <= 57 || //0-9
  keyCode >= 96 && keyCode <= 111 || //numpad
  keyCode >= 186 && keyCode <= 192 || //;=,-./`
  keyCode >= 219 && keyCode <= 222 || //[]{}\|"'
  keyCode >= 226 || //special chars (229 for Asian chars)
  keyCode >= 65 && keyCode <= 90; //a-z
}

/**
 * @param {Number} keyCode
 * @returns {Boolean}
 */

function isMetaKey(keyCode) {
  var metaKeys = [KEY_CODES.ARROW_DOWN, KEY_CODES.ARROW_UP, KEY_CODES.ARROW_LEFT, KEY_CODES.ARROW_RIGHT, KEY_CODES.HOME, KEY_CODES.END, KEY_CODES.DELETE, KEY_CODES.BACKSPACE, KEY_CODES.F1, KEY_CODES.F2, KEY_CODES.F3, KEY_CODES.F4, KEY_CODES.F5, KEY_CODES.F6, KEY_CODES.F7, KEY_CODES.F8, KEY_CODES.F9, KEY_CODES.F10, KEY_CODES.F11, KEY_CODES.F12, KEY_CODES.TAB, KEY_CODES.PAGE_DOWN, KEY_CODES.PAGE_UP, KEY_CODES.ENTER, KEY_CODES.ESCAPE, KEY_CODES.SHIFT, KEY_CODES.CAPS_LOCK, KEY_CODES.ALT];

  return metaKeys.indexOf(keyCode) !== -1;
}

/**
 * @param {Number} keyCode
 * @returns {Boolean}
 */

function isCtrlKey(keyCode) {
  return [KEY_CODES.CONTROL_LEFT, 224, KEY_CODES.COMMAND_LEFT, KEY_CODES.COMMAND_RIGHT].indexOf(keyCode) !== -1;
}

/**
 * @param {Number} keyCode
 * @param {String} baseCode
 * @returns {Boolean}
 */

function isKey(keyCode, baseCode) {
  var keys = baseCode.split('|');
  var result = false;

  (0, _array.arrayEach)(keys, function (key) {
    if (keyCode === KEY_CODES[key]) {
      result = true;

      return false;
    }
  });

  return result;
}

},{"./array":47}],59:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.MultiMap = MultiMap;

// TODO: Global expose for tests
window.MultiMap = MultiMap;

function MultiMap() {
  var map = {
    arrayMap: [],
    weakMap: new WeakMap()
  };

  return {
    'get': function get(key) {
      if (canBeAnArrayMapKey(key)) {
        return map.arrayMap[key];
      } else if (canBeAWeakMapKey(key)) {
        return map.weakMap.get(key);
      }
    },

    'set': function set(key, value) {
      if (canBeAnArrayMapKey(key)) {
        map.arrayMap[key] = value;
      } else if (canBeAWeakMapKey(key)) {
        map.weakMap.set(key, value);
      } else {
        throw new Error('Invalid key type');
      }
    },

    'delete': function _delete(key) {
      if (canBeAnArrayMapKey(key)) {
        delete map.arrayMap[key];
      } else if (canBeAWeakMapKey(key)) {
        map.weakMap['delete'](key); //Delete must be called using square bracket notation, because IE8 does not handle using `delete` with dot notation
      }
    }
  };

  function canBeAnArrayMapKey(obj) {
    return obj !== null && !isNaNSymbol(obj) && (typeof obj == 'string' || typeof obj == 'number');
  }

  function canBeAWeakMapKey(obj) {
    return obj !== null && (typeof obj == 'object' || typeof obj == 'function');
  }

  function isNaNSymbol(obj) {
    return obj !== obj; // NaN === NaN is always false
  }
}

},{}],60:[function(require,module,exports){

/**
 * @description
 * Handsontable events are the common interface that function in 2 ways: as __callbacks__ and as __hooks__.
 *
 * @example
 *
 * ```js
 * // Using events as callbacks:
 * ...
 * var hot1 = new Handsontable(document.getElementById('example1'), {
 *   afterChange: function(changes, source) {
 *     $.ajax({
 *       url: "save.php",
 *       data: change
 *     });
 *   }
 * });
 * ...
 * ```
 *
 * ```js
 * // Using events as plugin hooks:
 * ...
 * var hot1 = new Handsontable(document.getElementById('example1'), {
 *   myPlugin: true
 * });
 *
 * var hot2 = new Handsontable(document.getElementById('example2'), {
 *   myPlugin: false
 * });
 *
 * // global hook
 * Handsontable.hooks.add('afterChange', function() {
 *   // Fired twice - for hot1 and hot2
 *   if (this.getSettings().myPlugin) {
 *     // function body - will only run for hot1
 *   }
 * });
 *
 * // local hook (has same effect as a callback)
 * hot2.addHook('afterChange', function() {
 *   // function body - will only run in #example2
 * });
 * ```
 * ...
 */

// @TODO: Move plugin description hooks to plugin?
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _eventManager = require('./eventManager');

var _helpersArray = require('./helpers/array');

var _helpersObject = require('./helpers/object');

var REGISTERED_HOOKS = [
/**
 * Callback fired after reset cell's meta.
 *
 * @event Hooks#afterCellMetaReset
 * @since 0.11
 */
"afterCellMetaReset",

/**
 * @description
 * Callback fired after one or more cells is changed. Its main use case is to save the input.
 *
 * __Note:__ For performance reasons, the `changes` array is null for `"loadData"` source.
 *
 * @event Hooks#afterChange
 * @param {Array} changes 2D array containing information about each of the edited cells `[[row, prop, oldVal, newVal], ...]`
 * @param {String} source Is one of the strings: `"alter", "empty", "edit", "populateFromArray", "loadData", "autofill", "paste"`.
 */
"afterChange", "afterChangesObserved", "afterColumnMove", "afterColumnResize", "afterContextMenuDefaultOptions", "afterContextMenuHide", "afterContextMenuShow", "afterCopyLimit",

/**
 * Callback is fired when a new column is created.
 *
 * @event Hooks#afterCreateCol
 * @param {Number} index Represents the index of first newly created column in the data source array.
 * @param {Number} amount Number of newly created columns in the data source array.
 */
"afterCreateCol",

/**
 * Callback is fired when a new row is created.
 *
 * @event Hooks#afterCreateRow
 * @param {Number} index Represents the index of first newly created row in the data source array.
 * @param {Number} amount Number of newly created rows in the data source array.
 */
"afterCreateRow",

/**
 * Event called when current cell is deselected.
 *
 * @event Hooks#afterDeselect
 */
"afterDeselect",

/**
 * Callback fired after destroying Handsontable instance.
 *
 * @event Hooks#afterDestroy
 */
"afterDestroy",

/**
 * @event Hooks#afterDocumentKeyDown
 */
"afterDocumentKeyDown",

/**
 * Callback fired after getting cell settings.
 *
 * @event Hooks#afterGetCellMeta
 * @param {Number} row
 * @param {Number} col
 * @param {Object} cellProperties
 */
"afterGetCellMeta",

/**
 * Callback fired after getting info about column header.
 *
 * @event Hooks#afterGetColHeader
 * @param {Number} col
 * @param {Element} TH
 */
"afterGetColHeader",

/**
 * @event Hooks#afterGetRowHeader
 */
"afterGetRowHeader",

/**
 * Callback fired after Handsontable instance is initiated.
 *
 * @event Hooks#afterInit
 */
"afterInit",

/**
 * @event Hooks#afterIsMultipleSelectionCheck
 */
"afterIsMultipleSelectionCheck",

/**
 * Callback fired after new data is loaded (by `loadData` method) into the data source array.
 *
 * @event Hooks#afterLoadData
 */
"afterLoadData",

/**
 * @event Hooks#afterMomentumScroll
 */
"afterMomentumScroll",

/**
 * @event Hooks#afterOnCellCornerMouseDown
 * @since 0.11
 * @param {Object} event
 */
"afterOnCellCornerMouseDown",

/**
 * Callback fired after clicking on a cell or row/column header.
 * In case the row/column header was clicked, the index is negative.
 * For example clicking on the row header of cell (0, 0) results with `afterOnCellMouseDown` called with coords `{row: 0, col: -1}`.
 *
 * @event Hooks#afterOnCellMouseDown
 * @since 0.11
 * @param {Object} event
 * @param {Object} coords
 * @param {Object} TD
 */
"afterOnCellMouseDown",

/**
 * Callback fired after hovering a cell or row/column header with the mouse cursor.
 * In case the row/column header was hovered, the index is negative.
 * For example clicking on the row header of cell (0, 0) results with `afterOnCellMouseOver` called with coords `{row: 0, col: -1}`.
 *
 * @event Hooks#afterOnCellMouseOver
 * @since 0.11
 * @param {Object} event
 * @param {Object} coords
 * @param {Object} TD
 */
"afterOnCellMouseOver",

/**
 * Callback is fired when one or more columns are removed.
 *
 * @event Hooks#afterRemoveCol
 * @param {Number} index Is an index of starter column.
 * @param {Number} amount Is an amount of removed columns.
 */
"afterRemoveCol",

/**
 * Callback is fired when one or more rows are removed.
 *
 * @event Hooks#afterRemoveRow
 * @param {Number} index Is an index of starter row.
 * @param {Number} amount Is an amount of removed rows.
 */
"afterRemoveRow",

/**
 * Callback fired after Handsontable table is rendered.
 *
 * @event Hooks#afterRender
 * @param {Boolean} isForced Is `true` if rendering was triggered by a change of settings or data; or `false` if
 *                           rendering was triggered by scrolling or moving selection.
 */
"afterRender",

/**
 * @event Hooks#afterRenderer
 * @since 0.11
 * @param {Object} TD
 * @param {Number} row
 * @param {Number} col
 * @param {String} prop
 * @param {String} value
 * @param {Object} cellProperties
 */
"afterRenderer", "afterRowMove", "afterRowResize",

/**
 * @event Hooks#afterScrollHorizontally
 * @since 0.11
 */
"afterScrollHorizontally",

/**
 * @event Hooks#afterScrollVertically
 * @since 0.11
 */
"afterScrollVertically",

/**
 * Callback fired while one or more cells are being selected (on mouse move).
 *
 * @event Hooks#afterSelection
 * @param {Number} r Selection start row
 * @param {Number} c Selection start column
 * @param {Number} r2 Selection end row
 * @param {Number} c2 Selection end column
 */
"afterSelection",

/**
 * The same as above, but data source object property name is used instead of the column number.
 *
 * @event Hooks#afterSelectionByProp
 * @param {Number} r Selection start row
 * @param {String} p Selection start data source object property
 * @param {Number} r2 Selection end row
 * @param {String} p2 Selection end data source object property
 */
"afterSelectionByProp",

/**
 * Callback fired after one or more cells are selected (on mouse up).
 *
 * @event Hooks#afterSelectionEnd
 * @param {Number} r Selection start row
 * @param {Number} c Selection start column
 * @param {Number} r2 Selection end row
 * @param {Number} c2 Selection end column
 */
"afterSelectionEnd",

/**
 * The same as above, but data source object property name is used instead of the column number.
 *
 * @event Hooks#afterSelectionEndByProp
 * @param {Number} r Selection start row
 * @param {String} p Selection start data source object property
 * @param {Number} r2 Selection end row
 * @param {String} p2 Selection end data source object property
 */
"afterSelectionEndByProp",

/**
 * Called after cell meta was changed, e.g. using the context menu.
 *
 * @event Hooks#afterSetCellMeta
 * @since 0.11.0
 * @param {Number} row
 * @param {Number} col
 * @param {String} key
 * @param {*} value
 */
"afterSetCellMeta",

/**
 * @event Hooks#afterUpdateSettings
 */
"afterUpdateSettings",

/**
 * @description
 * A plugin hook executed after validator function, only if validator function is defined.
 * Validation result is the first parameter. This can be used to determinate if validation passed successfully or not.
 *
 * __You can cancel current change by returning false.__
 *
 * @event Hooks#afterValidate
 * @since 0.9.5
 * @param {Boolean} isValid
 * @param {*} value
 * @param {Number} row
 * @param {String} prop
 * @param {String} source
 */
"afterValidate",

/**
 * @event Hooks#beforeAutofill
 * @param {Object} start Object containing information about first filled cell: `{row: 2, col: 0}`
 * @param {Object} end Object containing information about last filled cell: `{row: 4, col: 1}`
 * @param {Array} data 2D array containing information about fill pattern: `[["1", "Ted"], ["1", "John"]]`
 */
"beforeAutofill",

/**
 * @event Hooks#beforeCellAlignment
 */
"beforeCellAlignment",

/**
 * Callback fired before one or more cells is changed. Its main purpose is to alter changes silently before input.
 *
 * @event Hooks#beforeChange
 * @param {Array} changes 2D array containing information about each of the edited cells.
 * @param {String} source The name of a source of changes.
 * @example
 * ```js
 * // To disregard a single change, set changes[i] to null or remove it from array using changes.splice(i, 1).
 * ...
 * new Handsontable(document.getElementById('example'), {
 *   beforeChange: function(changes, source) {
 *     // [[row, prop, oldVal, newVal], ...]
 *     changes[0] = null;
 *   }
 * });
 * ...
 *
 * // To alter a single change, overwrite the desired value to changes[i][3].
 * ...
 * new Handsontable(document.getElementById('example'), {
 *   beforeChange: function(changes, source) {
 *     // [[row, prop, oldVal, newVal], ...]
 *     changes[0][1] = 10;
 *   }
 * });
 * ...
 *
 * // To cancel all edit, return false from the callback or set array length to 0 (changes.length = 0).
 * ...
 * new Handsontable(document.getElementById('example'), {
 *   beforeChange: function(changes, source) {
 *     // [[row, prop, oldVal, newVal], ...]
 *     return false;
 *   }
 * });
 * ...
 * ```
 */
"beforeChange",

/**
 * @event Hooks#beforeChangeRender
 * @since 0.11
 */
"beforeChangeRender",

/**
 * @event Hooks#beforeDrawBorders
 */
"beforeDrawBorders",

/**
 * Callback fired before getting cell settings.
 *
 * @event Hooks#beforeGetCellMeta
 * @param {Number} row
 * @param {Number} col
 * @param {Object} cellProperties
 */
"beforeGetCellMeta",

/**
 * @description
 * Callback fired before Handsontable instance is initiated.
 *
 * @event Hooks#beforeInit
 */

"beforeInit",

/**
 * Callback fired before Walkontable instance is initiated.
 *
 * @since 0.11
 * @event Hooks#beforeInitWalkontable
 */
"beforeInitWalkontable",

/**
 * Callback fired before keydown event is handled. It can be used to overwrite default key bindings.
 * Caution - in your `beforeKeyDown` handler you need to call `event.stopImmediatePropagation()` to prevent default key behavior.
 *
 * @event Hooks#beforeKeyDown
 * @since 0.9.0
 * @param {Object} event Original DOM event
 */
"beforeKeyDown",

/**
 * @event Hooks#beforeOnCellMouseDown
 */
"beforeOnCellMouseDown",

/**
 * Callback is fired when one or more columns are about to be removed.
 *
 * @event Hooks#beforeRemoveCol
 * @param {Number} index Index of starter column.
 * @param {Number} amount Amount of columns to be removed.
 */
"beforeRemoveCol",

/**
 * Callback is fired when one or more rows are about to be removed.
 *
 * @event Hooks#beforeRemoveRow
 * @param {Number} index Index of starter column.
 * @param {Number} amount Amount of columns to be removed.
 */
"beforeRemoveRow",

/**
 * Callback fired before Handsontable table is rendered.
 *
 * @event Hooks#beforeRender
 * @param {Boolean} isForced If `true` rendering was triggered by a change of settings or data; or `false` if
 *                           rendering was triggered by scrolling or moving selection.
 */
"beforeRender",

/**
 * Callback fired before setting range is ended.
 *
 * @event Hooks#beforeSetRangeEnd
 * @param {Array} coords WalkontableCellCoords array.
 */
"beforeSetRangeEnd",

/**
 * @event Hooks#beforeTouchScroll
 */
"beforeTouchScroll",

/**
 * @description
 * A plugin hook executed before validator function, only if validator function is defined.
 * This can be used to manipulate value of changed cell before it is applied to the validator function.
 *
 * __Notice:__ this will not affect values of changes. This will change value ONLY for validation!
 *
 * @event Hooks#beforeValidate
 * @since 0.9.5
 * @param {*} value
 * @param {Number} row
 * @param {String} prop
 * @param {String} source
 */
"beforeValidate",

/**
 * Callback fired after Handsontable instance is constructed (via `new` operator).
 *
 * @event Hooks#construct
 * @since 0.16.1
 */
"construct",

/**
 * Callback fired after Handsontable instance is initiated but before table is rendered.
 *
 * @event Hooks#init
 * @since 0.16.1
 */
"init",

/**
 * Callback fired after column modify.
 *
 * @event Hooks#modifyCol
 * @since 0.11
 * @param {Number} col
 */
"modifyCol",

/**
 * Callback fired after modify column's width.
 *
 * @event Hooks#modifyColWidth
 * @since 0.11
 * @param {Number} width
 * @param {Number} col
 */
"modifyColWidth",

/**
 * Callback fired after row modify.
 *
 * @event Hooks#modifyRow
 * @since 0.11
 * @param {Number} row
 */
"modifyRow",

/**
 * Callback fired after modify height of row.
 *
 * @event Hooks#modifyRowHeight
 * @since 0.11
 * @param {Number} height
 * @param {Number} row
 */
"modifyRowHeight",

/**
 * @event Hooks#persistentStateLoad
 */
"persistentStateLoad",

/**
 * @event Hooks#persistentStateReset
 */
"persistentStateReset",

/**
 * @event Hooks#persistentStateSave
 */
"persistentStateSave"];

var Hooks = (function () {
  /**
   *
   */

  function Hooks() {
    _classCallCheck(this, Hooks);

    this.globalBucket = this.createEmptyBucket();
  }

  /**
   * Returns new object with empty handlers related to every registered hook name.
   *
   * @returns {Object}
   *
   * @example
   * ```js
   * Handsontable.hooks.createEmptyBucket();
   * // Results:
   * {
   * ...
   * afterCreateCol: [],
   * afterCreateRow: [],
   * beforeInit: [],
   * ...
   * }
   * ```
   */

  _createClass(Hooks, [{
    key: "createEmptyBucket",
    value: function createEmptyBucket() {
      var bucket = Object.create(null);

      (0, _helpersArray.arrayEach)(REGISTERED_HOOKS, function (hook) {
        return bucket[hook] = [];
      });

      return bucket;
    }

    /**
     * Get hook bucket based on context object or if argument is `undefined` get global hook bucked.
     *
     * @param {Object} [context=null]
     * @returns {Object} Returns global or handsontable instance bucket
     */
  }, {
    key: "getBucket",
    value: function getBucket() {
      var context = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      if (context) {
        if (!context.pluginHookBucket) {
          context.pluginHookBucket = this.createEmptyBucket();
        }

        return context.pluginHookBucket;
      }

      return this.globalBucket;
    }

    /**
     * Adds listener (globally or locally) to specified hook name.
     *
     * @see Core#addHook
     * @param {String} key Hook/Event name
     * @param {Function|Array} callback Callback function or array of functions
     * @param {Object} [context=null]
     * @returns {Hooks} Instance of Hooks
     *
     * @example
     * ```js
     * Handsontable.hooks.add('beforeInit', myCallback, hotInstance);
     * ```
     */
  }, {
    key: "add",
    value: function add(key, callback) {
      var _this = this;

      var context = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

      if (Array.isArray(callback)) {
        (0, _helpersArray.arrayEach)(callback, function (c) {
          return _this.add(key, c, context);
        });
      } else {
        var bucket = this.getBucket(context);

        if (typeof bucket[key] === 'undefined') {
          this.register(key);
          bucket[key] = [];
        }
        callback.skip = false;

        if (bucket[key].indexOf(callback) === -1) {
          // only add a hook if it has not already been added (adding the same hook twice is now silently ignored)
          bucket[key].push(callback);
        }
      }

      return this;
    }

    /**
     * Adds listener to specified hook. After hook runs this listener will be automatically removed.
     *
     * @see Core#addHookOnce
     * @param {String} key Hook/Event name
     * @param {Function} callback Callback function
     * @param {Object} [context=null]
     *
     * @example
     * ```js
     * Handsontable.hooks.once('beforeInit', myCallback, hotInstance);
     * ```
     */
  }, {
    key: "once",
    value: function once(key, callback) {
      var _this2 = this;

      var context = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

      if (Array.isArray(callback)) {
        (0, _helpersArray.arrayEach)(callback, function (c) {
          return _this2.once(key, c, context);
        });
      } else {
        callback.runOnce = true;
        this.add(key, callback, context);
      }
    }

    /**
     * Removes listener from hooks.
     *
     * @see Core#removeHook
     * @param {String} key Hook/Event name
     * @param {Function} callback Callback function
     * @param {Object} [context=null]
     * @return {Boolean} Returns `true` if hook was removed
     *
     * @example
     * ```js
     * Handsontable.hooks.remove('beforeInit', myCallback);
     * ```
     */
  }, {
    key: "remove",
    value: function remove(key, callback) {
      var context = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];

      var bucket = this.getBucket(context);

      if (typeof bucket[key] !== 'undefined') {
        if (bucket[key].indexOf(callback) >= 0) {
          callback.skip = true;

          return true;
        }
      }

      return false;
    }

    /**
     * Run all local and global listeners by hook name.
     *
     * @see Core#runHooks
     * @param {Object} context
     * @param {String} key Hook/Event name
     * @param {*} [p1]
     * @param {*} [p2]
     * @param {*} [p3]
     * @param {*} [p4]
     * @param {*} [p5]
     * @param {*} [p6]
     * @returns {*}
     *
     * @example
     * ```js
     * Handsontable.hooks.run(hot, 'beforeInit');
     * ```
     */
  }, {
    key: "run",
    value: function run(context, key, p1, p2, p3, p4, p5, p6) {
      {
        var globalHandlers = this.globalBucket[key];
        var index = -1;
        var _length = globalHandlers ? globalHandlers.length : 0;

        if (_length) {
          // Do not optimise this loop with arrayEach or arrow function! If you do You'll decrease perf because of GC.
          while (++index < _length) {
            if (!globalHandlers[index] || globalHandlers[index].skip) {
              continue;
            }
            // performance considerations - http://jsperf.com/call-vs-apply-for-a-plugin-architecture
            var res = globalHandlers[index].call(context, p1, p2, p3, p4, p5, p6);

            if (res !== void 0) {
              p1 = res;
            }
            if (globalHandlers[index] && globalHandlers[index].runOnce) {
              this.remove(key, globalHandlers[index]);
            }
          }
        }
      }
      {
        var localHandlers = this.getBucket(context)[key];
        var index = -1;
        var _length2 = localHandlers ? localHandlers.length : 0;

        if (_length2) {
          // Do not optimise this loop with arrayEach or arrow function! If you do You'll decrease perf because of GC.
          while (++index < _length2) {
            if (!localHandlers[index] || localHandlers[index].skip) {
              continue;
            }
            // performance considerations - http://jsperf.com/call-vs-apply-for-a-plugin-architecture
            var res = localHandlers[index].call(context, p1, p2, p3, p4, p5, p6);

            if (res !== void 0) {
              p1 = res;
            }
            if (localHandlers[index] && localHandlers[index].runOnce) {
              this.remove(key, localHandlers[index], context);
            }
          }
        }
      }

      return p1;
    }

    /**
     * Destroy all listeners connected to the context. If context is not exists then listeners will by destroy
     * from globally.
     *
     * @param {Object} [context=null]
     */
  }, {
    key: "destroy",
    value: function destroy() {
      var context = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

      (0, _helpersObject.objectEach)(this.getBucket(context), function (value, key, bucket) {
        return bucket[key].length = 0;
      });
    }

    /**
     * Registers a hook name (adds it to the list of the known hook names). Used by plugins. It is not necessary to call,
     * register, but if you use it, your plugin hook will be used returned by getRegistered
     * (which itself is used in the demo http://handsontable.com/demo/callbacks.html).
     *
     * @param key {String} Hook name
     *
     * @example
     * ```js
     * Handsontable.hooks.register('myHook');
     * ```
     */
  }, {
    key: "register",
    value: function register(key) {
      if (!this.isRegistered(key)) {
        REGISTERED_HOOKS.push(key);
      }
    }

    /**
     * Unregister a hook name (removes it from the list of known hook names).
     *
     * @param key {String} Hook name
     *
     * @example
     * ```js
     * Handsontable.hooks.deregister('myHook');
     * ```
     */
  }, {
    key: "deregister",
    value: function deregister(key) {
      if (this.isRegistered(key)) {
        REGISTERED_HOOKS.splice(REGISTERED_HOOKS.indexOf(key), 1);
      }
    }

    /**
     * Returns boolean information if a hook by such name has been registered.
     *
     * @param key {String} Hook name
     * @returns {Boolean}
     *
     * @example
     * ```js
     * Handsontable.hooks.isRegistered('beforeInit');
     * // Results:
     * true
     * ```
     */
  }, {
    key: "isRegistered",
    value: function isRegistered(key) {
      return REGISTERED_HOOKS.indexOf(key) >= 0;
    }

    /**
     * Returns an array of registered hooks.
     *
     * @returns {Array}
     *
     * @example
     * ```js
     * Handsontable.hooks.getRegistered();
     * // Results:
     * [
     * ...
     *   "beforeInit",
     *   "beforeRender",
     *   "beforeSetRangeEnd",
     *   "beforeDrawBorders",
     *   "beforeChange",
     * ...
     * ]
     * ```
     */
  }, {
    key: "getRegistered",
    value: function getRegistered() {
      return REGISTERED_HOOKS;
    }
  }]);

  return Hooks;
})();

exports.Hooks = Hooks;

// temp for tests only!
Handsontable.utils = Handsontable.utils || {};
Handsontable.utils.Hooks = Hooks;

},{"./eventManager":46,"./helpers/array":47,"./helpers/object":55}],61:[function(require,module,exports){
/**
 * Utility to register plugins and common namespace for keeping reference to all plugins classes
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _helpersObject = require('./helpers/object');

var _helpersString = require('./helpers/string');

var registeredPlugins = new WeakMap();

/**
 * Registers plugin under given name
 *
 * @param {String} pluginName
 * @param {Function} PluginClass
 */
function registerPlugin(pluginName, PluginClass) {
  pluginName = (0, _helpersString.toUpperCaseFirst)(pluginName);

  Handsontable.hooks.add('construct', function () {
    var holder;

    if (!registeredPlugins.has(this)) {
      registeredPlugins.set(this, {});
    }
    holder = registeredPlugins.get(this);

    if (!holder[pluginName]) {
      holder[pluginName] = new PluginClass(this);
    }
  });
  Handsontable.hooks.add('afterDestroy', function () {
    var i, pluginsHolder;

    if (registeredPlugins.has(this)) {
      pluginsHolder = registeredPlugins.get(this);

      for (i in pluginsHolder) {
        if (pluginsHolder.hasOwnProperty(i)) {
          pluginsHolder[i].destroy();
        }
      }
      registeredPlugins['delete'](this);
    }
  });
}

/**
 * @param {Object} instance
 * @param {String|Function} pluginName
 * @returns {Function} pluginClass Returns plugin instance if exists or `undefined` if not exists.
 */
function getPlugin(instance, pluginName) {
  if (typeof pluginName != 'string') {
    throw Error('Only strings can be passed as "plugin" parameter');
  }
  var _pluginName = (0, _helpersString.toUpperCaseFirst)(pluginName);

  if (!registeredPlugins.has(instance) || !registeredPlugins.get(instance)[_pluginName]) {
    return void 0;
  }

  return registeredPlugins.get(instance)[_pluginName];
}

/**
 * Get all registred plugins names for concrete Handsontable instance.
 *
 * @param {Object} hotInstance
 * @returns {Array}
 */
function getRegistredPluginNames(hotInstance) {
  return registeredPlugins.has(hotInstance) ? Object.keys(registeredPlugins.get(hotInstance)) : [];
}

/**
 * Get plugin name.
 *
 * @param {Object} hotInstance
 * @param {Object} plugin
 * @returns {String|null}
 */
function getPluginName(hotInstance, plugin) {
  var pluginName = null;

  if (registeredPlugins.has(hotInstance)) {
    (0, _helpersObject.objectEach)(registeredPlugins.get(hotInstance), function (pluginInstance, name) {
      if (pluginInstance === plugin) {
        pluginName = name;
      }
    });
  }

  return pluginName;
}

exports.registerPlugin = registerPlugin;
exports.getPlugin = getPlugin;
exports.getRegistredPluginNames = getRegistredPluginNames;
exports.getPluginName = getPluginName;

},{"./helpers/object":55,"./helpers/string":57}],62:[function(require,module,exports){
/**
 * Utility to register renderers and common namespace for keeping reference to all renderers classes
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _helpersString = require('./helpers/string');

var registeredRenderers = {};

// support for older versions of Handsontable
Handsontable.renderers = Handsontable.renderers || {};
Handsontable.renderers.registerRenderer = registerRenderer;
Handsontable.renderers.getRenderer = getRenderer;

/**
 * Registers renderer under given name
 * @param {String} rendererName
 * @param {Function} rendererFunction
 */
function registerRenderer(rendererName, rendererFunction) {
  var registerName;

  registeredRenderers[rendererName] = rendererFunction;

  registerName = (0, _helpersString.toUpperCaseFirst)(rendererName) + 'Renderer';
  // support for older versions of Handsontable
  Handsontable.renderers[registerName] = rendererFunction;
  Handsontable[registerName] = rendererFunction;
}

/**
 * @param {String|Function} rendererName
 * @returns {Function} rendererFunction
 */
function getRenderer(rendererName) {
  if (typeof rendererName == 'function') {
    return rendererName;
  }

  if (typeof rendererName != 'string') {
    throw Error('Only strings and functions can be passed as "renderer" parameter');
  }

  if (!(rendererName in registeredRenderers)) {
    throw Error('No editor registered under name "' + rendererName + '"');
  }

  return registeredRenderers[rendererName];
}

/**
 * @param rendererName
 * @returns {Boolean}
 */
function hasRenderer(rendererName) {
  return rendererName in registeredRenderers;
}

exports.registerRenderer = registerRenderer;
exports.getRenderer = getRenderer;
exports.hasRenderer = hasRenderer;

},{"./helpers/string":57}],63:[function(require,module,exports){
/**
 * Adds appropriate CSS class to table cell, based on cellProperties
 */

'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _helpersDomElement = require('./../helpers/dom/element');

var _renderers = require('./../renderers');

exports.cellDecorator = cellDecorator;

(0, _renderers.registerRenderer)('base', cellDecorator);

// support for older versions of Handsontable
Handsontable.renderers.cellDecorator = cellDecorator;

function cellDecorator(instance, TD, row, col, prop, value, cellProperties) {
  if (cellProperties.className) {
    if (TD.className) {
      TD.className = TD.className + " " + cellProperties.className;
    } else {
      TD.className = cellProperties.className;
    }
  }

  if (cellProperties.readOnly) {
    (0, _helpersDomElement.addClass)(TD, cellProperties.readOnlyCellClassName);
  }

  if (cellProperties.valid === false && cellProperties.invalidCellClassName) {
    (0, _helpersDomElement.addClass)(TD, cellProperties.invalidCellClassName);
  } else {
    (0, _helpersDomElement.removeClass)(TD, cellProperties.invalidCellClassName);
  }

  if (cellProperties.wordWrap === false && cellProperties.noWordWrapClassName) {
    (0, _helpersDomElement.addClass)(TD, cellProperties.noWordWrapClassName);
  }

  if (!value && cellProperties.placeholder) {
    (0, _helpersDomElement.addClass)(TD, cellProperties.placeholderCellClassName);
  }
}

},{"./../helpers/dom/element":50,"./../renderers":62}],64:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _helpersDomElement = require('./../helpers/dom/element');

var _eventManager = require('./../eventManager');

var _renderers = require('./../renderers');

var _rdpartyWalkontableSrcCellCoords = require('./../3rdparty/walkontable/src/cell/coords');

var clonableWRAPPER = document.createElement('DIV');
clonableWRAPPER.className = 'htAutocompleteWrapper';

var clonableARROW = document.createElement('DIV');
clonableARROW.className = 'htAutocompleteArrow';
// workaround for https://github.com/handsontable/handsontable/issues/1946
// this is faster than innerHTML. See: https://github.com/handsontable/handsontable/wiki/JavaScript-&-DOM-performance-tips
clonableARROW.appendChild(document.createTextNode(String.fromCharCode(9660)));

var wrapTdContentWithWrapper = function wrapTdContentWithWrapper(TD, WRAPPER) {
  WRAPPER.innerHTML = TD.innerHTML;
  dom.empty(TD);
  TD.appendChild(WRAPPER);
};

/**
 * Autocomplete renderer
 *
 * @private
 * @renderer AutocompleteRenderer
 * @param {Object} instance Handsontable instance
 * @param {Element} TD Table cell where to render
 * @param {Number} row
 * @param {Number} col
 * @param {String|Number} prop Row object property name
 * @param value Value to render (remember to escape unsafe HTML before inserting to DOM!)
 * @param {Object} cellProperties Cell properites (shared by cell renderer and editor)
 */
function autocompleteRenderer(instance, TD, row, col, prop, value, cellProperties) {

  var WRAPPER = clonableWRAPPER.cloneNode(true); //this is faster than createElement
  var ARROW = clonableARROW.cloneNode(true); //this is faster than createElement

  (0, _renderers.getRenderer)('text')(instance, TD, row, col, prop, value, cellProperties);

  TD.appendChild(ARROW);
  (0, _helpersDomElement.addClass)(TD, 'htAutocomplete');

  if (!TD.firstChild) {
    //http://jsperf.com/empty-node-if-needed
    //otherwise empty fields appear borderless in demo/renderers.html (IE)
    TD.appendChild(document.createTextNode(String.fromCharCode(160))); // workaround for https://github.com/handsontable/handsontable/issues/1946
    //this is faster than innerHTML. See: https://github.com/handsontable/handsontable/wiki/JavaScript-&-DOM-performance-tips
  }

  if (!instance.acArrowListener) {
    var eventManager = (0, _eventManager.eventManager)(instance);

    //not very elegant but easy and fast
    instance.acArrowListener = function (event) {
      if ((0, _helpersDomElement.hasClass)(event.target, 'htAutocompleteArrow')) {
        instance.view.wt.getSetting('onCellDblClick', null, new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(row, col), TD);
      }
    };

    eventManager.addEventListener(instance.rootElement, 'mousedown', instance.acArrowListener);

    //We need to unbind the listener after the table has been destroyed
    instance.addHookOnce('afterDestroy', function () {
      eventManager.destroy();
    });
  }
}

exports.autocompleteRenderer = autocompleteRenderer;

(0, _renderers.registerRenderer)('autocomplete', autocompleteRenderer);

},{"./../3rdparty/walkontable/src/cell/coords":11,"./../eventManager":46,"./../helpers/dom/element":50,"./../renderers":62}],65:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _helpersDomElement = require('./../helpers/dom/element');

var _helpersString = require('./../helpers/string');

var _eventManager = require('./../eventManager');

var _renderers = require('./../renderers');

var _helpersUnicode = require('./../helpers/unicode');

var _helpersDomEvent = require('./../helpers/dom/event');

var isListeningKeyDownEvent = new WeakMap();
var BAD_VALUE_CLASS = 'htBadValue';

/**
 * Checkbox renderer
 *
 * @private
 * @renderer CheckboxRenderer
 * @param {Object} instance Handsontable instance
 * @param {Element} TD Table cell where to render
 * @param {Number} row
 * @param {Number} col
 * @param {String|Number} prop Row object property name
 * @param value Value to render (remember to escape unsafe HTML before inserting to DOM!)
 * @param {Object} cellProperties Cell properties (shared by cell renderer and editor)
 */
function checkboxRenderer(instance, TD, row, col, prop, value, cellProperties) {
  var eventManager = new _eventManager.EventManager(instance);
  var input = createInput();

  if (typeof cellProperties.checkedTemplate === 'undefined') {
    cellProperties.checkedTemplate = true;
  }
  if (typeof cellProperties.uncheckedTemplate === 'undefined') {
    cellProperties.uncheckedTemplate = false;
  }
  (0, _helpersDomElement.empty)(TD); // TODO identify under what circumstances this line can be removed

  if (value === cellProperties.checkedTemplate || (0, _helpersString.equalsIgnoreCase)(value, cellProperties.checkedTemplate)) {
    input.checked = true;
    TD.appendChild(input);
  } else if (value === cellProperties.uncheckedTemplate || (0, _helpersString.equalsIgnoreCase)(value, cellProperties.uncheckedTemplate)) {
    TD.appendChild(input);
  } else if (value === null) {
    // default value
    (0, _helpersDomElement.addClass)(input, 'noValue');
    TD.appendChild(input);
  } else {
    input.style.display = 'none';
    (0, _helpersDomElement.addClass)(input, BAD_VALUE_CLASS);
    TD.appendChild(input);
    TD.appendChild(document.createTextNode('#bad-value#'));
  }

  if (cellProperties.readOnly) {
    eventManager.addEventListener(input, 'click', preventDefault);
  } else {
    eventManager.addEventListener(input, 'mousedown', _helpersDomEvent.stopPropagation);
    eventManager.addEventListener(input, 'mouseup', _helpersDomEvent.stopPropagation);
    eventManager.addEventListener(input, 'change', function (event) {
      instance.setDataAtRowProp(row, prop, event.target.checked ? cellProperties.checkedTemplate : cellProperties.uncheckedTemplate);
    });
  }

  if (!isListeningKeyDownEvent.has(instance)) {
    isListeningKeyDownEvent.set(instance, true);
    instance.addHook('beforeKeyDown', onBeforeKeyDown);
  }

  /**
   * On before key down DOM listener.
   *
   * @private
   * @param {Event} event
   */
  function onBeforeKeyDown(event) {
    var allowedKeys = [_helpersUnicode.KEY_CODES.SPACE, _helpersUnicode.KEY_CODES.ENTER, _helpersUnicode.KEY_CODES.DELETE, _helpersUnicode.KEY_CODES.BACKSPACE];

    if (allowedKeys.indexOf(event.keyCode) !== -1 && !(0, _helpersDomEvent.isImmediatePropagationStopped)(event)) {
      eachSelectedCheckboxCell(function () {
        (0, _helpersDomEvent.stopImmediatePropagation)(event);
        event.preventDefault();
      });
    }
    if (event.keyCode == _helpersUnicode.KEY_CODES.SPACE || event.keyCode == _helpersUnicode.KEY_CODES.ENTER) {
      toggleSelected();
    }
    if (event.keyCode == _helpersUnicode.KEY_CODES.DELETE || event.keyCode == _helpersUnicode.KEY_CODES.BACKSPACE) {
      toggleSelected(false);
    }
  }

  /**
   * Toggle checkbox checked property
   *
   * @private
   * @param {Boolean} [checked=null]
   */
  function toggleSelected() {
    var checked = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

    eachSelectedCheckboxCell(function (checkboxes) {
      for (var i = 0, len = checkboxes.length; i < len; i++) {
        // Block changing checked property on toggle keys (SPACE and ENTER)
        if ((0, _helpersDomElement.hasClass)(checkboxes[i], BAD_VALUE_CLASS) && checked === null) {
          return;
        }
        toggleCheckbox(checkboxes[i], checked);
      }
    });
  }

  /**
   * Toggle checkbox element.
   *
   * @private
   * @param {HTMLInputElement} checkbox
   * @param {Boolean} [checked=null]
   */
  function toggleCheckbox(checkbox) {
    var checked = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];

    if (checked === null) {
      checkbox.checked = !checkbox.checked;
    } else {
      checkbox.checked = checked;
    }
    eventManager.fireEvent(checkbox, 'change');
  }

  /**
   * Call callback for each found selected cell with checkbox type.
   *
   * @private
   * @param {Function} callback
   */
  function eachSelectedCheckboxCell(callback) {
    var selRange = instance.getSelectedRange();
    var topLeft = selRange.getTopLeftCorner();
    var bottomRight = selRange.getBottomRightCorner();

    for (var _row = topLeft.row; _row <= bottomRight.row; _row++) {
      for (var _col = topLeft.col; _col <= bottomRight.col; _col++) {
        var cell = instance.getCell(_row, _col);
        var _cellProperties = instance.getCellMeta(_row, _col);
        var checkboxes = cell.querySelectorAll('input[type=checkbox]');

        if (checkboxes.length > 0 && !_cellProperties.readOnly) {
          callback(checkboxes);
        }
      }
    }
  }
}

exports.checkboxRenderer = checkboxRenderer;

(0, _renderers.registerRenderer)('checkbox', checkboxRenderer);

/**
 * Create input element.
 *
 * @returns {Node}
 */
function createInput() {
  var input = document.createElement('INPUT');

  input.className = 'htCheckboxRendererInput';
  input.type = 'checkbox';
  input.setAttribute('autocomplete', 'off');

  return input.cloneNode(false);
}

function preventDefault(event) {
  event.preventDefault();
}

},{"./../eventManager":46,"./../helpers/dom/element":50,"./../helpers/dom/event":51,"./../helpers/string":57,"./../helpers/unicode":58,"./../renderers":62}],66:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _helpersDomElement = require('./../helpers/dom/element');

var _renderers = require('./../renderers');

/**
 * @private
 * @renderer HtmlRenderer
 * @param instance
 * @param TD
 * @param row
 * @param col
 * @param prop
 * @param value
 * @param cellProperties
 */
function htmlRenderer(instance, TD, row, col, prop, value, cellProperties) {
  (0, _renderers.getRenderer)('base').apply(this, arguments);
  (0, _helpersDomElement.fastInnerHTML)(TD, value);
}

exports.htmlRenderer = htmlRenderer;

(0, _renderers.registerRenderer)('html', htmlRenderer);

},{"./../helpers/dom/element":50,"./../renderers":62}],67:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _numeral = require('numeral');

var _numeral2 = _interopRequireDefault(_numeral);

var _helpersDomElement = require('./../helpers/dom/element');

var _renderers = require('./../renderers');

var _helpersNumber = require('./../helpers/number');

/**
 * Numeric cell renderer
 *
 * @private
 * @renderer NumericRenderer
 * @dependencies numeral
 * @param {Object} instance Handsontable instance
 * @param {Element} TD Table cell where to render
 * @param {Number} row
 * @param {Number} col
 * @param {String|Number} prop Row object property name
 * @param value Value to render (remember to escape unsafe HTML before inserting to DOM!)
 * @param {Object} cellProperties Cell properties (shared by cell renderer and editor)
 */
function numericRenderer(instance, TD, row, col, prop, value, cellProperties) {
  if ((0, _helpersNumber.isNumeric)(value)) {
    if (typeof cellProperties.language !== 'undefined') {
      _numeral2['default'].language(cellProperties.language);
    }
    value = (0, _numeral2['default'])(value).format(cellProperties.format || '0'); //docs: http://numeraljs.com/
    (0, _helpersDomElement.addClass)(TD, 'htNumeric');
  }
  (0, _renderers.getRenderer)('text')(instance, TD, row, col, prop, value, cellProperties);
}

exports.numericRenderer = numericRenderer;

(0, _renderers.registerRenderer)('numeric', numericRenderer);

},{"./../helpers/dom/element":50,"./../helpers/number":54,"./../renderers":62,"numeral":5}],68:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _helpersDomElement = require('./../helpers/dom/element');

var _renderers = require('./../renderers');

/**
 * @private
 * @renderer PasswordRenderer
 * @param instance
 * @param TD
 * @param row
 * @param col
 * @param prop
 * @param value
 * @param cellProperties
 */
function passwordRenderer(instance, TD, row, col, prop, value, cellProperties) {
  (0, _renderers.getRenderer)('text').apply(this, arguments);

  value = TD.innerHTML;

  var hash;
  var hashLength = cellProperties.hashLength || value.length;
  var hashSymbol = cellProperties.hashSymbol || '*';

  for (hash = ''; hash.split(hashSymbol).length - 1 < hashLength; hash += hashSymbol) {}

  (0, _helpersDomElement.fastInnerHTML)(TD, hash);
}

exports.passwordRenderer = passwordRenderer;

(0, _renderers.registerRenderer)('password', passwordRenderer);

},{"./../helpers/dom/element":50,"./../renderers":62}],69:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _helpersDomElement = require('./../helpers/dom/element');

var _helpersMixed = require('./../helpers/mixed');

var _renderers = require('./../renderers');

/**
 * Default text renderer
 *
 * @private
 * @renderer TextRenderer
 * @param {Object} instance Handsontable instance
 * @param {Element} TD Table cell where to render
 * @param {Number} row
 * @param {Number} col
 * @param {String|Number} prop Row object property name
 * @param value Value to render (remember to escape unsafe HTML before inserting to DOM!)
 * @param {Object} cellProperties Cell properties (shared by cell renderer and editor)
 */
function textRenderer(instance, TD, row, col, prop, value, cellProperties) {
  (0, _renderers.getRenderer)('base').apply(this, arguments);

  if (!value && cellProperties.placeholder) {
    value = cellProperties.placeholder;
  }

  var escaped = (0, _helpersMixed.stringify)(value);

  if (!instance.getSettings().trimWhitespace) {
    escaped = escaped.replace(/ /g, String.fromCharCode(160));
  }

  if (cellProperties.rendererTemplate) {
    (0, _helpersDomElement.empty)(TD);
    var TEMPLATE = document.createElement('TEMPLATE');
    TEMPLATE.setAttribute('bind', '{{}}');
    TEMPLATE.innerHTML = cellProperties.rendererTemplate;
    HTMLTemplateElement.decorate(TEMPLATE);
    TEMPLATE.model = instance.getSourceDataAtRow(row);
    TD.appendChild(TEMPLATE);
  } else {
    // this is faster than innerHTML. See: https://github.com/handsontable/handsontable/wiki/JavaScript-&-DOM-performance-tips
    (0, _helpersDomElement.fastInnerText)(TD, escaped);
  }
}

exports.textRenderer = textRenderer;

(0, _renderers.registerRenderer)('text', textRenderer);

},{"./../helpers/dom/element":50,"./../helpers/mixed":53,"./../renderers":62}],70:[function(require,module,exports){
/* jshint ignore:start */
'use strict';

(function (global) {
  'use strict';
  if (global.$traceurRuntime) {
    return;
  }
  var $Object = Object;
  var $TypeError = TypeError;
  var $create = $Object.create;
  var $defineProperties = $Object.defineProperties;
  var $defineProperty = $Object.defineProperty;
  var $freeze = $Object.freeze;
  var $getOwnPropertyDescriptor = $Object.getOwnPropertyDescriptor;
  var $getOwnPropertyNames = $Object.getOwnPropertyNames;
  var $keys = $Object.keys;
  var $hasOwnProperty = $Object.prototype.hasOwnProperty;
  var $preventExtensions = Object.preventExtensions;
  var $seal = Object.seal;
  var $isExtensible = Object.isExtensible;
  function nonEnum(value) {
    return {
      configurable: true,
      enumerable: false,
      value: value,
      writable: true
    };
  }
  var method = nonEnum;
  var counter = 0;
  function newUniqueString() {
    return '__$' + Math.floor(Math.random() * 1e9) + '$' + ++counter + '$__';
  }
  var symbolInternalProperty = newUniqueString();
  var symbolDescriptionProperty = newUniqueString();
  var symbolDataProperty = newUniqueString();
  var symbolValues = $create(null);
  var privateNames = $create(null);
  function isPrivateName(s) {
    return privateNames[s];
  }
  function createPrivateName() {
    var s = newUniqueString();
    privateNames[s] = true;
    return s;
  }
  function isShimSymbol(symbol) {
    return typeof symbol === 'object' && symbol instanceof SymbolValue;
  }
  function typeOf(v) {
    if (isShimSymbol(v)) return 'symbol';
    return typeof v;
  }
  function Symbol(description) {
    var value = new SymbolValue(description);
    if (!(this instanceof Symbol)) return value;
    throw new TypeError('Symbol cannot be new\'ed');
  }
  $defineProperty(Symbol.prototype, 'constructor', nonEnum(Symbol));
  $defineProperty(Symbol.prototype, 'toString', method(function () {
    var symbolValue = this[symbolDataProperty];
    if (!getOption('symbols')) return symbolValue[symbolInternalProperty];
    if (!symbolValue) throw TypeError('Conversion from symbol to string');
    var desc = symbolValue[symbolDescriptionProperty];
    if (desc === undefined) desc = '';
    return 'Symbol(' + desc + ')';
  }));
  $defineProperty(Symbol.prototype, 'valueOf', method(function () {
    var symbolValue = this[symbolDataProperty];
    if (!symbolValue) throw TypeError('Conversion from symbol to string');
    if (!getOption('symbols')) return symbolValue[symbolInternalProperty];
    return symbolValue;
  }));
  function SymbolValue(description) {
    var key = newUniqueString();
    $defineProperty(this, symbolDataProperty, { value: this });
    $defineProperty(this, symbolInternalProperty, { value: key });
    $defineProperty(this, symbolDescriptionProperty, { value: description });
    freeze(this);
    symbolValues[key] = this;
  }
  $defineProperty(SymbolValue.prototype, 'constructor', nonEnum(Symbol));
  $defineProperty(SymbolValue.prototype, 'toString', {
    value: Symbol.prototype.toString,
    enumerable: false
  });
  $defineProperty(SymbolValue.prototype, 'valueOf', {
    value: Symbol.prototype.valueOf,
    enumerable: false
  });
  var hashProperty = createPrivateName();
  var hashPropertyDescriptor = { value: undefined };
  var hashObjectProperties = {
    hash: { value: undefined },
    self: { value: undefined }
  };
  var hashCounter = 0;
  function getOwnHashObject(object) {
    var hashObject = object[hashProperty];
    if (hashObject && hashObject.self === object) return hashObject;
    if ($isExtensible(object)) {
      hashObjectProperties.hash.value = hashCounter++;
      hashObjectProperties.self.value = object;
      hashPropertyDescriptor.value = $create(null, hashObjectProperties);
      $defineProperty(object, hashProperty, hashPropertyDescriptor);
      return hashPropertyDescriptor.value;
    }
    return undefined;
  }
  function freeze(object) {
    getOwnHashObject(object);
    return $freeze.apply(this, arguments);
  }
  function preventExtensions(object) {
    getOwnHashObject(object);
    return $preventExtensions.apply(this, arguments);
  }
  function seal(object) {
    getOwnHashObject(object);
    return $seal.apply(this, arguments);
  }
  freeze(SymbolValue.prototype);
  function isSymbolString(s) {
    return symbolValues[s] || privateNames[s];
  }
  function toProperty(name) {
    if (isShimSymbol(name)) return name[symbolInternalProperty];
    return name;
  }
  function removeSymbolKeys(array) {
    var rv = [];
    for (var i = 0; i < array.length; i++) {
      if (!isSymbolString(array[i])) {
        rv.push(array[i]);
      }
    }
    return rv;
  }
  function getOwnPropertyNames(object) {
    return removeSymbolKeys($getOwnPropertyNames(object));
  }
  function keys(object) {
    return removeSymbolKeys($keys(object));
  }
  function getOwnPropertySymbols(object) {
    var rv = [];
    var names = $getOwnPropertyNames(object);
    for (var i = 0; i < names.length; i++) {
      var symbol = symbolValues[names[i]];
      if (symbol) {
        rv.push(symbol);
      }
    }
    return rv;
  }
  function getOwnPropertyDescriptor(object, name) {
    return $getOwnPropertyDescriptor(object, toProperty(name));
  }
  function hasOwnProperty(name) {
    return $hasOwnProperty.call(this, toProperty(name));
  }
  function getOption(name) {
    return global.traceur && global.traceur.options[name];
  }
  function defineProperty(object, name, descriptor) {
    if (isShimSymbol(name)) {
      name = name[symbolInternalProperty];
    }
    $defineProperty(object, name, descriptor);
    return object;
  }
  function polyfillObject(Object) {
    $defineProperty(Object, 'defineProperty', { value: defineProperty });
    $defineProperty(Object, 'getOwnPropertyNames', { value: getOwnPropertyNames });
    $defineProperty(Object, 'getOwnPropertyDescriptor', { value: getOwnPropertyDescriptor });
    $defineProperty(Object.prototype, 'hasOwnProperty', { value: hasOwnProperty });
    $defineProperty(Object, 'freeze', { value: freeze });
    $defineProperty(Object, 'preventExtensions', { value: preventExtensions });
    $defineProperty(Object, 'seal', { value: seal });
    $defineProperty(Object, 'keys', { value: keys });
  }
  function exportStar(object) {
    for (var i = 1; i < arguments.length; i++) {
      var names = $getOwnPropertyNames(arguments[i]);
      for (var j = 0; j < names.length; j++) {
        var name = names[j];
        if (isSymbolString(name)) continue;
        (function (mod, name) {
          $defineProperty(object, name, {
            get: function get() {
              return mod[name];
            },
            enumerable: true
          });
        })(arguments[i], names[j]);
      }
    }
    return object;
  }
  function isObject(x) {
    return x != null && (typeof x === 'object' || typeof x === 'function');
  }
  function toObject(x) {
    if (x == null) throw $TypeError();
    return $Object(x);
  }
  function checkObjectCoercible(argument) {
    if (argument == null) {
      throw new TypeError('Value cannot be converted to an Object');
    }
    return argument;
  }
  function polyfillSymbol(global, Symbol) {
    if (!global.Symbol) {
      global.Symbol = Symbol;
      Object.getOwnPropertySymbols = getOwnPropertySymbols;
    }
    if (!global.Symbol.iterator) {
      global.Symbol.iterator = Symbol('Symbol.iterator');
    }
  }
  function setupGlobals(global) {
    polyfillSymbol(global, Symbol);
    global.Reflect = global.Reflect || {};
    global.Reflect.global = global.Reflect.global || global;
    polyfillObject(global.Object);
  }
  setupGlobals(global);
  global.$traceurRuntime = {
    checkObjectCoercible: checkObjectCoercible,
    createPrivateName: createPrivateName,
    defineProperties: $defineProperties,
    defineProperty: $defineProperty,
    exportStar: exportStar,
    getOwnHashObject: getOwnHashObject,
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    getOwnPropertyNames: $getOwnPropertyNames,
    isObject: isObject,
    isPrivateName: isPrivateName,
    isSymbolString: isSymbolString,
    keys: $keys,
    setupGlobals: setupGlobals,
    toObject: toObject,
    toProperty: toProperty,
    'typeof': typeOf
  };
})(window);
(function () {
  'use strict';
  var $toProperty = $traceurRuntime.toProperty;

  function spread() {
    var rv = [],
        j = 0,
        iterResult;
    for (var i = 0; i < arguments.length; i++) {
      var valueToSpread = $traceurRuntime.checkObjectCoercible(arguments[i]);
      if (typeof valueToSpread[$toProperty(Symbol.iterator)] !== 'function') {
        throw new TypeError('Cannot spread non-iterable object.');
      }
      var iter = valueToSpread[$toProperty(Symbol.iterator)]();
      while (!(iterResult = iter.next()).done) {
        rv[j++] = iterResult.value;
      }
    }
    return rv;
  }
  $traceurRuntime.spread = spread;
})();
(function () {
  'use strict';
  var $Object = Object;
  var $TypeError = TypeError;
  var $create = $Object.create;
  var $defineProperties = $traceurRuntime.defineProperties;
  var $defineProperty = $traceurRuntime.defineProperty;
  var $getOwnPropertyDescriptor = $traceurRuntime.getOwnPropertyDescriptor;
  var $getPrototypeOf = Object.getPrototypeOf;
  var $toProperty = $traceurRuntime.toProperty;
  var $__0 = Object,
      getOwnPropertyNames = $__0.getOwnPropertyNames,
      getOwnPropertySymbols = $__0.getOwnPropertySymbols;
  function superDescriptor(homeObject, name) {
    var proto = $getPrototypeOf(homeObject);
    do {
      var result = $getOwnPropertyDescriptor(proto, name);
      if (result) return result;
      proto = $getPrototypeOf(proto);
    } while (proto);
    return undefined;
  }
  function superConstructor(ctor) {
    return ctor.__proto__;
  }
  function superCall(self, homeObject, name, args) {
    return superGet(self, homeObject, name).apply(self, args);
  }
  function superGet(self, homeObject, name) {
    var descriptor = superDescriptor(homeObject, name);
    if (descriptor) {
      if (!descriptor.get) return descriptor.value;
      return descriptor.get.call(self);
    }
    return undefined;
  }
  function superSet(self, homeObject, name, value) {
    var descriptor = superDescriptor(homeObject, name);
    if (descriptor && descriptor.set) {
      descriptor.set.call(self, value);
      return value;
    }
    throw $TypeError("super has no setter '" + name + "'.");
  }
  function getDescriptors(object) {
    var descriptors = {};
    var names = getOwnPropertyNames(object);
    for (var i = 0; i < names.length; i++) {
      var name = names[i];
      descriptors[name] = $getOwnPropertyDescriptor(object, name);
    }
    var symbols = getOwnPropertySymbols(object);
    for (var i = 0; i < symbols.length; i++) {
      var symbol = symbols[i];
      descriptors[$toProperty(symbol)] = $getOwnPropertyDescriptor(object, $toProperty(symbol));
    }
    return descriptors;
  }
  function createClass(ctor, object, staticObject, superClass) {
    $defineProperty(object, 'constructor', {
      value: ctor,
      configurable: true,
      enumerable: false,
      writable: true
    });
    if (arguments.length > 3) {
      if (typeof superClass === 'function') ctor.__proto__ = superClass;
      ctor.prototype = $create(getProtoParent(superClass), getDescriptors(object));
    } else {
      ctor.prototype = object;
    }
    $defineProperty(ctor, 'prototype', {
      configurable: false,
      writable: false
    });
    return $defineProperties(ctor, getDescriptors(staticObject));
  }
  function getProtoParent(superClass) {
    if (typeof superClass === 'function') {
      var prototype = superClass.prototype;
      if ($Object(prototype) === prototype || prototype === null) return superClass.prototype;
      throw new $TypeError('super prototype must be an Object or null');
    }
    if (superClass === null) return null;
    throw new $TypeError("Super expression must either be null or a function, not " + typeof superClass + ".");
  }
  function defaultSuperCall(self, homeObject, args) {
    if ($getPrototypeOf(homeObject) !== null) superCall(self, homeObject, 'constructor', args);
  }
  $traceurRuntime.createClass = createClass;
  $traceurRuntime.defaultSuperCall = defaultSuperCall;
  $traceurRuntime.superCall = superCall;
  $traceurRuntime.superConstructor = superConstructor;
  $traceurRuntime.superGet = superGet;
  $traceurRuntime.superSet = superSet;
})();
/* jshint ignore:end */

},{}],71:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _helpersDomElement = require('./helpers/dom/element');

var _eventManager = require('./eventManager');

var _helpersDomEvent = require('./helpers/dom/event');

var _rdpartyWalkontableSrcCellCoords = require('./3rdparty/walkontable/src/cell/coords');

var _rdpartyWalkontableSrcSelection = require('./3rdparty/walkontable/src/selection');

var _rdpartyWalkontableSrcCore = require('./3rdparty/walkontable/src/core');

// Support for older Handsontable versions
Handsontable.TableView = TableView;

/**
 * Handsontable TableView constructor
 * @param {Object} instance
 */
function TableView(instance) {
  var that = this;

  this.eventManager = (0, _eventManager.eventManager)(instance);
  this.instance = instance;
  this.settings = instance.getSettings();

  var originalStyle = instance.rootElement.getAttribute('style');

  if (originalStyle) {
    instance.rootElement.setAttribute('data-originalstyle', originalStyle); //needed to retrieve original style in jsFiddle link generator in HT examples. may be removed in future versions
  }

  (0, _helpersDomElement.addClass)(instance.rootElement, 'handsontable');
  //  instance.rootElement.addClass('handsontable');

  var table = document.createElement('TABLE');
  (0, _helpersDomElement.addClass)(table, 'htCore');

  if (instance.getSettings().tableClassName) {
    (0, _helpersDomElement.addClass)(table, instance.getSettings().tableClassName);
  }
  this.THEAD = document.createElement('THEAD');
  table.appendChild(this.THEAD);
  this.TBODY = document.createElement('TBODY');
  table.appendChild(this.TBODY);

  instance.table = table;

  instance.container.insertBefore(table, instance.container.firstChild);

  this.eventManager.addEventListener(instance.rootElement, 'mousedown', function (event) {
    if (!that.isTextSelectionAllowed(event.target)) {
      clearTextSelection();
      event.preventDefault();
      window.focus(); //make sure that window that contains HOT is active. Important when HOT is in iframe.
    }
  });

  this.eventManager.addEventListener(document.documentElement, 'keyup', function (event) {
    if (instance.selection.isInProgress() && !event.shiftKey) {
      instance.selection.finish();
    }
  });

  var isMouseDown;
  this.isMouseDown = function () {
    return isMouseDown;
  };

  this.eventManager.addEventListener(document.documentElement, 'mouseup', function (event) {
    if (instance.selection.isInProgress() && event.which === 1) {
      //is left mouse button
      instance.selection.finish();
    }

    isMouseDown = false;

    if ((0, _helpersDomElement.isOutsideInput)(document.activeElement)) {
      instance.unlisten();
    }
  });

  this.eventManager.addEventListener(document.documentElement, 'mousedown', function (event) {
    var next = event.target;
    var eventX = event.x || event.clientX;
    var eventY = event.y || event.clientY;

    if (isMouseDown || !instance.rootElement) {
      return; // it must have been started in a cell
    }

    // immediate click on "holder" means click on the right side of vertical scrollbar
    if (next !== instance.view.wt.wtTable.holder) {
      while (next !== document.documentElement) {
        if (next === null) {
          if (event.isTargetWebComponent) {
            break;
          }
          // click on something that was a row but now is detached (possibly because your click triggered a rerender)
          return;
        }
        if (next === instance.rootElement) {
          // click inside container
          return;
        }
        next = next.parentNode;
      }
    } else {
      var scrollbarWidth = (0, _helpersDomElement.getScrollbarWidth)();

      if (document.elementFromPoint(eventX + scrollbarWidth, eventY) !== instance.view.wt.wtTable.holder || document.elementFromPoint(eventX, eventY + scrollbarWidth) !== instance.view.wt.wtTable.holder) {
        return;
      }
    }

    // function did not return until here, we have an outside click!
    if (that.settings.outsideClickDeselects) {
      instance.deselectCell();
    } else {
      instance.destroyEditor();
    }
  });

  this.eventManager.addEventListener(table, 'selectstart', function (event) {
    if (that.settings.fragmentSelection) {
      return;
    }

    //https://github.com/handsontable/handsontable/issues/160
    //selectstart is IE only event. Prevent text from being selected when performing drag down in IE8
    event.preventDefault();
  });

  var clearTextSelection = function clearTextSelection() {
    //http://stackoverflow.com/questions/3169786/clear-text-selection-with-javascript
    if (window.getSelection) {
      if (window.getSelection().empty) {
        // Chrome
        window.getSelection().empty();
      } else if (window.getSelection().removeAllRanges) {
        // Firefox
        window.getSelection().removeAllRanges();
      }
    } else if (document.selection) {
      // IE?
      document.selection.empty();
    }
  };

  var selections = [new _rdpartyWalkontableSrcSelection.WalkontableSelection({
    className: 'current',
    border: {
      width: 2,
      color: '#5292F7',
      //style: 'solid', //not used
      cornerVisible: function cornerVisible() {
        return that.settings.fillHandle && !that.isCellEdited() && !instance.selection.isMultiple();
      },
      multipleSelectionHandlesVisible: function multipleSelectionHandlesVisible() {
        return !that.isCellEdited() && !instance.selection.isMultiple();
      }
    }
  }), new _rdpartyWalkontableSrcSelection.WalkontableSelection({
    className: 'area',
    border: {
      width: 1,
      color: '#89AFF9',
      //style: 'solid', // not used
      cornerVisible: function cornerVisible() {
        return that.settings.fillHandle && !that.isCellEdited() && instance.selection.isMultiple();
      },
      multipleSelectionHandlesVisible: function multipleSelectionHandlesVisible() {
        return !that.isCellEdited() && instance.selection.isMultiple();
      }
    }
  }), new _rdpartyWalkontableSrcSelection.WalkontableSelection({
    className: 'highlight',
    highlightRowClassName: that.settings.currentRowClassName,
    highlightColumnClassName: that.settings.currentColClassName
  }), new _rdpartyWalkontableSrcSelection.WalkontableSelection({
    className: 'fill',
    border: {
      width: 1,
      color: 'red'
      //style: 'solid' // not used
    }
  })];
  selections.current = selections[0];
  selections.area = selections[1];
  selections.highlight = selections[2];
  selections.fill = selections[3];

  var walkontableConfig = {
    debug: function debug() {
      return that.settings.debug;
    },
    externalRowCalculator: this.instance.getPlugin('autoRowSize') && this.instance.getPlugin('autoRowSize').isEnabled(),
    table: table,
    stretchH: this.settings.stretchH,
    data: instance.getDataAtCell,
    totalRows: instance.countRows,
    totalColumns: instance.countCols,
    fixedColumnsLeft: function fixedColumnsLeft() {
      return that.settings.fixedColumnsLeft;
    },
    fixedRowsTop: function fixedRowsTop() {
      return that.settings.fixedRowsTop;
    },
    renderAllRows: that.settings.renderAllRows,
    rowHeaders: function rowHeaders() {
      var arr = [];
      if (instance.hasRowHeaders()) {
        arr.push(function (index, TH) {
          that.appendRowHeader(index, TH);
        });
      }
      Handsontable.hooks.run(instance, 'afterGetRowHeaderRenderers', arr);
      return arr;
    },
    columnHeaders: function columnHeaders() {

      var arr = [];
      if (instance.hasColHeaders()) {
        arr.push(function (index, TH) {
          that.appendColHeader(index, TH);
        });
      }
      Handsontable.hooks.run(instance, 'afterGetColumnHeaderRenderers', arr);
      return arr;
    },
    columnWidth: instance.getColWidth,
    rowHeight: instance.getRowHeight,
    cellRenderer: function cellRenderer(row, col, TD) {

      var prop = that.instance.colToProp(col),
          cellProperties = that.instance.getCellMeta(row, col),
          renderer = that.instance.getCellRenderer(cellProperties);

      var value = that.instance.getDataAtRowProp(row, prop);

      renderer(that.instance, TD, row, col, prop, value, cellProperties);
      Handsontable.hooks.run(that.instance, 'afterRenderer', TD, row, col, prop, value, cellProperties);
    },
    selections: selections,
    hideBorderOnMouseDownOver: function hideBorderOnMouseDownOver() {
      return that.settings.fragmentSelection;
    },
    onCellMouseDown: function onCellMouseDown(event, coords, TD, wt) {
      instance.listen();
      that.activeWt = wt;

      isMouseDown = true;

      Handsontable.hooks.run(instance, 'beforeOnCellMouseDown', event, coords, TD);

      if (!(0, _helpersDomEvent.isImmediatePropagationStopped)(event)) {
        if (event.button === 2 && instance.selection.inInSelection(coords)) {//right mouse button
          //do nothing
        } else if (event.shiftKey) {
            if (coords.row >= 0 && coords.col >= 0) {
              instance.selection.setRangeEnd(coords);
            }
          } else {
            if ((coords.row < 0 || coords.col < 0) && (coords.row >= 0 || coords.col >= 0)) {
              if (coords.row < 0) {
                instance.selectCell(0, coords.col, instance.countRows() - 1, coords.col);
                instance.selection.setSelectedHeaders(false, true);
              }
              if (coords.col < 0) {
                instance.selectCell(coords.row, 0, coords.row, instance.countCols() - 1);
                instance.selection.setSelectedHeaders(true, false);
              }
            } else {
              coords.row = coords.row < 0 ? 0 : coords.row;
              coords.col = coords.col < 0 ? 0 : coords.col;

              instance.selection.setRangeStart(coords);

              instance.selection.setSelectedHeaders(false, false);
            }
          }

        Handsontable.hooks.run(instance, 'afterOnCellMouseDown', event, coords, TD);

        that.activeWt = that.wt;
      }
    },
    /*onCellMouseOut: function (/*event, coords, TD* /) {
     if (isMouseDown && that.settings.fragmentSelection === 'single') {
     clearTextSelection(); //otherwise text selection blinks during multiple cells selection
     }
     },*/
    onCellMouseOver: function onCellMouseOver(event, coords, TD, wt) {
      that.activeWt = wt;
      if (coords.row >= 0 && coords.col >= 0) {
        //is not a header
        if (isMouseDown) {
          /*if (that.settings.fragmentSelection === 'single') {
           clearTextSelection(); //otherwise text selection blinks during multiple cells selection
           }*/
          instance.selection.setRangeEnd(coords);
        }
      } else {
        if (isMouseDown) {
          // multi select columns
          if (coords.row < 0) {
            if (instance.selection.selectedHeader.cols) {
              instance.selection.setRangeEnd(new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(instance.countRows() - 1, coords.col));
              instance.selection.setSelectedHeaders(false, true);
            } else {
              instance.selection.setRangeEnd(new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(coords.row, coords.col));
            }
          }

          // multi select rows
          if (coords.col < 0) {
            if (instance.selection.selectedHeader.rows) {
              instance.selection.setRangeEnd(new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(coords.row, instance.countCols() - 1));
              instance.selection.setSelectedHeaders(true, false);
            } else {
              instance.selection.setRangeEnd(new _rdpartyWalkontableSrcCellCoords.WalkontableCellCoords(coords.row, coords.col));
            }
          }
        }
      }

      Handsontable.hooks.run(instance, 'afterOnCellMouseOver', event, coords, TD);
      that.activeWt = that.wt;
    },
    onCellCornerMouseDown: function onCellCornerMouseDown(event) {
      event.preventDefault();
      Handsontable.hooks.run(instance, 'afterOnCellCornerMouseDown', event);
    },
    beforeDraw: function beforeDraw(force) {
      that.beforeRender(force);
    },
    onDraw: function onDraw(force) {
      that.onDraw(force);
    },
    onScrollVertically: function onScrollVertically() {
      instance.runHooks('afterScrollVertically');
    },
    onScrollHorizontally: function onScrollHorizontally() {
      instance.runHooks('afterScrollHorizontally');
    },
    onBeforeDrawBorders: function onBeforeDrawBorders(corners, borderClassName) {
      instance.runHooks('beforeDrawBorders', corners, borderClassName);
    },
    onBeforeTouchScroll: function onBeforeTouchScroll() {
      instance.runHooks('beforeTouchScroll');
    },
    onAfterMomentumScroll: function onAfterMomentumScroll() {
      instance.runHooks('afterMomentumScroll');
    },
    viewportRowCalculatorOverride: function viewportRowCalculatorOverride(calc) {
      var rows = instance.countRows();
      var viewportOffset = that.settings.viewportRowRenderingOffset;

      if (viewportOffset === 'auto' && that.settings.fixedRowsTop) {
        viewportOffset = 10;
      }
      if (typeof viewportOffset === 'number') {
        calc.startRow = Math.max(calc.startRow - viewportOffset, 0);
        calc.endRow = Math.min(calc.endRow + viewportOffset, rows - 1);
      }
      if (viewportOffset === 'auto') {
        var center = calc.startRow + calc.endRow - calc.startRow;
        var offset = Math.ceil(center / rows * 12);

        calc.startRow = Math.max(calc.startRow - offset, 0);
        calc.endRow = Math.min(calc.endRow + offset, rows - 1);
      }
      instance.runHooks('afterViewportRowCalculatorOverride', calc);
    },
    viewportColumnCalculatorOverride: function viewportColumnCalculatorOverride(calc) {
      var cols = instance.countCols();
      var viewportOffset = that.settings.viewportColumnRenderingOffset;

      if (viewportOffset === 'auto' && that.settings.fixedColumnsLeft) {
        viewportOffset = 10;
      }
      if (typeof viewportOffset === 'number') {
        calc.startColumn = Math.max(calc.startColumn - viewportOffset, 0);
        calc.endColumn = Math.min(calc.endColumn + viewportOffset, cols - 1);
      }
      if (viewportOffset === 'auto') {
        var center = calc.startColumn + calc.endColumn - calc.startColumn;
        var offset = Math.ceil(center / cols * 12);

        calc.startRow = Math.max(calc.startColumn - offset, 0);
        calc.endColumn = Math.min(calc.endColumn + offset, cols - 1);
      }
      instance.runHooks('afterViewportColumnCalculatorOverride', calc);
    }
  };

  Handsontable.hooks.run(instance, 'beforeInitWalkontable', walkontableConfig);

  this.wt = new _rdpartyWalkontableSrcCore.Walkontable(walkontableConfig);
  this.activeWt = this.wt;

  this.eventManager.addEventListener(that.wt.wtTable.spreader, 'mousedown', function (event) {
    //right mouse button exactly on spreader means right click on the right hand side of vertical scrollbar
    if (event.target === that.wt.wtTable.spreader && event.which === 3) {
      (0, _helpersDomEvent.stopPropagation)(event);
      //event.stopPropagation();
    }
  });

  this.eventManager.addEventListener(that.wt.wtTable.spreader, 'contextmenu', function (event) {
    //right mouse button exactly on spreader means right click on the right hand side of vertical scrollbar
    if (event.target === that.wt.wtTable.spreader && event.which === 3) {
      (0, _helpersDomEvent.stopPropagation)(event);
      //event.stopPropagation();
    }
  });

  this.eventManager.addEventListener(document.documentElement, 'click', function () {
    if (that.settings.observeDOMVisibility) {
      if (that.wt.drawInterrupted) {
        that.instance.forceFullRender = true;
        that.render();
      }
    }
  });
}

TableView.prototype.isTextSelectionAllowed = function (el) {
  if ((0, _helpersDomElement.isInput)(el)) {
    return true;
  }
  if (this.settings.fragmentSelection && (0, _helpersDomElement.isChildOf)(el, this.TBODY)) {
    return true;
  }

  return false;
};

TableView.prototype.isCellEdited = function () {
  var activeEditor = this.instance.getActiveEditor();

  return activeEditor && activeEditor.isOpened();
};

TableView.prototype.beforeRender = function (force) {
  if (force) {
    //this.instance.forceFullRender = did Handsontable request full render?
    Handsontable.hooks.run(this.instance, 'beforeRender', this.instance.forceFullRender);
  }
};

TableView.prototype.onDraw = function (force) {
  if (force) {
    //this.instance.forceFullRender = did Handsontable request full render?
    Handsontable.hooks.run(this.instance, 'afterRender', this.instance.forceFullRender);
  }
};

TableView.prototype.render = function () {
  this.wt.draw(!this.instance.forceFullRender);
  this.instance.forceFullRender = false;
  this.instance.renderCall = false;
};

/**
 * Returns td object given coordinates
 * @param {WalkontableCellCoords} coords
 * @param {Boolean} topmost
 */
TableView.prototype.getCellAtCoords = function (coords, topmost) {
  var td = this.wt.getCell(coords, topmost);
  //var td = this.wt.wtTable.getCell(coords);
  if (td < 0) {
    //there was an exit code (cell is out of bounds)
    return null;
  } else {
    return td;
  }
};

/**
 * Scroll viewport to selection
 * @param {WalkontableCellCoords} coords
 */
TableView.prototype.scrollViewport = function (coords) {
  this.wt.scrollViewport(coords);
};

/**
 * Append row header to a TH element
 * @param row
 * @param TH
 */
TableView.prototype.appendRowHeader = function (row, TH) {
  if (TH.firstChild) {
    var container = TH.firstChild;

    if (!(0, _helpersDomElement.hasClass)(container, 'relative')) {
      (0, _helpersDomElement.empty)(TH);
      this.appendRowHeader(row, TH);

      return;
    }
    this.updateCellHeader(container.querySelector('.rowHeader'), row, this.instance.getRowHeader);
  } else {
    var div = document.createElement('div');
    var span = document.createElement('span');

    div.className = 'relative';
    span.className = 'rowHeader';
    this.updateCellHeader(span, row, this.instance.getRowHeader);

    div.appendChild(span);
    TH.appendChild(div);
  }
  Handsontable.hooks.run(this.instance, 'afterGetRowHeader', row, TH);
};

/**
 * Append column header to a TH element
 * @param col
 * @param TH
 */
TableView.prototype.appendColHeader = function (col, TH) {
  if (TH.firstChild) {
    var container = TH.firstChild;

    if (!(0, _helpersDomElement.hasClass)(container, 'relative')) {
      (0, _helpersDomElement.empty)(TH);
      this.appendRowHeader(col, TH);

      return;
    }
    this.updateCellHeader(container.querySelector('.colHeader'), col, this.instance.getColHeader);
  } else {
    var div = document.createElement('div');
    var span = document.createElement('span');

    div.className = 'relative';
    span.className = 'colHeader';
    this.updateCellHeader(span, col, this.instance.getColHeader);

    div.appendChild(span);
    TH.appendChild(div);
  }
  Handsontable.hooks.run(this.instance, 'afterGetColHeader', col, TH);
};

/**
 * Update header cell content
 *
 * @since 0.15.0-beta4
 * @param {HTMLElement} element Element to update
 * @param {Number} index Row index or column index
 * @param {Function} content Function which should be returns content for this cell
 */
TableView.prototype.updateCellHeader = function (element, index, content) {
  if (index > -1) {
    (0, _helpersDomElement.fastInnerHTML)(element, content(index));
  } else {
    // workaround for https://github.com/handsontable/handsontable/issues/1946
    (0, _helpersDomElement.fastInnerText)(element, String.fromCharCode(160));
    (0, _helpersDomElement.addClass)(element, 'cornerHeader');
  }
};

/**
 * Given a element's left position relative to the viewport, returns maximum element width until the right
 * edge of the viewport (before scrollbar)
 *
 * @param {Number} leftOffset
 * @return {Number}
 */
TableView.prototype.maximumVisibleElementWidth = function (leftOffset) {
  var workspaceWidth = this.wt.wtViewport.getWorkspaceWidth();
  var maxWidth = workspaceWidth - leftOffset;
  return maxWidth > 0 ? maxWidth : 0;
};

/**
 * Given a element's top position relative to the viewport, returns maximum element height until the bottom
 * edge of the viewport (before scrollbar)
 *
 * @param {Number} topOffset
 * @return {Number}
 */
TableView.prototype.maximumVisibleElementHeight = function (topOffset) {
  var workspaceHeight = this.wt.wtViewport.getWorkspaceHeight();
  var maxHeight = workspaceHeight - topOffset;
  return maxHeight > 0 ? maxHeight : 0;
};

TableView.prototype.mainViewIsActive = function () {
  return this.wt === this.activeWt;
};

TableView.prototype.destroy = function () {
  this.wt.destroy();
  this.eventManager.destroy();
};

exports.TableView = TableView;

},{"./3rdparty/walkontable/src/cell/coords":11,"./3rdparty/walkontable/src/core":13,"./3rdparty/walkontable/src/selection":24,"./eventManager":46,"./helpers/dom/element":50,"./helpers/dom/event":51}],72:[function(require,module,exports){
'use strict';

var _helpersMixed = require('./../helpers/mixed');

/**
 * Autocomplete cell validator.
 *
 * @private
 * @validator AutocompleteValidator
 * @param {*} value - Value of edited cell
 * @param {Function} callback - Callback called with validation result
 */
Handsontable.AutocompleteValidator = function (value, callback) {
  if (this.strict && this.source) {
    if (typeof this.source === 'function') {
      this.source(value, process(value, callback));
    } else {
      process(value, callback)(this.source);
    }
  } else {
    callback(true);
  }
};

/**
 * Function responsible for validation of autocomplete value.
 *
 * @param {*} value - Value of edited cell
 * @param {Function} callback - Callback called with validation result
 */
function process(value, callback) {
  var originalVal = value;
  var lowercaseVal = typeof originalVal === 'string' ? originalVal.toLowerCase() : null;

  return function (source) {
    var found = false;
    for (var s = 0, slen = source.length; s < slen; s++) {
      if (originalVal === source[s]) {
        found = true; //perfect match
        break;
      } else if (lowercaseVal === (0, _helpersMixed.stringify)(source[s]).toLowerCase()) {
        // changes[i][3] = source[s]; //good match, fix the case << TODO?
        found = true;
        break;
      }
    }

    callback(found);
  };
}

},{"./../helpers/mixed":53}],73:[function(require,module,exports){
'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

var _editors = require('./../editors');

/**
 * Date cell validator
 *
 * @private
 * @validator DateValidator
 * @dependencies moment
 * @param {*} value - Value of edited cell
 * @param {Function} callback - Callback called with validation result
 */
Handsontable.DateValidator = function (value, callback) {
  var valid = true;
  var dateEditor = (0, _editors.getEditor)('date', this.instance);

  if (value === null) {
    value = '';
  }
  var isValidDate = (0, _moment2['default'])(new Date(value)).isValid();
  // is it in the specified format
  var isValidFormat = (0, _moment2['default'])(value, this.dateFormat || dateEditor.defaultDateFormat, true).isValid();

  if (!isValidDate) {
    valid = false;
  }
  if (!isValidDate && isValidFormat) {
    valid = true;
  }

  if (isValidDate && !isValidFormat) {
    if (this.correctFormat === true) {
      // if format correction is enabled
      var correctedValue = correctFormat(value, this.dateFormat);

      this.instance.setDataAtCell(this.row, this.col, correctedValue, 'dateValidator');
      valid = true;
    } else {
      valid = false;
    }
  }

  callback(valid);
};

/**
 * Format the given string using moment.js' format feature
 *
 * @param {String} value
 * @param {String} dateFormat
 * @returns {String}
 */
var correctFormat = function correctFormat(value, dateFormat) {
  var date = (0, _moment2['default'])(new Date(value));
  var year = date.format('YYYY');
  var yearNow = (0, _moment2['default'])().format('YYYY');

  // Firefox and IE counting 2-digits year from 1900 rest from current age.
  if (year.substr(0, 2) !== yearNow.substr(0, 2)) {
    if (!value.match(new RegExp(year))) {
      date.year(year.replace(year.substr(0, 2), yearNow.substr(0, 2)));
    }
  } else if (year.length > 4) {
    // Ugly fix for moment bug which can not format 5-digits year using YYYY
    date.year((date.year() + '').substr(0, 4));
  }

  return date.format(dateFormat);
};

},{"./../editors":34,"moment":4}],74:[function(require,module,exports){
/**
 * Numeric cell validator
 *
 * @private
 * @validator NumericValidator
 * @param {*} value - Value of edited cell
 * @param {*} callback - Callback called with validation result
 */
'use strict';

Handsontable.NumericValidator = function (value, callback) {
  if (value === null) {
    value = '';
  }
  callback(/^-?\d*(\.|\,)?\d*$/.test(value));
};

},{}]},{},[29])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi9oYW5kc29udGFibGUvbm9kZV9tb2R1bGVzL1NoZWV0Q2xpcC5qcyIsIi4uL2hhbmRzb250YWJsZS9ub2RlX21vZHVsZXMvYXV0b1Jlc2l6ZS5qcyIsIi4uL2hhbmRzb250YWJsZS9ub2RlX21vZHVsZXMvZXM2Y29sbGVjdGlvbnMuanMiLCIuLi9oYW5kc29udGFibGUvbm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanMiLCIuLi9oYW5kc29udGFibGUvbm9kZV9tb2R1bGVzL251bWVyYWwuanMiLCIuLi9oYW5kc29udGFibGUvbm9kZV9tb2R1bGVzL3Bpa2FkYXkvcGlrYWRheS5qcyIsIi9Vc2Vycy90eWxlci9kZXYvaGFuZHNvbnRhYmxlL3BsdWdpbnMvanF1ZXJ5SGFuZHNvbnRhYmxlLmpzIiwiL1VzZXJzL3R5bGVyL2Rldi9oYW5kc29udGFibGUvc3JjLzNyZHBhcnR5L3dhbGtvbnRhYmxlL3NyYy9ib3JkZXIuanMiLCIvVXNlcnMvdHlsZXIvZGV2L2hhbmRzb250YWJsZS9zcmMvM3JkcGFydHkvd2Fsa29udGFibGUvc3JjL2NhbGN1bGF0b3Ivdmlld3BvcnRDb2x1bW5zLmpzIiwiL1VzZXJzL3R5bGVyL2Rldi9oYW5kc29udGFibGUvc3JjLzNyZHBhcnR5L3dhbGtvbnRhYmxlL3NyYy9jYWxjdWxhdG9yL3ZpZXdwb3J0Um93cy5qcyIsIi9Vc2Vycy90eWxlci9kZXYvaGFuZHNvbnRhYmxlL3NyYy8zcmRwYXJ0eS93YWxrb250YWJsZS9zcmMvY2VsbC9jb29yZHMuanMiLCIvVXNlcnMvdHlsZXIvZGV2L2hhbmRzb250YWJsZS9zcmMvM3JkcGFydHkvd2Fsa29udGFibGUvc3JjL2NlbGwvcmFuZ2UuanMiLCIvVXNlcnMvdHlsZXIvZGV2L2hhbmRzb250YWJsZS9zcmMvM3JkcGFydHkvd2Fsa29udGFibGUvc3JjL2NvcmUuanMiLCIvVXNlcnMvdHlsZXIvZGV2L2hhbmRzb250YWJsZS9zcmMvM3JkcGFydHkvd2Fsa29udGFibGUvc3JjL2V2ZW50LmpzIiwiL1VzZXJzL3R5bGVyL2Rldi9oYW5kc29udGFibGUvc3JjLzNyZHBhcnR5L3dhbGtvbnRhYmxlL3NyYy9maWx0ZXIvY29sdW1uLmpzIiwiL1VzZXJzL3R5bGVyL2Rldi9oYW5kc29udGFibGUvc3JjLzNyZHBhcnR5L3dhbGtvbnRhYmxlL3NyYy9maWx0ZXIvcm93LmpzIiwiL1VzZXJzL3R5bGVyL2Rldi9oYW5kc29udGFibGUvc3JjLzNyZHBhcnR5L3dhbGtvbnRhYmxlL3NyYy9vdmVybGF5L19iYXNlLmpzIiwiL1VzZXJzL3R5bGVyL2Rldi9oYW5kc29udGFibGUvc3JjLzNyZHBhcnR5L3dhbGtvbnRhYmxlL3NyYy9vdmVybGF5L2Nvcm5lci5qcyIsIi9Vc2Vycy90eWxlci9kZXYvaGFuZHNvbnRhYmxlL3NyYy8zcmRwYXJ0eS93YWxrb250YWJsZS9zcmMvb3ZlcmxheS9kZWJ1Zy5qcyIsIi9Vc2Vycy90eWxlci9kZXYvaGFuZHNvbnRhYmxlL3NyYy8zcmRwYXJ0eS93YWxrb250YWJsZS9zcmMvb3ZlcmxheS9sZWZ0LmpzIiwiL1VzZXJzL3R5bGVyL2Rldi9oYW5kc29udGFibGUvc3JjLzNyZHBhcnR5L3dhbGtvbnRhYmxlL3NyYy9vdmVybGF5L3RvcC5qcyIsIi9Vc2Vycy90eWxlci9kZXYvaGFuZHNvbnRhYmxlL3NyYy8zcmRwYXJ0eS93YWxrb250YWJsZS9zcmMvb3ZlcmxheXMuanMiLCIvVXNlcnMvdHlsZXIvZGV2L2hhbmRzb250YWJsZS9zcmMvM3JkcGFydHkvd2Fsa29udGFibGUvc3JjL3Njcm9sbC5qcyIsIi9Vc2Vycy90eWxlci9kZXYvaGFuZHNvbnRhYmxlL3NyYy8zcmRwYXJ0eS93YWxrb250YWJsZS9zcmMvc2VsZWN0aW9uLmpzIiwiL1VzZXJzL3R5bGVyL2Rldi9oYW5kc29udGFibGUvc3JjLzNyZHBhcnR5L3dhbGtvbnRhYmxlL3NyYy9zZXR0aW5ncy5qcyIsIi9Vc2Vycy90eWxlci9kZXYvaGFuZHNvbnRhYmxlL3NyYy8zcmRwYXJ0eS93YWxrb250YWJsZS9zcmMvdGFibGUuanMiLCIvVXNlcnMvdHlsZXIvZGV2L2hhbmRzb250YWJsZS9zcmMvM3JkcGFydHkvd2Fsa29udGFibGUvc3JjL3RhYmxlUmVuZGVyZXIuanMiLCIvVXNlcnMvdHlsZXIvZGV2L2hhbmRzb250YWJsZS9zcmMvM3JkcGFydHkvd2Fsa29udGFibGUvc3JjL3ZpZXdwb3J0LmpzIiwiL1VzZXJzL3R5bGVyL2Rldi9oYW5kc29udGFibGUvc3JjL2Jyb3dzZXIuanMiLCIvVXNlcnMvdHlsZXIvZGV2L2hhbmRzb250YWJsZS9zcmMvY2VsbFR5cGVzLmpzIiwiL1VzZXJzL3R5bGVyL2Rldi9oYW5kc29udGFibGUvc3JjL2NvcmUuanMiLCIvVXNlcnMvdHlsZXIvZGV2L2hhbmRzb250YWJsZS9zcmMvZGF0YU1hcC5qcyIsIi9Vc2Vycy90eWxlci9kZXYvaGFuZHNvbnRhYmxlL3NyYy9lZGl0b3JNYW5hZ2VyLmpzIiwiL1VzZXJzL3R5bGVyL2Rldi9oYW5kc29udGFibGUvc3JjL2VkaXRvcnMuanMiLCIvVXNlcnMvdHlsZXIvZGV2L2hhbmRzb250YWJsZS9zcmMvZWRpdG9ycy9fYmFzZUVkaXRvci5qcyIsIi9Vc2Vycy90eWxlci9kZXYvaGFuZHNvbnRhYmxlL3NyYy9lZGl0b3JzL2F1dG9jb21wbGV0ZUVkaXRvci5qcyIsIi9Vc2Vycy90eWxlci9kZXYvaGFuZHNvbnRhYmxlL3NyYy9lZGl0b3JzL2NoZWNrYm94RWRpdG9yLmpzIiwiL1VzZXJzL3R5bGVyL2Rldi9oYW5kc29udGFibGUvc3JjL2VkaXRvcnMvZGF0ZUVkaXRvci5qcyIsIi9Vc2Vycy90eWxlci9kZXYvaGFuZHNvbnRhYmxlL3NyYy9lZGl0b3JzL2Ryb3Bkb3duRWRpdG9yLmpzIiwiL1VzZXJzL3R5bGVyL2Rldi9oYW5kc29udGFibGUvc3JjL2VkaXRvcnMvaGFuZHNvbnRhYmxlRWRpdG9yLmpzIiwiL1VzZXJzL3R5bGVyL2Rldi9oYW5kc29udGFibGUvc3JjL2VkaXRvcnMvbW9iaWxlVGV4dEVkaXRvci5qcyIsIi9Vc2Vycy90eWxlci9kZXYvaGFuZHNvbnRhYmxlL3NyYy9lZGl0b3JzL251bWVyaWNFZGl0b3IuanMiLCIvVXNlcnMvdHlsZXIvZGV2L2hhbmRzb250YWJsZS9zcmMvZWRpdG9ycy9wYXNzd29yZEVkaXRvci5qcyIsIi9Vc2Vycy90eWxlci9kZXYvaGFuZHNvbnRhYmxlL3NyYy9lZGl0b3JzL3NlbGVjdEVkaXRvci5qcyIsIi9Vc2Vycy90eWxlci9kZXYvaGFuZHNvbnRhYmxlL3NyYy9lZGl0b3JzL3RleHRFZGl0b3IuanMiLCIvVXNlcnMvdHlsZXIvZGV2L2hhbmRzb250YWJsZS9zcmMvZXZlbnRNYW5hZ2VyLmpzIiwiL1VzZXJzL3R5bGVyL2Rldi9oYW5kc29udGFibGUvc3JjL2hlbHBlcnMvYXJyYXkuanMiLCIvVXNlcnMvdHlsZXIvZGV2L2hhbmRzb250YWJsZS9zcmMvaGVscGVycy9icm93c2VyLmpzIiwiL1VzZXJzL3R5bGVyL2Rldi9oYW5kc29udGFibGUvc3JjL2hlbHBlcnMvZGF0YS5qcyIsIi9Vc2Vycy90eWxlci9kZXYvaGFuZHNvbnRhYmxlL3NyYy9oZWxwZXJzL2RvbS9lbGVtZW50LmpzIiwiL1VzZXJzL3R5bGVyL2Rldi9oYW5kc29udGFibGUvc3JjL2hlbHBlcnMvZG9tL2V2ZW50LmpzIiwiL1VzZXJzL3R5bGVyL2Rldi9oYW5kc29udGFibGUvc3JjL2hlbHBlcnMvZnVuY3Rpb24uanMiLCIvVXNlcnMvdHlsZXIvZGV2L2hhbmRzb250YWJsZS9zcmMvaGVscGVycy9taXhlZC5qcyIsIi9Vc2Vycy90eWxlci9kZXYvaGFuZHNvbnRhYmxlL3NyYy9oZWxwZXJzL251bWJlci5qcyIsIi9Vc2Vycy90eWxlci9kZXYvaGFuZHNvbnRhYmxlL3NyYy9oZWxwZXJzL29iamVjdC5qcyIsIi9Vc2Vycy90eWxlci9kZXYvaGFuZHNvbnRhYmxlL3NyYy9oZWxwZXJzL3NldHRpbmcuanMiLCIvVXNlcnMvdHlsZXIvZGV2L2hhbmRzb250YWJsZS9zcmMvaGVscGVycy9zdHJpbmcuanMiLCIvVXNlcnMvdHlsZXIvZGV2L2hhbmRzb250YWJsZS9zcmMvaGVscGVycy91bmljb2RlLmpzIiwiL1VzZXJzL3R5bGVyL2Rldi9oYW5kc29udGFibGUvc3JjL211bHRpTWFwLmpzIiwiL1VzZXJzL3R5bGVyL2Rldi9oYW5kc29udGFibGUvc3JjL3BsdWdpbkhvb2tzLmpzIiwiL1VzZXJzL3R5bGVyL2Rldi9oYW5kc29udGFibGUvc3JjL3BsdWdpbnMuanMiLCIvVXNlcnMvdHlsZXIvZGV2L2hhbmRzb250YWJsZS9zcmMvcmVuZGVyZXJzLmpzIiwiL1VzZXJzL3R5bGVyL2Rldi9oYW5kc29udGFibGUvc3JjL3JlbmRlcmVycy9fY2VsbERlY29yYXRvci5qcyIsIi9Vc2Vycy90eWxlci9kZXYvaGFuZHNvbnRhYmxlL3NyYy9yZW5kZXJlcnMvYXV0b2NvbXBsZXRlUmVuZGVyZXIuanMiLCIvVXNlcnMvdHlsZXIvZGV2L2hhbmRzb250YWJsZS9zcmMvcmVuZGVyZXJzL2NoZWNrYm94UmVuZGVyZXIuanMiLCIvVXNlcnMvdHlsZXIvZGV2L2hhbmRzb250YWJsZS9zcmMvcmVuZGVyZXJzL2h0bWxSZW5kZXJlci5qcyIsIi9Vc2Vycy90eWxlci9kZXYvaGFuZHNvbnRhYmxlL3NyYy9yZW5kZXJlcnMvbnVtZXJpY1JlbmRlcmVyLmpzIiwiL1VzZXJzL3R5bGVyL2Rldi9oYW5kc29udGFibGUvc3JjL3JlbmRlcmVycy9wYXNzd29yZFJlbmRlcmVyLmpzIiwiL1VzZXJzL3R5bGVyL2Rldi9oYW5kc29udGFibGUvc3JjL3JlbmRlcmVycy90ZXh0UmVuZGVyZXIuanMiLCIvVXNlcnMvdHlsZXIvZGV2L2hhbmRzb250YWJsZS9zcmMvc2hpbXMvY2xhc3Nlcy5qcyIsIi9Vc2Vycy90eWxlci9kZXYvaGFuZHNvbnRhYmxlL3NyYy90YWJsZVZpZXcuanMiLCIvVXNlcnMvdHlsZXIvZGV2L2hhbmRzb250YWJsZS9zcmMvdmFsaWRhdG9ycy9hdXRvY29tcGxldGVWYWxpZGF0b3IuanMiLCIvVXNlcnMvdHlsZXIvZGV2L2hhbmRzb250YWJsZS9zcmMvdmFsaWRhdG9ycy9kYXRlVmFsaWRhdG9yLmpzIiwiL1VzZXJzL3R5bGVyL2Rldi9oYW5kc29udGFibGUvc3JjL3ZhbGlkYXRvcnMvbnVtZXJpY1ZhbGlkYXRvci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUMsSUFBSSxDQUFDLEtBQUssQ0FBQztBQUM1QixXQUFLLENBQUMsUUFBUSxHQUFHLFVBQVUsQ0FBQztBQUM1QixXQUFLLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztBQUNkLFdBQUssQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDOztBQUVmLFdBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDMUIsWUFBSSxRQUFRLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzdCLFlBQUksR0FBRyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDeEMsV0FBRyxDQUFDLFNBQVMsR0FBRyxXQUFXLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLElBQUksRUFBRSxDQUFBLEFBQUMsQ0FBQzs7QUFFOUQsWUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxFQUFFO0FBQzNELGFBQUcsQ0FBQyxTQUFTLElBQUksU0FBUyxDQUFDO1NBQzVCO0FBQ0QsYUFBSyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUM7QUFDbEIsYUFBSyxDQUFDLGVBQWUsR0FBRyxBQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxLQUFLLEdBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7QUFDM0ksYUFBSyxDQUFDLE1BQU0sR0FBRyxBQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxLQUFLLEdBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxLQUFLLEdBQUcs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QUFRLENBQUMsT0FBTyxDQUFFLENBQUMsR0FBRyxPQUFPLEdBQUcsSUFBSSxDQUFFLENBQUMsRUFBRSxFQUFFLENBQ3hFLE9BQU8sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFFLENBQUMsQ0FBRSxJQUFJLENBQUMsQ0FBQyxDQUNsRCxDQUNGLENBQ0YsQUFDRCxHQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFFLENBQzlCLElBQUksU0FBUyxDQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7QUFHOUMsR0FBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUUsQ0FDMUMsS0FBTyxTQUFTLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLElBQUksUUFBUSxDQUFDLFNBQVMsRUFBRSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFFLFNBQVMsRUFBRSxFQUFFLENBQzFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFFLENBQUMsQ0FBRSxJQUFJLENBQUMsQ0FBQyxDQUNsRCxDQUNGLENBQ0YsQUFDRCxDQUNFLElBQUksU0FBUyxVQUFBLENBQUM7QUFHZCxHQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFFLENBQ3ZELFNBQVMsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQzNDO0FBR0QsR0FBSSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxJQUFJLFFBQVEsQ0FBQyxTQUFTLEVBQUUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBRSxDQUNuRyxLQUFPLFFBQVEsQ0FBQyxTQUFTLEVBQUUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBRSxTQUFTLEVBQUUsRUFBRSxDQUNoRSxPQUFPLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBRSxDQUFDLENBQUUsSUFBSSxDQUFDLENBQUMsQ0FDbEQsQ0FDRjtBQUVELEdBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sSUFBSSxRQUFRLENBQUMsUUFBUSxLQUFLLE9BQU8sSUFDckYsU0FBUyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFFLENBQzFDLEtBQU8sU0FBUyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxJQUFJLFFBQVEsQ0FBQyxTQUFTLEVBQUUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBRSxTQUFTLEVBQUUsRUFBRSxDQUMxRyxPQUFPLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBRSxDQUFDLENBQUUsSUFBSSxDQUFDLENBQUMsQ0FDbEQsQ0FDRixDQUNGLEFBQ0QsSUFBSSxRQUFRLENBQUcsUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFDLEFBQ3BDLElBQUksUUFBUSxDQUFHLFFBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxBQUVwQyxHQUFJLFFBQVEsS0FBSyxDQUFDLElBQUksUUFBUSxLQUFLLENBQUMsQ0FBRSxDQUNwQyxTQUFTLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FDdEIsQUFFRCxHQUFJLFNBQVMsQ0FBQyxVQUFVLEVBQUUsQ0FBRSxDQUMxQixJQUFJLGdCQUFnQixDQUFHLEtBQUssQ0FBQyxBQUM3QixJQUFJLE9BQU8sQ0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQUFDckMsSUFBSSxPQUFPLENBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEFBQ3JDLElBQUksS0FBSyxDQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxBQUNqQyxJQUFJLEtBQUssQ0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUM7QUFHakMsR0FBSSxPQUFPLEdBQUcsUUFBUSxHQUFHLENBQUMsQ0FBRSxDQUMxQixPQUFPLEdBQUcsUUFBUSxHQUFHLENBQUMsQ0FBQyxBQUN2QixnQkFBZ0IsR0FBRyxJQUFJLENBQUMsQUFFeEIsR0FBSSxLQUFLLEdBQUcsT0FBTyxDQUFFLENBQ25CLEtBQUssR0FBRyxPQUFPLENBQUMsQ0FDakIsQ0FDRixLQUFNLEdBQUksS0FBSyxHQUFHLFFBQVEsR0FBRyxDQUFDLENBQUUsQ0FDL0IsS0FBSyxHQUFHLFFBQVEsR0FBRyxDQUFDLENBQUMsQUFDckIsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLEFBRXhCLEdBQUksT0FBTyxHQUFHLEtBQUssQ0FBRSxDQUNuQixPQUFPLEdBQUcsS0FBSyxDQUFDLENBQ2pCLENBQ0Y7QUFFRCxHQUFJLE9BQU8sR0FBRyxRQUFRLEdBQUcsQ0FBQyxDQUFFLENBQzFCLE9BQU8sR0FBRyxRQUFRLEdBQUcsQ0FBQyxDQUFDLEFBQ3ZCLGdCQUFnQixHQUFHLElBQUksQ0FBQyxBQUV4QixHQUFJLEtBQUssR0FBRyxPQUFPLENBQUUsQ0FDbkIsS0FBSyxHQUFHLE9BQU8sQ0FBQyxDQUNqQixDQUNGLEtBQU0sR0FBSSxLQUFLLEdBQUcsUUFBUSxHQUFHLENBQUMsQ0FBRSxDQUMvQixLQUFLLEdBQUcsUUFBUSxHQUFHLENBQUMsQ0FBQyxBQUNyQixnQkFBZ0IsR0FBRyxJQUFJLENBQUMsQUFFeEIsR0FBSSxPQUFPLEdBQUcsS0FBSyxDQUFFLENBQ25CLE9BQU8sR0FBRyxLQUFLLENBQUMsQ0FDakIsQ0FDRixBQUVELEdBQUksZ0JBQWdCLENBQUUsQ0FDcEIsUUFBUSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUUsT0FBTyxDQUFFLEtBQUssQ0FBRSxLQUFLLENBQUMsQ0FBQyxDQUNyRCxDQUNGLEFBQ0QsR0FBSSxRQUFRLENBQUMsSUFBSSxDQUFFLENBQ2pCLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDLENBQ2xELENBQ0Y7Ozs7Ozs7Ozs7OztPQWVELGlCQUFpQixDQUFFLDJCQUFTLEtBQUssQ0FBRSxLQUFLLENBQUUsR0FBRyxDQUFFLE1BQU0sQ0FBRSxNQUFNLENBQUUsU0FBUyxDQUFFLE1BQU0sQ0FBRSxDQUNoRixJQUFJLENBQUMsQ0FBRSxJQUFJLENBQUUsQ0FBQyxDQUFFLElBQUksQ0FBRSxPQUFPLENBQUcsRUFBRSxDQUFFLE9BQU8sQ0FBRyxFQUFFLENBQUMsQUFDakQsSUFBSSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsQUFDcEIsR0FBSSxJQUFJLEtBQUssQ0FBQyxDQUFFLENBQ2QsT0FBTyxLQUFLLENBQUMsQ0FDZCxBQUVELElBQUksU0FBUyxDQUNULFNBQVMsQ0FDVCxJQUFJLENBQ0osSUFBSSxDQUFDO0FBR1QsT0FBUSxNQUFNLEVBQ1osS0FBSyxZQUFZLENBQ2YsU0FBUyxHQUFHLEdBQUcsQ0FBRyxHQUFHLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFHLENBQUMsQ0FBQyxBQUM5QyxTQUFTLEdBQUcsR0FBRyxDQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUcsQ0FBQyxDQUFDLEFBQzlDLEtBQUssR0FBRyx3Q0FBdUIsS0FBSyxDQUFDLENBQUMsQUFDdEMsSUFBSyxDQUFDLEdBQUcsQ0FBQyxDQUFFLElBQUksR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFFLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBRSxTQUFTLENBQUMsQ0FBRSxDQUFDLEdBQUcsSUFBSSxDQUFFLENBQUMsRUFBRSxFQUFFLENBQ2hGLEdBQUksQ0FBQyxHQUFHLElBQUksQ0FBRSxDQUNaLElBQUssQ0FBQyxHQUFHLENBQUMsQ0FBRSxJQUFJLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBRSxDQUFDLEdBQUcsU0FBUyxHQUFHLElBQUksQ0FBRSxDQUFDLEVBQUUsRUFBRSxDQUM3RCxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUNuQyxBQUNELEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBRSxDQUFDLENBQUMsQ0FBQyxBQUM5QyxRQUFRLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FDOUMsS0FDSSxDQUNILEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQUFDbkMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFFLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUNyRCxDQUNGLEFBQ0QsTUFBTSxBQUVSLEtBQUssYUFBYSxDQUNoQixTQUFTLEdBQUcsR0FBRyxDQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUcsQ0FBQyxDQUFDLEFBQzlDLFNBQVMsR0FBRyxHQUFHLENBQUcsR0FBRyxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBRyxDQUFDLENBQUMsQUFDOUMsSUFBSyxDQUFDLEdBQUcsQ0FBQyxDQUFFLElBQUksR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFFLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBRSxTQUFTLENBQUMsQ0FBRSxDQUFDLEdBQUcsSUFBSSxDQUFFLENBQUMsRUFBRSxFQUFFLENBQ2hGLEdBQUksQ0FBQyxHQUFHLElBQUksQ0FBRSxDQUNaLElBQUssQ0FBQyxHQUFHLENBQUMsQ0FBRSxJQUFJLEdBQUcsS0FBSyxDQUFD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Q0FBRSxLQUFLLENBQUMsQ0FBQyxBQUNqRCxTQUFTLEdBQUcsUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFDLEFBQ2pDLFNBQVMsR0FBRyxRQUFRLENBQUMsU0FBUyxFQUFFLENBQUMsMEJBR2pDLEdBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsR0FBRyxHQUFHLFFBQVEsR0FBRyxTQUFTLEdBQUcsQ0FBQyxDQUFFLENBQzFELEdBQUksS0FBSyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxHQUFHLENBQUMsQ0FBRSxDQUMzQyxRQUFRLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBRSxTQUFTLENBQUMsQ0FBQyxBQUN4QyxTQUFTLEdBQUcsUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBRWxDLEtBQU0sR0FBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBRSxDQUNwQyxLQUFLLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxTQUFTLENBQUMsQUFDMUIsS0FBSyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDLEdBQUcsSUFBSSxTQUFTLEdBQUcsQ0FBQyxDQUFHLENBQUMsR0FBRyxTQUFTLENBQUcsQ0FBQyxDQUFDLENBQzFGLENBQ0YsS0FBTSxHQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsR0FBRyxHQUFHLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUUsQ0FDbkksS0FBSyxDQUFDLEdBQUcsR0FBRyxTQUFTLEdBQUcsQ0FBQyxDQUFDLEFBQzFCLEtBQUssQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFHLFNBQVMsR0FBRyxDQUFDLENBQUcsQ0FBQyxDQUFDLENBQUMsQ0FDL0UsQUFFRCxHQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsR0FBRyxHQUFHLFNBQVMsR0FBRyxDQUFDLENBQUUsQ0FDM0QsR0FBSSxLQUFLLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFFLENBQzNDLFFBQVEsQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFFLFNBQVMsQ0FBQyxDQUFDLEFBQ3hDLFNBQVMsR0FBRyxRQUFRLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FFbEMsS0FBTSxHQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFFLENBQ3BDLEtBQUssQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQyxHQUFHLElBQUksU0FBUyxHQUFHLENBQUMsQ0FBRyxDQUFDLEdBQUcsU0FBUyxDQUFHLENBQUMsQ0FBQyxBQUN6RixLQUFLLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FDM0IsQ0FDRixLQUFNLEdBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBRSxDQUNuSSxLQUFLLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBRyxTQUFTLEdBQUcsQ0FBQyxDQUFHLENBQUMsQ0FBQyxDQUFDLEFBQzlFLEtBQUssQ0FBQyxHQUFHLEdBQUcsU0FBUyxHQUFHLENBQUMsQ0FBQyxDQUMzQix3QkFHRCxNQUFNLEdBQUcs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QUFFLENBQUUsQ0FBQyxHQUFHLElBQUksQ0FBRSxDQUFDLEVBQUUsRUFBRSxDQUMxRCxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUNwQyxBQUNELE9BQU8sR0FBRyxDQUFDLENBQ1osS0FDSSxDQUNILElBQUksT0FBTyxDQUFHLEdBQUcsQ0FBQyxBQUVsQixHQUFHLEdBQUcsWUFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFFLFdBQVcsQ0FBRSxHQUFHLENBQUMsQ0FBQyxBQUV6RCxHQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBRSxDQUMzRixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUN6QyxLQUNJLEdBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEtBQUssQ0FBQyxDQUFFLENBQzVGLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FDdEMsS0FDSSxHQUFJLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLEtBQUssVUFBVSxDQUFFLENBQ3ZELE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FDdEMsS0FDSSxHQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxJQUFJLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLEtBQUssUUFBUSxJQUFJLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLEtBQUssUUFBUSxDQUFFLENBQ2pJLE9BQU8sd0NBQXVCLE9BQU8sQ0FBQyxDQUFDO0NBQ3hDLEtBQ0ksQ0FDSCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQ2pDLENBQ0YsQ0FDRixDQUFDOzs7Ozs7OztLQVdGLElBQUksQ0FBQyx3QkFBd0IsR0FBRyxTQUFTLEdBQUcsQ0FBRSxDQUM1QyxJQUFJLGNBQWMsQ0FBRyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBRSxHQUFHLENBQUMsQ0FBQyxBQUNsRCxJQUFJLEtBQUssQ0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDLEFBRWpDLEdBQUksS0FBSyxLQUFLLEtBQUssQ0FBQyxJQUFJLEtBQUssS0FBSyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBRSxDQUNyRCxLQUFLLEdBQUcsY0FBYyxDQUFDLFNBQVMsQ0FBQyxDQUNsQyxBQUNELEdBQUksS0FBSyxLQUFLLEtBQUssQ0FBQyxJQUFJLEtBQUssS0FBSyxJQUFJLENBQUUsQ0FDdEMsT0FBUSxPQUFPLEtBQUssRUFDbEIsS0FBSyxRQUFRO0FBQ1gsS0FBSyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxBQUNuQixNQUFNLEFBRVIsS0FBSyxVQUFVLENBQ2IsS0FBSyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxBQUNuQixNQUFNLENBQ1QsQUFDRCxHQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsQ0FBRSxDQUM3QixLQUFLLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBRSxFQUFFLENBQUMsQ0FBQyxDQUM3QixDQUNGLEFBRUQsT0FBTyxLQUFLLENBQUMsQ0FDZCxDQUFDOzs7Ozs7Ozs7S0FZRixJQUFJLENBQUMsV0FBVyxHQUFHLFNBQVMsR0FBRyxDQUFFLENBQy9CLElBQUksS0FBSyxDQUFHLFFBQVEsQ0FBQyx3QkFBd0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxBQUVuRCxLQUFLLEdBQUcsWUFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFFLGdCQUFnQixDQUFFLEtBQUssQ0FBRSxHQUFHLENBQUMsQ0FBQyxBQUV2RSxHQUFJLEtBQUssS0FBSyxLQUFLLENBQUMsQ0FBRSxDQUNwQixLQUFLLEdBQUcscUZBQXFDLGFBQWEsQ0FBQyxDQUM1RCxBQUVELE9BQU8sS0FBSyxDQUFDLENBQ2QsQ0FBQzs7Ozs7Ozs7S0FXRixJQUFJLENBQUMseUJBQXlCLEdBQUcsU0FBUyxHQUFHLENBQUU7Ozs7OztBQU83QyxJQUFJLE1BQU0sQ0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxBQUV0QyxHQUFJLE1BQU0sS0FBSyxLQUFLLENBQUMsSUFBSSxNQUFNLEtBQUssSUFBSSxDQUFFLENBQ3hDLE9BQVEsT0FBTyxNQUFNLEVBQ25CLEtBQUssUUFBUTtBQUNYLE1BQU0sR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQUFDckIsTUFBTSxBQUVSLEtBQUssVUFBVSxDQUNiLE1BQU0sR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQUFDckIsTUFBTSxDQUNULEFBQ0QsR0FBSSxPQUFPLE1BQU0sS0FBSyxRQUFRLENBQUUsQ0FDOUIsTUFBTSxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUUsRUFBRSxDQUFDLENBQUMsQ0FDL0IsQ0FDRixBQUVELE9BQU8sTUFBTSxDQUFDLENBQ2YsQ0FBQzs7Ozs7Ozs7O0tBWUYsSUFBSSxDQUFDLFlBQVksR0FBRyxTQUFTLEdBQUcsQ0FBRSxDQUNoQyxJQUFJLE1BQU0sQ0FBRyxRQUFRLENBQUMseUJBQXlCLENBQUMsR0FBRyxDQUFDLENBQUMsQUFFckQsTUFBTSxHQUFHLFlBQVksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBRSxpQkFBaUIsQ0FBRSxNQUFNLENBQUUsR0FBRyxDQUFDLENBQUMsQUFFMUUsT0FBTyxNQUFNLENBQUMsQ0FDZixDQUFDOzs7Ozs7S0FTRixJQUFJLENBQUMsU0FBUyxHQUFHLFVBQVcsQ0FDMUIsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FDbEMsQ0FBQzs7Ozs7O0tBU0YsSUFBSSxDQUFDLFNBQVMsR0FBRyxVQUFXLENBQzFCLEdBQUksUUFBUSxDQUFDLFFBQVEsS0FBSyxRQUFRLElBQUksUUFBUSxDQUFDLFFBQVEsS0FBSyxVQUFVLENBQUUsQ0FDdEUsR0FBSSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUUsQ0FDekQsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FDckMsS0FDSSxDQUNILE9BQU8sT0FBTyxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FDdEMsQ0FDRixLQUNJLEdBQUksUUFBUSxDQUFDLFFBQVEsS0FBSyxPQUFPLENBQUUsQ0FDdEMsR0FBSSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUUsQ0FDekQsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FDckMsS0FDSSxHQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBRSxDQUNwRixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUNyQyxLQUNJLENBQ0gsT0FBTyxDQUFDLENBQUMsQ0FDVixDQUNGLENBQ0YsQ0FBQzs7Ozs7O0tBU0YsSUFBSSxDQUFDLFNBQVMsR0FBRyxVQUFXLENBQzFCLE9BQU8sUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLG1CQUFtQixFQUFFLENBQUMsQ0FDdkQsQ0FBQzs7Ozs7O0tBU0YsSUFBSSxDQUFDLFNBQVMsR0FBRyxVQUFXLENBQzFCLE9BQU8sUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLHNCQUFzQixFQUFFLENBQUMsQ0FDMUQsQ0FBQzs7Ozs7O0tBU0YsSUFBSSxDQUFDLGlCQUFpQixHQUFHLFVBQVcsQ0FDbEMsT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLG9CQUFvQixFQUFFLENBQUcsQ0FBQyxDQUFDLENBQUMsQ0FDdEYsQ0FBQzs7Ozs7O0tBU0YsSUFBSSxDQUFDLGdCQUFnQixHQUFHLFVBQVcsQ0FDakMsT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLG1CQUFtQixFQUFFLENBQUcsQ0FBQyxDQUFDLENBQUMsQ0FDckYsQ0FBQzs7Ozs7O0tBU0YsSUFBSSxDQUFDLGlCQUFpQixHQUFHLFVBQVcsQ0FDbEMsT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLHVCQUF1QixFQUFFLENBQUcsQ0FBQyxDQUFDLENBQUMsQ0FDekYsQ0FBQzs7Ozs7O0tBU0YsSUFBSSxDQUFDLGdCQUFnQixHQUFHLFVBQVcsQ0FDakMsT0FBTyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLHNCQUFzQixFQUFFLENBQUcsQ0FBQyxDQUFDLENBQUMsQ0FDeEYsQ0FBQzs7Ozs7Ozs7O0tBWUYsSUFBSSxDQUFDLGNBQWMsR0FBRyxTQUFTLE1BQU0sQ0FBRSxDQUNyQyxJQUFJLENBQUMsQ0FBRyxRQUFRLENBQUMsU0FBUyxFQUFFLEdBQUcsQ0FBQyxDQUM5QixLQUFLLENBQUcsQ0FBQyxDQUNULEdBQUcsQ0FBQyxBQUVOLE1BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUNiLEdBQUcsR0FBRyxZQUFZLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUUsV0FBVyxDQUFFLENBQUMsQ0FBQyxDQUFDLEFBRW5ELEdBQUksUUFBUSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBRSxDQUM1QixLQUFLLEVBQUUsQ0FBQyxDQUVULEtBQU0sR0FBSSxNQUFNLENBQUUsQ0FDakIsTUFBTSxDQUNQLEFBQ0QsQ0FBQyxFQUFFLENBQUMsQ0FDTCxBQUVELE9BQU8sS0FBSyxDQUFDLENBQ2QsQ0FBQzs7Ozs7Ozs7S0FXRixJQUFJLENBQUMsY0FBYyxHQUFHLFNBQVMsTUFBTSxDQUFFLENBQ3JDLEdBQUksUUFBUSxDQUFDLFNBQVMsRUFBRSxHQUFHLENBQUMsQ0FBRSxDQUM1QixPQUFPLENBQUMsQ0FBQyxDQUNWLEFBRUQsSUFBSSxDQUFDLENBQUcsUUFBUSxDQUFDLFNBQVMsRUFBRSxHQUFHLENBQUMsQ0FDNUIsS0FBSyxDQUFHLENBQUMsQ0FBQyxBQUNkLE1BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUNiLEdBQUksUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBRSxDQUMxQixLQUFLLEVBQUUsQ0FBQyxDQUNULEtBQ0ksR0FBSSxNQUFNLENBQUUsQ0FDZixNQUFNLENBQ1AsQUFDRCxDQUFDLEVBQUUsQ0FBQyxDQUNMLEFBQ0QsT0FBTyxLQUFLLENBQUMsQ0FDZCxDQUFDOzs7Ozs7O0tBVUYsSUFBSSxDQUFDLFVBQVUsR0FBRyxTQUFTLEdBQUcsQ0FBRSxDQUM5QixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUUsR0FBRyxDQUFDLENBQUMsQ0FDckQsQ0FBQzs7Ozs7OztLQVVGLElBQUksQ0FBQyxVQUFVLEdBQUcsU0FBUyxHQUFHLENBQUUsQ0FDOUIsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFFLEdBQUcsQ0FBQyxDQUFDLENBQ3JELENBQUM7Ozs7Ozs7Ozs7Ozs7OztLQWtCRixJQUFJLENBQUMsVUFBVSxHQUFHLFNBQVMsR0FBRyxDQUFFLEdBQUcsQ0FBRSxNQUFNLENBQUUsTUFBTSxDQUFFLFlBQVksQ0FBRSxjQUFjLENBQUUsQ0FDakYsSUFBSSxNQUFNLENBQUMsQUFFWCxjQUFjLEdBQUcsT0FBTyxjQUFjLEtBQUssV0FBVyxJQUFJLGNBQWMsS0FBSyxJQUFJLENBQUMsQUFFbEYsR0FBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLElBQUksR0FBRyxHQUFHLENBQUMsSUFBSSxHQUFHLElBQUksUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFFLENBQ3JFLE9BQU8sS0FBSyxDQUFDLENBQ2QsQUFDRCxHQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVEsSUFBSSxHQUFHLEdBQUcsQ0FBQyxJQUFJLEdBQUcsSUFBSSxRQUFRLENBQUMsU0FBUyxFQUFFLENBQUUsQ0FDckUsT0FBTyxLQUFLLENBQUMsQ0FDZCxBQUNELEdBQUksT0FBTyxNQUFNLEtBQUssV0FBVyxDQUFFLENBQ2pDLEdBQUksT0FBTyxNQUFNLEtBQUssUUFBUSxJQUFJLE1BQU0sR0FBRyxDQUFDLElBQUksTUFBTSxJQUFJLFFBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBRSxDQUM5RSxPQUFPLEtBQUssQ0FBQyxDQUNkLEFBQ0QsR0FBSSxPQUFPLE1BQU0sS0FBSyxRQUFRLElBQUksTUFBTSxHQUFHLENBQUMsSUFBSSxNQUFNLElBQUksUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFFLENBQzlFLE9BQU8sS0FBSyxDQUFDLENBQ2QsQ0FDRixBQUNELE1BQU0sR0FBRywyREFBMEIsR0FBRyxDQUFFLEdBQUcsQ0FBQyxDQUFDLEFBQzdDLElBQUksQ0FBQyxRQUFRLEdBQUcseURBQXlCLE1BQU0sQ0FBRSxNQUFNLENBQUUsTUFBTSxDQUFDLENBQUMsQUFFakUsR0FBSSxRQUFRLENBQUMsYUFBYSxJQUFJLFFBQVEsQ0FBQyxhQUFhLEtBQUssUUFBUSxDQUFDLGVBQWUsSUFDL0UsUUFBUSxDQUFDLGFBQWEsS0FBSyxRQUFRLENBQUMsSUFBSSxDQUFFO0FBRTFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FDL0IsQUFDRCxHQUFJLGNBQWMsQ0FBRSxDQUNsQixRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FDbkIsQUFFRCxHQUFJLE9BQU8sTUFBTSxLQUFLLFdBQVcsQ0FBRSxDQUNqQyxTQUFTLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFFLFlBQVksQ0FBQyxDQUFDLENBRXpELEtBQU0sQ0FDTCxTQUFTLENBQUMsV0FBVyxDQUFDLDJEQUEwQixNQUFNLENBQUUsTUFBTSxDQUFDLENBQUUsWUFBWSxDQUFDLENBQUMsQ0FDaEYsQUFDRCxRQUFRLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDLEFBRTVCLE9BQU8sSUFBSSxDQUFDLENBQ2IsQ0FBQzs7Ozs7Ozs7Ozs7S0FjRixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsU0FBUyxHQUFHLENBQUUsSUFBSSxDQUFFLE1BQU0sQ0FBRSxPQUFPLENBQUUsWUFBWSxDQUFFLDJCQUV6RSxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxBQUMvQyxHQUFJLE9BQU8sU0FBUyxDQUFDLENBQUMsQ0FBQyxLQUFLLFdBQVcsQ0FBRSxDQUN2QyxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUNoRCxBQUNELE9BQU8sUUFBUSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFFLFNBQVMsQ0FBQyxDQUFDLHlCQUV2RCxDQUFDOzs7OztLQVFGLElBQUksQ0FBQyxZQUFZLEdBQUcsVUFBVyxDQUM3QixTQUFTLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FDdEIsQ0FBQzs7Ozs7O0tBU0YsSUFBSSxDQUFDLE9BQU8sR0FBRyxVQUFXLENBRXhCLFFBQVEsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxBQUMxQixHQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUU7QUFDakIsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUN6QixBQUNELDZCQUFNLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQyxBQUM1QixZQUFZLENBQUMsT0FBTyxFQUFFLENBQUMsQUFFdkIsWUFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFFLGNBQWMsQ0FBQyxDQUFDLEFBQ2pELFlBQVksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEFBRXJDLElBQUssSUFBSSxDQUFDLElBQUksUUFBUSxFQUFFLENBQ3RCLEdBQUksUUFBUSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBRTtBQUU5QixHQUFJLE9BQU8sUUFBUSxDQUFDLENBQUMsQ0FBQyxLQUFLLFVBQVUsQ0FBRSxDQUNyQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQzFCOztLQUdJLEdBQUksQ0FBQyxLQUFLLE1BQU0sQ0FBRSxDQUNyQixRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQ3BCLENBQ0YsQ0FDRjs7QUFLRCxJQUFJLEdBQUcsSUFBSSxDQUFDLEFBQ1osT0FBTyxHQUFHLElBQUksQ0FBQyxBQUNmLElBQUksR0FBRyxJQUFJLENBQUMsQUFDWixTQUFTLEdBQUcsSUFBSSxDQUFDLEFBQ2pCLGFBQWEsR0FBRyxJQUFJLENBQUMsQUFDckIsUUFBUSxHQUFHLElBQUksQ0FBQyxBQUNoQixZQUFZLEdBQUcsSUFBSSxDQUFDLENBQ3JCLENBQUM7Ozs7S0FPRixTQUFTLFVBQVUsRUFBRyxDQUNwQixNQUFNLElBQUksS0FBSyxDQUFDLG9GQUFvRixDQUFDLENBQUMsQ0FDdkc7Ozs7OztLQVNELElBQUksQ0FBQyxlQUFlLEdBQUcsVUFBVyxDQUNoQyxPQUFPLGFBQWEsQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUN4QyxDQUFDOzs7Ozs7OztLQVdGLElBQUksQ0FBQyxTQUFTLEdBQUcsU0FBUyxVQUFVLENBQUUsQ0FDcEMsT0FBTyx1QkFBVSxJQUFJLENBQUUsVUFBVSxDQUFDLENBQUMsQ0FDcEMsQ0FBQzs7Ozs7O0tBU0YsSUFBSSxDQUFDLFdBQVcsR0FBRyxVQUFXLENBQzVCLE9BQU8sUUFBUSxDQUFDLENBQ2pCLENBQUM7Ozs7Ozs7Ozs7Ozs7S0FnQkYsSUFBSSxDQUFDLE9BQU8sR0FBRyxTQUFTLEdBQUcsQ0FBRSxRQUFRLENBQUUsQ0FDckMsWUFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFFLFFBQVEsQ0FBRSxRQUFRLENBQUMsQ0FBQyxDQUNqRCxDQUFDOzs7Ozs7Ozs7Ozs7OztLQWlCRixJQUFJLENBQUMsV0FBVyxHQUFHLFNBQVMsR0FBRyxDQUFFLFFBQVEsQ0FBRSxDQUN6QyxZQUFZLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUUsUUFBUSxDQUFFLFFBQVEsQ0FBQyxDQUFDLENBQ2xELENBQUM7Ozs7Ozs7Ozs7Ozs7S0FnQkYsSUFBSSxDQUFDLFVBQVUsR0FBRyxTQUFTLEdBQUcsQ0FBRSxRQUFRLENBQUUsQ0FDeEMsWUFBWSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFFLFFBQVEsQ0FBRSxRQUFRLENBQUMsQ0FBQyxDQUNwRCxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztLQW9CRixJQUFJLENBQUMsUUFBUSxHQUFHLFNBQVMsR0FBRyxDQUFFLEVBQUUsQ0FBRSxFQUFFLENBQUUsRUFBRSxDQUFFLEVBQUUsQ0FBRSxFQUFFLENBQUUsRUFBRSxDQUFFLENBQ3BELE9BQU8sWUFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFFLEdBQUcsQ0FBRSxFQUFFLENBQUUsRUFBRSxDQUFFLEVBQUUsQ0FBRSxFQUFFLENBQUUsRUFBRSxDQUFFLEVBQUUsQ0FBQyxDQUFDLENBQ3RFLENBQUMsQUFFRixJQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQzs7Ozs7S0FRbkIsSUFBSSxDQUFDLGdCQUFnQixHQUFHLFNBQVMsTUFBTSxDQUFFLENBQ3ZDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQzVCLENBQUM7Ozs7S0FPRixJQUFJLENBQUMsY0FBYyxHQUFHLFVBQVcsQ0FDL0IsSUFBSyxJQUFJLENBQUMsQ0FBRyxDQUFDLENBQUUsSUFBSSxDQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFFLENBQUMsR0FBRyxJQUFJLENBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FDMUQsWUFBWSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUNoQyxDQUNGLENBQUM7Ozs7S0FPRixJQUFJLENBQUMsT0FBTyxHQUFHLFlBQVksQ0FBQyxPQUFPLENBQUMsQUFFcEMsWUFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFFLFdBQVcsQ0FBQyxDQUFDLENBQy9DLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBdUVGLElBQUksZUFBZSxDQUFHLFNBQWxCLGVBQWUsRUFBYyxFQUNoQyxDQUFDLEFBRUYsZUFBZSxDQUFDLFNBQVMsR0FBRzs7Ozs7Ozs7O0tBVzFCLElBQUksQ0FBRSxLQUFLLENBQUM7Ozs7Ozs7OztLQVlaLFVBQVUsQ0FBRSxLQUFLLENBQUM7Ozs7O0tBUWxCLEtBQUssQ0FBRSxLQUFLLENBQUM7Ozs7O0tBUWIsTUFBTSxDQUFFLEtBQUssQ0FBQzs7Ozs7Ozs7S0FXZCxTQUFTLENBQUUsQ0FBQzs7Ozs7Ozs7S0FXWixTQUFTLENBQUUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0E2QlosVUFBVSxDQUFFLElBQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBNkJoQixVQUFVLENBQUUsSUFBSTs7Ozs7OztLQVVoQixTQUFTLENBQUUsS0FBSyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FpQ2pCLE9BQU8sQ0FBRSxLQUFLLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQTJCZixLQUFLLENBQUUsS0FBSyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0tBbUJiLElBQUksQ0FBRSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXVCUixRQUFRLENBQUUsS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0F5Q2YsYUFBYSxDQUFFLEtBQUs7Ozs7O0tBUXBCLE9BQU8sQ0FBRSxDQUFDOzs7OztLQVFWLE9BQU8sQ0FBRSxDQUFDOzs7OztLQVFWLE9BQU8sQ0FBRSxRQUFROzs7OztLQVFqQixPQUFPLENBQUUsUUFBUTs7Ozs7S0FRakIsWUFBWSxDQUFFLENBQUM7Ozs7O0tBUWYsWUFBWSxDQUFFLENBQUM7OztLQU1mLGNBQWMsQ0FBRSxJQUFJOzs7S0FNcEIsaUJBQWlCLENBQUUsSUFBSTs7O0tBTXZCLGNBQWMsQ0FBRSxJQUFJOzs7S0FNcEIsaUJBQWlCLENBQUUsSUFBSTs7Ozs7S0FRdkIsV0FBVyxDQUFFLElBQUk7Ozs7Ozs7OztLQVlqQixVQUFVLENBQUUsSUFBSTs7Ozs7S0FRaEIsWUFBWSxDQUFFLENBQUM7Ozs7O0tBUWYsZ0JBQWdCLENBQUUsQ0FBQzs7Ozs7S0FRbkIscUJBQXFCLENBQUUsSUFBSTs7Ozs7O0tBUzNCLGtCQUFrQixDQUFFLElBQUk7Ozs7Ozs7O0tBV3hCLFVBQVUsQ0FBRSxDQUFDLEdBQUcsQ0FBRSxDQUFDLENBQUUsR0FBRyxDQUFFLENBQUMsQ0FBQzs7Ozs7Ozs7S0FXNUIsUUFBUSxDQUFFLENBQUMsR0FBRyxDQUFFLENBQUMsQ0FBRSxHQUFHLENBQUUsQ0FBQyxDQUFDOzs7OztLQVExQixXQUFXLENBQUUsS0FBSzs7Ozs7S0FRbEIsV0FBVyxDQUFFLEtBQUs7Ozs7O0tBUWxCLGFBQWEsQ0FBRSxJQUFJOzs7OztLQVFuQixhQUFhLENBQUUsSUFBSTs7Ozs7OztLQVVuQixTQUFTLENBQUUsV0FBVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQWtDdEIsZUFBZSxDQUFFLEtBQUs7Ozs7O0tBUXRCLG1CQUFtQixDQUFFLEtBQUssQ0FBQzs7Ozs7S0FRM0IsbUJBQW1CLENBQUUsS0FBSyxDQUFDOzs7OztLQVEzQixTQUFTLENBQUUsS0FBSyxDQUFDOzs7Ozs7S0FTakIsY0FBYyxDQUFFLEtBQUssQ0FBQzs7Ozs7O0tBU3RCLFFBQVEsQ0FBRSxNQUFNOzs7Ozs7S0FTaEIsVUFBVSxDQUFFLG9CQUFTLEdBQUcsQ0FBRSxDQUN4QixJQUFJLEdBQUcsQ0FBRSxNQUFNLENBQUUsS0FBSyxDQUFFLElBQUksQ0FBQyxBQUU3QixJQUFLLEdBQUcsR0FBRyxDQUFDLENBQUUsTUFBTSxHQUFHLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBRSxHQUFHLEdBQUcsTUFBTSxDQUFFLEdBQUcsRUFBRSxFQUFFLENBQzVELEtBQUssR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBRSxHQUFHLENBQUMsQ0FBQyxBQUVyQyxHQUFJLEtBQUssS0FBSyxFQUFFLElBQUksS0FBSyxLQUFLLElBQUksSUFBSSxPQUFPLEtBQUssS0FBSyxXQUFXLENBQUUsQ0FDbEUsR0FBSSxPQUFPLEtBQUssS0FBSyxRQUFRLENBQUUsQ0FDN0IsSUFBSSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFFLEdBQUcsQ0FBQyxDQUFDLEFBRWxDLE9BQU8sa0NBQWUsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBRSxLQUFLLENBQUMsQ0FBQyxDQUMzRCxBQUNELE9BQU8sS0FBSyxDQUFDLENBQ2QsQ0FDRixBQUVELE9BQU8sSUFBSSxDQUFDLENBQ2I7Ozs7OztLQVNELFVBQVUsQ0FBRSxvQkFBUyxHQUFHLENBQUUsQ0FDeEIsSUFBSSxHQUFHLENBQUUsTUFBTSxDQUFFLEtBQUssQ0FBQyxBQUV2QixJQUFLLEdBQUcsR0FBRyxDQUFDLENBQUUsTUFBTSxHQUFHLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBRSxHQUFHLEdBQUcsTUFBTSxDQUFFLEdBQUcsRUFBRSxFQUFFLENBQzVELEtBQUssR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBRSxHQUFHLENBQUMsQ0FBQyxBQUVyQyxHQUFJLEtBQUssS0FBSyxFQUFFLElBQUksS0FBSyxLQUFLLElBQUksSUFBSSxPQUFPLEtBQUssS0FBSyxXQUFXLENBQUUsQ0FDbEUsT0FBTyxLQUFLLENBQUMsQ0FDZCxDQUNGLEFBRUQsT0FBTyxJQUFJLENBQUMsQ0FDYjs7Ozs7S0FRRCxvQkFBb0IsQ0FBRSxJQUFJOzs7Ozs7O0tBVTFCLFlBQVksQ0FBRSxJQUFJOzs7OztLQVFsQixvQkFBb0IsQ0FBRSxXQUFXOzs7OztLQVFqQyxXQUFXLENBQUUsS0FBSzs7Ozs7S0FRbEIsd0JBQXdCLENBQUUsZUFBZTs7Ozs7S0FRekMscUJBQXFCLENBQUUsVUFBVTs7Ozs7OztLQVVqQyxRQUFRLENBQUUsS0FBSyxDQUFDOzs7S0FNaEIsc0JBQXNCLENBQUUsZUFBZTs7Ozs7S0FRdkMsaUJBQWlCLENBQUUsS0FBSzs7Ozs7O0tBU3hCLFFBQVEsQ0FBRSxLQUFLOzs7Ozs7S0FTZixNQUFNLENBQUUsS0FBSzs7Ozs7Ozs7Ozs7Ozs7S0FpQmIsSUFBSSxDQUFFLE1BQU07Ozs7Ozs7OztLQVlaLFFBQVEsQ0FBRSxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FxQmQsTUFBTSxDQUFFLEtBQUssQ0FBQzs7Ozs7O0tBU2QsWUFBWSxDQUFFLEtBQUssQ0FBQzs7Ozs7O0tBU3BCLFdBQVcsQ0FBRyxFQUFFOzs7Ozs7O0tBVWhCLFlBQVksQ0FBRyxJQUFJOzs7Ozs7S0FTbkIsS0FBSyxDQUFFLEtBQUs7Ozs7OztLQVNaLFFBQVEsQ0FBRSxJQUFJOzs7Ozs7S0FTZCxtQkFBbUIsQ0FBRSxVQUFVOzs7Ozs7Ozs7OztLQWMvQixXQUFXLENBQUUsS0FBSyxDQUFDOzs7Ozs7Ozs7Ozs7S0FlbkIsWUFBWSxDQUFFLEtBQUssQ0FBQzs7Ozs7S0FRcEIsSUFBSSxDQUFFLEtBQUssQ0FBQzs7Ozs7O0tBU1osYUFBYSxDQUFFLEtBQUssQ0FBQzs7Ozs7OztLQVVyQixnQkFBZ0IsQ0FBRSxLQUFLLENBQUM7Ozs7Ozs7S0FVeEIsa0JBQWtCLENBQUUsS0FBSyxDQUFDOzs7Ozs7OztLQVcxQixhQUFhLENBQUUsS0FBSyxDQUFDOzs7Ozs7OztLQVdyQixlQUFlLENBQUUsS0FBSyxDQUFDOzs7Ozs7O0tBVXZCLFVBQVUsQ0FBRSxLQUFLOzs7Ozs7S0FTakIsMEJBQTBCLENBQUUsTUFBTTs7Ozs7O0tBU2xDLDZCQUE2QixDQUFFLE1BQU07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0F5QnJDLE1BQU0sQ0FBRSxLQUFLLENBQUM7Ozs7Ozs7O0tBV2QsU0FBUyxDQUFFLEtBQUssQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBaUNqQixzQkFBc0IsQ0FBRSxLQUFLOzs7Ozs7O0tBVTdCLGFBQWEsQ0FBRSxLQUFLLENBQ3BCLGtCQUFrQixDQUFFLEtBQUssQ0FBQzs7Ozs7O0tBUzFCLGNBQWMsQ0FBRSxJQUFJLENBQ3BCLFFBQVEsQ0FBRSxLQUFLLENBQUMsQ0FDaEIsTUFBTSxDQUFFLEtBQUssQ0FBQyxDQUNkLEtBQUssQ0FBRSxLQUFLLENBQUM7Ozs7Ozs7S0FVYixlQUFlLENBQUUsS0FBSyxDQUFDOzs7Ozs7O0tBVXZCLGlCQUFpQixDQUFFLEtBQUssQ0FBQzs7OztLQU96QixNQUFNLENBQUUsS0FBSyxDQUFDOzs7Ozs7O0tBVWQsUUFBUSxDQUFFLEtBQUssQ0FBQzs7OztLQU9oQixhQUFhLENBQUUsS0FBSyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQTZCckIsY0FBYyxDQUFFLEtBQUssQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0E2QnRCLFdBQVcsQ0FBRSxLQUFLLENBQUM7Ozs7Ozs7S0FVbkIsVUFBVSxDQUFFLEtBQUssQ0FBQzs7Ozs7OztLQVVsQixhQUFhLENBQUUsS0FBSzs7Ozs7O0tBU3BCLFdBQVcsQ0FBRSxLQUFLLENBQUM7Ozs7OztLQVNuQixNQUFNLENBQUUsS0FBSyxDQUFDLENBQ2YsQ0FBQyxBQUNGLFlBQVksQ0FBQyxlQUFlLEdBQUcsZUFBZSxDQUFDOzs7Ozs7Ozs7Ozt5QkM5M0h6QixXQUFXOzs7OzJCQUNLLGdCQUFnQjs7OEJBQzFCLG1CQUFtQjs7NkJBQ1Ysa0JBQWtCOzs0QkFDbEIsaUJBQWlCOzt3QkFDL0IsWUFBWTs7Ozs7Ozs7Ozs7Ozs7QUFlbkMsU0FBUyxPQUFPLENBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxZQUFZLEVBQUU7QUFDN0MsTUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7QUFDekIsTUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7QUFDakIsTUFBSSxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7QUFDakMsTUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDLElBQUksQ0FBQzs7QUFFbkQsTUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUFFO0FBQ3RCLFFBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztHQUNoRSxNQUNJO0FBQ0gsUUFBSSxDQUFDLFVBQVUsR0FBRyxFQUFFLENBQUM7R0FDdEI7QUFDRCxNQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7Q0FDbEI7O0FBRUQsT0FBTyxDQUFDLFNBQVMsQ0FBQyxvQkFBb0IsR0FBRyxDQUFDLENBQUM7QUFDM0MsT0FBTyxDQUFDLFNBQVMsQ0FBQywrQkFBK0IsR0FBRyxDQUFDLENBQUM7Ozs7OztBQU10RCxPQUFPLENBQUMsU0FBUyxDQUFDLG1CQUFtQixHQUFHLFVBQVMsTUFBTSxFQUFFO0FBQ3ZELFNBQU8sK0JBQVcsTUFBTSxDQUFDLENBQUM7Q0FDM0IsQ0FBQzs7Ozs7Ozs7QUFRRixPQUFPLENBQUMsU0FBUyxDQUFDLG9CQUFvQixHQUFHLFVBQVUsTUFBTSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUU7QUFDMUUsTUFBSSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0FBQ1osTUFBSSxPQUFPLE9BQU8sS0FBSyxXQUFXLEVBQUU7QUFDbEMsV0FBTyxHQUFHLENBQUMsQ0FBQztBQUNaLFVBQU0sR0FBRyxFQUFFLENBQUM7R0FDYjtBQUNELE1BQUksT0FBTyxNQUFNLEtBQUssUUFBUSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFBRTtBQUN4RCxTQUFLLENBQUMsSUFBSSxNQUFNLEVBQUU7QUFDaEIsVUFBSSxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxFQUFFO0FBQzVCLFlBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksRUFBRTtBQUN0QixjQUFJLEdBQUcsTUFBTSxHQUFHLENBQUMsQ0FBQztBQUNsQixjQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUMvQixjQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7O0FBRXZDLGlCQUFPLEVBQUUsQ0FBQztTQUNYLE1BQ0k7QUFDSCxpQkFBTyxHQUFHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztTQUNsRTtPQUNGO0tBQ0Y7R0FDRjtBQUNELFNBQU8sT0FBTyxDQUFDO0NBQ2hCLENBQUM7O0FBRUYsT0FBTyxDQUFDLFNBQVMsQ0FBQyxTQUFTLEdBQUcsWUFBWTtBQUN4QyxNQUFJLENBQUM7TUFBRSxJQUFJO01BQUUsTUFBTSxHQUFHLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztBQUN2QyxNQUFJLE9BQU8sTUFBTSxLQUFLLFdBQVcsRUFBRTtBQUNqQyxVQUFNLElBQUksS0FBSyxDQUFDLGtGQUFrRixDQUFDLENBQUM7R0FDckc7QUFDRCxNQUFJLENBQUMsY0FBYyxHQUFHLEVBQUUsQ0FBQztBQUN6QixNQUFJLENBQUMsY0FBYyxHQUFHLHdCQUFjLENBQUM7QUFDckMsTUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLENBQUM7QUFDbEQsTUFBSSxPQUFPLEVBQUU7QUFDWCxTQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRTs7QUFFaEQsVUFBSSxPQUFPLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksV0FBVyxFQUFDO0FBQ3hDLFlBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztBQUN6QyxZQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO09BQzdDO0tBRUY7R0FDRixNQUNJO0FBQ0gsUUFBSSxDQUFDLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxDQUFDO0dBQ25DO0NBQ0YsQ0FBQzs7Ozs7Ozs7QUFRRixPQUFPLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxVQUFVLEdBQUcsRUFBRTtBQUMzQyxLQUFHLEdBQUcsWUFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxXQUFXLEVBQUUsR0FBRyxDQUFDLENBQUM7O0FBRTlELE1BQUksSUFBSSxDQUFDLGNBQWMsSUFBSSxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEtBQUssV0FBVyxFQUFFO0FBQzFFLFdBQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQztHQUNqQzs7QUFFRCxTQUFPLEdBQUcsQ0FBQztDQUNaLENBQUM7Ozs7Ozs7QUFPRixPQUFPLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxVQUFVLElBQUksRUFBRTtBQUM1QyxNQUFJLEdBQUcsQ0FBQzs7QUFFUixNQUFJLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssV0FBVyxFQUFFO0FBQ3hELE9BQUcsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztHQUNyQyxNQUFNO0FBQ0wsT0FBRyxHQUFHLElBQUksQ0FBQztHQUNaO0FBQ0QsS0FBRyxHQUFHLFlBQVksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsV0FBVyxFQUFFLEdBQUcsQ0FBQyxDQUFDOztBQUU5RCxTQUFPLEdBQUcsQ0FBQztDQUNaLENBQUM7Ozs7O0FBS0YsT0FBTyxDQUFDLFNBQVMsQ0FBQyxTQUFTLEdBQUcsWUFBWTtBQUN4QyxNQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDLFVBQVUsQ0FBQztBQUNwRCxNQUFJLE1BQU0sRUFBRTtBQUNWLFFBQUksT0FBTyxNQUFNLEtBQUssVUFBVSxFQUFFO0FBQ2hDLGFBQU8sTUFBTSxFQUFFLENBQUM7S0FDakI7QUFDRCxXQUFPLE1BQU0sQ0FBQztHQUNmOztBQUVELFNBQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQztDQUN4QixDQUFDOzs7Ozs7Ozs7QUFTRixPQUFPLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxVQUFVLEtBQUssRUFBRSxNQUFNLEVBQUUsb0JBQW9CLEVBQUU7QUFDM0UsTUFBSSxHQUFHO01BQUUsUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFO01BQzNDLG1CQUFtQixHQUFHLENBQUM7TUFDdkIsWUFBWSxDQUFDOztBQUVmLE1BQUksQ0FBQyxNQUFNLEVBQUU7QUFDWCxVQUFNLEdBQUcsQ0FBQyxDQUFDO0dBQ1o7O0FBRUQsTUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLElBQUksS0FBSyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLEVBQUU7QUFDbkUsU0FBSyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLENBQUM7R0FDbkM7O0FBRUQsY0FBWSxHQUFHLEtBQUssQ0FBQztBQUNyQixNQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sQ0FBQztBQUNsRCxTQUFPLG1CQUFtQixHQUFHLE1BQU0sSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxHQUFHLE9BQU8sRUFBRTs7QUFFMUUsUUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsS0FBSyxPQUFPLEVBQUU7QUFDdEMsU0FBRyxHQUFHLEVBQUUsQ0FBQztBQUNULFdBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDakMsV0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztPQUNoQjtLQUVGLE1BQU0sSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsS0FBSyxVQUFVLEVBQUU7QUFDaEQsU0FBRyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBRXJELE1BQU07QUFDTCxTQUFHLEdBQUcsRUFBRSxDQUFDO0FBQ1QscUNBQVcsR0FBRyxFQUFFLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDO0tBQ25DOztBQUVELFFBQUksS0FBSyxLQUFLLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLEVBQUU7QUFDdkMsVUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7S0FFM0IsTUFBTTtBQUNMLFVBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7S0FDdkM7O0FBRUQsdUJBQW1CLEVBQUUsQ0FBQztBQUN0QixnQkFBWSxFQUFFLENBQUM7R0FDaEI7O0FBR0QsY0FBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxnQkFBZ0IsRUFBRSxLQUFLLEVBQUUsbUJBQW1CLEVBQUUsb0JBQW9CLENBQUMsQ0FBQztBQUMxRyxNQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUM7O0FBRXJDLFNBQU8sbUJBQW1CLENBQUM7Q0FDNUIsQ0FBQzs7Ozs7Ozs7Ozs7QUFXRixPQUFPLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxVQUFVLEtBQUssRUFBRSxNQUFNLEVBQUUsb0JBQW9CLEVBQUU7QUFDM0UsTUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsMkJBQTJCLEVBQUUsRUFBRTtBQUNoRCxVQUFNLElBQUksS0FBSyxDQUFDLDJEQUEyRCxHQUN6RSwwR0FBMEcsR0FDMUcsOEVBQThFLENBQUMsQ0FBQztHQUNuRjtBQUNELE1BQUksSUFBSSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFO01BQ2xDLElBQUksR0FBRyxJQUFJLENBQUMsVUFBVTtNQUN0QixXQUFXO01BQUUsbUJBQW1CLEdBQUcsQ0FBQztNQUNwQyxZQUFZLENBQUM7O0FBRWYsTUFBSSxDQUFDLE1BQU0sRUFBRTtBQUNYLFVBQU0sR0FBRyxDQUFDLENBQUM7R0FDWjs7QUFFRCxjQUFZLEdBQUcsS0FBSyxDQUFDOztBQUVyQixNQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sQ0FBQztBQUNsRCxTQUFPLG1CQUFtQixHQUFHLE1BQU0sSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxHQUFHLE9BQU8sRUFBRTtBQUMxRSxlQUFXLEdBQUcsbUNBQWMsSUFBSSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLHVCQUF1QixDQUFDLENBQUM7QUFDbEYsUUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLElBQUksS0FBSyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLEVBQUU7QUFDbkUsV0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUM3QixZQUFJLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLFdBQVcsRUFBRTtBQUNsQyxjQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1NBQ2Q7QUFDRCxZQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO09BQ3BCOztBQUVELFVBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztLQUU1QyxNQUFNO0FBQ0wsV0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUM3QixZQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7T0FDdkM7O0FBRUQsVUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDLEVBQUUsV0FBVyxDQUFDLENBQUM7S0FDL0Q7O0FBRUQsdUJBQW1CLEVBQUUsQ0FBQztBQUN0QixnQkFBWSxFQUFFLENBQUM7R0FDaEI7O0FBRUQsY0FBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxnQkFBZ0IsRUFBRSxLQUFLLEVBQUUsbUJBQW1CLEVBQUUsb0JBQW9CLENBQUMsQ0FBQztBQUMxRyxNQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUM7O0FBRXJDLFNBQU8sbUJBQW1CLENBQUM7Q0FDNUIsQ0FBQzs7Ozs7Ozs7OztBQVVGLE9BQU8sQ0FBQyxTQUFTLENBQUMsU0FBUyxHQUFHLFVBQVUsS0FBSyxFQUFFLE1BQU0sRUFBRTtBQUNyRCxNQUFJLENBQUMsTUFBTSxFQUFFO0FBQ1gsVUFBTSxHQUFHLENBQUMsQ0FBQztHQUNaO0FBQ0QsTUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7QUFDN0IsU0FBSyxHQUFHLENBQUMsTUFBTSxDQUFDO0dBQ2pCOztBQUVELE9BQUssR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLEdBQUcsS0FBSyxDQUFBLEdBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsQ0FBQzs7O0FBR3hFLE1BQUksU0FBUyxHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7O0FBRTFELE1BQUkscUJBQXFCLEdBQUcsWUFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxpQkFBaUIsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7O0FBRXBHLE1BQUkscUJBQXFCLEtBQUssS0FBSyxFQUFFO0FBQ25DLFdBQU87R0FDUjs7QUFFRCxNQUFJLElBQUksR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO0FBQzNCLE1BQUksT0FBTyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBUyxHQUFHLEVBQUUsS0FBSyxFQUFFO0FBQzdDLFdBQU8sU0FBUyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztHQUN2QyxDQUFDLENBQUM7O0FBRUgsTUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDaEIsT0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQzs7QUFFMUMsY0FBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxnQkFBZ0IsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7O0FBRXZFLE1BQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQztDQUN0QyxDQUFDOzs7Ozs7Ozs7O0FBVUYsT0FBTyxDQUFDLFNBQVMsQ0FBQyxTQUFTLEdBQUcsVUFBVSxLQUFLLEVBQUUsTUFBTSxFQUFFO0FBQ3JELE1BQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEtBQUssUUFBUSxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxFQUFFO0FBQzlFLFVBQU0sSUFBSSxLQUFLLENBQUMsMEVBQTBFLENBQUMsQ0FBQztHQUM3RjtBQUNELE1BQUksQ0FBQyxNQUFNLEVBQUU7QUFDWCxVQUFNLEdBQUcsQ0FBQyxDQUFDO0dBQ1o7QUFDRCxNQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBRTtBQUM3QixTQUFLLEdBQUcsQ0FBQyxNQUFNLENBQUM7R0FDakI7O0FBRUQsT0FBSyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsR0FBRyxLQUFLLENBQUEsR0FBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFDOztBQUV4RSxNQUFJLHFCQUFxQixHQUFHLFlBQVksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsaUJBQWlCLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDOztBQUVwRyxNQUFJLHFCQUFxQixLQUFLLEtBQUssRUFBRTtBQUNuQyxXQUFPO0dBQ1I7O0FBRUQsTUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQztBQUMzQixPQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxJQUFJLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsRUFBRSxDQUFDLEdBQUcsSUFBSSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQy9ELFFBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0dBQy9CO0FBQ0QsTUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQzs7QUFFL0MsY0FBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxnQkFBZ0IsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDdkUsTUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDO0NBQ3RDLENBQUM7Ozs7Ozs7Ozs7QUFVRixPQUFPLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxVQUFVLEdBQUcsRUFBRSxLQUFLLEVBQUUsTUFBTSxvQkFBbUI7QUFDM0UsTUFBSSxRQUFRLEdBQUcsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQzs7QUFFeEUsTUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDOUMsTUFBSSxPQUFPLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsS0FBSyxHQUFHLE1BQU0sQ0FBQyxDQUFDO0FBQ25ELE1BQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxDQUFDOztBQUUxQyxpQ0FBWSxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDN0IsTUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ1YsU0FBTyxDQUFDLEdBQUcsTUFBTSxFQUFFO0FBQ2pCLFlBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDcEIsS0FBQyxFQUFFLENBQUM7R0FDTDtBQUNELCtCQUFVLFFBQVEsQ0FBQyxDQUFDO0FBQ3BCLE1BQUksQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxXQUFXLENBQUMsQ0FBQzs7QUFFL0UsU0FBTyxPQUFPLENBQUM7Q0FDaEIsQ0FBQzs7Ozs7Ozs7OztBQVVGLE9BQU8sQ0FBQyxTQUFTLENBQUMsU0FBUyxHQUFHLFVBQVUsR0FBRyxFQUFFLEtBQUssRUFBRSxNQUFNLG9CQUFtQjtBQUMzRSxNQUFJLFFBQVEsR0FBRyxDQUFDLElBQUksU0FBUyxDQUFDLE1BQU0sR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDOztBQUV4RSxNQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3BELE1BQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLEtBQUssR0FBRyxNQUFNLENBQUMsQ0FBQztBQUNuRCxNQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUMsQ0FBQzs7QUFFMUMsaUNBQVksUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQzdCLE1BQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNWLFNBQU8sQ0FBQyxHQUFHLE1BQU0sRUFBRTtBQUNqQixZQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3BCLEtBQUMsRUFBRSxDQUFDO0dBQ0w7QUFDRCxNQUFJLENBQUMsUUFBUSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLFdBQVcsQ0FBQyxDQUFDOztBQUVqRixTQUFPLE9BQU8sQ0FBQztDQUNoQixDQUFDOzs7Ozs7OztBQVFGLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxHQUFHLFVBQVUsR0FBRyxFQUFFLElBQUksRUFBRTtBQUMzQyxLQUFHLEdBQUcsWUFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxXQUFXLEVBQUUsR0FBRyxDQUFDLENBQUM7O0FBRTlELE1BQUksT0FBTyxJQUFJLEtBQUssUUFBUSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUU7QUFDdEQsUUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUM3QixRQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQy9CLFFBQUksQ0FBQyxHQUFHLEVBQUU7QUFDUixhQUFPLElBQUksQ0FBQztLQUNiO0FBQ0QsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUNuRCxTQUFHLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3JCLFVBQUksT0FBTyxHQUFHLEtBQUssV0FBVyxFQUFFO0FBQzlCLGVBQU8sSUFBSSxDQUFDO09BQ2I7S0FDRjtBQUNELFdBQU8sR0FBRyxDQUFDO0dBQ1osTUFBTSxJQUFJLE9BQU8sSUFBSSxLQUFLLFVBQVUsRUFBRTs7Ozs7Ozs7Ozs7Ozs7QUFjckMsV0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQy9CLEdBQUcsRUFDSCxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztHQUNoQixNQUFNO0FBQ0wsV0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDO0dBQ2pFO0NBQ0YsQ0FBQzs7QUFFRixJQUFJLGNBQWMsR0FBRywwQ0FBd0IsVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFDOzs7Ozs7Ozs7QUFTaEUsT0FBTyxDQUFDLFNBQVMsQ0FBQyxXQUFXLEdBQUcsVUFBVSxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQ25ELE1BQUksY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUU7QUFDakUsV0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztHQUM1QjtBQUNELFNBQU8sRUFBRSxDQUFDO0NBQ1gsQ0FBQzs7Ozs7Ozs7OztBQVVGLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxHQUFHLFVBQVUsR0FBRyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFO0FBQzFELEtBQUcsR0FBRyxZQUFZLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLFdBQVcsRUFBRSxHQUFHLEVBQUUsTUFBTSxJQUFJLFlBQVksQ0FBQyxDQUFDOztBQUV0RixNQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVEsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO0FBQ3RELFFBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDN0IsUUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUMvQixTQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxJQUFJLEdBQUcsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRTs7QUFFdkQsVUFBSSxPQUFPLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxXQUFXLEVBQUU7QUFDekMsV0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztPQUNyQjtBQUNELFNBQUcsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDdEI7QUFDRCxPQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO0dBRXhCLE1BQU0sSUFBSSxPQUFPLElBQUksS0FBSyxVQUFVLEVBQUU7O0FBRXJDLFFBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO0dBRXJELE1BQU07QUFDTCxRQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQztHQUNwQztDQUNGLENBQUM7Ozs7Ozs7Ozs7OztBQVlGLE9BQU8sQ0FBQyxTQUFTLENBQUMscUJBQXFCLEdBQUcsVUFBVSxLQUFLLEVBQUUsTUFBTSxFQUFFO0FBQ2pFLE1BQUksU0FBUyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLENBQUM7QUFDMUMsTUFBSSxTQUFTLEdBQUcsQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFBLEdBQUksU0FBUyxDQUFDO0FBQ2hELE1BQUksU0FBUyxHQUFHLEVBQUUsQ0FBQztBQUNuQixNQUFJLFlBQVksR0FBRyxNQUFNLENBQUM7QUFDMUIsTUFBSSxHQUFHLENBQUM7O0FBRVIsU0FBTyxTQUFTLEdBQUcsU0FBUyxJQUFJLFlBQVksRUFBRTtBQUM1QyxPQUFHLEdBQUcsWUFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxXQUFXLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDcEUsYUFBUyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQzs7QUFFcEIsZ0JBQVksRUFBRSxDQUFDO0FBQ2YsYUFBUyxFQUFFLENBQUM7R0FDYjs7QUFFRCxTQUFPLFNBQVMsQ0FBQztDQUNsQixDQUFDOzs7OztBQUtGLE9BQU8sQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHLFlBQVk7QUFDcEMsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDbEQsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDbEQsVUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztLQUNwQztHQUNGO0NBQ0YsQ0FBQzs7Ozs7OztBQU9GLE9BQU8sQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLFlBQVk7QUFDckMsU0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO0NBQ3hCLENBQUM7Ozs7Ozs7Ozs7QUFVRixPQUFPLENBQUMsU0FBUyxDQUFDLFFBQVEsR0FBRyxVQUFVLEtBQUssRUFBRSxHQUFHLEVBQUUsV0FBVyxFQUFFO0FBQzlELE1BQUksQ0FBQztNQUFFLElBQUk7TUFBRSxDQUFDO01BQUUsSUFBSTtNQUFFLE1BQU0sR0FBRyxFQUFFO01BQy9CLEdBQUcsQ0FBQzs7QUFFTixNQUFJLEtBQUssR0FBRyxXQUFXLEtBQUssSUFBSSxDQUFDLCtCQUErQixHQUFHLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQzs7QUFFL0YsTUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDcEMsTUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7O0FBRXBDLE9BQUssQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUNyRCxPQUFHLEdBQUcsRUFBRSxDQUFDO0FBQ1QsU0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksSUFBSSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3JELFNBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ2xEO0FBQ0QsVUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztHQUNsQjs7QUFFRCxTQUFPLE1BQU0sQ0FBQztDQUNmLENBQUM7Ozs7Ozs7OztBQVNGLE9BQU8sQ0FBQyxTQUFTLENBQUMsT0FBTyxHQUFHLFVBQVUsS0FBSyxFQUFFLEdBQUcsRUFBRTtBQUNoRCxTQUFPLHVCQUFVLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQztDQUNsRixDQUFDOzs7Ozs7Ozs7QUFTRixPQUFPLENBQUMsU0FBUyxDQUFDLGVBQWUsR0FBRyxVQUFVLEtBQUssRUFBRSxHQUFHLEVBQUU7QUFDeEQsU0FBTyx1QkFBVSxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQywrQkFBK0IsQ0FBQyxDQUFDLENBQUM7Q0FDN0YsQ0FBQzs7UUFFTSxPQUFPLEdBQVAsT0FBTzs7O0FBR2YsWUFBWSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7Ozs7Ozs7OzsrQ0N6a0JLLHdDQUF3Qzs7OEJBQzlCLG1CQUFtQjs7K0JBQ3NCLHFCQUFxQjs7dUJBQ3BGLFdBQVc7OzRCQUNjLGdCQUFnQjs7UUFFekQsYUFBYSxHQUFiLGFBQWE7OztBQUdyQixZQUFZLENBQUMsYUFBYSxHQUFHLGFBQWEsQ0FBQzs7QUFFM0MsU0FBUyxhQUFhLENBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUM7QUFDL0MsTUFBSSxLQUFLLEdBQUcsSUFBSTtNQUNkLFNBQVMsR0FBRyxLQUFLO01BQ2pCLFlBQVk7TUFDWixZQUFZLENBQUM7O0FBRWYsY0FBWSxHQUFHLGdDQUFtQixRQUFRLENBQUMsQ0FBQzs7QUFFNUMsV0FBUyx1QkFBdUIsQ0FBQyxRQUFRLEVBQUU7QUFDekMsUUFBSSxVQUFVLEdBQUcsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsS0FBSyxVQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUM7O0FBRTdILFFBQUksUUFBUSxFQUFFOztBQUVaLGVBQVMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUUsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBRTdELE1BQU07O0FBRUwsZUFBUyxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7S0FDaEU7R0FDRjs7QUFFRCxXQUFTLGVBQWUsQ0FBQyxRQUFRLEVBQUU7QUFDakMsUUFBSSxRQUFRLEVBQUU7QUFDWixlQUFTLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0tBQy9CLE1BQU07QUFDTCxlQUFTLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0tBQ2pDO0dBQ0Y7O0FBRUQsV0FBUyxpQkFBaUIsQ0FBQyxRQUFRLEVBQUU7QUFDbkMsUUFBSSxRQUFRLEVBQUU7O0FBRVosZUFBUyxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7S0FDOUIsTUFBTTs7QUFFTCxlQUFTLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztLQUNoQztHQUNGOztBQUVELFdBQVMsa0JBQWtCLENBQUMsUUFBUSxFQUFFO0FBQ3BDLFFBQUksUUFBUSxFQUFFO0FBQ1osZUFBUyxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7S0FDOUIsTUFBTTtBQUNMLGVBQVMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0tBQ2hDO0dBQ0Y7O0FBRUQsV0FBUyxpQkFBaUIsQ0FBQyxRQUFRLEVBQUU7QUFDbkMsUUFBSSxRQUFRLEVBQUU7QUFDWixlQUFTLENBQUMsWUFBWSxDQUFDLENBQUMsRUFBRSxDQUFFLENBQUMsQ0FBQyxDQUFDO0tBQ2hDLE1BQU07QUFDTCxlQUFTLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRSxDQUFFLENBQUMsQ0FBQyxDQUFDO0tBQ2xDO0dBQ0Y7O0FBRUQsV0FBUyxTQUFTLENBQUMsS0FBSyxFQUFFO0FBQ3hCLFFBQUksUUFBUSxFQUFFLGFBQWEsQ0FBQzs7QUFFNUIsUUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsRUFBRTtBQUMzQixhQUFPO0tBQ1I7QUFDRCxnQkFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLGVBQWUsRUFBRSxLQUFLLENBQUMsQ0FBQzs7QUFFekQsUUFBSSxTQUFTLEVBQUU7QUFDYixhQUFPO0tBQ1I7QUFDRCxRQUFJLG9EQUE4QixLQUFLLENBQUMsRUFBRTtBQUN4QyxhQUFPO0tBQ1I7QUFDRCxRQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUM7O0FBRWpDLFFBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxFQUFFLEVBQUU7QUFDM0IsYUFBTztLQUNSOztBQUVELFlBQVEsR0FBRyxDQUFDLEtBQUssQ0FBQyxPQUFPLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQSxJQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQzs7QUFFN0QsUUFBSSxZQUFZLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLEVBQUU7QUFDN0MsVUFBSSxDQUFDLCtCQUFVLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLCtCQUFVLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLEVBQUUsRUFBRTtBQUNsRyxhQUFLLENBQUMsVUFBVSxDQUFDLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQzs7QUFFNUIsZUFBTztPQUNSO0tBQ0Y7QUFDRCxpQkFBYSxHQUFHLEtBQUssQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDLFdBQVcsR0FBRyxTQUFTLENBQUMsYUFBYSxDQUFDOztBQUVqRixZQUFRLEtBQUssQ0FBQyxPQUFPOztBQUVuQixXQUFLLDBCQUFVLENBQUM7QUFDZCxZQUFJLENBQUMsS0FBSyxDQUFDLGNBQWMsRUFBRSxJQUFJLFFBQVEsRUFBRTtBQUN2QyxtQkFBUyxDQUFDLFNBQVMsRUFBRSxDQUFDOztBQUV0QixlQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7QUFDdkIsZ0RBQWdCLEtBQUssQ0FBQyxDQUFDO1NBQ3hCO0FBQ0QsY0FBTTs7QUFBQSxBQUVSLFdBQUssMEJBQVUsUUFBUTtBQUNyQixZQUFJLEtBQUssQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLEVBQUUsRUFBRTtBQUN2RCxlQUFLLENBQUMseUJBQXlCLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDM0M7QUFDRCx1QkFBZSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQzs7QUFFaEMsYUFBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO0FBQ3ZCLDhDQUFnQixLQUFLLENBQUMsQ0FBQztBQUN2QixjQUFNOztBQUFBLEFBRVIsV0FBSywwQkFBVSxVQUFVO0FBQ3ZCLFlBQUksS0FBSyxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsRUFBRSxFQUFFO0FBQ3ZELGVBQUssQ0FBQyx5QkFBeUIsQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUMzQztBQUNELHlCQUFpQixDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQzs7QUFFbEMsYUFBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO0FBQ3ZCLDhDQUFnQixLQUFLLENBQUMsQ0FBQztBQUN2QixjQUFNOztBQUFBLEFBRVIsV0FBSywwQkFBVSxXQUFXO0FBQ3hCLFlBQUksS0FBSyxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsRUFBRSxFQUFFO0FBQ3ZELGVBQUssQ0FBQyx5QkFBeUIsQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUMzQztBQUNELDBCQUFrQixDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQzs7QUFFbkMsYUFBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO0FBQ3ZCLDhDQUFnQixLQUFLLENBQUMsQ0FBQztBQUN2QixjQUFNOztBQUFBLEFBRVIsV0FBSywwQkFBVSxVQUFVO0FBQ3ZCLFlBQUksS0FBSyxDQUFDLGNBQWMsRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsRUFBRSxFQUFFO0FBQ3ZELGVBQUssQ0FBQyx5QkFBeUIsQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUMzQztBQUNELHlCQUFpQixDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQzs7QUFFbEMsYUFBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO0FBQ3ZCLDhDQUFnQixLQUFLLENBQUMsQ0FBQztBQUN2QixjQUFNOztBQUFBLEFBRVIsV0FBSywwQkFBVSxHQUFHO0FBQ2hCLFlBQUksUUFBUSxHQUFHLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEtBQUssVUFBVSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDOztBQUVySCxZQUFJLEtBQUssQ0FBQyxRQUFRLEVBQUU7O0FBRWxCLG1CQUFTLENBQUMsY0FBYyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUN4RCxNQUFNOztBQUVMLG1CQUFTLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztTQUM1RDtBQUNELGFBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztBQUN2Qiw4Q0FBZ0IsS0FBSyxDQUFDLENBQUM7QUFDdkIsY0FBTTs7QUFBQSxBQUVSLFdBQUssMEJBQVUsU0FBUyxDQUFDO0FBQ3pCLFdBQUssMEJBQVUsTUFBTTtBQUNuQixpQkFBUyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN2QixhQUFLLENBQUMsYUFBYSxFQUFFLENBQUM7QUFDdEIsYUFBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO0FBQ3ZCLGNBQU07O0FBQUEsQUFFUixXQUFLLDBCQUFVLEVBQUU7O0FBRWYsYUFBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7O0FBRTlCLFlBQUksWUFBWSxFQUFFO0FBQ2hCLHNCQUFZLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztTQUNuQztBQUNELGFBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztBQUN2QixjQUFNOztBQUFBLEFBRVIsV0FBSywwQkFBVSxLQUFLOztBQUVsQixZQUFJLEtBQUssQ0FBQyxjQUFjLEVBQUUsRUFBRTs7QUFFMUIsY0FBSSxZQUFZLElBQUksWUFBWSxDQUFDLEtBQUssS0FBSyxZQUFZLENBQUMsV0FBVyxDQUFDLE9BQU8sRUFBRTtBQUMzRSxpQkFBSyxDQUFDLHlCQUF5QixDQUFDLFFBQVEsQ0FBQyxDQUFDO1dBQzNDO0FBQ0QsaUNBQXVCLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBRXpDLE1BQU07QUFDTCxjQUFJLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxrQkFBa0IsRUFBRTtBQUM3QyxpQkFBSyxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7O0FBRTlCLGdCQUFJLFlBQVksRUFBRTtBQUNoQiwwQkFBWSxDQUFDLGtCQUFrQixFQUFFLENBQUM7YUFDbkM7V0FDRixNQUFNO0FBQ0wsbUNBQXVCLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1dBQ3pDO1NBQ0Y7QUFDRCxhQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7QUFDdkIsdURBQXlCLEtBQUssQ0FBQyxDQUFDO0FBQ2hDLGNBQU07O0FBQUEsQUFFUixXQUFLLDBCQUFVLE1BQU07QUFDbkIsWUFBSSxLQUFLLENBQUMsY0FBYyxFQUFFLEVBQUU7QUFDMUIsZUFBSyxDQUFDLGtDQUFrQyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQ3BEO0FBQ0QsYUFBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO0FBQ3ZCLGNBQU07O0FBQUEsQUFFUixXQUFLLDBCQUFVLElBQUk7QUFDakIsWUFBSSxLQUFLLENBQUMsT0FBTyxJQUFJLEtBQUssQ0FBQyxPQUFPLEVBQUU7QUFDbEMsdUJBQWEsQ0FBQywyREFBMEIsQ0FBQyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FDckUsTUFBTTtBQUNMLHVCQUFhLENBQUMsMkRBQTBCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3JFO0FBQ0QsYUFBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO0FBQ3ZCLDhDQUFnQixLQUFLLENBQUMsQ0FBQztBQUN2QixjQUFNOztBQUFBLEFBRVIsV0FBSywwQkFBVSxHQUFHO0FBQ2hCLFlBQUksS0FBSyxDQUFDLE9BQU8sSUFBSSxLQUFLLENBQUMsT0FBTyxFQUFFO0FBQ2xDLHVCQUFhLENBQUMsMkRBQTBCLFFBQVEsQ0FBQyxTQUFTLEVBQUUsR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztTQUM1RixNQUFNO0FBQ0wsdUJBQWEsQ0FBQywyREFBMEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLFFBQVEsQ0FBQyxTQUFTLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQzVGO0FBQ0QsYUFBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO0FBQ3ZCLDhDQUFnQixLQUFLLENBQUMsQ0FBQztBQUN2QixjQUFNOztBQUFBLEFBRVIsV0FBSywwQkFBVSxPQUFPO0FBQ3BCLGlCQUFTLENBQUMsY0FBYyxDQUFDLENBQUMsUUFBUSxDQUFDLGdCQUFnQixFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDMUQsYUFBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO0FBQ3ZCLDhDQUFnQixLQUFLLENBQUMsQ0FBQztBQUN2QixjQUFNOztBQUFBLEFBRVIsV0FBSywwQkFBVSxTQUFTO0FBQ3RCLGlCQUFTLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ3pELGFBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztBQUN2Qiw4Q0FBZ0IsS0FBSyxDQUFDLENBQUM7QUFDdkIsY0FBTTtBQUFBLEtBQ1Q7R0FDRjs7QUFFRCxXQUFTLElBQUksR0FBRztBQUNkLFlBQVEsQ0FBQyxPQUFPLENBQUMsc0JBQXNCLEVBQUUsU0FBUyxDQUFDLENBQUM7O0FBRXBELGdCQUFZLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLGVBQWUsRUFBRSxTQUFTLEVBQUUsVUFBUyxLQUFLLEVBQUU7QUFDakYsY0FBUSxDQUFDLFFBQVEsQ0FBQyxzQkFBc0IsRUFBRSxLQUFLLENBQUMsQ0FBQztLQUNsRCxDQUFDLENBQUM7O0FBRUgsYUFBUyxVQUFVLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7O0FBRXZDLFVBQUksSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLEVBQUU7QUFDekIsYUFBSyxDQUFDLFVBQVUsRUFBRSxDQUFDOztBQUVuQixZQUFJLFlBQVksRUFBRTtBQUNoQixzQkFBWSxDQUFDLGtCQUFrQixFQUFFLENBQUM7U0FDbkM7T0FDRjtLQUNGO0FBQ0QsWUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLGdCQUFnQixFQUFFLFVBQVUsQ0FBQyxDQUFDOztBQUV0RCxZQUFRLENBQUMsT0FBTyxDQUFDLGNBQWMsRUFBRSxZQUFXO0FBQzFDLGVBQVMsR0FBRyxJQUFJLENBQUM7S0FDbEIsQ0FBQyxDQUFDO0dBQ0o7Ozs7Ozs7OztBQVNELE1BQUksQ0FBQyxhQUFhLEdBQUcsVUFBUyxjQUFjLEVBQUU7QUFDNUMsUUFBSSxDQUFDLFdBQVcsQ0FBQyxjQUFjLENBQUMsQ0FBQztHQUNsQyxDQUFDOzs7Ozs7Ozs7QUFTRixNQUFJLENBQUMsZUFBZSxHQUFHLFlBQVc7QUFDaEMsV0FBTyxZQUFZLENBQUM7R0FDckIsQ0FBQzs7Ozs7Ozs7QUFRRixNQUFJLENBQUMsYUFBYSxHQUFHLFlBQVc7QUFDOUIsUUFBSSxHQUFHLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsYUFBYSxFQUFFLGNBQWMsRUFBRSxXQUFXLENBQUM7O0FBRW5FLFFBQUksWUFBWSxJQUFJLFlBQVksQ0FBQyxTQUFTLEVBQUUsRUFBRTtBQUM1QyxVQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsVUFBUyxTQUFTLEVBQUU7QUFDakQsWUFBSSxTQUFTLEVBQUU7QUFDYixlQUFLLENBQUMsYUFBYSxFQUFFLENBQUM7U0FDdkI7T0FDRixDQUFDLENBQUM7O0FBRUgsYUFBTztLQUNSO0FBQ0QsT0FBRyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQztBQUNsQyxPQUFHLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDO0FBQ2xDLFFBQUksR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQy9CLE1BQUUsR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUNoQyxpQkFBYSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQ2pELGtCQUFjLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDaEQsZUFBVyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsY0FBYyxDQUFDLENBQUM7O0FBRXJELFFBQUksV0FBVyxFQUFFO0FBQ2Ysa0JBQVksR0FBRyxZQUFZLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxXQUFXLEVBQUUsUUFBUSxDQUFDLENBQUM7QUFDckUsa0JBQVksQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLGFBQWEsRUFBRSxjQUFjLENBQUMsQ0FBQztLQUV6RSxNQUFNO0FBQ0wsa0JBQVksR0FBRyxLQUFLLENBQUMsQ0FBQztLQUN2QjtHQUNGLENBQUM7Ozs7Ozs7OztBQVNGLE1BQUksQ0FBQyxjQUFjLEdBQUcsWUFBVztBQUMvQixXQUFPLFlBQVksSUFBSSxZQUFZLENBQUMsUUFBUSxFQUFFLENBQUM7R0FDaEQsQ0FBQzs7Ozs7Ozs7OztBQVVGLE1BQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxZQUFZLEVBQUUsS0FBSyxFQUFFO0FBQy9DLFFBQUksWUFBWSxJQUFJLENBQUMsWUFBWSxDQUFDLGNBQWMsQ0FBQyxRQUFRLEVBQUU7QUFDekQsa0JBQVksQ0FBQyxZQUFZLENBQUMsWUFBWSxFQUFFLEtBQUssQ0FBQyxDQUFDO0tBQ2hELE1BQU0sSUFBSSxZQUFZLElBQUksWUFBWSxDQUFDLGNBQWMsQ0FBQyxRQUFRLEVBQUU7OztBQUcvRCxVQUFJLEtBQUssSUFBSSxLQUFLLENBQUMsT0FBTyxLQUFLLDBCQUFVLEtBQUssRUFBRTtBQUM5QywrQkFBdUIsRUFBRSxDQUFDO09BQzNCO0tBQ0Y7R0FDRixDQUFDOzs7Ozs7Ozs7OztBQVdGLE1BQUksQ0FBQyxXQUFXLEdBQUcsVUFBUyxvQkFBb0IsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFO0FBQ3BFLFFBQUksQ0FBQyxZQUFZLEVBQUU7QUFDakIsVUFBSSxRQUFRLEVBQUU7QUFDWixnQkFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO09BQ2pCO0tBQ0YsTUFBTTtBQUNMLGtCQUFZLENBQUMsYUFBYSxDQUFDLG9CQUFvQixFQUFFLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztLQUN0RTtHQUNGLENBQUM7Ozs7Ozs7OztBQVNGLE1BQUksQ0FBQyx5QkFBeUIsR0FBRyxVQUFTLFFBQVEsRUFBRTtBQUNsRCxXQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0dBQzFDLENBQUM7Ozs7Ozs7OztBQVNGLE1BQUksQ0FBQyxrQ0FBa0MsR0FBRyxVQUFTLFFBQVEsRUFBRTtBQUMzRCxXQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0dBQ3pDLENBQUM7O0FBRUYsTUFBSSxFQUFFLENBQUM7Q0FDUjs7Ozs7Ozs7Ozs7Ozs2QkMzWThCLGtCQUFrQjs7UUFFekMsY0FBYyxHQUFkLGNBQWM7UUFBRSxTQUFTLEdBQVQsU0FBUztRQUFFLFNBQVMsR0FBVCxTQUFTO1FBQUUsb0JBQW9CLEdBQXBCLG9CQUFvQjs7QUFFbEUsSUFDRSxxQkFBcUIsR0FBRyxFQUFFO0lBQzFCLHVCQUF1QixHQUFHLElBQUksT0FBTyxFQUFFLENBQUM7OztBQUcxQyxZQUFZLENBQUMsT0FBTyxHQUFHLFlBQVksQ0FBQyxPQUFPLElBQUksRUFBRSxDQUFDO0FBQ2xELFlBQVksQ0FBQyxPQUFPLENBQUMsY0FBYyxHQUFHLGNBQWMsQ0FBQztBQUNyRCxZQUFZLENBQUMsT0FBTyxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7O0FBRTNDLFNBQVMsZ0JBQWdCLENBQUMsV0FBVyxFQUFFO0FBQ3JDLE1BQUksS0FBSyxFQUFFLFNBQVMsQ0FBQzs7QUFFckIsV0FBUyxHQUFHLEVBQUUsQ0FBQztBQUNmLE9BQUssR0FBRyxXQUFXLENBQUM7O0FBRXBCLE1BQUksQ0FBQyxjQUFjLEdBQUcsWUFBVztBQUMvQixXQUFPLFdBQVcsQ0FBQztHQUNwQixDQUFDOztBQUVGLE1BQUksQ0FBQyxXQUFXLEdBQUcsVUFBVSxXQUFXLEVBQUU7QUFDeEMsUUFBSSxFQUFFLFdBQVcsQ0FBQyxJQUFJLElBQUksU0FBUyxDQUFBLEFBQUMsRUFBRTtBQUNwQyxlQUFTLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0tBQ3REOztBQUVELFdBQU8sU0FBUyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztHQUNwQyxDQUFDO0NBQ0g7Ozs7Ozs7QUFPRCxTQUFTLGNBQWMsQ0FBQyxVQUFVLEVBQUUsV0FBVyxFQUFFO0FBQy9DLE1BQUksTUFBTSxHQUFHLElBQUksZ0JBQWdCLENBQUMsV0FBVyxDQUFDLENBQUM7O0FBRS9DLE1BQUksT0FBTyxVQUFVLEtBQUssUUFBUSxFQUFFO0FBQ2xDLHlCQUFxQixDQUFDLFVBQVUsQ0FBQyxHQUFHLE1BQU0sQ0FBQztBQUMzQyxnQkFBWSxDQUFDLE9BQU8sQ0FBQyxxQ0FBaUIsVUFBVSxDQUFDLEdBQUcsUUFBUSxDQUFDLEdBQUcsV0FBVyxDQUFDO0dBQzdFO0FBQ0QseUJBQXVCLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQztDQUNsRDs7Ozs7Ozs7O0FBU0QsU0FBUyxTQUFTLENBQUMsVUFBVSxFQUFFLFdBQVcsRUFBRTtBQUMxQyxNQUFJLE1BQU0sQ0FBQzs7QUFFWCxNQUFJLE9BQU8sVUFBVSxJQUFJLFVBQVUsRUFBRTtBQUNuQyxRQUFJLENBQUUsdUJBQXVCLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxBQUFDLEVBQUU7QUFDOUMsb0JBQWMsQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUM7S0FDbEM7QUFDRCxVQUFNLEdBQUcsdUJBQXVCLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0dBQ2xELE1BQ0ksSUFBSSxPQUFPLFVBQVUsSUFBSSxRQUFRLEVBQUU7QUFDdEMsVUFBTSxHQUFHLHFCQUFxQixDQUFDLFVBQVUsQ0FBQyxDQUFDO0dBQzVDLE1BQ0k7QUFDSCxVQUFNLEtBQUssQ0FBQyxpRUFBaUUsQ0FBQyxDQUFDO0dBQ2hGOztBQUVELE1BQUksQ0FBQyxNQUFNLEVBQUU7QUFDWCxVQUFNLEtBQUssQ0FBQyxtQ0FBbUMsR0FBRyxVQUFVLEdBQUcsR0FBRyxDQUFDLENBQUM7R0FDckU7O0FBRUQsU0FBTyxNQUFNLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0NBQ3hDOzs7Ozs7OztBQVFELFNBQVMsb0JBQW9CLENBQUMsVUFBVSxFQUFFO0FBQ3hDLE1BQUksTUFBTSxDQUFDOztBQUVYLE1BQUksT0FBTyxVQUFVLElBQUksUUFBUSxFQUFFO0FBQ2pDLFVBQU0sR0FBRyxxQkFBcUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztHQUM1QyxNQUNJO0FBQ0gsVUFBTSxLQUFLLENBQUMsaUVBQWlFLENBQUMsQ0FBQztHQUNoRjs7QUFFRCxNQUFJLENBQUMsTUFBTSxFQUFFO0FBQ1gsVUFBTSxLQUFLLENBQUMsbUNBQW1DLEdBQUcsVUFBVSxHQUFHLEdBQUcsQ0FBQyxDQUFDO0dBQ3JFOztBQUVELFNBQU8sTUFBTSxDQUFDLGNBQWMsRUFBRSxDQUFDO0NBQ2hDOzs7Ozs7QUFNRCxTQUFTLFNBQVMsQ0FBQyxVQUFVLEVBQUU7QUFDN0IsU0FBTyxxQkFBcUIsQ0FBQyxVQUFVLENBQUMsR0FBRyxJQUFJLEdBQUcsS0FBSyxDQUFDO0NBQ3pEOzs7Ozs7Ozs7NEJDN0d1QixvQkFBb0I7OytDQUNSLDJDQUEyQzs7UUFFdkUsVUFBVSxHQUFWLFVBQVU7O0FBRWxCLFlBQVksQ0FBQyxPQUFPLEdBQUcsWUFBWSxDQUFDLE9BQU8sSUFBSSxFQUFFLENBQUM7QUFDbEQsWUFBWSxDQUFDLE9BQU8sQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDOztBQUU3QyxZQUFZLENBQUMsV0FBVyxHQUFHO0FBQ3pCLFFBQU0sRUFBRSxjQUFjO0FBQ3RCLFNBQU8sRUFBRSxlQUFlO0FBQ3hCLFNBQU8sRUFBRSxlQUFlO0FBQ3hCLFVBQVEsRUFBRSxnQkFBZ0I7Q0FDM0IsQ0FBQzs7QUFFRixTQUFTLFVBQVUsQ0FBQyxRQUFRLEVBQUU7QUFDNUIsTUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7QUFDekIsTUFBSSxDQUFDLEtBQUssR0FBRyxZQUFZLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQzs7QUFFN0MsTUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7QUFDckIsTUFBSSxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQUM7QUFDM0IsTUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7O0FBRTNCLE1BQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztDQUNiOztBQUVELFVBQVUsQ0FBQyxTQUFTLENBQUMsY0FBYyxHQUFHLFVBQVMsTUFBTSxFQUFFO0FBQ3JELE1BQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtBQUN2QixRQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQzVCLFFBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDO0dBQzVCO0NBQ0YsQ0FBQzs7QUFFRixVQUFVLENBQUMsU0FBUyxDQUFDLElBQUksR0FBRyxZQUFXLEVBQUUsQ0FBQzs7QUFFMUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsWUFBVztBQUN6QyxRQUFNLEtBQUssQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFDO0NBQ3ZELENBQUM7O0FBRUYsVUFBVSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsVUFBUyxRQUFRLEVBQUU7QUFDakQsUUFBTSxLQUFLLENBQUMsd0NBQXdDLENBQUMsQ0FBQztDQUN2RCxDQUFDOztBQUVGLFVBQVUsQ0FBQyxTQUFTLENBQUMsSUFBSSxHQUFHLFlBQVc7QUFDckMsUUFBTSxLQUFLLENBQUMsb0NBQW9DLENBQUMsQ0FBQztDQUNuRCxDQUFDOztBQUVGLFVBQVUsQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHLFlBQVc7QUFDdEMsUUFBTSxLQUFLLENBQUMscUNBQXFDLENBQUMsQ0FBQztDQUNwRCxDQUFDOztBQUVGLFVBQVUsQ0FBQyxTQUFTLENBQUMsT0FBTyxHQUFHLFVBQVMsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLGFBQWEsRUFBRSxjQUFjLEVBQUU7QUFDekYsTUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUM7QUFDYixNQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztBQUNmLE1BQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO0FBQ2YsTUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7QUFDakIsTUFBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7QUFDbkMsTUFBSSxDQUFDLGNBQWMsR0FBRyxjQUFjLENBQUM7O0FBRXJDLE1BQUksQ0FBQyxLQUFLLEdBQUcsWUFBWSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUM7Q0FDOUMsQ0FBQzs7QUFFRixVQUFVLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxZQUFXO0FBQ3ZDLE1BQUksU0FBUyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7O0FBRWpDLFdBQVMsTUFBTSxHQUFHO0FBQ2hCLGFBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0dBQ2xDOztBQUVELFdBQVMsT0FBTyxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUU7QUFDOUIsYUFBUyxNQUFNLEdBQUcsRUFBRTtBQUNwQixVQUFNLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUM7QUFDcEMsU0FBSyxDQUFDLFNBQVMsR0FBRyxJQUFJLE1BQU0sRUFBRSxDQUFDO0FBQy9CLFNBQUssQ0FBQyxTQUFTLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQzs7QUFFcEMsV0FBTyxLQUFLLENBQUM7R0FDZDs7QUFFRCxTQUFPLE9BQU8sQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7Q0FDbkMsQ0FBQzs7QUFFRixVQUFVLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxVQUFTLEdBQUcsRUFBRSxRQUFRLEVBQUU7QUFDdkQsTUFBSSxHQUFHLEVBQUUsR0FBRyxDQUFDOzs7QUFHYixNQUFJLFFBQVEsRUFBRTtBQUNaLE9BQUcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDOztBQUVsQyxRQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUU7QUFDbkIsU0FBRyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNiLFNBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDaEIsU0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztLQUNkO0FBQ0QsUUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFO0FBQ25CLFNBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDYixTQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2hCLFNBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUM7S0FDZDs7QUFFRCxRQUFJLENBQUMsUUFBUSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLENBQUM7R0FDOUUsTUFBTTtBQUNMLFFBQUksQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0dBQzlFO0NBQ0YsQ0FBQzs7QUFFRixVQUFVLENBQUMsU0FBUyxDQUFDLFlBQVksR0FBRyxVQUFTLFlBQVksRUFBRSxLQUFLLEVBQUU7QUFDaEUsTUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLFlBQVksQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFO0FBQ2pELFdBQU87R0FDUjtBQUNELE1BQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQywyREFBMEIsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNqRixNQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztBQUM1QixNQUFJLENBQUMsS0FBSyxHQUFHLFlBQVksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDOztBQUU5QyxjQUFZLEdBQUcsT0FBTyxZQUFZLElBQUksUUFBUSxHQUFHLFlBQVksR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDO0FBQ25GLE1BQUksQ0FBQyxRQUFRLENBQUMsNkJBQVUsWUFBWSxDQUFDLENBQUMsQ0FBQzs7QUFFdkMsTUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNqQixNQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztBQUNwQixNQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7OztBQUdiLE1BQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO0NBQzdCLENBQUM7O0FBRUYsVUFBVSxDQUFDLFNBQVMsQ0FBQyxhQUFhLEdBQUcsVUFBUyxvQkFBb0IsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFO0FBQ3RGLE1BQUksS0FBSyxHQUFHLElBQUk7TUFDZCxHQUFHLENBQUM7O0FBRU4sTUFBSSxRQUFRLEVBQUU7QUFDWixRQUFJLHFCQUFxQixHQUFHLElBQUksQ0FBQyxjQUFjLENBQUM7O0FBRWhELFFBQUksQ0FBQyxjQUFjLEdBQUcsVUFBUyxNQUFNLEVBQUU7QUFDckMsVUFBSSxxQkFBcUIsRUFBRTtBQUN6Qiw2QkFBcUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztPQUMvQjtBQUNELGNBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUNsQixDQUFDO0dBQ0g7O0FBRUQsTUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFLEVBQUU7QUFDcEIsV0FBTztHQUNSOztBQUVELE1BQUksSUFBSSxDQUFDLEtBQUssSUFBSSxZQUFZLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRTtBQUNqRCxRQUFJLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxZQUFXO0FBQ25ELFdBQUssQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDNUIsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDOztBQUVQLFdBQU87R0FDUjs7QUFFRCxNQUFJLElBQUksQ0FBQyxLQUFLLElBQUksWUFBWSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUU7QUFDbEQsUUFBSSxvQkFBb0IsRUFBRTtBQUN4QixVQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7QUFDckIsVUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7O0FBRTVCLGFBQU87S0FDUjs7QUFFRCxRQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLENBQUMsY0FBYyxFQUFFOztBQUU5QyxTQUFHLEdBQUc7O0FBRUosT0FBQyxPQUFPLElBQUksQ0FBQyxRQUFRLEVBQUUsS0FBSyxRQUFRLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO0tBQ2hILE1BQU07QUFDTCxTQUFHLEdBQUcsQ0FDSixDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUNsQixDQUFDO0tBQ0g7O0FBRUQsUUFBSSxDQUFDLEtBQUssR0FBRyxZQUFZLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQztBQUM5QyxRQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQzs7QUFFOUIsUUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRTtBQUN2RCxVQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxtQkFBbUIsRUFBRSxVQUFTLE1BQU0sRUFBRTtBQUM5RCxhQUFLLENBQUMsS0FBSyxHQUFHLFlBQVksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDO0FBQ2hELGFBQUssQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUM7T0FDN0IsQ0FBQyxDQUFDO0tBQ0osTUFBTTtBQUNMLFVBQUksQ0FBQyxLQUFLLEdBQUcsWUFBWSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUM7QUFDL0MsVUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUMxQjtHQUNGO0NBQ0YsQ0FBQzs7QUFFRixVQUFVLENBQUMsU0FBUyxDQUFDLGFBQWEsR0FBRyxZQUFXO0FBQzlDLE1BQUksQ0FBQyxLQUFLLEdBQUcsWUFBWSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUM7QUFDL0MsTUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO0NBQ3RCLENBQUM7O0FBRUYsVUFBVSxDQUFDLFNBQVMsQ0FBQyxhQUFhLEdBQUcsVUFBUyxNQUFNLEVBQUU7QUFDcEQsTUFBSSxJQUFJLENBQUMsS0FBSyxLQUFLLFlBQVksQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFO0FBQ3BELFdBQU87R0FDUjs7QUFFRCxNQUFJLE1BQU0sS0FBSyxLQUFLLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLEtBQUssSUFBSSxFQUFFO0FBQ2pFLFFBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzdDLFFBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztBQUNiLFFBQUksQ0FBQyxLQUFLLEdBQUcsWUFBWSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUM7QUFDOUMsUUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQztHQUU1QixNQUFNO0FBQ0wsUUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO0FBQ2IsUUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7QUFDckIsUUFBSSxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQUM7QUFDM0IsUUFBSSxDQUFDLEtBQUssR0FBRyxZQUFZLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQztBQUM3QyxRQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO0dBQzNCO0NBQ0YsQ0FBQzs7Ozs7O0FBTUYsVUFBVSxDQUFDLFNBQVMsQ0FBQyxrQkFBa0IsR0FBRyxZQUFXO0FBQ25ELE1BQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDO0NBQzNCLENBQUM7Ozs7Ozs7QUFPRixVQUFVLENBQUMsU0FBUyxDQUFDLGdCQUFnQixHQUFHLFlBQVc7QUFDakQsU0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDO0NBQzNCLENBQUM7O0FBRUYsVUFBVSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsWUFBVztBQUN6QyxTQUFPLElBQUksQ0FBQyxPQUFPLENBQUM7Q0FDckIsQ0FBQzs7QUFFRixVQUFVLENBQUMsU0FBUyxDQUFDLFNBQVMsR0FBRyxZQUFXO0FBQzFDLFNBQU8sSUFBSSxDQUFDLEtBQUssS0FBSyxZQUFZLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQztDQUN4RCxDQUFDOzs7Ozs7Ozs7OEJDMU91QyxzQkFBc0I7OzRCQUN2QyxvQkFBb0I7OzRCQUN4QixvQkFBb0I7O2lDQVFqQywwQkFBMEI7O3VCQUNrQixjQUFjOztrQ0FDaEMsc0JBQXNCOztBQUV2RCxJQUFJLGtCQUFrQixHQUFHLHVDQUFtQixTQUFTLENBQUMsTUFBTSxFQUFFLENBQUM7Ozs7Ozs7O0FBUS9ELGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxJQUFJLEdBQUcsWUFBVztBQUM3Qyx5Q0FBbUIsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDOztBQUV6RCxNQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztBQUNsQixNQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQztDQUNuQixDQUFDOztBQUVGLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxjQUFjLEdBQUcsWUFBVztBQUN2RCx5Q0FBbUIsU0FBUyxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDOztBQUVuRSxtQ0FBUyxJQUFJLENBQUMsV0FBVyxFQUFFLG9CQUFvQixDQUFDLENBQUM7QUFDakQsbUNBQVMsSUFBSSxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsYUFBYSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0NBQ2xHLENBQUM7O0FBRUYsSUFBSSxPQUFPLEdBQUcsS0FBSyxDQUFDO0FBQ3BCLFNBQVMsZUFBZSxDQUFDLEtBQUssRUFBRTtBQUM5QixTQUFPLEdBQUcsS0FBSyxDQUFDO0FBQ2hCLE1BQUksTUFBTSxHQUFHLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQzs7QUFFcEMsTUFBSSxxQ0FBZ0IsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEtBQUssQ0FBQyxPQUFPLEtBQUssMEJBQVUsU0FBUyxJQUN6RSxLQUFLLENBQUMsT0FBTyxLQUFLLDBCQUFVLE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxLQUFLLDBCQUFVLE1BQU0sRUFBRTtBQUMxRSxRQUFJLFVBQVUsR0FBRyxDQUFDLENBQUM7OztBQUduQixRQUFJLEtBQUssQ0FBQyxPQUFPLEtBQUssMEJBQVUsQ0FBQyxLQUFLLEtBQUssQ0FBQyxPQUFPLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQSxBQUFDLEVBQUU7QUFDckUsYUFBTztLQUNSO0FBQ0QsUUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsRUFBRTtBQUN0QixnQkFBVSxJQUFJLEVBQUUsQ0FBQztLQUNsQjs7QUFFRCxRQUFJLE1BQU0sQ0FBQyxRQUFRLEVBQUU7QUFDbkIsWUFBTSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsWUFBVztBQUNyRCxjQUFNLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDM0MsZUFBTyxHQUFHLElBQUksQ0FBQztPQUNoQixFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUM7S0FDakI7R0FDRjtDQUNGOztBQUVELGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxPQUFPLEdBQUcsWUFBVztBQUNoRCxNQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxlQUFlLEVBQUUsZUFBZSxDQUFDLENBQUM7QUFDeEQseUNBQW1CLFNBQVMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQztDQUM3RCxDQUFDOztBQUVGLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxJQUFJLEdBQUcsWUFBVzs7QUFFN0MsTUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsUUFBUSxHQUFHLE1BQU0sQ0FBQztBQUM3Qyx5Q0FBbUIsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ3pELE1BQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7O0FBRXpDLE1BQUksY0FBYyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLENBQUM7QUFDakQsTUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBQ2hCLE1BQUksWUFBWSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsWUFBWSxLQUFLLEtBQUssQ0FBQyxHQUFHLElBQUksR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FBQzs7QUFFekcsTUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsVUFBVSxHQUFHLFNBQVMsQ0FBQztBQUMzQyxNQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7O0FBRWIsZ0JBQWMsQ0FBQyxjQUFjLENBQUM7QUFDNUIsYUFBUyxFQUFFLFlBQVksR0FBRyxDQUFDLG1DQUFXLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7QUFDbEUsU0FBSyxFQUFFLFlBQVksR0FBRyxtQ0FBVyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsMkNBQW1CLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQztBQUNsRixpQkFBYSxFQUFFLHVCQUFTLEVBQUUsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUU7QUFDakQsVUFBSSxhQUFhLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsc0JBQXNCLEtBQUssSUFBSTtVQUM1RSxZQUFZO1VBQ1osS0FBSztVQUNMLEtBQUssR0FBRyw2QkFBVSxLQUFLLENBQUMsQ0FBQzs7QUFFM0IsVUFBSSxLQUFLLEVBQUU7QUFDVCxvQkFBWSxHQUFHLGFBQWEsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQzs7QUFFakgsWUFBSSxZQUFZLElBQUksQ0FBQyxDQUFDLEVBQUU7QUFDdEIsZUFBSyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDdEQsWUFBRSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxVQUFVLEdBQUcsS0FBSyxHQUFHLFdBQVcsQ0FBQyxDQUFDO1NBQ3ZFO09BQ0Y7S0FDRjtBQUNELGtCQUFjLEVBQUUsSUFBSTtBQUNwQixrQkFBYyxFQUFFLHdCQUFTLEtBQUssRUFBRSxHQUFHLEVBQUU7O0FBRW5DLFVBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxNQUFNLENBQUM7O0FBRXpELFVBQUksVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFO0FBQ25CLGFBQUssR0FBRyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7T0FDekI7O0FBRUQsYUFBTyxZQUFZLEdBQUcsS0FBSyxHQUFHLEtBQUssR0FBRyxFQUFFLENBQUM7S0FDMUM7R0FDRixDQUFDLENBQUM7OztBQUdILE1BQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsZUFBZSxDQUFDLEdBQUcsMkNBQW1CLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQzs7QUFFeEcsTUFBSSxPQUFPLEVBQUU7QUFDWCxXQUFPLEdBQUcsS0FBSyxDQUFDO0dBQ2pCOztBQUVELE1BQUksQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxDQUFDLFlBQVc7QUFDbkQsUUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0dBQ3hDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUNSLENBQUM7O0FBRUYsa0JBQWtCLENBQUMsU0FBUyxDQUFDLEtBQUssR0FBRyxZQUFXO0FBQzlDLHlDQUFtQixTQUFTLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7Q0FDM0QsQ0FBQztBQUNGLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxZQUFZLEdBQUcsVUFBUyxLQUFLLEVBQUU7QUFDMUQsTUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7O0FBRW5CLE1BQUksT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sSUFBSSxVQUFVLEVBQUU7QUFDbkQsUUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDOztBQUVoQixRQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsVUFBUyxPQUFPLEVBQUU7QUFDbEQsVUFBSSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxDQUFDO0tBQ2pDLENBQUMsQ0FBQztHQUVKLE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLEVBQUU7O0FBRXBELFFBQUksT0FBTyxDQUFDOztBQUVaLFFBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEtBQUssS0FBSyxFQUFFO0FBQ2xELGFBQU8sR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQztLQUN0QyxNQUFNOztBQUVMLFVBQUksc0JBQXNCLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxzQkFBc0IsS0FBSyxJQUFJLENBQUM7QUFDakYsVUFBSSxjQUFjLEdBQUcsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDOztBQUV6QyxhQUFPLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFVBQVMsTUFBTSxFQUFFOztBQUUzRCxZQUFJLHNCQUFzQixFQUFFO0FBQzFCLGlCQUFPLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7U0FDcEMsTUFBTTtBQUNMLGlCQUFPLE1BQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7U0FDM0Q7T0FFRixDQUFDLENBQUM7S0FDSjs7QUFFRCxRQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDLENBQUM7R0FFakMsTUFBTTtBQUNMLFFBQUksQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsQ0FBQztHQUM1QjtDQUVGLENBQUM7O0FBRUYsa0JBQWtCLENBQUMsU0FBUyxDQUFDLGlCQUFpQixHQUFHLFVBQVMsT0FBTyxFQUFFO0FBQ2pFLE1BQUksR0FBRyxHQUFHLHlDQUFpQixJQUFJLENBQUMsUUFBUSxDQUFDO01BQ3ZDLE1BQU0sR0FBRyxnREFBd0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDOztBQUVsRCxNQUFJLGdCQUFnQixHQUFHLGtCQUFrQixDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEVBQUUsT0FBTyxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsc0JBQXNCLENBQUMsQ0FBQztBQUNoSSxNQUFJLGNBQWMsQ0FBQzs7O0FBR25CLE1BQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLElBQUksS0FBSyxFQUFFO0FBQ3ZDLFFBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQztBQUNoQixTQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxZQUFZLEdBQUcsZ0JBQWdCLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxZQUFZLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDN0UsWUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQzNDO0FBQ0Qsa0JBQWMsR0FBRyxDQUFDLENBQUM7QUFDbkIsV0FBTyxHQUFHLE1BQU0sQ0FBQztHQUNsQixNQUFNO0FBQ0wsa0JBQWMsR0FBRyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztHQUN0Qzs7O0FBR0QsTUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7QUFDdkIsTUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMseUJBQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7O0FBRXpDLE1BQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDOztBQUU1QixNQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxLQUFLLElBQUksRUFBRTtBQUN2QyxRQUFJLENBQUMsMkJBQTJCLENBQUMsY0FBYyxDQUFDLENBQUM7R0FDbEQ7O0FBRUQsTUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQztBQUN2QixNQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxDQUFDO0FBQ3RCLDJDQUFpQixJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsRUFBRyxHQUFHLElBQUksTUFBTSxHQUFHLE1BQU0sR0FBRyxLQUFLLENBQUMsQ0FBRSxDQUFDO0NBQ3pFLENBQUM7O0FBRUYsa0JBQWtCLENBQUMsU0FBUyxDQUFDLG9CQUFvQixHQUFHLFlBQVc7QUFDN0QsTUFBSSxvQkFBb0IsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsR0FBRywyQ0FBbUIsR0FBRyxDQUFDLENBQUM7QUFDbEYsTUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLEtBQUssS0FBSyxDQUFDLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDOztBQUV6RyxNQUFJLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQztBQUMzQixVQUFNLEVBQUUsSUFBSSxDQUFDLGlCQUFpQixFQUFFO0FBQ2hDLFNBQUssRUFBRSxZQUFZLEdBQUcsS0FBSyxDQUFDLEdBQUcsb0JBQW9CO0dBQ3BELENBQUMsQ0FBQzs7QUFFSCxNQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLGtDQUFrQyxFQUFFLENBQUM7Q0FDcEUsQ0FBQzs7QUFFRixrQkFBa0IsQ0FBQyxTQUFTLENBQUMsYUFBYSxHQUFHLFVBQVMsb0JBQW9CLEVBQUU7QUFDMUUsTUFBSSxDQUFDLG9CQUFvQixFQUFFO0FBQ3pCLFFBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLGVBQWUsRUFBRSxlQUFlLENBQUMsQ0FBQztHQUM1RDtBQUNELHlDQUFtQixTQUFTLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7Q0FDbkUsQ0FBQzs7QUFFRixrQkFBa0IsQ0FBQyxTQUFTLENBQUMsMkJBQTJCLEdBQUcsVUFBUyxLQUFLLEVBQUU7QUFDekUsTUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7QUFDN0IsUUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO0dBQ3BDLE1BQU07QUFDTCxRQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxDQUFDO0dBQzlCO0NBQ0YsQ0FBQzs7Ozs7Ozs7O0FBU0Ysa0JBQWtCLENBQUMsZUFBZSxHQUFHLFVBQVMsS0FBSyxFQUFFLE9BQU8sRUFBRSxhQUFhLEVBQUU7O0FBRTNFLE1BQUksZ0JBQWdCLEdBQUcsRUFBRTtNQUN2QixXQUFXO01BQUUsV0FBVyxHQUFHLEtBQUssQ0FBQyxNQUFNO01BQ3ZDLFVBQVU7TUFBRSxTQUFTO01BQUUsTUFBTSxHQUFHLEVBQUU7TUFDbEMsQ0FBQztNQUFFLFlBQVksQ0FBQzs7QUFFbEIsTUFBSSxXQUFXLEtBQUssQ0FBQyxFQUFFO0FBQ3JCLFNBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxZQUFZLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsWUFBWSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ2hFLFlBQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDaEI7QUFDRCxXQUFPLE1BQU0sQ0FBQztHQUNmOztBQUVELE9BQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxZQUFZLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsWUFBWSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ2hFLGVBQVcsR0FBRyw2QkFBVSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7QUFFcEMsUUFBSSxhQUFhLEVBQUU7QUFDakIsZ0JBQVUsR0FBRyxXQUFXLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQ3pDLE1BQU07QUFDTCxnQkFBVSxHQUFHLFdBQVcsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7S0FDckU7O0FBR0QsUUFBSSxVQUFVLElBQUksQ0FBQyxDQUFDLEVBQUU7QUFDcEIsZUFBUztLQUNWO0FBQ0QsYUFBUyxHQUFHLFdBQVcsQ0FBQyxNQUFNLEdBQUcsVUFBVSxHQUFHLFdBQVcsQ0FBQzs7QUFFMUQsb0JBQWdCLENBQUMsSUFBSSxDQUFDO0FBQ3BCLGVBQVMsRUFBRSxDQUFDO0FBQ1osV0FBSyxFQUFFLFVBQVU7QUFDakIsZUFBUyxFQUFFLFNBQVM7QUFDcEIsV0FBSyxFQUFFLFdBQVc7S0FDbkIsQ0FBQyxDQUFDO0dBQ0o7O0FBRUQsa0JBQWdCLENBQUMsSUFBSSxDQUFDLFVBQVMsQ0FBQyxFQUFFLENBQUMsRUFBRTs7QUFFbkMsUUFBSSxDQUFDLENBQUMsS0FBSyxLQUFLLENBQUMsQ0FBQyxFQUFFO0FBQ2xCLGFBQU8sQ0FBQyxDQUFDLENBQUM7S0FDWDtBQUNELFFBQUksQ0FBQyxDQUFDLEtBQUssS0FBSyxDQUFDLENBQUMsRUFBRTtBQUNsQixhQUFPLENBQUMsQ0FBQztLQUNWOztBQUVELFFBQUksQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFO0FBQ3JCLGFBQU8sQ0FBQyxDQUFDLENBQUM7S0FDWCxNQUFNLElBQUksQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFO0FBQzVCLGFBQU8sQ0FBQyxDQUFDO0tBQ1YsTUFBTSxJQUFJLENBQUMsQ0FBQyxLQUFLLEtBQUssQ0FBQyxDQUFDLEtBQUssRUFBRTtBQUM5QixVQUFJLENBQUMsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDLFNBQVMsRUFBRTtBQUM3QixlQUFPLENBQUMsQ0FBQyxDQUFDO09BQ1gsTUFBTSxJQUFJLENBQUMsQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDLFNBQVMsRUFBRTtBQUNwQyxlQUFPLENBQUMsQ0FBQztPQUNWLE1BQU07QUFDTCxlQUFPLENBQUMsQ0FBQztPQUNWO0tBQ0Y7R0FDRixDQUFDLENBQUM7O0FBRUgsT0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLFlBQVksR0FBRyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLFlBQVksRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUN6RSxVQUFNLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0dBQzVDOztBQUVELFNBQU8sTUFBTSxDQUFDO0NBQ2YsQ0FBQzs7QUFFRixrQkFBa0IsQ0FBQyxTQUFTLENBQUMsaUJBQWlCLEdBQUcsWUFBVztBQUMxRCxNQUFJLGNBQWMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDdkUsTUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUM7O0FBRW5ELFNBQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLElBQUksWUFBWSxHQUFHLFlBQVksR0FBRyxjQUFjLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsY0FBYyxHQUFHLENBQUMsQ0FBQztDQUN2SCxDQUFDOztBQUVGLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyx3QkFBd0IsR0FBRyxVQUFTLE9BQU8sRUFBRTtBQUN4RSxNQUFJLFFBQVEsR0FBRyxFQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLGdCQUFnQixFQUFFLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUMsQ0FBQztBQUN4RyxNQUFJLE9BQU8sR0FBRyxLQUFLLENBQUM7O0FBRXBCLE1BQUksT0FBTyxLQUFLLDBCQUFVLFVBQVUsSUFBSSxRQUFRLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLEdBQUcsQ0FBQyxFQUFFO0FBQ3BGLFdBQU8sR0FBRyxJQUFJLENBQUM7R0FDaEI7QUFDRCxNQUFJLE9BQU8sS0FBSywwQkFBVSxRQUFRLElBQUksUUFBUSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsRUFBRTtBQUN2RCxXQUFPLEdBQUcsSUFBSSxDQUFDO0dBQ2hCOztBQUVELFNBQU8sT0FBTyxDQUFDO0NBQ2hCLENBQUM7O1FBRU0sa0JBQWtCLEdBQWxCLGtCQUFrQjs7QUFFMUIsNkJBQWUsY0FBYyxFQUFFLGtCQUFrQixDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O3VCQ3BVdEIsY0FBYzs7MEJBQ2xCLGVBQWU7O2lDQUNqQiwwQkFBMEI7Ozs7Ozs7O0lBUTNDLGNBQWM7WUFBZCxjQUFjOztXQUFkLGNBQWM7MEJBQWQsY0FBYzs7K0JBQWQsY0FBYzs7O2VBQWQsY0FBYzs7V0FDTix3QkFBRztBQUNiLFVBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLHdCQUF3QixDQUFDLENBQUM7O0FBRS9ELFVBQUksQ0FBQyxpQ0FBUyxRQUFRLEVBQUUsWUFBWSxDQUFDLEVBQUU7QUFDckMsZ0JBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztPQUNsQjtLQUNGOzs7V0FFWSx5QkFBRyxFQUFFOzs7V0FDZCxnQkFBRyxFQUFFOzs7V0FDTCxnQkFBRyxFQUFFOzs7V0FDSixpQkFBRyxFQUFFOzs7V0FDRixvQkFBRyxFQUFFOzs7V0FDTCxvQkFBRyxFQUFFOzs7V0FDUixpQkFBRyxFQUFFOzs7U0FmTixjQUFjOzs7UUFrQlosY0FBYyxHQUFkLGNBQWM7O0FBRXRCLDZCQUFlLFVBQVUsRUFBRSxjQUFjLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpQ0M5QlAsMEJBQTBCOzs2QkFDckMscUJBQXFCOzs0QkFDbkIsbUJBQW1COzt1QkFDTixjQUFjOzs4QkFDOUIsc0JBQXNCOzsrQkFDaEIsd0JBQXdCOzswQkFDN0IsY0FBYzs7c0JBQ3BCLFFBQVE7Ozs7dUJBQ1AsU0FBUzs7OztBQUc3QixZQUFZLENBQUMsT0FBTyxHQUFHLFlBQVksQ0FBQyxPQUFPLElBQUksRUFBRSxDQUFDO0FBQ2xELFlBQVksQ0FBQyxPQUFPLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQzs7Ozs7Ozs7O0lBUXZDLFVBQVU7WUFBVixVQUFVOzs7Ozs7QUFJSCxXQUpQLFVBQVUsQ0FJRixXQUFXLEVBQUU7MEJBSnJCLFVBQVU7O0FBS1osK0JBTEUsVUFBVSw2Q0FLTixXQUFXLEVBQUU7O0FBRW5CLFFBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO0FBQ3hCLFFBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDO0FBQ3ZCLFFBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDO0FBQzVCLFFBQUksQ0FBQyxpQkFBaUIsR0FBRyxZQUFZLENBQUM7QUFDdEMsUUFBSSxDQUFDLFlBQVksR0FBRyxLQUFLLENBQUM7QUFDMUIsUUFBSSxDQUFDLGVBQWUsR0FBRyxLQUFLLENBQUM7R0FDOUI7O2VBYkcsVUFBVTs7V0FlVixnQkFBRzs7O0FBQ0wsVUFBSSwwQkFBYSxLQUFLLFVBQVUsRUFBRTtBQUNoQyxjQUFNLElBQUksS0FBSyxDQUFDLGdEQUFnRCxDQUFDLENBQUM7T0FDbkU7O0FBRUQsVUFBSSwyQkFBYyxLQUFLLFVBQVUsRUFBRTtBQUNqQyxjQUFNLElBQUksS0FBSyxDQUFDLDhDQUE4QyxDQUFDLENBQUM7T0FDakU7QUFDRCxpQ0F2QkUsVUFBVSxzQ0F1QkM7QUFDYixVQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxjQUFjLEVBQUUsWUFBTTtBQUMxQyxjQUFLLGVBQWUsR0FBRyxJQUFJLENBQUM7QUFDNUIsY0FBSyxlQUFlLEVBQUUsQ0FBQztPQUN4QixDQUFDLENBQUM7S0FDSjs7Ozs7OztXQUthLDBCQUFHO0FBQ2YsaUNBbENFLFVBQVUsZ0RBa0NXOztBQUV2QixVQUFJLENBQUMsVUFBVSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDaEQsVUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQztBQUM3QyxVQUFJLENBQUMsZUFBZSxDQUFDLFFBQVEsR0FBRyxVQUFVLENBQUM7QUFDM0MsVUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0FBQzdCLFVBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztBQUM5QixVQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7O0FBRW5DLHVDQUFTLElBQUksQ0FBQyxVQUFVLEVBQUUsb0JBQW9CLENBQUMsQ0FBQztBQUNoRCxjQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7O0FBRTNDLFVBQUksQ0FBQyxXQUFXLEdBQUcseUJBQVksSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUMsQ0FBQztBQUMzRCxVQUFNLFlBQVksR0FBRywrQkFBaUIsSUFBSSxDQUFDLENBQUM7Ozs7O0FBSzVDLGtCQUFZLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxXQUFXLEVBQUUsVUFBQyxLQUFLO2VBQUssc0NBQWdCLEtBQUssQ0FBQztPQUFBLENBQUMsQ0FBQztBQUMvRixVQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7S0FDdkI7Ozs7Ozs7V0FLYywyQkFBRztBQUNoQixVQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sRUFBRSxDQUFDO0tBQzVCOzs7Ozs7Ozs7Ozs7OztXQVlNLGlCQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxhQUFhLEVBQUUsY0FBYyxFQUFFO0FBQ3pELFVBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO0FBQ3JCLGlDQTNFRSxVQUFVLHlDQTJFRSxHQUFHLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsYUFBYSxFQUFFLGNBQWMsRUFBRTtLQUNsRTs7Ozs7Ozs7O1dBT0csZ0JBQWU7VUFBZCxLQUFLLHlEQUFHLElBQUk7O0FBQ2YsaUNBcEZFLFVBQVUsc0NBb0ZDO0FBQ2IsVUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUM1Qjs7Ozs7OztXQUtJLGlCQUFHOzs7QUFDTixVQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztBQUNyQixVQUFJLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxZQUFNO0FBQzlDLGVBQUssUUFBUSxDQUFDLFNBQVMsQ0FBQyxjQUFjLEVBQUUsQ0FBQztPQUMxQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7O0FBRVAsaUNBakdFLFVBQVUsdUNBaUdFO0tBQ2Y7Ozs7Ozs7O1dBTVkseUJBQXdDO1VBQXZDLFdBQVcseURBQUcsS0FBSztVQUFFLFFBQVEseURBQUcsS0FBSzs7QUFDakQsVUFBSSxXQUFXLEVBQUU7OztBQUVmLFlBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUM7O0FBRS9CLFlBQUksS0FBSyxLQUFLLEtBQUssQ0FBQyxFQUFFO0FBQ3BCLGNBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDdEI7T0FDRjtBQUNELFVBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztBQUN0QixpQ0FsSEUsVUFBVSwrQ0FrSFEsV0FBVyxFQUFFLFFBQVEsRUFBRTtLQUM1Qzs7Ozs7Ozs7O1dBT2Esd0JBQUMsS0FBSyxFQUFFO0FBQ3BCLFVBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDLENBQUM7O0FBRXBELFVBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMscUJBQXFCLEVBQUUsQ0FBQztBQUM3QyxVQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsaUJBQWlCLENBQUM7QUFDMUUsVUFBSSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBQ2pELFVBQUksT0FBTyxZQUFBLENBQUM7QUFDWixVQUFJLFdBQVcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztBQUNuRCxVQUFJLE1BQU0sR0FBRyxLQUFLLEdBQUcsK0JBQVUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEtBQUssQ0FBQzs7QUFFdEQsVUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLEdBQUcsQUFBQyxNQUFNLENBQUMsV0FBVyxHQUFHLE1BQU0sQ0FBQyxHQUFHLEdBQUcsb0NBQVksSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFJLElBQUksQ0FBQztBQUMzRixVQUFJLENBQUMsZUFBZSxDQUFDLElBQUksR0FBRyxBQUFDLE1BQU0sQ0FBQyxXQUFXLEdBQUcsTUFBTSxDQUFDLElBQUksR0FBSSxJQUFJLENBQUM7O0FBRXRFLFVBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxHQUFHLFlBQVcsRUFBRSxDQUFDO0FBQy9DLHNCQUFnQixDQUFDLE1BQU0sR0FBRyxVQUFVLENBQUM7O0FBRXJDLFVBQUksSUFBSSxDQUFDLGFBQWEsRUFBRTtBQUN0QixlQUFPLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQzs7QUFFN0IsWUFBSSx5QkFBTyxPQUFPLEVBQUUsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFO0FBQy9DLGNBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLHlCQUFPLE9BQU8sRUFBRSxVQUFVLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztTQUMvRDtBQUNELFlBQUksQ0FBQyxNQUFNLElBQUksQ0FBQyxXQUFXLEVBQUU7QUFDM0IsY0FBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUNuQjtPQUVGLE1BQU07QUFDTCxZQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsV0FBVyxFQUFFO0FBQ25DLGlCQUFPLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUM7O0FBRTFDLDBCQUFnQixDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUM7O0FBRXZDLGNBQUkseUJBQU8sT0FBTyxFQUFFLFVBQVUsRUFBRSxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRTtBQUMvQyxnQkFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMseUJBQU8sT0FBTyxFQUFFLFVBQVUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1dBQy9EOztBQUVELGNBQUksQ0FBQyxNQUFNLElBQUksQ0FBQyxXQUFXLEVBQUU7QUFDM0IsZ0JBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7V0FDbkI7U0FDRixNQUFNOzs7QUFHTCxjQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRSxDQUFDO1NBQzlCO09BQ0Y7O0FBRUQsVUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO0FBQ3ZDLFVBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLENBQUM7S0FDekI7Ozs7Ozs7V0FLYSwwQkFBRztBQUNmLFVBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztBQUN0QyxVQUFJLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxDQUFDO0tBQ3pCOzs7Ozs7Ozs7V0FPa0IsK0JBQUc7OztBQUNwQixVQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO0FBQzVCLFVBQUksT0FBTyxHQUFHLEVBQUUsQ0FBQzs7QUFFakIsVUFBSSxJQUFJLENBQUMsY0FBYyxJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsZ0JBQWdCLEVBQUU7QUFDL0QsdUNBQVcsT0FBTyxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztPQUMzRDtBQUNELFVBQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUM7QUFDdEMsVUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQzs7QUFFcEMsYUFBTyxDQUFDLEtBQUssR0FBRyxPQUFPLENBQUM7QUFDeEIsYUFBTyxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7QUFDMUIsYUFBTyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO0FBQ3BDLGFBQU8sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQ3RCLGFBQU8sQ0FBQyxNQUFNLEdBQUcsT0FBTyxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsaUJBQWlCLENBQUM7QUFDMUQsYUFBTyxDQUFDLFVBQVUsR0FBRyxPQUFPLENBQUMsVUFBVSxJQUFJLEtBQUssQ0FBQztBQUNqRCxhQUFPLENBQUMsUUFBUSxHQUFHLFVBQUMsT0FBTyxFQUFLO0FBQzlCLFlBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDLEVBQUU7QUFDN0IsaUJBQU8sR0FBRyx5QkFBTyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBSyxjQUFjLENBQUMsVUFBVSxJQUFJLE9BQUssaUJBQWlCLENBQUMsQ0FBQztTQUM1RjtBQUNELGVBQUssUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ3ZCLGVBQUssY0FBYyxFQUFFLENBQUM7O0FBRXRCLFlBQUksWUFBWSxFQUFFO0FBQ2hCLHNCQUFZLEVBQUUsQ0FBQztTQUNoQjtPQUNGLENBQUM7QUFDRixhQUFPLENBQUMsT0FBTyxHQUFHLFlBQU07QUFDdEIsWUFBSSxDQUFDLE9BQUssZUFBZSxFQUFFO0FBQ3pCLGlCQUFLLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUMzQjtBQUNELFlBQUksV0FBVyxFQUFFO0FBQ2YscUJBQVcsRUFBRSxDQUFDO1NBQ2Y7T0FDRixDQUFDOztBQUVGLGFBQU8sT0FBTyxDQUFDO0tBQ2hCOzs7U0E5TkcsVUFBVTs7O1FBaU9SLFVBQVUsR0FBVixVQUFVOztBQUVsQiw2QkFBZSxNQUFNLEVBQUUsVUFBVSxDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O3VCQ3hQSyxjQUFjOztrQ0FDckIsc0JBQXNCOzs7Ozs7Ozs7SUFTakQsY0FBYztZQUFkLGNBQWM7O1dBQWQsY0FBYzswQkFBZCxjQUFjOzsrQkFBZCxjQUFjOzs7ZUFBZCxjQUFjOztXQUNYLGlCQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxhQUFhLEVBQUUsY0FBYyxFQUFFO0FBQ3pELGlDQUZFLGNBQWMseUNBRUYsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLGFBQWEsRUFBRSxjQUFjLEVBQUU7QUFDakUsVUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO0FBQ25DLFVBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztLQUNuQzs7O1NBTEcsY0FBYzs7O0FBUXBCLFlBQVksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLGdCQUFnQixFQUFFLFVBQVMsS0FBSyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFO0FBQ3pFLE1BQUksUUFBUSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDOztBQUUxQyxNQUFJLFFBQVEsQ0FBQyxNQUFNLEtBQUssWUFBWSxDQUFDLE9BQU8sQ0FBQyxjQUFjLEVBQUU7QUFDM0QsUUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLEtBQUssQ0FBQyxFQUFFO0FBQzlCLGNBQVEsQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO0FBQ3hCLGNBQVEsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO0tBQ3hCO0dBQ0Y7Q0FDRixDQUFDLENBQUM7O1FBRUssY0FBYyxHQUFkLGNBQWM7O0FBRXRCLDZCQUFlLFVBQVUsRUFBRSxjQUFjLENBQUMsQ0FBQzs7Ozs7Ozs7OzhCQzlCbkIsc0JBQXNCOzs2QkFDekIscUJBQXFCOztpQ0FDWCwwQkFBMEI7OytCQUNhLHdCQUF3Qjs7dUJBQ3RELGNBQWM7OzBCQUM3QixjQUFjOztBQUV2QyxJQUFJLGtCQUFrQixHQUFHLHVCQUFXLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQzs7Ozs7Ozs7QUFTdkQsa0JBQWtCLENBQUMsU0FBUyxDQUFDLGNBQWMsR0FBRyxZQUFXO0FBQ3ZELHlCQUFXLFNBQVMsQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQzs7QUFFM0QsTUFBSSxHQUFHLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN4QyxLQUFHLENBQUMsU0FBUyxHQUFHLG9CQUFvQixDQUFDO0FBQ3JDLE1BQUksQ0FBQyxlQUFlLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDOztBQUV0QyxNQUFJLENBQUMsV0FBVyxHQUFHLEdBQUcsQ0FBQztBQUN2QixNQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7Q0FDcEIsQ0FBQzs7QUFFRixrQkFBa0IsQ0FBQyxTQUFTLENBQUMsT0FBTyxHQUFHLFVBQVMsRUFBRSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxjQUFjLEVBQUU7O0FBRXpGLHlCQUFXLFNBQVMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQzs7QUFFcEQsTUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDO0FBQ2xCLE1BQUksT0FBTyxHQUFHO0FBQ1osYUFBUyxFQUFFLENBQUM7QUFDWixhQUFTLEVBQUUsQ0FBQztBQUNaLFdBQU8sRUFBRSxDQUFDO0FBQ1YsV0FBTyxFQUFFLENBQUM7QUFDVixhQUFTLEVBQUUsU0FBUztBQUNwQixhQUFTLEVBQUUsS0FBSztBQUNoQixrQkFBYyxFQUFFLEtBQUs7QUFDckIsZUFBVyxFQUFFLEtBQUs7QUFDbEIsWUFBUSxFQUFFLElBQUk7QUFDZCxjQUFVLEVBQUUsS0FBSztBQUNqQix3QkFBb0IsRUFBRSxnQ0FBVztBQUMvQixVQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7OztBQUc1QixVQUFJLEtBQUssS0FBSyxLQUFLLENBQUMsRUFBRTtBQUNwQixjQUFNLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO09BQ3hCO0FBQ0QsWUFBTSxDQUFDLFFBQVEsQ0FBQyxhQUFhLEVBQUUsQ0FBQztLQUNqQztHQUNGLENBQUM7O0FBRUYsTUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLFlBQVksRUFBRTtBQUNwQywrQkFBTyxPQUFPLEVBQUUsY0FBYyxDQUFDLFlBQVksQ0FBQyxDQUFDO0dBQzlDO0FBQ0QsTUFBSSxDQUFDLFNBQVMsR0FBRyxPQUFPLENBQUM7Q0FDMUIsQ0FBQzs7QUFFRixJQUFJLGVBQWUsR0FBRyxTQUFsQixlQUFlLENBQVksS0FBSyxFQUFFO0FBQ3BDLE1BQUksb0RBQThCLEtBQUssQ0FBQyxFQUFFO0FBQ3hDLFdBQU87R0FDUjtBQUNELE1BQUksTUFBTSxHQUFHLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQzs7QUFFcEMsTUFBSSxRQUFRLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQzs7QUFFN0MsTUFBSSxXQUFXLENBQUM7O0FBRWhCLE1BQUksS0FBSyxDQUFDLE9BQU8sSUFBSSwwQkFBVSxVQUFVLEVBQUU7QUFDekMsUUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsRUFBRTtBQUMzQixpQkFBVyxHQUFHLENBQUMsQ0FBQztLQUNqQixNQUFNO0FBQ0wsVUFBSSxXQUFXLEdBQUcsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzVDLFVBQUksT0FBTyxHQUFHLFFBQVEsQ0FBQyxTQUFTLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDdkMsaUJBQVcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxXQUFXLEdBQUcsQ0FBQyxDQUFDLENBQUM7S0FDbEQ7R0FDRixNQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sSUFBSSwwQkFBVSxRQUFRLEVBQUU7QUFDOUMsUUFBSSxRQUFRLENBQUMsV0FBVyxFQUFFLEVBQUU7QUFDMUIsVUFBSSxXQUFXLEdBQUcsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzVDLGlCQUFXLEdBQUcsV0FBVyxHQUFHLENBQUMsQ0FBQztLQUMvQjtHQUNGOztBQUVELE1BQUksV0FBVyxLQUFLLEtBQUssQ0FBQyxFQUFFO0FBQzFCLFFBQUksV0FBVyxHQUFHLENBQUMsRUFBRTtBQUNuQixjQUFRLENBQUMsWUFBWSxFQUFFLENBQUM7S0FDekIsTUFBTTtBQUNMLGNBQVEsQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDO0tBQ3JDO0FBQ0QsUUFBSSxRQUFRLENBQUMsT0FBTyxFQUFFLENBQUMsTUFBTSxFQUFFO0FBQzdCLFdBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztBQUN2QixxREFBeUIsS0FBSyxDQUFDLENBQUM7O0FBRWhDLFlBQU0sQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUM7QUFDekIsWUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztLQUN6QjtHQUNGO0NBQ0YsQ0FBQzs7QUFFRixrQkFBa0IsQ0FBQyxTQUFTLENBQUMsSUFBSSxHQUFHLFlBQVc7O0FBRTdDLE1BQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLGVBQWUsRUFBRSxlQUFlLENBQUMsQ0FBQzs7QUFFeEQseUJBQVcsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDOztBQUVqRCxNQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7QUFDakIsUUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsQ0FBQztHQUN6QjtBQUNELE1BQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxZQUFZLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7O0FBRW5FLE1BQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEVBQUU7QUFDOUIsUUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQy9CLFFBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLFVBQVUsR0FBRyxRQUFRLENBQUM7R0FDM0MsTUFBTTtBQUNMLFFBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxFQUFFLENBQUM7QUFDN0IsUUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsVUFBVSxHQUFHLFNBQVMsQ0FBQztHQUM1Qzs7QUFFRCwyQ0FBaUIsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7Q0FDaEUsQ0FBQzs7QUFFRixrQkFBa0IsQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHLFlBQVc7QUFDOUMsTUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsZUFBZSxFQUFFLGVBQWUsQ0FBQyxDQUFDO0FBQzNELE1BQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUM7O0FBRXZCLHlCQUFXLFNBQVMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQztDQUNuRCxDQUFDOztBQUVGLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxLQUFLLEdBQUcsWUFBVztBQUM5QyxNQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDO0FBQ3ZCLHlCQUFXLFNBQVMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQztDQUNuRCxDQUFDOztBQUVGLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxZQUFZLEdBQUcsVUFBUyxZQUFZLEVBQUU7QUFDakUsTUFBSSxjQUFjLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxjQUFjLENBQUM7O0FBRWhFLE1BQUksY0FBYyxJQUFJLGNBQWMsRUFBRSxLQUFLLEtBQUssRUFBRTtBQUNoRCxXQUFPO0dBQ1I7QUFDRCx5QkFBVyxTQUFTLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7Q0FDMUQsQ0FBQzs7QUFFRixrQkFBa0IsQ0FBQyxTQUFTLENBQUMsYUFBYSxHQUFHLFVBQVMsV0FBVyxFQUFFLFFBQVEsRUFBRTtBQUMzRSxNQUFJLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsRUFBRTs7Ozs7QUFJaEQsUUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQztHQUN4Qjs7QUFFRCxNQUFJLElBQUksQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsRUFBRTs7OztBQUloRCxRQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDOztBQUVuRCxRQUFJLEtBQUssS0FBSyxLQUFLLENBQUMsRUFBRTs7QUFDcEIsVUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUN0QjtHQUNGOztBQUVELFNBQU8sdUJBQVcsU0FBUyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0NBQ2xFLENBQUM7O0FBRUYsa0JBQWtCLENBQUMsU0FBUyxDQUFDLFdBQVcsR0FBRyxZQUFXO0FBQ3BELE1BQUksS0FBSyxHQUFHLElBQUksQ0FBQzs7QUFFakIsTUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsY0FBYyxFQUFFLFlBQVc7QUFDL0MsUUFBSSxLQUFLLENBQUMsUUFBUSxFQUFFO0FBQ2xCLFdBQUssQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLENBQUM7S0FDMUI7R0FDRixDQUFDLENBQUM7Q0FDSixDQUFDOztRQUVNLGtCQUFrQixHQUFsQixrQkFBa0I7O0FBRTFCLDZCQUFlLGNBQWMsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDOzs7Ozs7Ozs7OEJDbEwzQixzQkFBc0I7OytCQUN3Qix3QkFBd0I7O2lDQVluRiwwQkFBMEI7O3VCQUNHLGNBQWM7OzBCQUM3QixlQUFlOzs0QkFDUyxtQkFBbUI7O0FBRXBFLElBQ0UsZ0JBQWdCLEdBQUcsdUJBQVcsU0FBUyxDQUFDLE1BQU0sRUFBRTtJQUNoRCxrQkFBa0IsR0FBRyxFQUFFLENBQUM7Ozs7Ozs7QUFRMUIsSUFBSSxjQUFjLEdBQUcsU0FBakIsY0FBYyxHQUFlO0FBQy9CLE1BQUksQ0FBQyxRQUFRLEdBQUcsRUFBRSxDQUFDOztBQUVuQixNQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3pELE1BQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLFNBQVMsR0FBRyxZQUFZLENBQUM7QUFDbEQsTUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMxRCxNQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxTQUFTLEdBQUcsYUFBYSxDQUFDO0FBQ3BELE1BQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDdkQsTUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsU0FBUyxHQUFHLFVBQVUsQ0FBQztBQUM5QyxNQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3pELE1BQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLFNBQVMsR0FBRyxZQUFZLENBQUM7O0FBRWxELE9BQUssSUFBSSxNQUFNLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRTtBQUNoQyxRQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxFQUFFO0FBQ3hDLFVBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0tBQzFEO0dBQ0Y7Q0FDRixDQUFDOztBQUVGLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxZQUFZLEdBQUcsWUFBVztBQUNuRCxTQUFPLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO0NBQzFDLENBQUM7O0FBRUYsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLElBQUksR0FBRyxZQUFXO0FBQzNDLE1BQUksSUFBSSxHQUFHLElBQUksQ0FBQztBQUNoQixNQUFJLENBQUMsWUFBWSxHQUFHLGdDQUFtQixJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7O0FBRXRELE1BQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztBQUN0QixNQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7O0FBRWxCLE1BQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLGNBQWMsRUFBRSxZQUFXO0FBQy9DLFFBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztHQUNoQixDQUFDLENBQUM7Q0FFSixDQUFDOztBQUVGLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsWUFBVztBQUMvQyxTQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDO0NBQzVCLENBQUM7O0FBRUYsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLFFBQVEsR0FBRyxVQUFTLFFBQVEsRUFBRTtBQUN2RCxNQUFJLENBQUMsU0FBUyxHQUFHLFFBQVEsQ0FBQzs7QUFFMUIsTUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDO0NBQ2hDLENBQUM7O0FBRUYsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLGNBQWMsR0FBRyxZQUFXO0FBQ3JELE1BQUksQ0FBQyxlQUFlLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNyRCxNQUFJLENBQUMsZUFBZSxDQUFDLFNBQVMsR0FBRyx5QkFBeUIsQ0FBQzs7QUFFM0QsTUFBSSxDQUFDLFdBQVcsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ2pELE1BQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxHQUFHLGFBQWEsQ0FBQzs7QUFFM0MsTUFBSSxDQUFDLFVBQVUsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ2hELE1BQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxHQUFHLFlBQVksQ0FBQzs7QUFFekMsTUFBSSxDQUFDLFNBQVMsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQy9DLE1BQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxHQUFHLFFBQVEsQ0FBQzs7QUFFcEMsTUFBSSxDQUFDLGdCQUFnQixHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDdEQsTUFBSSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsR0FBRyxrQkFBa0IsQ0FBQzs7QUFFckQsTUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ25ELG1DQUFTLElBQUksQ0FBQyxRQUFRLEVBQUUsbUJBQW1CLENBQUMsQ0FBQzs7QUFFN0MsTUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDOztBQUUxQyxNQUFJLENBQUMsZUFBZSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDbkQsTUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ2xELE1BQUksQ0FBQyxlQUFlLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUNqRCxNQUFJLENBQUMsZUFBZSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQzs7QUFFeEQsZ0JBQWMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7O0FBRTFCLFVBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztDQUNqRCxDQUFDOztBQUVGLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxlQUFlLEdBQUcsVUFBUyxLQUFLLEVBQUU7QUFDM0QsTUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDO0FBQ3BCLE1BQUksSUFBSSxHQUFHLFFBQVEsQ0FBQyxlQUFlLEVBQUUsQ0FBQzs7QUFFdEMsTUFBSSxLQUFLLENBQUMsTUFBTSxLQUFLLElBQUksQ0FBQyxRQUFRLElBQUksb0RBQThCLEtBQUssQ0FBQyxFQUFFO0FBQzFFLFdBQU87R0FDUjs7QUFFRCxVQUFRLEtBQUssQ0FBQyxPQUFPO0FBQ25CLFNBQUssMEJBQVUsS0FBSztBQUNsQixVQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDYixXQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7QUFDdkIsWUFBTTtBQUFBLEFBQ1IsU0FBSywwQkFBVSxTQUFTO0FBQ3RCLHFEQUF5QixLQUFLLENBQUMsQ0FBQztBQUNoQyxZQUFNO0FBQUEsR0FDVDtDQUNGLENBQUM7O0FBRUYsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLElBQUksR0FBRyxZQUFXO0FBQzNDLE1BQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7O0FBRTdELG1DQUFTLElBQUksQ0FBQyxlQUFlLEVBQUUsUUFBUSxDQUFDLENBQUM7QUFDekMsc0NBQVksSUFBSSxDQUFDLFdBQVcsRUFBRSxRQUFRLENBQUMsQ0FBQzs7QUFFeEMsTUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUM7Q0FDN0IsQ0FBQzs7QUFFRixnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHLFlBQVc7QUFDNUMsTUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztBQUN0QiwyQ0FBaUIsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztDQUM3RCxDQUFDOztBQUVGLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxLQUFLLEdBQUcsWUFBVztBQUM1QyxNQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDO0FBQ3JCLE1BQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7O0FBRWhFLHNDQUFZLElBQUksQ0FBQyxlQUFlLEVBQUUsUUFBUSxDQUFDLENBQUM7Q0FDN0MsQ0FBQzs7QUFFRixnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsWUFBWSxHQUFHLFlBQVc7QUFDbkQsTUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDLFNBQVMsQ0FBQztBQUN4RCxNQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUM7Q0FDM0MsQ0FBQzs7QUFFRixnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsZUFBZSxHQUFHLFlBQVc7QUFDdEQsTUFBSSxDQUFDLGlDQUFTLElBQUksQ0FBQyxXQUFXLEVBQUUsUUFBUSxDQUFDLEVBQUU7QUFDekMscUNBQVMsSUFBSSxDQUFDLFdBQVcsRUFBRSxRQUFRLENBQUMsQ0FBQztHQUN0QztDQUNGLENBQUM7O0FBRUYsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLG9CQUFvQixHQUFHLFVBQVMsQ0FBQyxFQUFFLENBQUMsRUFBRTtBQUMvRCxNQUFJLENBQUMsSUFBSSxDQUFDLEVBQUU7QUFDVixLQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUNwQixLQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQzs7QUFFcEIsUUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUM7QUFDMUMsUUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUM7R0FFNUMsTUFBTTtBQUNMLFFBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFO1FBQ3pDLFlBQVksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7OztBQUduRSxRQUFJLENBQUMsa0JBQWtCLENBQUMsV0FBVyxFQUFFO0FBQ25DLHdCQUFrQixDQUFDLFdBQVcsR0FBRztBQUMvQixjQUFNLEVBQUUsb0NBQVksSUFBSSxDQUFDLFdBQVcsQ0FBQztBQUNyQyxhQUFLLEVBQUUsbUNBQVcsSUFBSSxDQUFDLFdBQVcsQ0FBQztPQUNwQyxDQUFDO0tBQ0g7QUFDRCxRQUFJLENBQUMsa0JBQWtCLENBQUMsZUFBZSxFQUFFO0FBQ3ZDLHdCQUFrQixDQUFDLGVBQWUsR0FBRztBQUNuQyxhQUFLLEVBQUUsbUNBQVcsSUFBSSxDQUFDLGVBQWUsQ0FBQztPQUN4QyxDQUFDO0tBQ0g7O0FBRUQsUUFBSSxZQUFZLEtBQUssU0FBUyxFQUFFO0FBQzlCLFVBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUN4RCxpQkFBaUIsSUFBSSxNQUFNLEdBQUcsQ0FBQyxHQUFHLHNDQUFjLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQzFHLFVBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUN0RCxpQkFBaUIsSUFBSSxNQUFNLEdBQUcsQ0FBQyxHQUFHLHFDQUFhLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDOztBQUV4RyxVQUFJLGtCQUFrQixHQUFHLCtCQUFPLFlBQVksQ0FBQztVQUMzQyxpQkFBaUIsR0FBRyxtQ0FBVyxZQUFZLENBQUM7VUFDNUMscUJBQXFCLEdBQUc7QUFDdEIsU0FBQyxFQUFFLFVBQVU7QUFDYixTQUFDLEVBQUUsU0FBUztPQUNiLENBQUM7O0FBRUosVUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLEdBQUcsb0NBQVksWUFBWSxDQUFDLEdBQ3hGLHFCQUFxQixDQUFDLENBQUMsR0FBRyxrQkFBa0IsQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQztBQUNoRixVQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxJQUFJLEdBQUcsUUFBUSxDQUFDLEFBQUMsTUFBTSxDQUFDLFVBQVUsR0FBRyxDQUFDLEdBQUssa0JBQWtCLENBQUMsZUFBZSxDQUFDLEtBQUssR0FBRyxDQUFDLEFBQUMsRUFBRSxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUM7O0FBRWhJLFVBQUksa0JBQWtCLENBQUMsSUFBSSxHQUFHLGlCQUFpQixHQUFHLENBQUMsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxHQUMvRixrQkFBa0IsQ0FBQyxlQUFlLENBQUMsS0FBSyxFQUFFO0FBQzVDLFlBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsVUFBVSxHQUFHLGtCQUFrQixDQUFDLGVBQWUsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO09BRXZHLE1BQU0sSUFBSSxrQkFBa0IsQ0FBQyxJQUFJLEdBQUcsaUJBQWlCLEdBQUcsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFO0FBQy9HLFlBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDO09BQzVDOztBQUVELFVBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxRQUFRLENBQUMsa0JBQWtCLENBQUMsSUFBSSxHQUFJLGtCQUFrQixDQUFDLFdBQVcsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxBQUFDLEdBQ3pHLCtCQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxJQUFJLEdBQUksaUJBQWlCLEdBQUcsQ0FBQyxBQUFDLEdBQUcscUJBQXFCLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQztLQUNyRztHQUNGO0NBQ0YsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCRixnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLEdBQUcsWUFBVztBQUN2RCxNQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRTtNQUN4QyxhQUFhLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDOztBQUV4RSxNQUFJLENBQUMsR0FBRyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN2QixNQUFJLENBQUMsR0FBRyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN2QixNQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQzdCLE1BQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO0NBQzdCLENBQUM7O0FBRUYsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLGNBQWMsR0FBRyxZQUFXO0FBQ3JELE1BQUksR0FBRyxDQUFDOztBQUVSLE1BQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLEVBQUU7QUFDeEIsV0FBTyxJQUFJLENBQUM7R0FDYjs7QUFFRCxNQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLENBQUMsY0FBYyxFQUFFO0FBQzlDLE9BQUcsR0FBRyxDQUNKLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQzlDLENBQUM7R0FDSCxNQUFNO0FBQ0wsT0FBRyxHQUFHLENBQ0osQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FDbEIsQ0FBQztHQUNIOztBQUdELE1BQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUM7Q0FDckIsQ0FBQzs7QUFFRixnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsVUFBVSxHQUFHLFlBQVc7QUFDakQsTUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDOztBQUVoQixNQUFJLENBQUMsWUFBWSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFFLFVBQVUsRUFBRSxVQUFTLEtBQUssRUFBRTtBQUN2RixRQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7QUFDdEIsUUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLENBQUMsRUFBRSxDQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDM0QsUUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7QUFDeEIsU0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO0dBQ3hCLENBQUMsQ0FBQztBQUNILE1BQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsVUFBVSxFQUFFLFVBQVMsS0FBSyxFQUFFO0FBQ3hGLFFBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztBQUN0QixRQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDekQsUUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7QUFDeEIsU0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO0dBQ3hCLENBQUMsQ0FBQztBQUNILE1BQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsVUFBVSxFQUFFLFVBQVMsS0FBSyxFQUFFO0FBQ3JGLFFBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztBQUN0QixRQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztBQUMxRCxRQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztBQUN4QixTQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7R0FDeEIsQ0FBQyxDQUFDO0FBQ0gsTUFBSSxDQUFDLFlBQVksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBUyxLQUFLLEVBQUU7QUFDdkYsUUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO0FBQ3RCLFFBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztBQUN6RCxRQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztBQUN4QixTQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7R0FDeEIsQ0FBQyxDQUFDOztBQUVILE1BQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxZQUFZLEVBQUUsVUFBUyxLQUFLLEVBQUU7QUFDaEYsUUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUU7QUFDN0IsVUFBSSxLQUFLLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7VUFDMUIsZUFBZSxHQUFHO0FBQ2hCLFNBQUMsRUFBRSxJQUFJLENBQUMsZUFBZSxDQUFDLFVBQVU7QUFDbEMsU0FBQyxFQUFFLElBQUksQ0FBQyxlQUFlLENBQUMsU0FBUztPQUNsQztVQUFFLGFBQWEsR0FBRztBQUNqQixTQUFDLEVBQUUsS0FBSyxDQUFDLEtBQUssR0FBRyxlQUFlLENBQUMsQ0FBQztBQUNsQyxTQUFDLEVBQUUsS0FBSyxDQUFDLEtBQUssR0FBRyxlQUFlLENBQUMsQ0FBQztPQUNuQyxDQUFDOztBQUVKLFVBQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLFdBQVcsRUFBRSxVQUFTLEtBQUssRUFBRTtBQUNwRSxZQUFJLEtBQUssR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzdCLFlBQUksQ0FBQyxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLGFBQWEsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLEtBQUssR0FBRyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDeEYsWUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO0FBQ3ZCLGFBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztPQUN4QixDQUFDLENBQUM7S0FFSjtHQUNGLENBQUMsQ0FBQzs7QUFFSCxNQUFJLENBQUMsWUFBWSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsVUFBVSxFQUFFLFVBQVMsS0FBSyxFQUFFO0FBQzVFLFFBQUksQ0FBQyxrQ0FBVSxLQUFLLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLGtDQUFVLEtBQUssQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsRUFBRTtBQUN6RyxVQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7S0FDZDtHQUNGLENBQUMsQ0FBQzs7QUFFSCxNQUFJLENBQUMsWUFBWSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxRQUFRLEVBQUUsVUFBUyxLQUFLLEVBQUU7QUFDaEgsUUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxpQkFBaUIsSUFBSSxNQUFNLEVBQUU7QUFDNUUsVUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO0tBQ3hCO0dBQ0YsQ0FBQyxDQUFDOztBQUVILE1BQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLFFBQVEsRUFBRSxVQUFTLEtBQUssRUFBRTtBQUMvRyxRQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLGlCQUFpQixJQUFJLE1BQU0sRUFBRTtBQUMzRSxVQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7S0FDeEI7R0FDRixDQUFDLENBQUM7Q0FFSixDQUFDOztBQUVGLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxPQUFPLEdBQUcsWUFBVztBQUM5QyxNQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssRUFBRSxDQUFDOztBQUUxQixNQUFJLENBQUMsZUFBZSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0NBQ25FLENBQUM7O1FBRU0sZ0JBQWdCLEdBQWhCLGdCQUFnQjs7QUFFeEIsNkJBQWUsUUFBUSxFQUFFLGdCQUFnQixDQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUJDclZ2QixTQUFTOzs7O3VCQUNXLGNBQWM7OzBCQUM3QixjQUFjOzs7Ozs7Ozs7SUFTakMsYUFBYTtZQUFiLGFBQWE7O1dBQWIsYUFBYTswQkFBYixhQUFhOzsrQkFBYixhQUFhOzs7ZUFBYixhQUFhOzs7Ozs7V0FJTCxzQkFBQyxZQUFZLEVBQUU7QUFDekIsVUFBSSxPQUFPLFlBQVksQUFBQyxLQUFLLFdBQVcsSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFO0FBQzlELFlBQUksT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsS0FBSyxXQUFXLEVBQUU7QUFDdkQsK0JBQVEsUUFBUSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDaEQ7QUFDRCxZQUFJLGdCQUFnQixHQUFHLHFCQUFRLFlBQVksRUFBRSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUM7QUFDakUsb0JBQVksR0FBRyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFBLENBQUUsT0FBTyxDQUFDLEdBQUcsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO09BQ3pFO0FBQ0QsaUNBWkUsYUFBYSw4Q0FZSSxZQUFZLEVBQUU7S0FDbEM7OztTQWJHLGFBQWE7OztRQWdCWCxhQUFhLEdBQWIsYUFBYTs7QUFFckIsNkJBQWUsU0FBUyxFQUFFLGFBQWEsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztpQ0M3QnJCLDBCQUEwQjs7dUJBQ04sY0FBYzs7MEJBQzdCLGNBQWM7Ozs7Ozs7OztJQVNqQyxjQUFjO1lBQWQsY0FBYzs7V0FBZCxjQUFjOzBCQUFkLGNBQWM7OytCQUFkLGNBQWM7OztlQUFkLGNBQWM7O1dBQ0osMEJBQUc7QUFDZixpQ0FGRSxjQUFjLGdEQUVPOztBQUV2QixVQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDaEQsVUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0FBQy9DLFVBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxHQUFHLG1CQUFtQixDQUFDO0FBQzlDLFVBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUM7QUFDekMsVUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO0FBQzdCLFVBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQzs7QUFFOUIsb0NBQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBQzVCLFVBQUksQ0FBQyxlQUFlLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUNqRDs7O1NBYkcsY0FBYzs7O1FBZ0JaLGNBQWMsR0FBZCxjQUFjOztBQUV0Qiw2QkFBZSxVQUFVLEVBQUUsY0FBYyxDQUFDLENBQUM7Ozs7Ozs7OztpQ0NsQmhDLDBCQUEwQjs7K0JBQ0Usd0JBQXdCOzs4QkFDdkMsc0JBQXNCOzt1QkFDTixjQUFjOzswQkFDN0IsZUFBZTs7QUFFeEMsSUFBSSxZQUFZLEdBQUcsdUJBQVcsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDOzs7Ozs7O0FBUWpELFlBQVksQ0FBQyxTQUFTLENBQUMsSUFBSSxHQUFHLFlBQVc7QUFDdkMsTUFBSSxDQUFDLE1BQU0sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQy9DLG1DQUFTLElBQUksQ0FBQyxNQUFNLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztBQUN4QyxNQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO0FBQ25DLE1BQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDbkQsTUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO0NBQ3RCLENBQUM7O0FBRUYsWUFBWSxDQUFDLFNBQVMsQ0FBQyxhQUFhLEdBQUcsWUFBVzs7O0FBQ2hELE1BQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLHVCQUF1QixFQUFFO1dBQU0sTUFBSyxpQkFBaUIsRUFBRTtHQUFBLENBQUMsQ0FBQztBQUMvRSxNQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxtQkFBbUIsRUFBRTtXQUFNLE1BQUssaUJBQWlCLEVBQUU7R0FBQSxDQUFDLENBQUM7QUFDM0UsTUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLEVBQUU7V0FBTSxNQUFLLGlCQUFpQixFQUFFO0dBQUEsQ0FBQyxDQUFDO0NBQ3pFLENBQUM7O0FBRUYsWUFBWSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEdBQUcsWUFBVztBQUMxQyx5QkFBVyxTQUFTLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7O0FBRXBELE1BQUksYUFBYSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsYUFBYSxDQUFDO0FBQ3RELE1BQUksT0FBTyxDQUFDOztBQUVaLE1BQUksT0FBTyxhQUFhLElBQUksVUFBVSxFQUFFO0FBQ3RDLFdBQU8sR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7R0FDN0UsTUFBTTtBQUNMLFdBQU8sR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0dBQzlDOztBQUVELGdDQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQzs7QUFFbkIsT0FBSyxJQUFJLE1BQU0sSUFBSSxPQUFPLEVBQUU7QUFDMUIsUUFBSSxPQUFPLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxFQUFFO0FBQ2xDLFVBQUksYUFBYSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDckQsbUJBQWEsQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDO0FBQzdCLDRDQUFjLGFBQWEsRUFBRSxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUM5QyxVQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUMsQ0FBQztLQUN4QztHQUNGO0NBQ0YsQ0FBQzs7QUFFRixZQUFZLENBQUMsU0FBUyxDQUFDLGNBQWMsR0FBRyxVQUFTLGdCQUFnQixFQUFFO0FBQ2pFLE1BQUksZUFBZSxHQUFHLEVBQUUsQ0FBQzs7QUFFekIsTUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLGdCQUFnQixDQUFDLEVBQUU7QUFDbkMsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzNELHFCQUFlLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUM1RDtHQUNGLE1BQU0sSUFBSSxPQUFPLGdCQUFnQixJQUFJLFFBQVEsRUFBRTtBQUM5QyxtQkFBZSxHQUFHLGdCQUFnQixDQUFDO0dBQ3BDOztBQUVELFNBQU8sZUFBZSxDQUFDO0NBRXhCLENBQUM7O0FBRUYsWUFBWSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsWUFBVztBQUMzQyxTQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDO0NBQzFCLENBQUM7O0FBRUYsWUFBWSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsVUFBUyxLQUFLLEVBQUU7QUFDaEQsTUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0NBQzNCLENBQUM7O0FBRUYsSUFBSSxlQUFlLEdBQUcsU0FBbEIsZUFBZSxDQUFZLEtBQUssRUFBRTtBQUNwQyxNQUFJLFFBQVEsR0FBRyxJQUFJLENBQUM7QUFDcEIsTUFBSSxNQUFNLEdBQUcsUUFBUSxDQUFDLGVBQWUsRUFBRSxDQUFDOztBQUV4QyxVQUFRLEtBQUssQ0FBQyxPQUFPO0FBQ25CLFNBQUssMEJBQVUsUUFBUTtBQUNyQixVQUFJLG1CQUFtQixHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztBQUMxRCxVQUFJLG1CQUFtQixJQUFJLENBQUMsRUFBRTtBQUM1QixjQUFNLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztPQUNwRDs7QUFFRCxxREFBeUIsS0FBSyxDQUFDLENBQUM7QUFDaEMsV0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO0FBQ3ZCLFlBQU07O0FBQUEsQUFFUixTQUFLLDBCQUFVLFVBQVU7QUFDdkIsVUFBSSxlQUFlLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDO0FBQ3RELFVBQUksZUFBZSxJQUFJLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtBQUMvQyxjQUFNLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7T0FDaEQ7O0FBRUQscURBQXlCLEtBQUssQ0FBQyxDQUFDO0FBQ2hDLFdBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztBQUN2QixZQUFNO0FBQUEsR0FDVDtDQUNGLENBQUM7OztBQUdGLFlBQVksQ0FBQyxTQUFTLENBQUMsa0JBQWtCLEdBQUcsWUFBVztBQUNyRCxNQUFJLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxZQUFZLEVBQUU7QUFDdkQsUUFBSSxJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLENBQUMsZ0JBQWdCLEVBQUU7QUFDM0QsYUFBTyxRQUFRLENBQUM7S0FDakIsTUFBTTtBQUNMLGFBQU8sS0FBSyxDQUFDO0tBQ2Q7R0FDRixNQUFNO0FBQ0wsUUFBSSxJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLENBQUMsZ0JBQWdCLEVBQUU7QUFDM0QsYUFBTyxNQUFNLENBQUM7S0FDZjtHQUNGO0NBQ0YsQ0FBQzs7QUFFRixZQUFZLENBQUMsU0FBUyxDQUFDLElBQUksR0FBRyxZQUFXO0FBQ3ZDLE1BQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO0FBQ3BCLE1BQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO0FBQ3pCLE1BQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7QUFDL0IsTUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsZUFBZSxFQUFFLGVBQWUsQ0FBQyxDQUFDO0NBQ3pELENBQUM7O0FBRUYsWUFBWSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEdBQUcsWUFBVztBQUN4QyxNQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztBQUNyQixNQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO0FBQ25DLE1BQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLGVBQWUsRUFBRSxlQUFlLENBQUMsQ0FBQztDQUM1RCxDQUFDOztBQUVGLFlBQVksQ0FBQyxTQUFTLENBQUMsS0FBSyxHQUFHLFlBQVc7QUFDeEMsTUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQztDQUNyQixDQUFDOztBQUVGLFlBQVksQ0FBQyxTQUFTLENBQUMsaUJBQWlCLEdBQUcsWUFBVztBQUNwRCxNQUFJLElBQUksQ0FBQyxLQUFLLEtBQUssWUFBWSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUU7QUFDbkQsV0FBTztHQUNSO0FBQ0QsTUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7OztBQUcvQixNQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRTtBQUNaLFFBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQzs7QUFFYixXQUFPO0dBQ1I7QUFDRCxNQUNFLEtBQUssR0FBRyxtQ0FBVyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQztNQUMvQixNQUFNLEdBQUcsb0NBQVksSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUM7TUFDakMsYUFBYSxHQUFHLCtCQUFPLElBQUksQ0FBQyxFQUFFLENBQUM7TUFDL0IsZUFBZSxHQUFHLCtCQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDO01BQ25ELG1CQUFtQixHQUFHLDZDQUFxQixJQUFJLENBQUMsRUFBRSxDQUFDO01BQ25ELE9BQU8sR0FBRyxhQUFhLENBQUMsR0FBRyxHQUFHLGVBQWUsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxJQUFJLG1CQUFtQixDQUFDLFNBQVMsSUFBSSxDQUFDLENBQUEsQUFBQztNQUM1RixRQUFRLEdBQUcsYUFBYSxDQUFDLElBQUksR0FBRyxlQUFlLENBQUMsSUFBSSxHQUFHLENBQUMsSUFBSSxtQkFBbUIsQ0FBQyxVQUFVLElBQUksQ0FBQyxDQUFBLEFBQUM7TUFDaEcsYUFBYSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsRUFBRTtNQUN6QyxrQkFBa0IsQ0FBQzs7QUFFckIsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQztBQUM3QyxNQUFJLGVBQWUsR0FBRyxRQUFRLENBQUMsVUFBVSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDbEQsTUFBSSxlQUFlLEdBQUcsUUFBUSxDQUFDLFVBQVUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDOztBQUVsRCxVQUFRLGFBQWE7QUFDbkIsU0FBSyxLQUFLO0FBQ1Isd0JBQWtCLEdBQUcsd0NBQWdCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ2xILFlBQU07QUFBQSxBQUNSLFNBQUssTUFBTTtBQUNULHdCQUFrQixHQUFHLHdDQUFnQixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUNuSCxZQUFNO0FBQUEsQUFDUixTQUFLLFFBQVE7QUFDWCx3QkFBa0IsR0FBRyx3Q0FBZ0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUM1SCxZQUFNO0FBQUEsR0FDVDtBQUNELE1BQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDeEMsV0FBTyxJQUFJLENBQUMsQ0FBQztHQUNkOztBQUVELE1BQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDeEMsWUFBUSxJQUFJLENBQUMsQ0FBQztHQUNmOztBQUVELE1BQUksV0FBVyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDOztBQUVwQyxNQUFJLGtCQUFrQixJQUFJLGtCQUFrQixJQUFJLENBQUMsQ0FBQyxFQUFFO0FBQ2xELGVBQVcsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxDQUFDO0dBQzVELE1BQU07QUFDTCw4Q0FBa0IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0dBQ2hDO0FBQ0QsTUFBTSxpQkFBaUIsR0FBRyx5Q0FBaUIsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDOztBQUVwRCxNQUFJLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxjQUFjLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFO0FBQ3RELFVBQU0sSUFBSSxDQUFDLENBQUM7R0FDYjtBQUNELE1BQUksUUFBUSxDQUFDLGlCQUFpQixDQUFDLGVBQWUsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUU7QUFDdkQsU0FBSyxJQUFJLENBQUMsQ0FBQztHQUNaOztBQUVELGFBQVcsQ0FBQyxNQUFNLEdBQUcsTUFBTSxHQUFHLElBQUksQ0FBQztBQUNuQyxhQUFXLENBQUMsUUFBUSxHQUFHLEtBQUssR0FBRyxJQUFJLENBQUM7QUFDcEMsYUFBVyxDQUFDLEdBQUcsR0FBRyxPQUFPLEdBQUcsSUFBSSxDQUFDO0FBQ2pDLGFBQVcsQ0FBQyxJQUFJLEdBQUcsUUFBUSxHQUFHLElBQUksQ0FBQztBQUNuQyxhQUFXLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztDQUM1QixDQUFDOztBQUVGLFlBQVksQ0FBQyxTQUFTLENBQUMsYUFBYSxHQUFHLFlBQVc7QUFDaEQsTUFBSSxhQUFhLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixFQUFFO01BQzNDLFVBQVUsQ0FBQzs7QUFFYixVQUFRLGFBQWE7QUFDbkIsU0FBSyxLQUFLO0FBQ1IsZ0JBQVUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQztBQUM3RSxXQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUc7QUFDYixXQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUc7T0FDZCxDQUFDLENBQUM7QUFDSCxVQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDO0FBQy9CLFlBQU07QUFBQSxBQUNSLFNBQUssUUFBUTtBQUNYLGdCQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQztBQUN2RixXQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUc7QUFDYixXQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUc7T0FDZCxDQUFDLENBQUM7QUFDSCxVQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDO0FBQy9CLFlBQU07QUFBQSxBQUNSLFNBQUssTUFBTTtBQUNULGdCQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUM7QUFDOUUsV0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHO0FBQ2IsV0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHO09BQ2QsQ0FBQyxDQUFDO0FBQ0gsVUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLEdBQUcsQ0FBQztBQUMvQixZQUFNO0FBQUEsQUFDUjtBQUNFLGdCQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDdkQsVUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQztBQUM5QixZQUFNO0FBQUEsR0FDVDs7QUFFRCxTQUFPLFVBQVUsSUFBSSxDQUFDLENBQUMsSUFBSSxVQUFVLElBQUksQ0FBQyxDQUFDLEdBQUcsVUFBVSxHQUFHLEtBQUssQ0FBQyxDQUFDO0NBQ25FLENBQUM7O1FBRU0sWUFBWSxHQUFaLFlBQVk7O0FBRXBCLDZCQUFlLFFBQVEsRUFBRSxZQUFZLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7aUNDalA1QiwwQkFBMEI7OzBCQUNkLFlBQVk7Ozs7MEJBQ1YsZUFBZTs7NEJBQ1MsbUJBQW1COzt1QkFDNUIsY0FBYzs7OEJBQzlCLHNCQUFzQjs7K0JBQ3lDLHdCQUF3Qjs7QUFFL0csSUFBSSxVQUFVLEdBQUcsdUJBQVcsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDOzs7Ozs7OztBQVMvQyxVQUFVLENBQUMsU0FBUyxDQUFDLElBQUksR0FBRyxZQUFXO0FBQ3JDLE1BQUksSUFBSSxHQUFHLElBQUksQ0FBQztBQUNoQixNQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7QUFDdEIsTUFBSSxDQUFDLFlBQVksR0FBRyxnQ0FBbUIsSUFBSSxDQUFDLENBQUM7QUFDN0MsTUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO0FBQ2xCLE1BQUksQ0FBQyxVQUFVLEdBQUcsOEJBQVksQ0FBQzs7QUFFL0IsTUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsY0FBYyxFQUFFLFlBQVc7QUFDL0MsUUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO0dBQ2hCLENBQUMsQ0FBQztDQUNKLENBQUM7O0FBRUYsVUFBVSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsWUFBVztBQUN6QyxTQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDO0NBQzVCLENBQUM7O0FBRUYsVUFBVSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsVUFBUyxRQUFRLEVBQUU7QUFDakQsTUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDO0NBQ2hDLENBQUM7O0FBRUYsSUFBSSxlQUFlLEdBQUcsU0FBUyxlQUFlLENBQUMsS0FBSyxFQUFFO0FBQ3BELE1BQUksUUFBUSxHQUFHLElBQUk7TUFDakIsSUFBSSxHQUFHLFFBQVEsQ0FBQyxlQUFlLEVBQUU7TUFDakMsUUFBUSxDQUFDOzs7QUFHWCxVQUFRLEdBQUcsQ0FBQyxLQUFLLENBQUMsT0FBTyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUEsSUFBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7OztBQUc3RCxNQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssSUFBSSxDQUFDLFFBQVEsSUFBSSxvREFBOEIsS0FBSyxDQUFDLEVBQUU7QUFDMUUsV0FBTztHQUNSOztBQUVELE1BQUksS0FBSyxDQUFDLE9BQU8sS0FBSyxFQUFFLElBQUksS0FBSyxDQUFDLE9BQU8sS0FBSyxHQUFHLElBQUksS0FBSyxDQUFDLE9BQU8sS0FBSyxFQUFFLElBQUksS0FBSyxDQUFDLE9BQU8sS0FBSyxFQUFFLEVBQUU7O0FBRWpHLG1EQUF5QixLQUFLLENBQUMsQ0FBQztBQUNoQyxXQUFPO0dBQ1I7O0FBRUQsVUFBUSxLQUFLLENBQUMsT0FBTztBQUNuQixTQUFLLDBCQUFVLFdBQVc7QUFDeEIsVUFBSSxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsRUFBRTtBQUMzQixZQUFJLEFBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsd0JBQXdCLElBQ25ELENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLElBQUksQ0FBQyx3QkFBd0IsSUFBSSxDQUFDLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEFBQUMsRUFBRTtBQUN6Ryx5REFBeUIsS0FBSyxDQUFDLENBQUM7U0FDakM7T0FDRjtBQUNELFlBQU07QUFBQSxBQUNSLFNBQUssMEJBQVUsVUFBVTtBQUN2QixVQUFJLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxFQUFFO0FBQzNCLFlBQUksQUFBQyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyx3QkFBd0IsSUFDbkQsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLElBQUksSUFBSSxDQUFDLHdCQUF3QixJQUFJLENBQUMsSUFBSSxDQUFDLHdCQUF3QixDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQUFBQyxFQUFFO0FBQ3pHLHlEQUF5QixLQUFLLENBQUMsQ0FBQztTQUNqQztPQUNGO0FBQ0QsWUFBTTtBQUFBLEFBQ1IsU0FBSywwQkFBVSxRQUFRLENBQUM7QUFDeEIsU0FBSywwQkFBVSxVQUFVO0FBQ3ZCLFVBQUksSUFBSSxDQUFDLGdCQUFnQixFQUFFLEVBQUU7QUFDM0IsWUFBSSxBQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLHdCQUF3QixJQUNuRCxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxJQUFJLENBQUMsd0JBQXdCLElBQUksQ0FBQyxJQUFJLENBQUMsd0JBQXdCLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxBQUFDLEVBQUU7QUFDekcseURBQXlCLEtBQUssQ0FBQyxDQUFDO1NBQ2pDO09BQ0Y7QUFDRCxZQUFNOztBQUFBLEFBRVIsU0FBSywwQkFBVSxLQUFLO0FBQ2xCLFVBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLENBQUM7QUFDM0MsVUFBSSxtQkFBbUIsR0FBRyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksUUFBUSxDQUFDLENBQUMsQ0FBQyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQSxBQUFDLENBQUM7QUFDeEYsVUFBSSxBQUFDLFFBQVEsSUFBSSxDQUFDLG1CQUFtQixJQUFLLEtBQUssQ0FBQyxNQUFNLEVBQUU7O0FBQ3RELFlBQUksSUFBSSxDQUFDLFFBQVEsRUFBRSxFQUFFO0FBQ25CLGNBQUksYUFBYSxHQUFHLHlDQUFpQixJQUFJLENBQUMsUUFBUSxDQUFDO2NBQ2pELEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7O0FBRTFCLGNBQUksUUFBUSxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLGFBQWEsQ0FBQyxHQUFHLElBQUksR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDOztBQUVqRixjQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDOztBQUV4QixtREFBaUIsSUFBSSxDQUFDLFFBQVEsRUFBRSxhQUFhLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FFcEQsTUFBTTtBQUNMLGNBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsQ0FBQztTQUM5QztBQUNELHVEQUF5QixLQUFLLENBQUMsQ0FBQztPQUNqQztBQUNELFdBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztBQUN2QixZQUFNOztBQUFBLEFBRVIsU0FBSywwQkFBVSxDQUFDLENBQUM7QUFDakIsU0FBSywwQkFBVSxDQUFDLENBQUM7QUFDakIsU0FBSywwQkFBVSxDQUFDLENBQUM7QUFDakIsU0FBSywwQkFBVSxDQUFDO0FBQ2QsVUFBSSxRQUFRLEVBQUU7QUFDWix1REFBeUIsS0FBSyxDQUFDLENBQUM7T0FDakM7QUFDRCxZQUFNOztBQUFBLEFBRVIsU0FBSywwQkFBVSxTQUFTLENBQUM7QUFDekIsU0FBSywwQkFBVSxNQUFNLENBQUM7QUFDdEIsU0FBSywwQkFBVSxJQUFJLENBQUM7QUFDcEIsU0FBSywwQkFBVSxHQUFHO0FBQ2hCLHFEQUF5QixLQUFLLENBQUMsQ0FBQztBQUNoQyxZQUFNO0FBQUEsR0FDVDs7QUFFRCxNQUFJLENBQUMsMEJBQVUsUUFBUSxFQUFFLDBCQUFVLFdBQVcsRUFBRSwwQkFBVSxVQUFVLEVBQUUsMEJBQVUsVUFBVSxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtBQUN6SCxRQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0dBQzVEO0NBQ0YsQ0FBQzs7QUFJRixVQUFVLENBQUMsU0FBUyxDQUFDLElBQUksR0FBRyxZQUFXO0FBQ3JDLE1BQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDOztBQUV6QixNQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxlQUFlLEVBQUUsZUFBZSxDQUFDLENBQUM7Q0FDekQsQ0FBQzs7QUFFRixVQUFVLENBQUMsU0FBUyxDQUFDLEtBQUssR0FBRyxZQUFXO0FBQ3RDLE1BQUksQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDOztBQUUxQyxNQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsRUFBRSxDQUFDOztBQUU1QixNQUFJLFFBQVEsQ0FBQyxhQUFhLEtBQUssSUFBSSxDQUFDLFFBQVEsRUFBRTtBQUM1QyxRQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDO0dBQ3hCO0FBQ0QsTUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsZUFBZSxFQUFFLGVBQWUsQ0FBQyxDQUFDO0NBQzVELENBQUM7O0FBRUYsVUFBVSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEdBQUcsWUFBVztBQUN0QyxNQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxDQUFDO0FBQ3RCLDJDQUFpQixJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0NBQzdELENBQUM7O0FBRUYsVUFBVSxDQUFDLFNBQVMsQ0FBQyxjQUFjLEdBQUcsWUFBVzs7O0FBRy9DLE1BQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsQ0FBQzs7QUFFbkQsbUNBQVMsSUFBSSxDQUFDLFFBQVEsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDOztBQUU3QyxNQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDO0FBQ3pDLE1BQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztBQUM3QixNQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7O0FBRTlCLE1BQUksQ0FBQyxlQUFlLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNyRCxtQ0FBUyxJQUFJLENBQUMsZUFBZSxFQUFFLHlCQUF5QixDQUFDLENBQUM7O0FBRTFELE1BQUksQ0FBQyxtQkFBbUIsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQztBQUN0RCxNQUFJLENBQUMsbUJBQW1CLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztBQUNqQyxNQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQztBQUNsQyxNQUFJLENBQUMsbUJBQW1CLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQzs7QUFFMUMsTUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDOztBQUVoRCxNQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDOztBQUU1RCxNQUFJLElBQUksR0FBRyxJQUFJLENBQUM7QUFDaEIsTUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsWUFBVztBQUNuRCxRQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztHQUMxQixFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDUixDQUFDOztBQUVGLFVBQVUsQ0FBQyxTQUFTLENBQUMsa0JBQWtCLEdBQUcsWUFBVztBQUNuRCxNQUFJLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxZQUFZLEVBQUU7QUFDdkQsUUFBSSxJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLENBQUMsZ0JBQWdCLEVBQUU7QUFDM0QsYUFBTyxRQUFRLENBQUM7S0FDakIsTUFBTTtBQUNMLGFBQU8sS0FBSyxDQUFDO0tBQ2Q7R0FDRixNQUFNO0FBQ0wsUUFBSSxJQUFJLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLENBQUMsZ0JBQWdCLEVBQUU7QUFDM0QsYUFBTyxNQUFNLENBQUM7S0FDZjtHQUNGO0NBQ0YsQ0FBQzs7QUFFRixVQUFVLENBQUMsU0FBUyxDQUFDLGFBQWEsR0FBRyxZQUFXO0FBQzlDLE1BQUksYUFBYSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsRUFBRTtNQUMzQyxVQUFVLENBQUM7O0FBRWIsVUFBUSxhQUFhO0FBQ25CLFNBQUssS0FBSztBQUNSLGdCQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUM7QUFDN0UsV0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHO0FBQ2IsV0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHO09BQ2QsQ0FBQyxDQUFDO0FBQ0gsVUFBSSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUM7QUFDdEMsWUFBTTtBQUFBLEFBQ1IsU0FBSyxRQUFRO0FBQ1gsZ0JBQVUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLG9CQUFvQixDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDO0FBQ3ZGLFdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRztBQUNiLFdBQUcsRUFBRSxJQUFJLENBQUMsR0FBRztPQUNkLENBQUMsQ0FBQztBQUNILFVBQUksQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLEdBQUcsR0FBRyxDQUFDO0FBQ3RDLFlBQU07QUFBQSxBQUNSLFNBQUssTUFBTTtBQUNULGdCQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUM7QUFDOUUsV0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHO0FBQ2IsV0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHO09BQ2QsQ0FBQyxDQUFDO0FBQ0gsVUFBSSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUM7QUFDdEMsWUFBTTtBQUFBLEFBQ1I7QUFDRSxnQkFBVSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3ZELFVBQUksQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDO0FBQ3JDLFlBQU07QUFBQSxHQUNUOztBQUVELFNBQU8sVUFBVSxJQUFJLENBQUMsQ0FBQyxJQUFJLFVBQVUsSUFBSSxDQUFDLENBQUMsR0FBRyxVQUFVLEdBQUcsS0FBSyxDQUFDLENBQUM7Q0FDbkUsQ0FBQzs7QUFHRixVQUFVLENBQUMsU0FBUyxDQUFDLGlCQUFpQixHQUFHLFlBQVc7QUFDbEQsTUFBSSxJQUFJLENBQUMsS0FBSyxLQUFLLFlBQVksQ0FBQyxXQUFXLENBQUMsT0FBTyxFQUFFO0FBQ25ELFdBQU87R0FDUjtBQUNELE1BQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDOzs7QUFHL0IsTUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUU7QUFDWixRQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7O0FBRWIsV0FBTztHQUNSO0FBQ0QsTUFBSSxhQUFhLEdBQUcsK0JBQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQztNQUNqQyxlQUFlLEdBQUcsK0JBQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUM7TUFDbkQsbUJBQW1CLEdBQUcsNkNBQXFCLElBQUksQ0FBQyxFQUFFLENBQUM7TUFDbkQsT0FBTyxHQUFHLGFBQWEsQ0FBQyxHQUFHLEdBQUcsZUFBZSxDQUFDLEdBQUcsR0FBRyxDQUFDLElBQUksbUJBQW1CLENBQUMsU0FBUyxJQUFJLENBQUMsQ0FBQSxBQUFDO01BQzVGLFFBQVEsR0FBRyxhQUFhLENBQUMsSUFBSSxHQUFHLGVBQWUsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxJQUFJLG1CQUFtQixDQUFDLFVBQVUsSUFBSSxDQUFDLENBQUEsQUFBQztNQUVoRyxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUU7TUFDdEMsZUFBZSxHQUFHLFFBQVEsQ0FBQyxVQUFVLEdBQUcsQ0FBQyxHQUFHLENBQUM7TUFDN0MsZUFBZSxHQUFHLFFBQVEsQ0FBQyxVQUFVLEdBQUcsQ0FBQyxHQUFHLENBQUM7TUFDN0MsYUFBYSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsRUFBRTtNQUN6QyxlQUFlLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsZUFBZTtNQUMvQyxrQkFBa0IsQ0FBQzs7O0FBR3JCLFVBQVEsYUFBYTtBQUNuQixTQUFLLEtBQUs7QUFDUix3QkFBa0IsR0FBRyx3Q0FBZ0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDbEgsWUFBTTtBQUFBLEFBQ1IsU0FBSyxNQUFNO0FBQ1Qsd0JBQWtCLEdBQUcsd0NBQWdCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ25ILFlBQU07QUFBQSxBQUNSLFNBQUssUUFBUTtBQUNYLHdCQUFrQixHQUFHLHdDQUFnQixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLG9CQUFvQixDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQzVILFlBQU07QUFBQSxHQUNUOztBQUVELE1BQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDeEMsV0FBTyxJQUFJLENBQUMsQ0FBQztHQUNkOztBQUVELE1BQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDeEMsWUFBUSxJQUFJLENBQUMsQ0FBQztHQUNmOztBQUVELE1BQUksa0JBQWtCLElBQUksa0JBQWtCLElBQUksQ0FBQyxDQUFDLEVBQUU7QUFDbEQsUUFBSSxDQUFDLG1CQUFtQixDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLENBQUM7R0FDekUsTUFBTTtBQUNMLDhDQUFrQixJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQztHQUM3Qzs7QUFFRCxNQUFJLENBQUMsbUJBQW1CLENBQUMsR0FBRyxHQUFHLE9BQU8sR0FBRyxJQUFJLENBQUM7QUFDOUMsTUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksR0FBRyxRQUFRLEdBQUcsSUFBSSxDQUFDOzs7QUFHaEQsTUFBSSxhQUFhLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsaUJBQWlCLEVBQUU7TUFDckcsY0FBYyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLGlCQUFpQixFQUFFLENBQUM7O0FBRXpHLE1BQUksS0FBSyxHQUFHLG1DQUFXLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7O0FBRXBDLE1BQUksUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLDBCQUEwQixDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNqRixNQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLFlBQVksR0FBRyxDQUFDLENBQUM7O0FBRXRDLE1BQUksU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsMkJBQTJCLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDOztBQUVoRyxNQUFNLGlCQUFpQixHQUFHLHlDQUFpQixJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7O0FBRXBELE1BQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLFFBQVEsR0FBRyxpQkFBaUIsQ0FBQyxRQUFRLENBQUM7QUFDMUQsTUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsVUFBVSxHQUFHLGlCQUFpQixDQUFDLFVBQVUsQ0FBQzs7QUFFOUQsTUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsZUFBZSxHQUFHLEVBQUUsQ0FBQzs7QUFFekMsTUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsZUFBZSxHQUFHLGVBQWUsR0FBRyxlQUFlLEdBQUcseUNBQWlCLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxlQUFlLENBQUM7O0FBRTFILE1BQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUU7QUFDbEMsYUFBUyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQztBQUN0QyxhQUFTLEVBQUUsU0FBUztBQUNwQixZQUFRLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDO0FBQ25DLFlBQVEsRUFBRSxRQUFRO0dBQ25CLEVBQUUsSUFBSSxDQUFDLENBQUM7O0FBRVQsTUFBSSxDQUFDLG1CQUFtQixDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7Q0FDNUMsQ0FBQzs7QUFFRixVQUFVLENBQUMsU0FBUyxDQUFDLFVBQVUsR0FBRyxZQUFXO0FBQzNDLE1BQUksTUFBTSxHQUFHLElBQUksQ0FBQzs7QUFFbEIsTUFBSSxDQUFDLFlBQVksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEtBQUssRUFBRSxVQUFTLEtBQUssRUFBRTtBQUN2RSwwQ0FBZ0IsS0FBSyxDQUFDLENBQUM7R0FDeEIsQ0FBQyxDQUFDOztBQUVILE1BQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxPQUFPLEVBQUUsVUFBUyxLQUFLLEVBQUU7QUFDekUsMENBQWdCLEtBQUssQ0FBQyxDQUFDO0dBQ3hCLENBQUMsQ0FBQzs7QUFFSCxNQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyx1QkFBdUIsRUFBRSxZQUFXO0FBQ3hELFVBQU0sQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO0dBQzVCLENBQUMsQ0FBQzs7QUFFSCxNQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxtQkFBbUIsRUFBRSxZQUFXO0FBQ3BELFVBQU0sQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO0FBQzNCLFVBQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQztHQUNoQixDQUFDLENBQUM7O0FBRUgsTUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLEVBQUUsWUFBVztBQUNqRCxVQUFNLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztBQUMzQixVQUFNLENBQUMsS0FBSyxFQUFFLENBQUM7R0FDaEIsQ0FBQyxDQUFDOztBQUVILE1BQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLGNBQWMsRUFBRSxZQUFXO0FBQy9DLFVBQU0sQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLENBQUM7R0FDL0IsQ0FBQyxDQUFDO0NBQ0osQ0FBQzs7QUFFRixVQUFVLENBQUMsU0FBUyxDQUFDLE9BQU8sR0FBRyxZQUFXO0FBQ3hDLE1BQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLENBQUM7Q0FDN0IsQ0FBQzs7UUFFTSxVQUFVLEdBQVYsVUFBVTs7QUFFbEIsNkJBQWUsTUFBTSxFQUFFLFVBQVUsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7O2lDQ3pXQSx1QkFBdUI7OzhCQUNaLG1CQUFtQjs7Ozs7Ozs7OztJQVUzRCxZQUFZOzs7OztBQUlMLFdBSlAsWUFBWSxHQUlZO1FBQWhCLE9BQU8seURBQUcsSUFBSTs7MEJBSnRCLFlBQVk7O0FBS2QsUUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLElBQUksSUFBSSxDQUFDOztBQUUvQixRQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLEVBQUU7QUFDaEMsVUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLEdBQUcsRUFBRSxDQUFDO0tBQ2xDO0dBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQVZHLFlBQVk7O1dBb0JBLDBCQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFOzs7QUFDN0MsVUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQzs7QUFFM0IsZUFBUyxhQUFhLENBQUMsS0FBSyxFQUFFO0FBQzVCLFlBQUksS0FBSyxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUMsVUFBVSxJQUFJLEtBQUssQ0FBQyxFQUFFO0FBQ3hELGNBQUksS0FBSyxDQUFDLGFBQWEsRUFBRTtBQUN2QixpQkFBSyxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUU7QUFDNUIsbUJBQUssRUFBRSxLQUFLLENBQUMsVUFBVTthQUN4QixDQUFDLENBQUM7V0FDSixNQUFNO0FBQ0wsaUJBQUssQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDLFVBQVUsQ0FBQztXQUNqQztTQUNGO0FBQ0QsWUFBSSxLQUFLLENBQUMsY0FBYyxJQUFJLEtBQUssQ0FBQyxFQUFFO0FBQ2xDLGNBQUksS0FBSyxDQUFDLGFBQWEsRUFBRTtBQUN2QixpQkFBSyxDQUFDLGFBQWEsQ0FBQyxnQkFBZ0IsRUFBRTtBQUNwQyxtQkFBSyxFQUFFLGlCQUFXO0FBQ2hCLG9CQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQztlQUMxQjthQUNGLENBQUMsQ0FBQztXQUNKLE1BQU07QUFDTCxpQkFBSyxDQUFDLGNBQWMsR0FBRyxZQUFZO0FBQ2pDLGtCQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQzthQUMxQixDQUFDO1dBQ0g7U0FDRjtBQUNELGFBQUssR0FBRyxXQUFXLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDOzs7QUFHcEMsZ0JBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO09BQzVCO0FBQ0QsVUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDO0FBQy9CLGVBQU8sRUFBRSxPQUFPO0FBQ2hCLGFBQUssRUFBRSxTQUFTO0FBQ2hCLGdCQUFRLEVBQUUsUUFBUTtBQUNsQixxQkFBYSxFQUFFLGFBQWE7T0FDN0IsQ0FBQyxDQUFDOztBQUVILFVBQUksTUFBTSxDQUFDLGdCQUFnQixFQUFFO0FBQzNCLGVBQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsYUFBYSxFQUFFLEtBQUssQ0FBQyxDQUFDO09BQzNELE1BQU07QUFDTCxlQUFPLENBQUMsV0FBVyxDQUFDLElBQUksR0FBRyxTQUFTLEVBQUUsYUFBYSxDQUFDLENBQUM7T0FDdEQ7QUFDRCxrQkFBWSxDQUFDLDBCQUEwQixFQUFHLENBQUM7O0FBRTNDLGFBQU8sWUFBTTtBQUNYLGNBQUssbUJBQW1CLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxRQUFRLENBQUMsQ0FBQztPQUN4RCxDQUFDO0tBQ0g7Ozs7Ozs7Ozs7O1dBU2tCLDZCQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFO0FBQ2hELFVBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQztBQUM3QyxVQUFJLFFBQVEsWUFBQSxDQUFDOztBQUViLGFBQU8sR0FBRyxFQUFFLEVBQUU7QUFDWixnQkFBUSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxDQUFDOztBQUU1QyxZQUFJLFFBQVEsQ0FBQyxLQUFLLElBQUksU0FBUyxJQUFJLFFBQVEsQ0FBQyxPQUFPLElBQUksT0FBTyxFQUFFO0FBQzlELGNBQUksUUFBUSxJQUFJLFFBQVEsSUFBSSxRQUFRLENBQUMsUUFBUSxFQUFFO0FBQzdDLHFCQUFTO1dBQ1Y7QUFDRCxjQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDOztBQUUzQyxjQUFJLFFBQVEsQ0FBQyxPQUFPLENBQUMsbUJBQW1CLEVBQUU7QUFDeEMsb0JBQVEsQ0FBQyxPQUFPLENBQUMsbUJBQW1CLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsYUFBYSxFQUFFLEtBQUssQ0FBQyxDQUFDO1dBQ3JGLE1BQU07QUFDTCxvQkFBUSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxHQUFHLFFBQVEsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1dBQzdFO0FBQ0Qsc0JBQVksQ0FBQywwQkFBMEIsRUFBRyxDQUFDO1NBQzVDO09BQ0Y7S0FDRjs7Ozs7Ozs7O1dBT1UsdUJBQUc7QUFDWixVQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRTtBQUNqQixlQUFPO09BQ1I7QUFDRCxVQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUM7O0FBRTdDLGFBQU8sR0FBRyxFQUFFLEVBQUU7QUFDWixZQUFJLE1BQUssR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQzs7QUFFN0MsWUFBSSxNQUFLLEVBQUU7QUFDVCxjQUFJLENBQUMsbUJBQW1CLENBQUMsTUFBSyxDQUFDLE9BQU8sRUFBRSxNQUFLLENBQUMsS0FBSyxFQUFFLE1BQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUN0RTtPQUNGO0tBQ0Y7Ozs7Ozs7V0FLSSxpQkFBRztBQUNOLFVBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztLQUNwQjs7Ozs7OztXQUtNLG1CQUFHO0FBQ1IsVUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0FBQ25CLFVBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO0tBQ3JCOzs7Ozs7Ozs7O1dBUVEsbUJBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRTtBQUM1QixVQUFJLE9BQU8sR0FBRztBQUNaLGVBQU8sRUFBRSxJQUFJO0FBQ2Isa0JBQVUsRUFBRyxTQUFTLEtBQUssV0FBVyxBQUFDO0FBQ3ZDLFlBQUksRUFBRSxNQUFNO0FBQ1osY0FBTSxFQUFFLENBQUM7QUFDVCxlQUFPLEVBQUUsQ0FBQztBQUNWLGVBQU8sRUFBRSxDQUFDO0FBQ1YsZUFBTyxFQUFFLENBQUM7QUFDVixlQUFPLEVBQUUsQ0FBQztBQUNWLGVBQU8sRUFBRSxLQUFLO0FBQ2QsY0FBTSxFQUFFLEtBQUs7QUFDYixnQkFBUSxFQUFFLEtBQUs7QUFDZixlQUFPLEVBQUUsS0FBSztBQUNkLGNBQU0sRUFBRSxDQUFDO0FBQ1QscUJBQWEsRUFBRSxTQUFTO09BQ3pCLENBQUM7QUFDRixVQUFJLEtBQUssQ0FBQzs7QUFFVixVQUFJLFFBQVEsQ0FBQyxXQUFXLEVBQUU7QUFDeEIsYUFBSyxHQUFHLFFBQVEsQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDNUMsYUFBSyxDQUFDLGNBQWMsQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsVUFBVSxFQUNqRSxPQUFPLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxNQUFNLEVBQzVCLE9BQU8sQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxPQUFPLEVBQ2xFLE9BQU8sQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxPQUFPLEVBQ2xFLE9BQU8sQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLGFBQWEsSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO09BRXRFLE1BQU07QUFDTCxhQUFLLEdBQUcsUUFBUSxDQUFDLGlCQUFpQixFQUFFLENBQUM7T0FDdEM7O0FBRUQsVUFBSSxPQUFPLENBQUMsYUFBYSxFQUFFO0FBQ3pCLGVBQU8sQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7T0FDOUIsTUFBTTtBQUNMLGVBQU8sQ0FBQyxTQUFTLENBQUMsSUFBSSxHQUFHLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQztPQUM1QztLQUNGOzs7U0FqTEcsWUFBWTs7O0FBMExsQixTQUFTLFdBQVcsQ0FBQyxPQUFPLEVBQUUsS0FBSyxFQUFFO0FBQ25DLE1BQUksYUFBYSxHQUFHLFdBQVcsQ0FBQztBQUNoQyxNQUFJLGlCQUFpQixZQUFBLENBQUM7QUFDdEIsTUFBSSxXQUFXLFlBQUEsQ0FBQztBQUNoQixNQUFJLFVBQVUsWUFBQSxDQUFDO0FBQ2YsTUFBSSxNQUFNLFlBQUEsQ0FBQztBQUNYLE1BQUksR0FBRyxZQUFBLENBQUM7O0FBRVIsT0FBSyxDQUFDLG9CQUFvQixHQUFHLEtBQUssQ0FBQztBQUNuQyxPQUFLLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7O0FBRWhDLE1BQUksQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDLGFBQWEsRUFBRTtBQUM1QyxXQUFPLEtBQUssQ0FBQztHQUNkO0FBQ0QsT0FBSyxHQUFHLG9DQUFZLEtBQUssQ0FBQyxDQUFDO0FBQzNCLEtBQUcsR0FBRyxLQUFLLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQzs7QUFFekMsU0FBTyxHQUFHLEVBQUcsRUFBRTtBQUNiLFFBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLEtBQUssYUFBYSxFQUFFO0FBQzlDLHVCQUFpQixHQUFHLElBQUksQ0FBQztLQUUxQixNQUFNLElBQUksaUJBQWlCLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxVQUFVLEVBQUU7QUFDMUQsWUFBTSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7O0FBRXpCLFlBQU07S0FDUDtBQUNELFFBQUksR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtBQUN4QixZQUFNLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUMxQjtHQUNGO0FBQ0QsTUFBSSxDQUFDLE1BQU0sRUFBRTtBQUNYLFVBQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDO0dBQ3ZCO0FBQ0QsT0FBSyxDQUFDLG9CQUFvQixHQUFHLElBQUksQ0FBQzs7QUFFbEMsTUFBSSxzREFBaUMsRUFBRTtBQUNyQyxTQUFLLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQyxVQUFVLElBQUksS0FBSyxDQUFDLFNBQVMsQ0FBQztHQUV4RCxNQUFNLElBQUksT0FBTyxZQUFZLFlBQVksQ0FBQyxJQUFJLElBQUksT0FBTyxZQUFZLFdBQVcsRUFBRTs7QUFFakYsUUFBSSxPQUFPLFlBQVksWUFBWSxDQUFDLElBQUksRUFBRTtBQUN4QyxpQkFBVyxHQUFHLE9BQU8sQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7S0FFbkUsTUFBTSxJQUFJLE9BQU8sWUFBWSxXQUFXLEVBQUU7O0FBRXpDLGlCQUFXLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQztLQUMzRDtBQUNELGNBQVUsR0FBRyxnQ0FBUSxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsYUFBYSxDQUFDLEVBQUUsV0FBVyxDQUFDLENBQUM7O0FBRWpFLFFBQUksVUFBVSxFQUFFO0FBQ2QsV0FBSyxDQUFDLFVBQVUsR0FBRyxXQUFXLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUM7S0FDN0UsTUFBTTtBQUNMLFdBQUssQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQztLQUNqQztHQUNGOztBQUVELFFBQU0sQ0FBQyxjQUFjLENBQUMsS0FBSyxFQUFFLFFBQVEsRUFBRTtBQUNyQyxPQUFHLEVBQUUsZUFBVztBQUNkLGFBQU8sb0NBQVksTUFBTSxDQUFDLENBQUM7S0FDNUI7QUFDRCxjQUFVLEVBQUUsSUFBSTtBQUNoQixnQkFBWSxFQUFFLElBQUk7R0FDbkIsQ0FBQyxDQUFDOztBQUVILFNBQU8sS0FBSyxDQUFDO0NBQ2Q7O1FBRU8sWUFBWSxHQUFaLFlBQVk7UUFBRSxZQUFZLEdBQVosWUFBWTs7QUFFbEMsTUFBTSxDQUFDLFlBQVksR0FBRyxNQUFNLENBQUMsWUFBWSxJQUFJLEVBQUUsQ0FBQzs7QUFFaEQsWUFBWSxDQUFDLDBCQUEwQixHQUFHLENBQUMsQ0FBQzs7QUFFNUMsWUFBWSxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7O0FBRXpDLFNBQVMsWUFBWSxDQUFDLE9BQU8sRUFBRTtBQUM3QixTQUFPLElBQUksWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0NBQ2xDOzs7Ozs7Ozs7Ozs7Ozs7O0FDbFJNLFNBQVMsU0FBUyxDQUFDLEdBQUcsRUFBRTtBQUM3QixNQUFJLENBQUMsR0FBRyxDQUFDO01BQ0wsSUFBSSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUM7QUFDdEIsU0FBTyxDQUFDLEdBQUcsSUFBSSxFQUFFO0FBQ2YsT0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbEIsS0FBQyxFQUFFLENBQUM7R0FDTDtDQUNGOztBQUVNLFNBQVMsV0FBVyxDQUFDLEdBQUcsRUFBRSxTQUFTLEVBQUU7QUFDMUMsTUFBSSxDQUFDLEdBQUcsQ0FBQztNQUNMLElBQUksR0FBRyxTQUFTLENBQUMsTUFBTSxDQUFDO0FBQzVCLFNBQU8sQ0FBQyxHQUFHLElBQUksRUFBRTtBQUNmLE9BQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdkIsS0FBQyxFQUFFLENBQUM7R0FDTDtDQUNGOztBQUVNLFNBQVMsS0FBSyxDQUFDLEdBQUcsRUFBRTtBQUN6QixNQUFJLFVBQVUsR0FBRyxFQUFFLENBQUM7O0FBRXBCLE1BQUcsQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUM7QUFDNUQsV0FBTyxVQUFVLENBQUM7R0FDbkI7O0FBRUQsTUFBSSxRQUFRLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQztBQUMxQixNQUFJLFFBQVEsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDOztBQUU3QixPQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxFQUFFLENBQUMsRUFBRSxFQUFDO0FBQy9CLFNBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLEVBQUUsQ0FBQyxFQUFFLEVBQUM7QUFDL0IsVUFBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFBQztBQUNoQixrQkFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztPQUNwQjs7QUFFRCxnQkFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUM5QjtHQUNGOztBQUVELFNBQU8sVUFBVSxDQUFDO0NBQ25COzs7Ozs7Ozs7Ozs7OztBQWNELFNBQVMsV0FBVyxDQUFDLEtBQUssRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLGFBQWEsRUFBRTtBQUNoRSxNQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7TUFDWixNQUFNLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQzs7QUFFeEIsTUFBSSxhQUFhLElBQUksTUFBTSxFQUFFO0FBQzNCLGVBQVcsR0FBRyxLQUFLLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztHQUM5QjtBQUNELFNBQU8sRUFBRSxLQUFLLEdBQUcsTUFBTSxFQUFFO0FBQ3ZCLGVBQVcsR0FBRyxRQUFRLENBQUMsV0FBVyxFQUFFLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7R0FDakU7O0FBRUQsU0FBTyxXQUFXLENBQUM7Q0FDcEI7Ozs7Ozs7Ozs7Ozs7QUFZTSxTQUFTLFdBQVcsQ0FBQyxLQUFLLEVBQUUsU0FBUyxFQUFFO0FBQzVDLE1BQUksS0FBSyxHQUFHLENBQUMsQ0FBQztNQUNaLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTTtNQUNyQixRQUFRLEdBQUcsQ0FBQyxDQUFDO01BQ2IsTUFBTSxHQUFHLEVBQUUsQ0FBQzs7QUFFZCxTQUFPLEVBQUUsS0FBSyxHQUFHLE1BQU0sRUFBRTtBQUN2QixRQUFJLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7O0FBRXpCLFFBQUksU0FBUyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLEVBQUU7QUFDbEMsWUFBTSxDQUFDLEVBQUUsUUFBUSxDQUFDLEdBQUcsS0FBSyxDQUFDO0tBQzVCO0dBQ0Y7O0FBRUQsU0FBTyxNQUFNLENBQUM7Q0FDZjs7Ozs7Ozs7Ozs7OztBQVlNLFNBQVMsU0FBUyxDQUFDLEtBQUssRUFBRSxRQUFRLEVBQUU7QUFDekMsTUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO01BQ1osTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7O0FBRXhCLFNBQU8sRUFBRSxLQUFLLEdBQUcsTUFBTSxFQUFFO0FBQ3ZCLFFBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLEtBQUssS0FBSyxFQUFFO0FBQ2xELFlBQU07S0FDUDtHQUNGOztBQUVELFNBQU8sS0FBSyxDQUFDO0NBQ2Q7Ozs7Ozs7OztBQVFNLFNBQVMsUUFBUSxDQUFDLEtBQUssRUFBRTtBQUM5QixTQUFPLFdBQVcsQ0FBQyxLQUFLLEVBQUUsVUFBQyxDQUFDLEVBQUUsQ0FBQztXQUFNLENBQUMsR0FBRyxDQUFDO0dBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztDQUNqRDs7Ozs7Ozs7O0FBUU0sU0FBUyxRQUFRLENBQUMsS0FBSyxFQUFFO0FBQzlCLE1BQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFO0FBQ2pCLFdBQU8sQ0FBQyxDQUFDO0dBQ1Y7O0FBRUQsU0FBTyxRQUFRLENBQUMsS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQztDQUN2Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzSUQsSUFBSSxNQUFNLEdBQUcsQ0FBRSxRQUFRLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDLFdBQVcsQUFBQyxDQUFDOztBQUVyRCxTQUFTLEtBQUssR0FBRztBQUN0QixTQUFPLE1BQU0sQ0FBQztDQUNmOztBQUVELElBQUksTUFBTSxHQUFHLENBQUMsQ0FBRSxRQUFRLENBQUMsWUFBWSxBQUFDLENBQUM7O0FBRWhDLFNBQVMsS0FBSyxHQUFHO0FBQ3RCLFNBQU8sTUFBTSxDQUFDO0NBQ2Y7O0FBRUQsSUFBSSxTQUFTLEdBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLElBQUksZ0JBQWdCLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQUFBQyxDQUFDOztBQUV6RixTQUFTLFFBQVEsR0FBRztBQUN6QixTQUFPLFNBQVMsQ0FBQztDQUNsQjs7QUFFRCxJQUFJLFNBQVMsR0FBSSxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQUFBQyxDQUFDOztBQUVqRixTQUFTLFFBQVEsR0FBRztBQUN6QixTQUFPLFNBQVMsQ0FBQztDQUNsQjs7QUFFTSxTQUFTLGVBQWUsQ0FBQyxTQUFTLEVBQUU7QUFDekMsTUFBSSxDQUFDLFNBQVMsRUFBRTtBQUNkLGFBQVMsR0FBRyxTQUFTLENBQUMsU0FBUyxDQUFDO0dBQ2pDOztBQUVELFNBQVEsaUVBQWdFLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQztJQUFFO0NBQzNGOztBQUVNLFNBQVMsZ0JBQWdCLEdBQUc7QUFDakMsU0FBUSxjQUFjLElBQUksTUFBTSxDQUFFO0NBQ25DOzs7Ozs7OztBQU9NLFNBQVMsK0JBQStCLEdBQUc7QUFDaEQsTUFBSSxJQUFJLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQzs7QUFFekMsU0FBTyxJQUFJLENBQUMsZ0JBQWdCLElBQUksSUFBSSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLElBQUksR0FBRyxLQUFLLENBQUM7Q0FDMUc7O0FBRUQsSUFBSSxrQkFBa0IsQ0FBQzs7QUFFdkIsU0FBUyxvQkFBb0IsR0FBRztBQUM5QixNQUFJLEtBQUssR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzVDLE9BQUssQ0FBQyxLQUFLLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQztBQUM5QixPQUFLLENBQUMsS0FBSyxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUM7QUFDNUIsT0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDO0FBQ3hCLE1BQUksS0FBSyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDNUMsT0FBSyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN6QixPQUFLLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUNoRCxPQUFLLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDM0QsT0FBSyxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsU0FBUyxHQUFHLDBCQUEwQixDQUFDOztBQUVuRSxNQUFJLE9BQU8sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ2hELFNBQU8sQ0FBQyxTQUFTLEdBQUcsa0JBQWtCLENBQUM7QUFDdkMsU0FBTyxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDO0FBQzFCLFNBQU8sQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztBQUN6QixPQUFLLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQzs7QUFFbkMsVUFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDakMsb0JBQWtCLEdBQUksS0FBSyxDQUFDLFlBQVksR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQyxZQUFZLEFBQUMsQ0FBQztBQUM3RSxVQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztDQUNsQzs7QUFFTSxTQUFTLGlCQUFpQixHQUFHO0FBQ2xDLE1BQUksa0JBQWtCLEtBQUssS0FBSyxDQUFDLEVBQUU7QUFDakMsd0JBQW9CLEVBQUUsQ0FBQztHQUN4Qjs7QUFFRCxTQUFPLGtCQUFrQixDQUFDO0NBQzNCOzs7Ozs7Ozs7Ozs7OztzQkM3RTRCLFVBQVU7Ozs7Ozs7O0FBT2hDLFNBQVMsc0JBQXNCLENBQUMsS0FBSyxFQUFFO0FBQzVDLE1BQUksUUFBUSxHQUFHLEtBQUssR0FBRyxDQUFDLENBQUM7QUFDekIsTUFBSSxXQUFXLEdBQUcsRUFBRSxDQUFDO0FBQ3JCLE1BQUksTUFBTSxDQUFDO0FBQ1gsU0FBTyxRQUFRLEdBQUcsQ0FBQyxFQUFFO0FBQ25CLFVBQU0sR0FBRyxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUEsR0FBSSxFQUFFLENBQUM7QUFDN0IsZUFBVyxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsRUFBRSxHQUFHLE1BQU0sQ0FBQyxHQUFHLFdBQVcsQ0FBQztBQUM3RCxZQUFRLEdBQUcsUUFBUSxDQUFDLENBQUMsUUFBUSxHQUFHLE1BQU0sQ0FBQSxHQUFJLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztHQUNuRDtBQUNELFNBQU8sV0FBVyxDQUFDO0NBQ3BCOzs7Ozs7Ozs7QUFRTSxTQUFTLHFCQUFxQixDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUU7QUFDeEQsVUFBUSxHQUFHLE9BQU8sUUFBUSxLQUFLLFFBQVEsR0FBRyxRQUFRLEdBQUcsR0FBRyxDQUFDO0FBQ3pELFVBQVEsR0FBRyxPQUFPLFFBQVEsS0FBSyxRQUFRLEdBQUcsUUFBUSxHQUFHLENBQUMsQ0FBQzs7QUFFdkQsTUFBSSxJQUFJLEdBQUcsRUFBRTtNQUNULENBQUM7TUFDRCxDQUFDLENBQUM7O0FBRU4sT0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDN0IsUUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFDO0FBQ2IsU0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDN0IsU0FBRyxDQUFDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFBLEFBQUMsQ0FBQyxDQUFDO0tBQy9DO0FBQ0QsUUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztHQUNoQjtBQUNELFNBQU8sSUFBSSxDQUFDO0NBQ2I7O0FBRU0sU0FBUywyQkFBMkIsQ0FBQyxRQUFRLEVBQUUsUUFBUSxFQUFFO0FBQzlELFVBQVEsR0FBRyxPQUFPLFFBQVEsS0FBSyxRQUFRLEdBQUcsUUFBUSxHQUFHLEdBQUcsQ0FBQztBQUN6RCxVQUFRLEdBQUcsT0FBTyxRQUFRLEtBQUssUUFBUSxHQUFHLFFBQVEsR0FBRyxDQUFDLENBQUM7O0FBRXZELE1BQUksSUFBSSxHQUFHLEVBQUU7TUFDVCxDQUFDO01BQ0QsQ0FBQyxDQUFDOztBQUVOLE9BQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzdCLFFBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQztBQUNiLFNBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzdCLFNBQUcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEdBQUcsc0JBQXNCLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQSxBQUFDLENBQUM7S0FDdkQ7QUFDRCxRQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0dBQ2hCO0FBQ0QsU0FBTyxJQUFJLENBQUM7Q0FDYjs7QUFFTSxTQUFTLHNCQUFzQixDQUFDLEtBQUssRUFBRTtBQUM1QyxNQUFJLENBQUM7TUFDRCxJQUFJO01BQ0osQ0FBQztNQUNELElBQUk7TUFDSixNQUFNLEdBQUcsRUFBRTtNQUNYLElBQUksR0FBRyxDQUFDLENBQUM7O0FBRWIsT0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxJQUFJLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDOUMsU0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLElBQUksR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUMsR0FBRyxJQUFJLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDakQsVUFBSSxDQUFDLElBQUksSUFBSSxFQUFFO0FBQ2IsY0FBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUNoQixZQUFJLEVBQUUsQ0FBQztPQUNSO0FBQ0QsWUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUM3QjtHQUNGO0FBQ0QsU0FBTyxNQUFNLENBQUM7Q0FDZjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQk0sU0FBUyx1QkFBdUIsQ0FBQyxVQUFVLEVBQUUsY0FBYyxFQUFFOztBQUVsRSxnQkFBYyxHQUFHLE9BQU8sY0FBYyxJQUFJLFdBQVcsR0FBRyxJQUFJLEdBQUcsY0FBYyxDQUFDOztBQUU5RSxTQUFPLFNBQVMsZ0JBQWdCLENBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRTs7QUFFMUMsV0FBTyxDQUFDLFNBQVMsdUJBQXVCOzs7Z0NBQWE7WUFBWixVQUFVO0FBYTNDLFlBQUk7OztBQVhWLFlBQUksQ0FBQyxVQUFVLEVBQUM7O0FBRWQsaUJBQU87U0FFUixNQUNJLElBQUksVUFBVSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsSUFBSSxVQUFVLENBQUMsVUFBVSxDQUFDLEtBQUssS0FBSyxDQUFDLEVBQUU7OztBQUVuRixtQkFBTyxVQUFVLENBQUMsVUFBVSxDQUFDLENBQUM7V0FFL0IsTUFBTSxJQUFJLFVBQVUsQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLElBQUksVUFBVSxDQUFDLElBQUksRUFBRTs7O0FBRS9ELGtCQUFJLElBQUksQ0FBQzs7QUFFVCxrQkFBRyxPQUFPLFVBQVUsQ0FBQyxJQUFJLElBQUksUUFBUSxFQUFFO0FBQ3JDLHNCQUFNLElBQUksS0FBSyxDQUFDLDZCQUE2QixDQUFDLENBQUM7ZUFDaEQ7O0FBRUQsa0JBQUksR0FBRyx5QkFBeUIsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7O0FBRWxELGtCQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLEVBQUU7QUFDbkMsdUJBQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2VBQ3pCLE1BQU0sSUFBSSxjQUFjLEVBQUU7QUFDekIseUJBQU87aUJBQ1I7YUFFRjs7YUFFOEIsNEJBQWUsVUFBVSxDQUFDOzs7T0FFMUQ7TUFBQSxDQUFFLE9BQU8sR0FBRyxJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztHQUUvRCxDQUFDOztBQUVGLFdBQVMseUJBQXlCLENBQUMsUUFBUSxFQUFFO0FBQzNDLFFBQUksSUFBSSxHQUFHLFlBQVksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUM7O0FBRTVDLFFBQUcsT0FBTyxJQUFJLElBQUksV0FBVyxFQUFDO0FBQzVCLFlBQU0sSUFBSSxLQUFLLENBQUMsMEJBQTBCLEdBQUcsUUFBUSxHQUFHLHNEQUFzRCxHQUM1Ryx1RkFBdUYsQ0FBQyxDQUFDO0tBQzVGOztBQUVELFdBQU8sSUFBSSxDQUFDO0dBQ2I7Q0FDRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUJDckp1RCxZQUFZOzs7Ozs7Ozs7Ozs7QUFXN0QsU0FBUyxPQUFPLENBQUMsT0FBTyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUU7QUFDN0MsU0FBTyxPQUFPLElBQUksSUFBSSxJQUFJLE9BQU8sS0FBSyxLQUFLLEVBQUU7QUFDM0MsUUFBSSxPQUFPLENBQUMsUUFBUSxLQUFLLElBQUksQ0FBQyxZQUFZLEtBQ3ZDLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUEsQUFBQyxFQUFFO0FBQ3ZFLGFBQU8sT0FBTyxDQUFDO0tBQ2hCO0FBQ0QsUUFBSSxPQUFPLENBQUMsSUFBSSxJQUFJLE9BQU8sQ0FBQyxRQUFRLEtBQUssSUFBSSxDQUFDLHNCQUFzQixFQUFFO0FBQ3BFLGFBQU8sR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDO0tBRXhCLE1BQU07QUFDTCxhQUFPLEdBQUcsT0FBTyxDQUFDLFVBQVUsQ0FBQztLQUM5QjtHQUNGOztBQUVELFNBQU8sSUFBSSxDQUFDO0NBQ2I7Ozs7Ozs7Ozs7O0FBVU0sU0FBUyxTQUFTLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRTtBQUN2QyxNQUFJLElBQUksR0FBRyxLQUFLLENBQUMsVUFBVSxDQUFDO0FBQzVCLE1BQUksY0FBYyxHQUFHLEVBQUUsQ0FBQzs7QUFFeEIsTUFBSSxPQUFPLE1BQU0sS0FBSyxRQUFRLEVBQUU7QUFDOUIsa0JBQWMsR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0dBQ25GLE1BQU07QUFDTCxrQkFBYyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztHQUM3Qjs7QUFFRCxTQUFPLElBQUksSUFBSSxJQUFJLEVBQUU7QUFDbkIsUUFBSSxjQUFjLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO0FBQ3JDLGFBQU8sSUFBSSxDQUFDO0tBQ2I7QUFDRCxRQUFJLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQztHQUN4QjtBQUNELFNBQU8sS0FBSyxDQUFDO0NBQ2Q7Ozs7Ozs7OztBQVFNLFNBQVMsMEJBQTBCLENBQUMsT0FBTyxFQUFFO0FBQ2xELE1BQUksWUFBWSxHQUFHLFdBQVc7TUFDNUIsTUFBTSxHQUFHLEtBQUs7TUFDZCxVQUFVLENBQUM7O0FBRWIsWUFBVSxHQUFHLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQzs7QUFFbEMsV0FBUyxVQUFVLENBQUMsT0FBTyxFQUFFO0FBQzNCLFdBQU8sT0FBTyxDQUFDLFFBQVEsS0FBSyxJQUFJLENBQUMsWUFBWSxJQUFJLE9BQU8sQ0FBQyxRQUFRLEtBQUssWUFBWSxDQUFDLFdBQVcsRUFBRSxDQUFDO0dBQ2xHOztBQUVELFNBQU8sVUFBVSxJQUFJLElBQUksRUFBRTtBQUN6QixRQUFJLFVBQVUsQ0FBQyxVQUFVLENBQUMsRUFBRTtBQUMxQixZQUFNLEdBQUcsSUFBSSxDQUFDO0FBQ2QsWUFBTTtLQUNQLE1BQ0ksSUFBSSxVQUFVLENBQUMsSUFBSSxJQUFJLFVBQVUsQ0FBQyxRQUFRLEtBQUssSUFBSSxDQUFDLHNCQUFzQixFQUFFO0FBQy9FLFlBQU0sR0FBRyxVQUFVLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDOztBQUVyQyxVQUFJLE1BQU0sRUFBRTtBQUNWLGNBQU07T0FDUDtBQUNELGdCQUFVLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQztLQUM5QjtBQUNELGNBQVUsR0FBRyxVQUFVLENBQUMsVUFBVSxDQUFDO0dBQ3BDOztBQUVELFNBQU8sTUFBTSxDQUFDO0NBQ2Y7Ozs7Ozs7OztBQVFNLFNBQVMsV0FBVyxDQUFDLE9BQU8sRUFBRTs7QUFFbkMsU0FBTyxPQUFPLE9BQU8sS0FBSyxXQUFXLElBQUksT0FBTyxJQUFJLEtBQUssVUFBVSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxPQUFPLENBQUM7Q0FDL0Y7Ozs7Ozs7OztBQVFNLFNBQVMsYUFBYSxDQUFDLE9BQU8sRUFBRTs7QUFFckMsU0FBTyxPQUFPLE9BQU8sS0FBSyxXQUFXLElBQUksT0FBTyxNQUFNLEtBQUssVUFBVSxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxPQUFPLENBQUM7Q0FDbkc7Ozs7Ozs7Ozs7OztBQVdNLFNBQVMsS0FBSyxDQUFDLE9BQU8sRUFBRTtBQUM3QixNQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7O0FBRVYsTUFBSSxPQUFPLENBQUMsZUFBZSxFQUFFOztBQUUzQixXQUFPLE9BQU8sR0FBRyxPQUFPLENBQUMsZUFBZSxFQUFFO0FBQ3hDLFFBQUUsQ0FBQyxDQUFDO0tBQ0w7O0dBRUY7O0FBRUQsU0FBTyxDQUFDLENBQUM7Q0FDVjs7Ozs7Ozs7OztBQVNNLFNBQVMsc0JBQXNCLENBQUMsV0FBVyxFQUFFLE9BQU8sRUFBRTtBQUMzRCxNQUFJLGNBQWMsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFlBQVksR0FBRyxXQUFXLENBQUMsQ0FBQztBQUN4RSxTQUFPLGNBQWMsR0FBRyxjQUFjLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQztDQUNqRTs7QUFFRCxJQUFJLGdCQUFnQixHQUFHLFFBQVEsQ0FBQyxlQUFlLENBQUMsU0FBUyxHQUFHLElBQUksR0FBRyxLQUFLLENBQUM7QUFDekUsSUFBSSxTQUFTLEVBQUUsU0FBUyxFQUFFLFlBQVksQ0FBQzs7QUFFdkMsU0FBUyxxQkFBcUIsQ0FBQyxVQUFVLEVBQUU7QUFDekMsTUFBSSxHQUFHLEdBQUcsQ0FBQztNQUFFLE1BQU0sR0FBRyxFQUFFLENBQUM7O0FBRXpCLE1BQUksQ0FBQyxVQUFVLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFO0FBQ3JDLFdBQU8sTUFBTSxDQUFDO0dBQ2Y7QUFDRCxTQUFPLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRTtBQUN0QixVQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQzdCLE9BQUcsRUFBRSxDQUFDO0dBQ1A7O0FBRUQsU0FBTyxNQUFNLENBQUM7Q0FDZjs7QUFFRCxJQUFJLGdCQUFnQixFQUFFO0FBQ3BCLE1BQUksMkJBQTJCLEdBQUksQ0FBQSxZQUFZO0FBQzdDLFFBQUksT0FBTyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7O0FBRTVDLFdBQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQzs7QUFFdkMsV0FBTyxPQUFPLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztHQUM1QyxDQUFBLEVBQUUsQUFBQyxDQUFDOztBQUVMLFdBQVMsR0FBRyxTQUFTLFNBQVMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxFQUFFO0FBQ2pELFFBQUksU0FBUyxLQUFLLEVBQUUsRUFBRTtBQUNwQixhQUFPLEtBQUssQ0FBQztLQUNkOztBQUVELFdBQU8sT0FBTyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUM7R0FDOUMsQ0FBQzs7QUFFRixXQUFTLEdBQUcsU0FBUyxTQUFTLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRTtBQUNqRCxRQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7O0FBRVosUUFBSSxPQUFPLFNBQVMsS0FBSyxRQUFRLEVBQUU7QUFDakMsZUFBUyxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDbEM7QUFDRCxhQUFTLEdBQUcscUJBQXFCLENBQUMsU0FBUyxDQUFDLENBQUM7O0FBRTdDLFFBQUksMkJBQTJCLEVBQUU7QUFDL0IsYUFBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUM7S0FFM0QsTUFBTTtBQUNMLGFBQU8sU0FBUyxJQUFJLFNBQVMsQ0FBQyxHQUFHLENBQUMsRUFBRTtBQUNsQyxlQUFPLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUN0QyxXQUFHLEVBQUUsQ0FBQztPQUNQO0tBQ0Y7R0FDRixDQUFDOztBQUVGLGNBQVksR0FBRyxTQUFTLFlBQVksQ0FBQyxPQUFPLEVBQUUsU0FBUyxFQUFFO0FBQ3ZELFFBQUksR0FBRyxHQUFHLENBQUMsQ0FBQzs7QUFFWixRQUFJLE9BQU8sU0FBUyxLQUFLLFFBQVEsRUFBRTtBQUNqQyxlQUFTLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUNsQztBQUNELGFBQVMsR0FBRyxxQkFBcUIsQ0FBQyxTQUFTLENBQUMsQ0FBQzs7QUFFN0MsUUFBSSwyQkFBMkIsRUFBRTtBQUMvQixhQUFPLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQztLQUU5RCxNQUFNO0FBQ0wsYUFBTyxTQUFTLElBQUksU0FBUyxDQUFDLEdBQUcsQ0FBQyxFQUFFO0FBQ2xDLGVBQU8sQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ3pDLFdBQUcsRUFBRSxDQUFDO09BQ1A7S0FDRjtHQUNGLENBQUM7Q0FFSCxNQUFNO0FBQ0wsTUFBSSxxQkFBcUIsR0FBRyxTQUFTLHFCQUFxQixDQUFDLFNBQVMsRUFBRTtBQUNwRSxXQUFPLElBQUksTUFBTSxDQUFDLFNBQVMsR0FBRyxTQUFTLEdBQUcsU0FBUyxDQUFDLENBQUM7R0FDdEQsQ0FBQzs7QUFFRixXQUFTLEdBQUcsU0FBUyxTQUFTLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRTs7QUFFakQsV0FBTyxPQUFPLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBRyxLQUFLLENBQUM7R0FDakYsQ0FBQzs7QUFFRixXQUFTLEdBQUcsU0FBUyxTQUFTLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRTtBQUNqRCxRQUFJLEdBQUcsR0FBRyxDQUFDO1FBQ1QsVUFBVSxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUM7O0FBRWpDLFFBQUksT0FBTyxTQUFTLEtBQUssUUFBUSxFQUFFO0FBQ2pDLGVBQVMsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQ2xDO0FBQ0QsUUFBSSxVQUFVLEtBQUssRUFBRSxFQUFFO0FBQ3JCLGdCQUFVLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUVsQyxNQUFNO0FBQ0wsYUFBTyxTQUFTLElBQUksU0FBUyxDQUFDLEdBQUcsQ0FBQyxFQUFFO0FBQ2xDLFlBQUksQ0FBQyxxQkFBcUIsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUU7QUFDM0Qsb0JBQVUsSUFBSSxHQUFHLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3BDO0FBQ0QsV0FBRyxFQUFFLENBQUM7T0FDUDtLQUNGO0FBQ0QsV0FBTyxDQUFDLFNBQVMsR0FBRyxVQUFVLENBQUM7R0FDaEMsQ0FBQzs7QUFFRixjQUFZLEdBQUcsU0FBUyxZQUFZLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRTtBQUN2RCxRQUFJLEdBQUcsR0FBRyxDQUFDO1FBQ1QsVUFBVSxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUM7O0FBRWpDLFFBQUksT0FBTyxTQUFTLEtBQUssUUFBUSxFQUFFO0FBQ2pDLGVBQVMsR0FBRyxTQUFTLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQ2xDO0FBQ0QsV0FBTyxTQUFTLElBQUksU0FBUyxDQUFDLEdBQUcsQ0FBQyxFQUFFOztBQUVsQyxnQkFBVSxHQUFHLFVBQVUsQ0FBQyxPQUFPLENBQUMscUJBQXFCLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7QUFDbkYsU0FBRyxFQUFFLENBQUM7S0FDUDtBQUNELFFBQUksT0FBTyxDQUFDLFNBQVMsS0FBSyxVQUFVLEVBQUU7QUFDcEMsYUFBTyxDQUFDLFNBQVMsR0FBRyxVQUFVLENBQUM7S0FDaEM7R0FDRixDQUFDO0NBQ0g7Ozs7Ozs7Ozs7QUFTTSxTQUFTLFFBQVEsQ0FBQyxPQUFPLEVBQUUsU0FBUyxFQUFFO0FBQzNDLFNBQU8sU0FBUyxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQztDQUN0Qzs7Ozs7Ozs7O0FBUU0sU0FBUyxRQUFRLENBQUMsT0FBTyxFQUFFLFNBQVMsRUFBRTtBQUMzQyxTQUFPLFNBQVMsQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUM7Q0FDdEM7Ozs7Ozs7OztBQVFNLFNBQVMsV0FBVyxDQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUU7QUFDOUMsU0FBTyxZQUFZLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0NBQ3pDOztBQUVNLFNBQVMsZUFBZSxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUU7QUFDL0MsTUFBSSxPQUFPLENBQUMsUUFBUSxLQUFLLENBQUMsRUFBRTtBQUMxQixVQUFNLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0dBQzdCLE1BQ0ksSUFBSSxDQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO0FBQ2xGLFVBQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUM7QUFDaEMsV0FBSyxJQUFJLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQzNDLHVCQUFlLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDO09BQ3JDO0tBQ0Y7Q0FDRjs7Ozs7Ozs7Ozs7OztBQVlNLFNBQVMsS0FBSyxDQUFDLE9BQU8sRUFBRTtBQUM3QixNQUFJLEtBQUssQ0FBQzs7QUFFVixTQUFPLEtBQUssR0FBRyxPQUFPLENBQUMsU0FBUyxFQUFFO0FBQ2hDLFdBQU8sQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7R0FDNUI7O0NBRUY7O0FBRU0sSUFBSSxlQUFlLEdBQUcsaUJBQWlCLENBQUM7Ozs7Ozs7O0FBTXhDLFNBQVMsYUFBYSxDQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUU7QUFDOUMsTUFBSSxlQUFlLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFO0FBQ2pDLFdBQU8sQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDO0dBQzdCLE1BQ0k7QUFDSCxpQkFBYSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztHQUNqQztDQUNGOzs7Ozs7O0FBT0QsSUFBSSxrQkFBa0IsR0FBRyxRQUFRLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDLFdBQVcsR0FBRyxJQUFJLEdBQUcsS0FBSyxDQUFDOztBQUU3RSxTQUFTLGFBQWEsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFO0FBQzlDLE1BQUksS0FBSyxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUM7O0FBRS9CLE1BQUksS0FBSyxJQUFJLEtBQUssQ0FBQyxRQUFRLEtBQUssQ0FBQyxJQUFJLEtBQUssQ0FBQyxXQUFXLEtBQUssSUFBSSxFQUFFOzs7QUFHL0QsUUFBSSxrQkFBa0IsRUFBRTs7QUFFdEIsV0FBSyxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUM7S0FDN0IsTUFBTTs7QUFFTCxXQUFLLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQztLQUN0QjtHQUNGLE1BQ0k7O0FBRUgsU0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ2YsV0FBTyxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7R0FDdkQ7Q0FDRjs7Ozs7Ozs7QUFPTSxTQUFTLFNBQVM7Ozs0QkFBTztRQUFOLElBQUk7QUFDeEIsUUFBSTs7O0FBQVIsUUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDOztBQUVoQixXQUFPLGFBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxRQUFRLENBQUMsZUFBZSxFQUFFOztBQUN2RCxVQUFJLElBQUksS0FBSyxJQUFJLEVBQUU7O0FBQ2pCLGVBQU8sS0FBSyxDQUFDO09BQ2QsTUFDSSxJQUFJLElBQUksQ0FBQyxRQUFRLEtBQUssSUFBSSxDQUFDLHNCQUFzQixFQUFFO0FBQ3RELFlBQUksSUFBSSxDQUFDLElBQUksRUFBRTs7OztBQUdiLGNBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUU7O2lCQUNELElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSTs7O1dBQ2hDLE1BQ0ksSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFOztpQkFDRCxJQUFJLENBQUMsSUFBSTs7O1dBQzNCLE1BQ0k7QUFDSCxrQkFBTSxJQUFJLEtBQUssQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDO1dBQ2pEO1NBQ0YsTUFDSTtBQUNILGlCQUFPLEtBQUssQ0FBQztTQUNkO09BQ0YsTUFDSSxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxLQUFLLE1BQU0sRUFBRTtBQUN0QyxpQkFBTyxLQUFLLENBQUM7U0FDZDtBQUNELFVBQUksR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDO0tBQ3hCOztBQUVELFdBQU8sSUFBSSxDQUFDO0dBQ2I7Q0FBQTs7Ozs7Ozs7O0FBUU0sU0FBUyxNQUFNLENBQUMsSUFBSSxFQUFFO0FBQzNCLE1BQUksVUFBVSxFQUNaLFNBQVMsRUFDVCxRQUFRLEVBQ1IsT0FBTyxFQUNQLEdBQUcsQ0FBQzs7QUFFTixTQUFPLEdBQUcsUUFBUSxDQUFDLGVBQWUsQ0FBQzs7QUFFbkMsTUFBSSxpQ0FBbUIsSUFBSSxJQUFJLENBQUMsVUFBVSxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxLQUFLLFNBQVMsRUFBRTs7O0FBR3BGLE9BQUcsR0FBRyxJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQzs7QUFFbkMsV0FBTztBQUNMLFNBQUcsRUFBRSxHQUFHLENBQUMsR0FBRyxJQUFJLE1BQU0sQ0FBQyxXQUFXLElBQUksT0FBTyxDQUFDLFNBQVMsQ0FBQSxBQUFDLElBQUksT0FBTyxDQUFDLFNBQVMsSUFBSSxDQUFDLENBQUEsQUFBQztBQUNuRixVQUFJLEVBQUUsR0FBRyxDQUFDLElBQUksSUFBSSxNQUFNLENBQUMsV0FBVyxJQUFJLE9BQU8sQ0FBQyxVQUFVLENBQUEsQUFBQyxJQUFJLE9BQU8sQ0FBQyxVQUFVLElBQUksQ0FBQyxDQUFBLEFBQUM7S0FDeEYsQ0FBQztHQUNIO0FBQ0QsWUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7QUFDN0IsV0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7QUFDM0IsVUFBUSxHQUFHLElBQUksQ0FBQzs7O0FBR2hCLFNBQU8sSUFBSSxHQUFHLElBQUksQ0FBQyxZQUFZLEVBQUU7O0FBRS9CLFFBQUksSUFBSSxLQUFLLFFBQVEsQ0FBQyxJQUFJLEVBQUU7QUFDMUIsWUFBTTtLQUNQO0FBQ0QsY0FBVSxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUM7QUFDOUIsYUFBUyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUM7QUFDNUIsWUFBUSxHQUFHLElBQUksQ0FBQztHQUNqQjs7OztBQUlELE1BQUksUUFBUSxJQUFJLFFBQVEsQ0FBQyxLQUFLLENBQUMsUUFBUSxLQUFLLE9BQU8sRUFBRTs7QUFFbkQsY0FBVSxJQUFJLE1BQU0sQ0FBQyxXQUFXLElBQUksT0FBTyxDQUFDLFVBQVUsQ0FBQztBQUN2RCxhQUFTLElBQUksTUFBTSxDQUFDLFdBQVcsSUFBSSxPQUFPLENBQUMsU0FBUyxDQUFDO0dBQ3REOztBQUVELFNBQU87QUFDTCxRQUFJLEVBQUUsVUFBVTtBQUNoQixPQUFHLEVBQUUsU0FBUztHQUNmLENBQUM7Q0FDSDs7Ozs7Ozs7QUFPTSxTQUFTLGtCQUFrQixHQUFHO0FBQ25DLE1BQUksR0FBRyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUM7O0FBRXpCLE1BQUksR0FBRyxLQUFLLEtBQUssQ0FBQyxFQUFFOztBQUNsQixPQUFHLEdBQUcsUUFBUSxDQUFDLGVBQWUsQ0FBQyxTQUFTLENBQUM7R0FDMUM7O0FBRUQsU0FBTyxHQUFHLENBQUM7Q0FDWjs7Ozs7Ozs7QUFPTSxTQUFTLG1CQUFtQixHQUFHO0FBQ3BDLE1BQUksR0FBRyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUM7O0FBRXpCLE1BQUksR0FBRyxLQUFLLEtBQUssQ0FBQyxFQUFFOztBQUNsQixPQUFHLEdBQUcsUUFBUSxDQUFDLGVBQWUsQ0FBQyxVQUFVLENBQUM7R0FDM0M7O0FBRUQsU0FBTyxHQUFHLENBQUM7Q0FDWjs7Ozs7Ozs7O0FBUU0sU0FBUyxZQUFZLENBQUMsT0FBTyxFQUFFO0FBQ3BDLE1BQUksT0FBTyxLQUFLLE1BQU0sRUFBRTtBQUN0QixXQUFPLGtCQUFrQixFQUFFLENBQUM7R0FDN0IsTUFDSTtBQUNILFdBQU8sT0FBTyxDQUFDLFNBQVMsQ0FBQztHQUMxQjtDQUNGOzs7Ozs7Ozs7QUFRTSxTQUFTLGFBQWEsQ0FBQyxPQUFPLEVBQUU7QUFDckMsTUFBSSxPQUFPLEtBQUssTUFBTSxFQUFFO0FBQ3RCLFdBQU8sbUJBQW1CLEVBQUUsQ0FBQztHQUM5QixNQUNJO0FBQ0gsV0FBTyxPQUFPLENBQUMsVUFBVSxDQUFDO0dBQzNCO0NBQ0Y7Ozs7Ozs7OztBQVFNLFNBQVMsb0JBQW9CLENBQUMsT0FBTyxFQUFFO0FBQzVDLE1BQUksRUFBRSxHQUFHLE9BQU8sQ0FBQyxVQUFVO01BQ3pCLEtBQUssR0FBRyxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUM7TUFDMUIsUUFBUTtNQUFFLFNBQVM7TUFBRSxTQUFTO01BQzlCLGFBQWEsR0FBRyxFQUFFO01BQ2xCLGdCQUFnQixHQUFHLEVBQUU7TUFDckIsaUJBQWlCLEdBQUcsRUFBRTtNQUN0QixpQkFBaUIsR0FBRyxFQUFFLENBQUM7O0FBRXpCLFNBQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxLQUFLLElBQUksUUFBUSxDQUFDLElBQUksS0FBSyxFQUFFLEVBQUU7QUFDN0MsWUFBUSxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDO0FBQzdCLGFBQVMsR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQztBQUMvQixhQUFTLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUM7O0FBRS9CLFFBQUksUUFBUSxJQUFJLFFBQVEsSUFBSSxTQUFTLElBQUksUUFBUSxJQUFJLFNBQVMsSUFBSSxRQUFRLEVBQUU7QUFDMUUsYUFBTyxFQUFFLENBQUM7S0FFWCxNQUFNLElBQUksTUFBTSxDQUFDLGdCQUFnQixFQUFFO0FBQ2xDLG1CQUFhLEdBQUcsTUFBTSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQzVDLHNCQUFnQixHQUFHLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUM5RCx1QkFBaUIsR0FBRyxhQUFhLENBQUMsZ0JBQWdCLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDakUsdUJBQWlCLEdBQUcsYUFBYSxDQUFDLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxDQUFDOztBQUVqRSxVQUFJLGdCQUFnQixLQUFLLFFBQVEsSUFBSSxpQkFBaUIsS0FBSyxRQUFRLElBQUksaUJBQWlCLEtBQUssUUFBUSxFQUFFO0FBQ3JHLGVBQU8sRUFBRSxDQUFDO09BQ1g7S0FDRjs7QUFFRCxRQUFJLEVBQUUsQ0FBQyxZQUFZLElBQUksRUFBRSxDQUFDLFlBQVksS0FBSyxLQUFLLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQ3hHLEtBQUssQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUEsQUFBQyxFQUFFO0FBQ3RGLGFBQU8sRUFBRSxDQUFDO0tBQ1g7QUFDRCxRQUFJLEVBQUUsQ0FBQyxXQUFXLElBQUksRUFBRSxDQUFDLFdBQVcsS0FBSyxLQUFLLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQ3RHLEtBQUssQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUEsQUFBQyxFQUFFO0FBQ3RGLGFBQU8sRUFBRSxDQUFDO0tBQ1g7QUFDRCxNQUFFLEdBQUcsRUFBRSxDQUFDLFVBQVUsQ0FBQztHQUNwQjs7QUFFRCxTQUFPLE1BQU0sQ0FBQztDQUNmOzs7Ozs7Ozs7QUFRTSxTQUFTLG9CQUFvQixDQUFDLElBQUksRUFBRTtBQUN6QyxNQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDOztBQUV6QixTQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsS0FBSyxJQUFJLFFBQVEsQ0FBQyxJQUFJLEtBQUssRUFBRSxFQUFFO0FBQzdDLFFBQUksRUFBRSxDQUFDLEtBQUssQ0FBQyxRQUFRLEtBQUssU0FBUyxJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUMsUUFBUSxLQUFLLEVBQUUsRUFBRTtBQUMvRCxhQUFPLEVBQUUsQ0FBQztLQUVYLE1BQU0sSUFBSSxNQUFNLENBQUMsZ0JBQWdCLEVBQUU7QUFDbEMsVUFBSSxhQUFhLEdBQUcsTUFBTSxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxDQUFDOztBQUVoRCxVQUFJLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsS0FBSyxTQUFTLElBQUksYUFBYSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtBQUNqSCxlQUFPLEVBQUUsQ0FBQztPQUNYO0tBQ0Y7O0FBRUQsTUFBRSxHQUFHLEVBQUUsQ0FBQyxVQUFVLENBQUM7R0FDcEI7O0FBRUQsU0FBTyxNQUFNLENBQUM7Q0FDZjs7Ozs7Ozs7OztBQVNNLFNBQVMsUUFBUSxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUU7QUFDdEMsTUFBSSxDQUFDLE9BQU8sRUFBRTtBQUNaLFdBQU87R0FFUixNQUFNLElBQUksT0FBTyxLQUFLLE1BQU0sRUFBRTtBQUM3QixRQUFJLElBQUksS0FBSyxPQUFPLEVBQUU7QUFDcEIsYUFBTyxNQUFNLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztLQUNqQyxNQUFNLElBQUksSUFBSSxLQUFLLFFBQVEsRUFBRTtBQUM1QixhQUFPLE1BQU0sQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO0tBQ2xDO0FBQ0QsV0FBTztHQUNSOztBQUVELE1BQUksU0FBUyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDO01BQ2pDLGFBQWEsQ0FBQztBQUNoQixNQUFJLFNBQVMsS0FBSyxFQUFFLElBQUksU0FBUyxLQUFLLEtBQUssQ0FBQyxFQUFFO0FBQzVDLFdBQU8sU0FBUyxDQUFDO0dBRWxCLE1BQU07QUFDTCxpQkFBYSxHQUFHLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzFDLFFBQUksYUFBYSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxhQUFhLENBQUMsSUFBSSxDQUFDLEtBQUssS0FBSyxDQUFDLEVBQUU7QUFDaEUsYUFBTyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDNUI7QUFDRCxXQUFPLEtBQUssQ0FBQyxDQUFDO0dBQ2Y7Q0FDRjs7Ozs7Ozs7O0FBUU0sU0FBUyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUU7QUFDeEMsU0FBTyxPQUFPLENBQUMsWUFBWSxJQUFJLFFBQVEsQ0FBQyxXQUFXLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUM7Q0FDL0U7Ozs7Ozs7OztBQVFNLFNBQVMsVUFBVSxDQUFDLE9BQU8sRUFBRTtBQUNsQyxTQUFPLE9BQU8sQ0FBQyxXQUFXLENBQUM7Q0FDNUI7Ozs7Ozs7O0FBT00sU0FBUyxXQUFXLENBQUMsSUFBSSxFQUFFO0FBQ2hDLE1BQUksaUNBQW1CLElBQUksSUFBSSxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsS0FBSyxTQUFTLEVBQUU7Ozs7Ozs7O0FBUXBGLFdBQU8sSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQztHQUN6RCxNQUNJO0FBQ0gsV0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDO0dBQzFCO0NBQ0Y7Ozs7Ozs7OztBQVFNLFNBQVMsV0FBVyxDQUFDLE9BQU8sRUFBRTtBQUNuQyxTQUFPLE9BQU8sQ0FBQyxZQUFZLElBQUksT0FBTyxDQUFDLFdBQVcsQ0FBQztDQUNwRDs7Ozs7Ozs7O0FBUU0sU0FBUyxVQUFVLENBQUMsT0FBTyxFQUFFO0FBQ2xDLFNBQU8sT0FBTyxDQUFDLFdBQVcsSUFBSSxPQUFPLENBQUMsVUFBVSxDQUFDO0NBQ2xEOztBQUVNLFNBQVMsUUFBUSxDQUFDLE9BQU8sRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFO0FBQ2pELE1BQUksTUFBTSxDQUFDLGdCQUFnQixFQUFFO0FBQzNCLFdBQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDO0dBQ2xELE1BQU07QUFDTCxXQUFPLENBQUMsV0FBVyxDQUFDLElBQUksR0FBRyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUM7R0FDN0M7Q0FDRjs7QUFFTSxTQUFTLFdBQVcsQ0FBQyxPQUFPLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRTtBQUNwRCxNQUFJLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRTtBQUM5QixXQUFPLENBQUMsbUJBQW1CLENBQUMsS0FBSyxFQUFFLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQztHQUNyRCxNQUFNO0FBQ0wsV0FBTyxDQUFDLFdBQVcsQ0FBQyxJQUFJLEdBQUcsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0dBQzdDO0NBQ0Y7Ozs7Ozs7OztBQVFNLFNBQVMsZ0JBQWdCLENBQUMsRUFBRSxFQUFFO0FBQ25DLE1BQUksRUFBRSxDQUFDLGNBQWMsRUFBRTtBQUNyQixXQUFPLEVBQUUsQ0FBQyxjQUFjLENBQUM7R0FDMUIsTUFDSSxJQUFJLFFBQVEsQ0FBQyxTQUFTLEVBQUU7O0FBQzNCLE1BQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQzs7QUFFWCxRQUFJLENBQUMsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFDOztBQUV6QyxRQUFJLENBQUMsSUFBSSxJQUFJLEVBQUU7QUFDYixhQUFPLENBQUMsQ0FBQztLQUNWO0FBQ0QsUUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDLGVBQWUsRUFBRSxDQUFDO0FBQzlCLFFBQUksRUFBRSxHQUFHLEVBQUUsQ0FBQyxTQUFTLEVBQUUsQ0FBQzs7QUFFeEIsTUFBRSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztBQUNuQyxNQUFFLENBQUMsV0FBVyxDQUFDLFlBQVksRUFBRSxFQUFFLENBQUMsQ0FBQzs7QUFFakMsV0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztHQUN2Qjs7QUFFRCxTQUFPLENBQUMsQ0FBQztDQUNWOzs7Ozs7OztBQU9NLFNBQVMsdUJBQXVCLENBQUMsRUFBRSxFQUFFO0FBQzFDLE1BQUksRUFBRSxDQUFDLFlBQVksRUFBRTtBQUNuQixXQUFPLEVBQUUsQ0FBQyxZQUFZLENBQUM7R0FFeEIsTUFBTSxJQUFJLFFBQVEsQ0FBQyxTQUFTLEVBQUU7O0FBQzdCLFFBQUksQ0FBQyxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFLENBQUM7O0FBRXpDLFFBQUksQ0FBQyxJQUFJLElBQUksRUFBRTtBQUNiLGFBQU8sQ0FBQyxDQUFDO0tBQ1Y7QUFDRCxRQUFJLEVBQUUsR0FBRyxFQUFFLENBQUMsZUFBZSxFQUFFLENBQUM7O0FBRTlCLFdBQU8sRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDO0dBQ2hEO0NBQ0Y7Ozs7Ozs7Ozs7O0FBVU0sU0FBUyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRTtBQUNyRCxNQUFJLE1BQU0sS0FBSyxLQUFLLENBQUMsRUFBRTtBQUNyQixVQUFNLEdBQUcsR0FBRyxDQUFDO0dBQ2Q7QUFDRCxNQUFJLE9BQU8sQ0FBQyxpQkFBaUIsRUFBRTtBQUM3QixXQUFPLENBQUMsS0FBSyxFQUFFLENBQUM7O0FBRWhCLFFBQUk7QUFDRixhQUFPLENBQUMsaUJBQWlCLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0tBQ3hDLENBQ0QsT0FBTSxHQUFHLEVBQUU7QUFDVCxVQUFJLGFBQWEsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDO0FBQ3ZDLFVBQUksa0JBQWtCLEdBQUcsYUFBYSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUM7QUFDckQsbUJBQWEsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztBQUN0QyxhQUFPLENBQUMsaUJBQWlCLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQ3ZDLG1CQUFhLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxrQkFBa0IsQ0FBQztLQUNsRDtHQUVGLE1BQ0ksSUFBSSxPQUFPLENBQUMsZUFBZSxFQUFFOztBQUNoQyxRQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsZUFBZSxFQUFFLENBQUM7QUFDdEMsU0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNyQixTQUFLLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUNuQyxTQUFLLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUNsQyxTQUFLLENBQUMsTUFBTSxFQUFFLENBQUM7R0FDaEI7Q0FDRjs7QUFFRCxJQUFJLG9CQUFvQixDQUFDOzs7QUFHekIsU0FBUyxrQ0FBa0MsR0FBRztBQUM1QyxNQUFJLEtBQUssR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3hDLE9BQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQztBQUMzQixPQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUM7O0FBRTdCLE1BQUksS0FBSyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDMUMsT0FBSyxDQUFDLEtBQUssQ0FBQyxRQUFRLEdBQUcsVUFBVSxDQUFDO0FBQ2xDLE9BQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQztBQUN4QixPQUFLLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxLQUFLLENBQUM7QUFDekIsT0FBSyxDQUFDLEtBQUssQ0FBQyxVQUFVLEdBQUcsUUFBUSxDQUFDO0FBQ2xDLE9BQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLE9BQU8sQ0FBQztBQUM1QixPQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUM7QUFDN0IsT0FBSyxDQUFDLEtBQUssQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0FBQ2hDLE9BQUssQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7O0FBRXpCLEdBQUMsUUFBUSxDQUFDLElBQUksSUFBSSxRQUFRLENBQUMsZUFBZSxDQUFBLENBQUUsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQy9ELE1BQUksRUFBRSxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUM7QUFDM0IsT0FBSyxDQUFDLEtBQUssQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0FBQ2hDLE1BQUksRUFBRSxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUM7QUFDM0IsTUFBSSxFQUFFLElBQUksRUFBRSxFQUFFO0FBQ1osTUFBRSxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUM7R0FDeEI7O0FBRUQsR0FBQyxRQUFRLENBQUMsSUFBSSxJQUFJLFFBQVEsQ0FBQyxlQUFlLENBQUEsQ0FBRSxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7O0FBRS9ELFNBQVEsRUFBRSxHQUFHLEVBQUUsQ0FBRTtDQUNsQjs7Ozs7Ozs7QUFPTSxTQUFTLGlCQUFpQixHQUFHO0FBQ2xDLE1BQUksb0JBQW9CLEtBQUssS0FBSyxDQUFDLEVBQUU7QUFDbkMsd0JBQW9CLEdBQUcsa0NBQWtDLEVBQUUsQ0FBQztHQUM3RDs7QUFFRCxTQUFPLG9CQUFvQixDQUFDO0NBQzdCOzs7Ozs7QUFNTSxTQUFTLGtCQUFrQixDQUFDLFdBQVcsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFO0FBQ3pELE1BQUkscUJBQU8sSUFBSSxxQkFBTyxFQUFFO0FBQ3RCLGVBQVcsQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztBQUM1QixlQUFXLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7R0FDL0IsTUFBTSxJQUFJLHdCQUFVLEVBQUU7O0FBRXJCLGVBQVcsQ0FBQyxLQUFLLENBQUMsbUJBQW1CLENBQUMsR0FBRyxjQUFjLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsS0FBSyxDQUFDO0dBQ3BGLE1BQU07QUFDTCxlQUFXLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxjQUFjLEdBQUcsSUFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsS0FBSyxDQUFDO0dBQ3pFO0NBQ0Y7O0FBRU0sU0FBUyxlQUFlLENBQUMsT0FBTyxFQUFFO0FBQ3ZDLE1BQUksU0FBUyxDQUFDOzs7QUFHZCxNQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQSxLQUFNLEVBQUUsRUFBRTtBQUNqRixXQUFPLENBQUMsV0FBVyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0dBRWpDLE1BQU0sSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFBLEtBQU0sRUFBRSxFQUFFOztBQUV4RyxXQUFPLENBQUMsbUJBQW1CLEVBQUUsU0FBUyxDQUFDLENBQUM7R0FDekM7O0FBRUQsU0FBTyxDQUFDLENBQUMsQ0FBQztDQUNYOztBQUVNLFNBQVMsaUJBQWlCLENBQUMsT0FBTyxFQUFFOztBQUV6QyxNQUFJLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxPQUFPLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxFQUFFO0FBQ3ZELFdBQU8sQ0FBQyxXQUFXLENBQUMsR0FBRyxFQUFFLENBQUM7R0FDM0IsTUFBTSxJQUFJLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLEVBQUUsRUFBRTtBQUM5RSxXQUFPLENBQUMsbUJBQW1CLENBQUMsR0FBRyxFQUFFLENBQUM7R0FDbkM7Q0FDRjs7Ozs7Ozs7O0FBUU0sU0FBUyxPQUFPLENBQUMsT0FBTyxFQUFFO0FBQy9CLE1BQUksTUFBTSxHQUFHLENBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxVQUFVLENBQUMsQ0FBQzs7QUFFN0MsU0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxPQUFPLENBQUMsZUFBZSxLQUFLLE1BQU0sQ0FBQztDQUNwRjs7Ozs7Ozs7O0FBUU0sU0FBUyxjQUFjLENBQUMsT0FBTyxFQUFFO0FBQ3RDLFNBQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLE9BQU8sQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7Q0FDakk7OztBQUlELElBQUksUUFBUSxHQUFHLENBQUMsQ0FBQztBQUNqQixJQUFJLE9BQU8sR0FBRyxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBQzNDLElBQUksc0JBQXNCLEdBQUcsTUFBTSxDQUFDLHFCQUFxQixDQUFDO0FBQzFELElBQUkscUJBQXFCLEdBQUcsTUFBTSxDQUFDLG9CQUFvQixDQUFDOztBQUV4RCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDLE1BQU0sSUFBSSxDQUFDLHNCQUFzQixFQUFFLEVBQUUsQ0FBQyxFQUFFO0FBQ2xFLHdCQUFzQixHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsdUJBQXVCLENBQUMsQ0FBQztBQUN0RSx1QkFBcUIsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLHNCQUFzQixDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyw2QkFBNkIsQ0FBQyxDQUFDO0NBQzNIOztBQUVELElBQUksQ0FBQyxzQkFBc0IsRUFBRTtBQUMzQix3QkFBc0IsR0FBRyxVQUFTLFFBQVEsRUFBRTtBQUMxQyxRQUFJLFFBQVEsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQ3BDLFFBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUUsSUFBSSxRQUFRLEdBQUcsUUFBUSxDQUFBLEFBQUMsQ0FBQyxDQUFDO0FBQ3pELFFBQUksRUFBRSxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsWUFBVztBQUNwQyxjQUFRLENBQUMsUUFBUSxHQUFHLFVBQVUsQ0FBQyxDQUFDO0tBQ2pDLEVBQUUsVUFBVSxDQUFDLENBQUM7QUFDZixZQUFRLEdBQUcsUUFBUSxHQUFHLFVBQVUsQ0FBQzs7QUFFakMsV0FBTyxFQUFFLENBQUM7R0FDWCxDQUFDO0NBQ0g7O0FBRUQsSUFBSSxDQUFDLHFCQUFxQixFQUFFO0FBQzFCLHVCQUFxQixHQUFHLFVBQVMsRUFBRSxFQUFFO0FBQ25DLGdCQUFZLENBQUMsRUFBRSxDQUFDLENBQUM7R0FDbEIsQ0FBQztDQUNIOzs7Ozs7Ozs7QUFRTSxTQUFTLHFCQUFxQixDQUFDLFFBQVEsRUFBRTtBQUM5QyxTQUFPLHNCQUFzQixDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7Q0FDdEQ7Ozs7Ozs7O0FBT00sU0FBUyxvQkFBb0IsQ0FBQyxFQUFFLEVBQUU7QUFDdkMsdUJBQXFCLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQztDQUN4Qzs7Ozs7Ozs7Ozs7Ozs7QUMxN0JNLFNBQVMsd0JBQXdCLENBQUMsS0FBSyxFQUFFO0FBQzlDLE9BQUssQ0FBQyw2QkFBNkIsR0FBRyxLQUFLLENBQUM7QUFDNUMsT0FBSyxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7Q0FDM0I7O0FBRU0sU0FBUyw2QkFBNkIsQ0FBQyxLQUFLLEVBQUU7QUFDbkQsU0FBTyxLQUFLLENBQUMsNkJBQTZCLEtBQUssS0FBSyxDQUFDO0NBQ3REOztBQUVNLFNBQVMsZUFBZSxDQUFDLEtBQUssRUFBRTs7O0FBR3JDLE1BQUksT0FBTyxLQUFLLENBQUMsZUFBZSxLQUFLLFVBQVUsRUFBRTtBQUMvQyxTQUFLLENBQUMsZUFBZSxFQUFFLENBQUM7R0FDekIsTUFDSTtBQUNILFNBQUssQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDO0dBQzNCO0NBQ0Y7O0FBRU0sU0FBUyxLQUFLLENBQUMsS0FBSyxFQUFFO0FBQzNCLE1BQUksS0FBSyxDQUFDLEtBQUssRUFBRTtBQUNmLFdBQU8sS0FBSyxDQUFDLEtBQUssQ0FBQztHQUNwQjs7QUFFRCxNQUFJLFVBQVUsR0FBRyxtQkFBbUIsRUFBRSxDQUFDO0FBQ3ZDLE1BQUksT0FBTyxHQUFHLEtBQUssQ0FBQyxPQUFPLEdBQUcsVUFBVSxDQUFDOztBQUV6QyxTQUFPLE9BQU8sQ0FBQztDQUNoQjs7QUFFTSxTQUFTLEtBQUssQ0FBQyxLQUFLLEVBQUU7QUFDM0IsTUFBSSxLQUFLLENBQUMsS0FBSyxFQUFFO0FBQ2YsV0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDO0dBQ3BCOztBQUVELE1BQUksU0FBUyxHQUFHLGtCQUFrQixFQUFFLENBQUM7QUFDckMsTUFBSSxPQUFPLEdBQUcsS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLENBQUM7O0FBRXhDLFNBQU8sT0FBTyxDQUFDO0NBQ2hCOzs7Ozs7Ozs7Ozs7QUN4Q00sU0FBUyxLQUFLLENBQUMsR0FBRyxFQUFFLE9BQU8sRUFBRTtBQUNsQyxTQUFPLFlBQVk7QUFDakIsV0FBTyxHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQztHQUN0QyxDQUFDO0NBQ0g7Ozs7Ozs7Ozs7QUFTTSxTQUFTLFFBQVEsQ0FBQyxJQUFJLEVBQWM7TUFBWixJQUFJLHlEQUFHLEdBQUc7O0FBQ3ZDLE1BQUksVUFBVSxHQUFHLENBQUMsQ0FBQztBQUNuQixNQUFJLE1BQU0sR0FBRztBQUNYLHFCQUFpQixFQUFFLElBQUk7R0FDeEIsQ0FBQztBQUNGLE1BQUksU0FBUyxHQUFHLElBQUksQ0FBQzs7QUFFckIsV0FBUyxTQUFTLEdBQUc7OztBQUNuQixRQUFNLElBQUksR0FBRyxTQUFTLENBQUM7QUFDdkIsUUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO0FBQ3ZCLFFBQUksUUFBUSxHQUFHLEtBQUssQ0FBQzs7QUFFckIsVUFBTSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQzs7QUFFaEMsUUFBSSxDQUFDLFVBQVUsRUFBRTtBQUNmLGdCQUFVLEdBQUcsS0FBSyxDQUFDO0FBQ25CLGNBQVEsR0FBRyxJQUFJLENBQUM7S0FDakI7QUFDRCxRQUFJLFNBQVMsR0FBRyxJQUFJLElBQUksS0FBSyxHQUFHLFVBQVUsQ0FBQSxBQUFDLENBQUM7O0FBRTVDLFFBQUksUUFBUSxFQUFFO0FBQ1osWUFBTSxDQUFDLGlCQUFpQixHQUFHLEtBQUssQ0FBQztBQUNqQyxVQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztLQUN4QixNQUFNO0FBQ0wsVUFBSSxTQUFTLEVBQUU7QUFDYixvQkFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDO09BQ3pCO0FBQ0QsZUFBUyxHQUFHLFVBQVUsQ0FBQyxZQUFNO0FBQzNCLGNBQU0sQ0FBQyxpQkFBaUIsR0FBRyxLQUFLLENBQUM7QUFDakMsWUFBSSxDQUFDLEtBQUssUUFBTyxJQUFJLENBQUMsQ0FBQztBQUN2QixrQkFBVSxHQUFHLENBQUMsQ0FBQztBQUNmLGlCQUFTLEdBQUcsS0FBSyxDQUFDLENBQUM7T0FDcEIsRUFBRSxTQUFTLENBQUMsQ0FBQztLQUNmOztBQUVELFdBQU8sTUFBTSxDQUFDO0dBQ2Y7O0FBRUQsU0FBTyxTQUFTLENBQUM7Q0FDbEI7Ozs7Ozs7Ozs7O0FBVU0sU0FBUyxpQkFBaUIsQ0FBQyxJQUFJLEVBQXlCO01BQXZCLElBQUkseURBQUcsR0FBRztNQUFFLElBQUkseURBQUcsRUFBRTs7QUFDM0QsTUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztBQUMxQyxNQUFJLFVBQVUsR0FBRyxJQUFJLENBQUM7O0FBRXRCLFdBQVMsVUFBVSxHQUFHO0FBQ3BCLGNBQVUsR0FBRyxJQUFJLENBQUM7R0FDbkI7QUFDRCxXQUFTLGtCQUFrQixHQUFHO0FBQzVCLFFBQUksVUFBVSxFQUFFO0FBQ2QsZ0JBQVUsRUFBRyxDQUFDOztBQUVkLGFBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7S0FDcEM7O0FBRUQsV0FBTyxZQUFZLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQztHQUM1QztBQUNELG9CQUFrQixDQUFDLFNBQVMsR0FBRyxVQUFVLENBQUM7O0FBRTFDLFNBQU8sa0JBQWtCLENBQUM7Q0FDM0I7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0VNLFNBQVMsU0FBUyxDQUFDLEtBQUssRUFBRTtBQUMvQixVQUFRLE9BQU8sS0FBSztBQUNsQixTQUFLLFFBQVEsQ0FBQztBQUNkLFNBQUssUUFBUTtBQUNYLGFBQU8sS0FBSyxHQUFHLEVBQUUsQ0FBQzs7QUFBQSxBQUVwQixTQUFLLFFBQVE7QUFDWCxVQUFJLEtBQUssS0FBSyxJQUFJLEVBQUU7QUFDbEIsZUFBTyxFQUFFLENBQUM7T0FDWCxNQUNJO0FBQ0gsZUFBTyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7T0FDekI7QUFDRCxZQUFNO0FBQUEsQUFDUixTQUFLLFdBQVc7QUFDZCxhQUFPLEVBQUUsQ0FBQzs7QUFBQSxBQUVaO0FBQ0UsYUFBTyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7QUFBQSxHQUMzQjtDQUNGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEJNLFNBQVMsU0FBUyxDQUFDLENBQUMsRUFBRTtBQUMzQixNQUFJLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQztBQUNqQixTQUFPLENBQUMsSUFBSSxRQUFRLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUM3QyxDQUFDLElBQUksUUFBUSxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxLQUFLLEdBQy9CLENBQUMsQ0FBQyxNQUFNLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQzFCLHFFQUFxRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FDL0UsQ0FBQyxJQUFJLFFBQVEsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxJQUFJLFFBQVEsSUFBSSxFQUFFLENBQUMsWUFBWSxJQUFJLENBQUEsQUFBQyxHQUFHLEtBQUssQ0FBQztDQUMzRjs7Ozs7Ozs7OztBQVNNLFNBQVMsU0FBUyxDQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFO0FBQ3RELE1BQUksS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDOztBQUVmLE1BQUksT0FBTyxPQUFPLEtBQUssVUFBVSxFQUFFO0FBQ2pDLFlBQVEsR0FBRyxPQUFPLENBQUM7QUFDbkIsV0FBTyxHQUFHLFNBQVMsQ0FBQztHQUNyQixNQUFNO0FBQ0wsU0FBSyxHQUFHLFNBQVMsR0FBRyxDQUFDLENBQUM7R0FDdkI7QUFDRCxTQUFPLEVBQUUsS0FBSyxJQUFJLE9BQU8sRUFBRTtBQUN6QixRQUFJLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxLQUFLLEVBQUU7QUFDN0IsWUFBTTtLQUNQO0dBQ0Y7Q0FDRjs7Ozs7Ozs7OztBQVNNLFNBQVMscUJBQXFCLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRTtBQUNwRCxTQUFPLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQzVELFNBQU8sR0FBRyxRQUFRLENBQUMsS0FBSyxHQUFHLE9BQU8sR0FBRyxHQUFHLENBQUMsQ0FBQzs7QUFFMUMsU0FBTyxPQUFPLENBQUM7Q0FDaEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVDTSxTQUFTLFVBQVUsQ0FBQyxNQUFNLEVBQUU7QUFDakMsTUFBSSxNQUFNLENBQUM7O0FBRVgsTUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFO0FBQ3pCLFVBQU0sR0FBRyxFQUFFLENBQUM7R0FDYixNQUFNO0FBQ0wsVUFBTSxHQUFHLEVBQUUsQ0FBQzs7QUFFWixjQUFVLENBQUMsTUFBTSxFQUFFLFVBQVMsS0FBSyxFQUFFLEdBQUcsRUFBRTtBQUN0QyxVQUFJLEtBQUssSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO0FBQy9ELGNBQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7T0FFakMsTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7QUFDL0IsWUFBSSxLQUFLLENBQUMsTUFBTSxJQUFJLE9BQU8sS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLFFBQVEsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7QUFDNUUsZ0JBQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3RDLE1BQU07QUFDTCxnQkFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztTQUNsQjtPQUVGLE1BQU07QUFDTCxjQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDO09BQ3BCO0tBQ0YsQ0FBQyxDQUFDO0dBQ0o7O0FBRUQsU0FBTyxNQUFNLENBQUM7Q0FDZjs7Ozs7Ozs7Ozs7O0FBV00sU0FBUyxPQUFPLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRTtBQUNyQyxRQUFNLENBQUMsU0FBUyxDQUFDLFdBQVcsR0FBRyxNQUFNLENBQUM7QUFDdEMsT0FBSyxDQUFDLFNBQVMsR0FBRyxJQUFJLE1BQU0sRUFBRSxDQUFDO0FBQy9CLE9BQUssQ0FBQyxTQUFTLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQzs7QUFFcEMsU0FBTyxLQUFLLENBQUM7Q0FDZDs7Ozs7Ozs7QUFPTSxTQUFTLE1BQU0sQ0FBQyxNQUFNLEVBQUUsU0FBUyxFQUFFO0FBQ3hDLFlBQVUsQ0FBQyxTQUFTLEVBQUUsVUFBUyxLQUFLLEVBQUUsR0FBRyxFQUFFO0FBQ3pDLFVBQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUM7R0FDckIsQ0FBQyxDQUFDO0NBQ0o7Ozs7Ozs7O0FBT00sU0FBUyxVQUFVLENBQUMsTUFBTSxFQUFFLFNBQVMsRUFBRTtBQUM1QyxZQUFVLENBQUMsU0FBUyxFQUFFLFVBQVMsS0FBSyxFQUFFLEdBQUcsRUFBRTtBQUN6QyxRQUFJLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxPQUFPLFNBQVMsQ0FBQyxHQUFHLENBQUMsS0FBSyxRQUFRLEVBQUU7QUFDeEQsVUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRTtBQUNoQixZQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUU7QUFDakMsZ0JBQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUM7U0FDbEIsTUFDSTtBQUNILGdCQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDO1NBQ2xCO09BQ0Y7QUFDRCxnQkFBVSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsRUFBRSxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztLQUV6QyxNQUFNO0FBQ0wsWUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUM5QjtHQUNGLENBQUMsQ0FBQztDQUNKOzs7Ozs7Ozs7O0FBU00sU0FBUyxTQUFTLENBQUMsR0FBRyxFQUFFO0FBQzdCLE1BQUksT0FBTyxHQUFHLEtBQUssUUFBUSxFQUFFO0FBQzNCLFdBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7R0FDeEM7O0FBRUQsU0FBTyxHQUFHLENBQUM7Q0FDWjs7Ozs7Ozs7O0FBUU0sU0FBUyxLQUFLLENBQUMsTUFBTSxFQUFFO0FBQzVCLE1BQUksTUFBTSxHQUFHLEVBQUUsQ0FBQzs7QUFFaEIsWUFBVSxDQUFDLE1BQU0sRUFBRSxVQUFDLEtBQUssRUFBRSxHQUFHO1dBQUssTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUs7R0FBQSxDQUFDLENBQUM7O0FBRXhELFNBQU8sTUFBTSxDQUFDO0NBQ2Y7Ozs7Ozs7Ozs7QUFTTSxTQUFTLGNBQWMsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFO0FBQy9DLFNBQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsS0FBSyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0NBQzVEOzs7Ozs7Ozs7QUFRTSxTQUFTLFFBQVEsQ0FBQyxHQUFHLEVBQUU7QUFDNUIsU0FBTyxNQUFNLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksaUJBQWlCLENBQUM7Q0FDakU7O0FBRU0sU0FBUyxjQUFjLENBQUMsR0FBRyxFQUFFO0FBQ2xDLE1BQUksU0FBUyxDQUFDOzs7QUFHZCxNQUFHLE9BQU8sR0FBRyxDQUFDLFNBQVMsSUFBSSxRQUFRLEVBQUM7QUFDbEMsYUFBUyxHQUFHLEdBQUcsQ0FBQyxTQUFTLENBQUM7R0FDM0IsTUFBTTtBQUNMLFFBQUksY0FBYztRQUNoQixXQUFXLEdBQUcsR0FBRyxDQUFDLFdBQVcsQ0FBQzs7QUFFaEMsUUFBSSxPQUFPLEdBQUcsQ0FBQyxXQUFXLElBQUksVUFBVSxFQUFFO0FBQ3hDLG9CQUFjLEdBQUcsV0FBVyxDQUFDOztBQUU3QixVQUFJLE9BQU8sR0FBRyxDQUFDLFdBQVcsRUFBQztBQUN6QixtQkFBVyxHQUFHLEdBQUcsQ0FBQyxXQUFXLENBQUM7QUFDOUIsV0FBRyxDQUFDLFdBQVcsR0FBRyxjQUFjLENBQUM7T0FDbEM7S0FHRjs7QUFFRCxhQUFTLEdBQUcsV0FBVyxHQUFHLFdBQVcsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO0dBQ3hEOzs7QUFHRCxTQUFPLFNBQVMsQ0FBQztDQUNsQjs7QUFFTSxTQUFTLFlBQVksQ0FBQyxNQUFNLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUU7QUFDN0QsU0FBTyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDdEIsU0FBTyxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUMsUUFBUSxLQUFLLEtBQUssR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDO0FBQzdELFNBQU8sQ0FBQyxVQUFVLEdBQUcsT0FBTyxDQUFDLFVBQVUsS0FBSyxLQUFLLEdBQUcsS0FBSyxHQUFHLElBQUksQ0FBQztBQUNqRSxTQUFPLENBQUMsWUFBWSxHQUFHLE9BQU8sQ0FBQyxZQUFZLEtBQUssS0FBSyxHQUFHLEtBQUssR0FBRyxJQUFJLENBQUM7O0FBRXJFLFFBQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztDQUNsRDs7Ozs7Ozs7OztBQVNNLFNBQVMsVUFBVSxDQUFDLE1BQU0sRUFBRSxRQUFRLEVBQUU7QUFDM0MsT0FBSyxJQUFJLEdBQUcsSUFBSSxNQUFNLEVBQUU7QUFDdEIsUUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLElBQUssTUFBTSxDQUFDLGNBQWMsSUFBSSxNQUFNLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxBQUFDLEVBQUU7QUFDbkYsVUFBSSxRQUFRLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxNQUFNLENBQUMsS0FBSyxLQUFLLEVBQUU7QUFDaEQsY0FBTTtPQUNQO0tBQ0Y7R0FDRjs7QUFFRCxTQUFPLE1BQU0sQ0FBQztDQUNmOzs7Ozs7Ozs7O3NCQzlMcUIsVUFBVTs7Ozs7Ozs7OztBQVN6QixTQUFTLGFBQWEsQ0FBQyxZQUFZLEVBQUUsWUFBWSxFQUFFO0FBQ3hELFdBQVMsY0FBYyxHQUFHLEVBQUUsQ0FBQzs7QUFFN0IsdUJBQVEsY0FBYyxFQUFFLFlBQVksQ0FBQyxDQUFDOzs7QUFHdEMsT0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLFlBQVksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUN2RCxrQkFBYyxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQztHQUNwRDs7QUFFRCxTQUFPLGNBQWMsQ0FBQztDQUN2Qjs7Ozs7Ozs7Ozs7OztxQkNwQnVCLFNBQVM7Ozs7Ozs7OztBQVExQixTQUFTLGdCQUFnQixDQUFDLE1BQU0sRUFBRTtBQUN2QyxTQUFPLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0NBQ25EOzs7Ozs7Ozs7QUFRTSxTQUFTLGdCQUFnQixHQUFhO0FBQzNDLE1BQUksTUFBTSxHQUFHLEVBQUUsQ0FBQzs7b0NBRGtCLE9BQU87QUFBUCxXQUFPOzs7QUFFekMsTUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQzs7QUFFNUIsU0FBTyxNQUFNLEVBQUcsRUFBRTtBQUNoQixRQUFJLE1BQU0sR0FBRyxzQkFBVSxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQzs7QUFFdEQsUUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO0FBQ2pDLFlBQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDckI7R0FDRjs7QUFFRCxTQUFPLE1BQU0sQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO0NBQzVCOzs7Ozs7O0FBTU0sU0FBUyxZQUFZLEdBQUc7QUFDN0IsV0FBUyxFQUFFLEdBQUc7QUFDWixXQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFBLEdBQUksT0FBTyxDQUFDLENBQzdDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FDWixTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7R0FDakI7O0FBRUQsU0FBTyxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsQ0FBQztDQUNsQzs7Ozs7Ozs7O0FBUU0sU0FBUyxjQUFjLENBQUMsS0FBSyxFQUFFO0FBQ3BDLFNBQU8sOEJBQTZCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztJQUFDO0NBQ2xEOzs7Ozs7Ozs7Ozs7O3FCQ3ZEdUIsU0FBUzs7QUFFMUIsSUFBTSxTQUFTLEdBQUc7QUFDdkIsWUFBVSxFQUFFLENBQUM7QUFDYixhQUFXLEVBQUUsQ0FBQztBQUNkLGNBQVksRUFBRSxDQUFDO0FBQ2YsV0FBUyxFQUFFLENBQUM7QUFDWixPQUFLLEVBQUUsR0FBRztBQUNWLFFBQU0sRUFBRSxFQUFFO0FBQ1YsUUFBTSxFQUFFLEVBQUU7QUFDVixLQUFHLEVBQUUsRUFBRTtBQUNQLE9BQUssRUFBRSxFQUFFO0FBQ1QsUUFBTSxFQUFFLEVBQUU7QUFDVixjQUFZLEVBQUUsRUFBRTtBQUNoQixjQUFZLEVBQUUsRUFBRTtBQUNoQixlQUFhLEVBQUUsRUFBRTtBQUNqQixLQUFHLEVBQUUsRUFBRTtBQUNQLE1BQUksRUFBRSxFQUFFO0FBQ1IsV0FBUyxFQUFFLEVBQUU7QUFDYixTQUFPLEVBQUUsRUFBRTtBQUNYLFFBQU0sRUFBRSxHQUFHO0FBQ1gsT0FBSyxFQUFFLEVBQUU7QUFDVCxPQUFLLEVBQUUsRUFBRTtBQUNULFdBQVMsRUFBRSxFQUFFO0FBQ2IsS0FBRyxFQUFFLENBQUM7QUFDTixhQUFXLEVBQUUsRUFBRTtBQUNmLFlBQVUsRUFBRSxFQUFFO0FBQ2QsVUFBUSxFQUFFLEVBQUU7QUFDWixZQUFVLEVBQUUsRUFBRTtBQUNkLElBQUUsRUFBRSxHQUFHO0FBQ1AsSUFBRSxFQUFFLEdBQUc7QUFDUCxJQUFFLEVBQUUsR0FBRztBQUNQLElBQUUsRUFBRSxHQUFHO0FBQ1AsSUFBRSxFQUFFLEdBQUc7QUFDUCxJQUFFLEVBQUUsR0FBRztBQUNQLElBQUUsRUFBRSxHQUFHO0FBQ1AsSUFBRSxFQUFFLEdBQUc7QUFDUCxJQUFFLEVBQUUsR0FBRztBQUNQLEtBQUcsRUFBRSxHQUFHO0FBQ1IsS0FBRyxFQUFFLEdBQUc7QUFDUixLQUFHLEVBQUUsR0FBRztBQUNSLEdBQUMsRUFBRSxFQUFFO0FBQ0wsR0FBQyxFQUFFLEVBQUU7QUFDTCxHQUFDLEVBQUUsRUFBRTtBQUNMLEdBQUMsRUFBRSxFQUFFO0NBQ04sQ0FBQzs7Ozs7Ozs7OztBQVFLLFNBQVMsZUFBZSxDQUFDLE9BQU8sRUFBRTtBQUN2QyxTQUFRLEFBQUMsT0FBTyxJQUFJLEVBQUU7QUFDakIsU0FBTyxJQUFJLEVBQUUsSUFBSSxPQUFPLElBQUksRUFBRSxBQUFDO0FBQy9CLFNBQU8sSUFBSSxFQUFFLElBQUksT0FBTyxJQUFJLEdBQUcsQUFBQztBQUNoQyxTQUFPLElBQUksR0FBRyxJQUFJLE9BQU8sSUFBSSxHQUFHLEFBQUM7QUFDakMsU0FBTyxJQUFJLEdBQUcsSUFBSSxPQUFPLElBQUksR0FBRyxBQUFDO0FBQ2xDLFNBQU8sSUFBSSxHQUFHO0FBQ2IsU0FBTyxJQUFJLEVBQUUsSUFBSSxPQUFPLElBQUksRUFBRSxBQUFDLENBQUU7Q0FDdkM7Ozs7Ozs7QUFNTSxTQUFTLFNBQVMsQ0FBQyxPQUFPLEVBQUU7QUFDakMsTUFBSSxRQUFRLEdBQUcsQ0FDYixTQUFTLENBQUMsVUFBVSxFQUNwQixTQUFTLENBQUMsUUFBUSxFQUNsQixTQUFTLENBQUMsVUFBVSxFQUNwQixTQUFTLENBQUMsV0FBVyxFQUNyQixTQUFTLENBQUMsSUFBSSxFQUNkLFNBQVMsQ0FBQyxHQUFHLEVBQ2IsU0FBUyxDQUFDLE1BQU0sRUFDaEIsU0FBUyxDQUFDLFNBQVMsRUFDbkIsU0FBUyxDQUFDLEVBQUUsRUFDWixTQUFTLENBQUMsRUFBRSxFQUNaLFNBQVMsQ0FBQyxFQUFFLEVBQ1osU0FBUyxDQUFDLEVBQUUsRUFDWixTQUFTLENBQUMsRUFBRSxFQUNaLFNBQVMsQ0FBQyxFQUFFLEVBQ1osU0FBUyxDQUFDLEVBQUUsRUFDWixTQUFTLENBQUMsRUFBRSxFQUNaLFNBQVMsQ0FBQyxFQUFFLEVBQ1osU0FBUyxDQUFDLEdBQUcsRUFDYixTQUFTLENBQUMsR0FBRyxFQUNiLFNBQVMsQ0FBQyxHQUFHLEVBQ2IsU0FBUyxDQUFDLEdBQUcsRUFDYixTQUFTLENBQUMsU0FBUyxFQUNuQixTQUFTLENBQUMsT0FBTyxFQUNqQixTQUFTLENBQUMsS0FBSyxFQUNmLFNBQVMsQ0FBQyxNQUFNLEVBQ2hCLFNBQVMsQ0FBQyxLQUFLLEVBQ2YsU0FBUyxDQUFDLFNBQVMsRUFDbkIsU0FBUyxDQUFDLEdBQUcsQ0FDZCxDQUFDOztBQUVGLFNBQU8sUUFBUSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztDQUN6Qzs7Ozs7OztBQU1NLFNBQVMsU0FBUyxDQUFDLE9BQU8sRUFBRTtBQUNqQyxTQUFPLENBQUMsU0FBUyxDQUFDLFlBQVksRUFBRSxHQUFHLEVBQUUsU0FBUyxDQUFDLFlBQVksRUFBRSxTQUFTLENBQUMsYUFBYSxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0NBQy9HOzs7Ozs7OztBQU9NLFNBQVMsS0FBSyxDQUFDLE9BQU8sRUFBRSxRQUFRLEVBQUU7QUFDdkMsTUFBSSxJQUFJLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUMvQixNQUFJLE1BQU0sR0FBRyxLQUFLLENBQUM7O0FBRW5CLHdCQUFVLElBQUksRUFBRSxVQUFTLEdBQUcsRUFBRTtBQUM1QixRQUFJLE9BQU8sS0FBSyxTQUFTLENBQUMsR0FBRyxDQUFDLEVBQUU7QUFDOUIsWUFBTSxHQUFHLElBQUksQ0FBQzs7QUFFZCxhQUFPLEtBQUssQ0FBQztLQUNkO0dBQ0YsQ0FBQyxDQUFDOztBQUVILFNBQU8sTUFBTSxDQUFDO0NBQ2Y7Ozs7Ozs7O1FDaElPLFFBQVEsR0FBUixRQUFROzs7QUFHaEIsTUFBTSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7O0FBRTNCLFNBQVMsUUFBUSxHQUFHO0FBQ2xCLE1BQUksR0FBRyxHQUFHO0FBQ1IsWUFBUSxFQUFFLEVBQUU7QUFDWixXQUFPLEVBQUUsSUFBSSxPQUFPLEVBQUU7R0FDdkIsQ0FBQzs7QUFFRixTQUFPO0FBQ0wsU0FBSyxFQUFFLGFBQVUsR0FBRyxFQUFFO0FBQ3BCLFVBQUksa0JBQWtCLENBQUMsR0FBRyxDQUFDLEVBQUU7QUFDM0IsZUFBTyxHQUFHLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO09BQzFCLE1BQU0sSUFBSSxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsRUFBRTtBQUNoQyxlQUFPLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO09BQzdCO0tBQ0Y7O0FBRUQsU0FBSyxFQUFFLGFBQVUsR0FBRyxFQUFFLEtBQUssRUFBRTtBQUMzQixVQUFJLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxFQUFFO0FBQzNCLFdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDO09BQzNCLE1BQU0sSUFBSSxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsRUFBRTtBQUNoQyxXQUFHLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7T0FDN0IsTUFBTTtBQUNMLGNBQU0sSUFBSSxLQUFLLENBQUMsa0JBQWtCLENBQUMsQ0FBQztPQUNyQztLQUdGOztBQUVELFlBQVEsRUFBRSxpQkFBVSxHQUFHLEVBQUU7QUFDdkIsVUFBSSxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsRUFBRTtBQUMzQixlQUFPLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7T0FDMUIsTUFBTSxJQUFJLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxFQUFFO0FBQ2hDLFdBQUcsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7T0FDNUI7S0FDRjtHQUNGLENBQUM7O0FBRUYsV0FBUyxrQkFBa0IsQ0FBQyxHQUFHLEVBQUM7QUFDOUIsV0FBTyxHQUFHLEtBQUssSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxLQUFLLE9BQU8sR0FBRyxJQUFJLFFBQVEsSUFBSSxPQUFPLEdBQUcsSUFBSSxRQUFRLENBQUEsQUFBQyxDQUFDO0dBQ2hHOztBQUVELFdBQVMsZ0JBQWdCLENBQUMsR0FBRyxFQUFDO0FBQzVCLFdBQU8sR0FBRyxLQUFLLElBQUksS0FBSyxPQUFPLEdBQUcsSUFBSSxRQUFRLElBQUksT0FBTyxHQUFHLElBQUksVUFBVSxDQUFBLEFBQUMsQ0FBQztHQUM3RTs7QUFFRCxXQUFTLFdBQVcsQ0FBQyxHQUFHLEVBQUM7QUFDdkIsV0FBTyxHQUFHLEtBQUssR0FBRyxDQUFDO0dBQ3BCO0NBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzRCQzBmMEIsZ0JBQWdCOzs0QkFDbkIsaUJBQWlCOzs2QkFDaEIsa0JBQWtCOztBQWhnQjNDLElBQU0sZ0JBQWdCLEdBQUc7Ozs7Ozs7QUFPdkIsb0JBQW9COzs7Ozs7Ozs7Ozs7QUFZcEIsYUFBYSxFQUNiLHNCQUFzQixFQUN0QixpQkFBaUIsRUFDakIsbUJBQW1CLEVBQ25CLGdDQUFnQyxFQUNoQyxzQkFBc0IsRUFDdEIsc0JBQXNCLEVBQ3RCLGdCQUFnQjs7Ozs7Ozs7O0FBU2hCLGdCQUFnQjs7Ozs7Ozs7O0FBU2hCLGdCQUFnQjs7Ozs7OztBQU9oQixlQUFlOzs7Ozs7O0FBT2YsY0FBYzs7Ozs7QUFLZCxzQkFBc0I7Ozs7Ozs7Ozs7QUFVdEIsa0JBQWtCOzs7Ozs7Ozs7QUFTbEIsbUJBQW1COzs7OztBQUtuQixtQkFBbUI7Ozs7Ozs7QUFPbkIsV0FBVzs7Ozs7QUFLWCwrQkFBK0I7Ozs7Ozs7QUFPL0IsZUFBZTs7Ozs7QUFLZixxQkFBcUI7Ozs7Ozs7QUFPckIsNEJBQTRCOzs7Ozs7Ozs7Ozs7O0FBYTVCLHNCQUFzQjs7Ozs7Ozs7Ozs7OztBQWF0QixzQkFBc0I7Ozs7Ozs7OztBQVN0QixnQkFBZ0I7Ozs7Ozs7OztBQVNoQixnQkFBZ0I7Ozs7Ozs7OztBQVNoQixhQUFhOzs7Ozs7Ozs7Ozs7QUFZYixlQUFlLEVBQ2YsY0FBYyxFQUNkLGdCQUFnQjs7Ozs7O0FBTWhCLHlCQUF5Qjs7Ozs7O0FBTXpCLHVCQUF1Qjs7Ozs7Ozs7Ozs7QUFXdkIsZ0JBQWdCOzs7Ozs7Ozs7OztBQVdoQixzQkFBc0I7Ozs7Ozs7Ozs7O0FBV3RCLG1CQUFtQjs7Ozs7Ozs7Ozs7QUFXbkIseUJBQXlCOzs7Ozs7Ozs7Ozs7QUFZekIsa0JBQWtCOzs7OztBQUtsQixxQkFBcUI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJyQixlQUFlOzs7Ozs7OztBQVFmLGdCQUFnQjs7Ozs7QUFLaEIscUJBQXFCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlDckIsY0FBYzs7Ozs7O0FBTWQsb0JBQW9COzs7OztBQUtwQixtQkFBbUI7Ozs7Ozs7Ozs7QUFVbkIsbUJBQW1COzs7Ozs7Ozs7QUFTbkIsWUFBWTs7Ozs7Ozs7QUFRWix1QkFBdUI7Ozs7Ozs7Ozs7QUFVdkIsZUFBZTs7Ozs7QUFLZix1QkFBdUI7Ozs7Ozs7OztBQVN2QixpQkFBaUI7Ozs7Ozs7OztBQVNqQixpQkFBaUI7Ozs7Ozs7OztBQVNqQixjQUFjOzs7Ozs7OztBQVFkLG1CQUFtQjs7Ozs7QUFLbkIsbUJBQW1COzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JuQixnQkFBZ0I7Ozs7Ozs7O0FBUWhCLFdBQVc7Ozs7Ozs7O0FBUVgsTUFBTTs7Ozs7Ozs7O0FBU04sV0FBVzs7Ozs7Ozs7OztBQVVYLGdCQUFnQjs7Ozs7Ozs7O0FBU2hCLFdBQVc7Ozs7Ozs7Ozs7QUFVWCxpQkFBaUI7Ozs7O0FBS2pCLHFCQUFxQjs7Ozs7QUFLckIsc0JBQXNCOzs7OztBQUt0QixxQkFBcUIsQ0FDdEIsQ0FBQzs7SUFNSSxLQUFLOzs7OztBQUlFLFdBSlAsS0FBSyxHQUlLOzBCQUpWLEtBQUs7O0FBS1AsUUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztHQUM5Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VBTkcsS0FBSzs7V0EwQlEsNkJBQUc7QUFDbEIsVUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQzs7QUFFbkMsbUNBQVUsZ0JBQWdCLEVBQUUsVUFBQyxJQUFJO2VBQU0sTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUU7T0FBQyxDQUFDLENBQUM7O0FBRTNELGFBQU8sTUFBTSxDQUFDO0tBQ2Y7Ozs7Ozs7Ozs7V0FRUSxxQkFBaUI7VUFBaEIsT0FBTyx5REFBRyxJQUFJOztBQUN0QixVQUFJLE9BQU8sRUFBRTtBQUNYLFlBQUksQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLEVBQUU7QUFDN0IsaUJBQU8sQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztTQUNyRDs7QUFFRCxlQUFPLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQztPQUNqQzs7QUFFRCxhQUFPLElBQUksQ0FBQyxZQUFZLENBQUM7S0FDMUI7Ozs7Ozs7Ozs7Ozs7Ozs7OztXQWdCRSxhQUFDLEdBQUcsRUFBRSxRQUFRLEVBQWtCOzs7VUFBaEIsT0FBTyx5REFBRyxJQUFJOztBQUMvQixVQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUU7QUFDM0IscUNBQVUsUUFBUSxFQUFFLFVBQUMsQ0FBQztpQkFBTSxNQUFLLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLE9BQU8sQ0FBQztTQUFDLENBQUMsQ0FBQztPQUV6RCxNQUFNO0FBQ0wsWUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQzs7QUFFdkMsWUFBSSxPQUFPLE1BQU0sQ0FBQyxHQUFHLENBQUMsS0FBSyxXQUFXLEVBQUU7QUFDdEMsY0FBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNuQixnQkFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztTQUNsQjtBQUNELGdCQUFRLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQzs7QUFFdEIsWUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFOztBQUV4QyxnQkFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUM1QjtPQUNGOztBQUVELGFBQU8sSUFBSSxDQUFDO0tBQ2I7Ozs7Ozs7Ozs7Ozs7Ozs7O1dBZUcsY0FBQyxHQUFHLEVBQUUsUUFBUSxFQUFrQjs7O1VBQWhCLE9BQU8seURBQUcsSUFBSTs7QUFDaEMsVUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxFQUFFO0FBQzNCLHFDQUFVLFFBQVEsRUFBRSxVQUFDLENBQUM7aUJBQU0sT0FBSyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxPQUFPLENBQUM7U0FBQyxDQUFDLENBQUM7T0FFMUQsTUFBTTtBQUNMLGdCQUFRLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztBQUN4QixZQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUM7T0FDbEM7S0FDRjs7Ozs7Ozs7Ozs7Ozs7Ozs7O1dBZ0JLLGdCQUFDLEdBQUcsRUFBRSxRQUFRLEVBQWtCO1VBQWhCLE9BQU8seURBQUcsSUFBSTs7QUFDbEMsVUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQzs7QUFFckMsVUFBSSxPQUFPLE1BQU0sQ0FBQyxHQUFHLENBQUMsS0FBSyxXQUFXLEVBQUU7QUFDdEMsWUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUN0QyxrQkFBUSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7O0FBRXJCLGlCQUFPLElBQUksQ0FBQztTQUNiO09BQ0Y7O0FBRUQsYUFBTyxLQUFLLENBQUM7S0FDZDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7V0FxQkUsYUFBQyxPQUFPLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQ3hDO0FBQ0UsWUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUM5QyxZQUFJLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNmLFlBQUksT0FBTSxHQUFHLGNBQWMsR0FBRyxjQUFjLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQzs7QUFFeEQsWUFBSSxPQUFNLEVBQUU7O0FBRVYsaUJBQU8sRUFBRSxLQUFLLEdBQUcsT0FBTSxFQUFFO0FBQ3ZCLGdCQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxJQUFJLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLEVBQUU7QUFDeEQsdUJBQVM7YUFDVjs7QUFFRCxnQkFBSSxHQUFHLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQzs7QUFFdEUsZ0JBQUksR0FBRyxLQUFLLEtBQUssQ0FBQyxFQUFFO0FBQ2xCLGdCQUFFLEdBQUcsR0FBRyxDQUFDO2FBQ1Y7QUFDRCxnQkFBSSxjQUFjLENBQUMsS0FBSyxDQUFDLElBQUksY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sRUFBRTtBQUMxRCxrQkFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7YUFDekM7V0FDRjtTQUNGO09BQ0Y7QUFDRDtBQUNFLFlBQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDbkQsWUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDZixZQUFJLFFBQU0sR0FBRyxhQUFhLEdBQUcsYUFBYSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7O0FBRXRELFlBQUksUUFBTSxFQUFFOztBQUVWLGlCQUFPLEVBQUUsS0FBSyxHQUFHLFFBQU0sRUFBRTtBQUN2QixnQkFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsSUFBSSxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxFQUFFO0FBQ3RELHVCQUFTO2FBQ1Y7O0FBRUQsZ0JBQUksR0FBRyxHQUFHLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7O0FBRXJFLGdCQUFJLEdBQUcsS0FBSyxLQUFLLENBQUMsRUFBRTtBQUNsQixnQkFBRSxHQUFHLEdBQUcsQ0FBQzthQUNWO0FBQ0QsZ0JBQUksYUFBYSxDQUFDLEtBQUssQ0FBQyxJQUFJLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLEVBQUU7QUFDeEQsa0JBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLGFBQWEsQ0FBQyxLQUFLLENBQUMsRUFBRSxPQUFPLENBQUMsQ0FBQzthQUNqRDtXQUNGO1NBQ0Y7T0FDRjs7QUFFRCxhQUFPLEVBQUUsQ0FBQztLQUNYOzs7Ozs7Ozs7O1dBUU0sbUJBQWlCO1VBQWhCLE9BQU8seURBQUcsSUFBSTs7QUFDcEIscUNBQVcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsRUFBRSxVQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsTUFBTTtlQUFNLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQztPQUFDLENBQUMsQ0FBQztLQUN2Rjs7Ozs7Ozs7Ozs7Ozs7OztXQWNPLGtCQUFDLEdBQUcsRUFBRTtBQUNaLFVBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxFQUFFO0FBQzNCLHdCQUFnQixDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztPQUM1QjtLQUNGOzs7Ozs7Ozs7Ozs7OztXQVlTLG9CQUFDLEdBQUcsRUFBRTtBQUNkLFVBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsRUFBRTtBQUMxQix3QkFBZ0IsQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO09BQzNEO0tBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7O1dBZVcsc0JBQUMsR0FBRyxFQUFFO0FBQ2hCLGFBQU8sZ0JBQWdCLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUMzQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1dBc0JZLHlCQUFHO0FBQ2QsYUFBTyxnQkFBZ0IsQ0FBQztLQUN6Qjs7O1NBcFNHLEtBQUs7OztRQXVTSCxLQUFLLEdBQUwsS0FBSzs7O0FBR2IsWUFBWSxDQUFDLEtBQUssR0FBRyxZQUFZLENBQUMsS0FBSyxJQUFJLEVBQUUsQ0FBQztBQUM5QyxZQUFZLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7Ozs7Ozs7Ozs7Ozs7NkJDMTFCUixrQkFBa0I7OzZCQUNaLGtCQUFrQjs7QUFFakQsSUFBTSxpQkFBaUIsR0FBRyxJQUFJLE9BQU8sRUFBRSxDQUFDOzs7Ozs7OztBQVF4QyxTQUFTLGNBQWMsQ0FBQyxVQUFVLEVBQUUsV0FBVyxFQUFFO0FBQy9DLFlBQVUsR0FBRyxxQ0FBaUIsVUFBVSxDQUFDLENBQUM7O0FBRTFDLGNBQVksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxZQUFZO0FBQzlDLFFBQUksTUFBTSxDQUFDOztBQUVYLFFBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUU7QUFDaEMsdUJBQWlCLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztLQUNqQztBQUNELFVBQU0sR0FBRyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7O0FBRXJDLFFBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQUU7QUFDdkIsWUFBTSxDQUFDLFVBQVUsQ0FBQyxHQUFHLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQzVDO0dBQ0YsQ0FBQyxDQUFDO0FBQ0gsY0FBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsY0FBYyxFQUFFLFlBQVk7QUFDakQsUUFBSSxDQUFDLEVBQUUsYUFBYSxDQUFDOztBQUVyQixRQUFJLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUMvQixtQkFBYSxHQUFHLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQzs7QUFFNUMsV0FBSyxDQUFDLElBQUksYUFBYSxFQUFFO0FBQ3ZCLFlBQUksYUFBYSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsRUFBRTtBQUNuQyx1QkFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1NBQzVCO09BQ0Y7QUFDRCx1QkFBaUIsVUFBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ2hDO0dBQ0YsQ0FBQyxDQUFDO0NBQ0o7Ozs7Ozs7QUFPRCxTQUFTLFNBQVMsQ0FBQyxRQUFRLEVBQUUsVUFBVSxFQUFFO0FBQ3ZDLE1BQUksT0FBTyxVQUFVLElBQUksUUFBUSxFQUFFO0FBQ2pDLFVBQU0sS0FBSyxDQUFDLGtEQUFrRCxDQUFDLENBQUM7R0FDakU7QUFDRCxNQUFJLFdBQVcsR0FBRyxxQ0FBaUIsVUFBVSxDQUFDLENBQUM7O0FBRS9DLE1BQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsV0FBVyxDQUFDLEVBQUU7QUFDckYsV0FBTyxLQUFLLENBQUMsQ0FBQztHQUNmOztBQUVELFNBQU8saUJBQWlCLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0NBQ3JEOzs7Ozs7OztBQVFELFNBQVMsdUJBQXVCLENBQUMsV0FBVyxFQUFFO0FBQzVDLFNBQU8saUJBQWlCLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO0NBQ2xHOzs7Ozs7Ozs7QUFTRCxTQUFTLGFBQWEsQ0FBQyxXQUFXLEVBQUUsTUFBTSxFQUFFO0FBQzFDLE1BQUksVUFBVSxHQUFHLElBQUksQ0FBQzs7QUFFdEIsTUFBSSxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLEVBQUU7QUFDdEMsbUNBQVcsaUJBQWlCLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxFQUFFLFVBQUMsY0FBYyxFQUFFLElBQUksRUFBSztBQUN2RSxVQUFJLGNBQWMsS0FBSyxNQUFNLEVBQUU7QUFDN0Isa0JBQVUsR0FBRyxJQUFJLENBQUM7T0FDbkI7S0FDRixDQUFDLENBQUM7R0FDSjs7QUFFRCxTQUFPLFVBQVUsQ0FBQztDQUNuQjs7UUFFTyxjQUFjLEdBQWQsY0FBYztRQUFFLFNBQVMsR0FBVCxTQUFTO1FBQUUsdUJBQXVCLEdBQXZCLHVCQUF1QjtRQUFFLGFBQWEsR0FBYixhQUFhOzs7Ozs7Ozs7Ozs7OzZCQzNGMUMsa0JBQWtCOztBQUVqRCxJQUFJLG1CQUFtQixHQUFHLEVBQUUsQ0FBQzs7O0FBRzdCLFlBQVksQ0FBQyxTQUFTLEdBQUcsWUFBWSxDQUFDLFNBQVMsSUFBSSxFQUFFLENBQUM7QUFDdEQsWUFBWSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsR0FBRyxnQkFBZ0IsQ0FBQztBQUMzRCxZQUFZLENBQUMsU0FBUyxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7Ozs7Ozs7QUFPakQsU0FBUyxnQkFBZ0IsQ0FBQyxZQUFZLEVBQUUsZ0JBQWdCLEVBQUU7QUFDeEQsTUFBSSxZQUFZLENBQUM7O0FBRWpCLHFCQUFtQixDQUFDLFlBQVksQ0FBQyxHQUFHLGdCQUFnQixDQUFDOztBQUVyRCxjQUFZLEdBQUcscUNBQWlCLFlBQVksQ0FBQyxHQUFHLFVBQVUsQ0FBQzs7QUFFM0QsY0FBWSxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsR0FBRyxnQkFBZ0IsQ0FBQztBQUN4RCxjQUFZLENBQUMsWUFBWSxDQUFDLEdBQUcsZ0JBQWdCLENBQUM7Q0FDL0M7Ozs7OztBQU1ELFNBQVMsV0FBVyxDQUFDLFlBQVksRUFBRTtBQUNqQyxNQUFJLE9BQU8sWUFBWSxJQUFJLFVBQVUsRUFBRTtBQUNyQyxXQUFPLFlBQVksQ0FBQztHQUNyQjs7QUFFRCxNQUFJLE9BQU8sWUFBWSxJQUFJLFFBQVEsRUFBRTtBQUNuQyxVQUFNLEtBQUssQ0FBQyxrRUFBa0UsQ0FBQyxDQUFDO0dBQ2pGOztBQUVELE1BQUksRUFBRSxZQUFZLElBQUksbUJBQW1CLENBQUEsQUFBQyxFQUFFO0FBQzFDLFVBQU0sS0FBSyxDQUFDLG1DQUFtQyxHQUFHLFlBQVksR0FBRyxHQUFHLENBQUMsQ0FBQztHQUN2RTs7QUFFRCxTQUFPLG1CQUFtQixDQUFDLFlBQVksQ0FBQyxDQUFDO0NBQzFDOzs7Ozs7QUFNRCxTQUFTLFdBQVcsQ0FBQyxZQUFZLEVBQUU7QUFDakMsU0FBTyxZQUFZLElBQUksbUJBQW1CLENBQUM7Q0FDNUM7O1FBRU8sZ0JBQWdCLEdBQWhCLGdCQUFnQjtRQUFFLFdBQVcsR0FBWCxXQUFXO1FBQUUsV0FBVyxHQUFYLFdBQVc7Ozs7Ozs7Ozs7Ozs7aUNDckRkLDBCQUEwQjs7eUJBQy9CLGdCQUFnQjs7UUFFdkMsYUFBYSxHQUFiLGFBQWE7O0FBRXJCLGlDQUFpQixNQUFNLEVBQUUsYUFBYSxDQUFDLENBQUM7OztBQUd4QyxZQUFZLENBQUMsU0FBUyxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7O0FBRXJELFNBQVMsYUFBYSxDQUFDLFFBQVEsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLGNBQWMsRUFBRTtBQUMxRSxNQUFJLGNBQWMsQ0FBQyxTQUFTLEVBQUU7QUFDNUIsUUFBRyxFQUFFLENBQUMsU0FBUyxFQUFFO0FBQ2YsUUFBRSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUMsU0FBUyxHQUFHLEdBQUcsR0FBRyxjQUFjLENBQUMsU0FBUyxDQUFDO0tBQzlELE1BQU07QUFDTCxRQUFFLENBQUMsU0FBUyxHQUFHLGNBQWMsQ0FBQyxTQUFTLENBQUM7S0FDekM7R0FDRjs7QUFFRCxNQUFJLGNBQWMsQ0FBQyxRQUFRLEVBQUU7QUFDM0IscUNBQVMsRUFBRSxFQUFFLGNBQWMsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0dBQ3BEOztBQUVELE1BQUksY0FBYyxDQUFDLEtBQUssS0FBSyxLQUFLLElBQUksY0FBYyxDQUFDLG9CQUFvQixFQUFFO0FBQ3pFLHFDQUFTLEVBQUUsRUFBRSxjQUFjLENBQUMsb0JBQW9CLENBQUMsQ0FBQztHQUNuRCxNQUFNO0FBQ0wsd0NBQVksRUFBRSxFQUFFLGNBQWMsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0dBQ3REOztBQUVELE1BQUksY0FBYyxDQUFDLFFBQVEsS0FBSyxLQUFLLElBQUksY0FBYyxDQUFDLG1CQUFtQixFQUFFO0FBQzNFLHFDQUFTLEVBQUUsRUFBRSxjQUFjLENBQUMsbUJBQW1CLENBQUMsQ0FBQztHQUNsRDs7QUFFRCxNQUFJLENBQUMsS0FBSyxJQUFJLGNBQWMsQ0FBQyxXQUFXLEVBQUU7QUFDeEMscUNBQVMsRUFBRSxFQUFFLGNBQWMsQ0FBQyx3QkFBd0IsQ0FBQyxDQUFDO0dBQ3ZEO0NBQ0Y7Ozs7Ozs7OztpQ0N2Q2dDLDBCQUEwQjs7NEJBQ1YsbUJBQW1COzt5QkFDeEIsZ0JBQWdCOzsrQ0FDeEIsMkNBQTJDOztBQUUvRSxJQUFJLGVBQWUsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3BELGVBQWUsQ0FBQyxTQUFTLEdBQUcsdUJBQXVCLENBQUM7O0FBRXBELElBQUksYUFBYSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDbEQsYUFBYSxDQUFDLFNBQVMsR0FBRyxxQkFBcUIsQ0FBQzs7O0FBR2hELGFBQWEsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQzs7QUFFOUUsSUFBSSx3QkFBd0IsR0FBRyxTQUEzQix3QkFBd0IsQ0FBWSxFQUFFLEVBQUUsT0FBTyxFQUFDO0FBQ2xELFNBQU8sQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDLFNBQVMsQ0FBQztBQUNqQyxLQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ2QsSUFBRSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztDQUN6QixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7QUFlRixTQUFTLG9CQUFvQixDQUFDLFFBQVEsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLGNBQWMsRUFBRTs7QUFFakYsTUFBSSxPQUFPLEdBQUcsZUFBZSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUM5QyxNQUFJLEtBQUssR0FBRyxhQUFhLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDOztBQUUxQyw4QkFBWSxNQUFNLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxjQUFjLENBQUMsQ0FBQzs7QUFFekUsSUFBRSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN0QixtQ0FBUyxFQUFFLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQzs7QUFHL0IsTUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUU7OztBQUVsQixNQUFFLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7O0dBRW5FOztBQUlELE1BQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxFQUFFO0FBQzdCLFFBQUksWUFBWSxHQUFHLGdDQUFtQixRQUFRLENBQUMsQ0FBQzs7O0FBR2hELFlBQVEsQ0FBQyxlQUFlLEdBQUcsVUFBVSxLQUFLLEVBQUU7QUFDMUMsVUFBSSxpQ0FBUyxLQUFLLENBQUMsTUFBTSxFQUFFLHFCQUFxQixDQUFDLEVBQUU7QUFDakQsZ0JBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsRUFBRSxJQUFJLEVBQUUsMkRBQTBCLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztPQUM5RjtLQUNGLENBQUM7O0FBRUYsZ0JBQVksQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLFdBQVcsRUFBRSxRQUFRLENBQUMsZUFBZSxDQUFDLENBQUM7OztBQUczRixZQUFRLENBQUMsV0FBVyxDQUFDLGNBQWMsRUFBRSxZQUFZO0FBQy9DLGtCQUFZLENBQUMsT0FBTyxFQUFFLENBQUM7S0FDeEIsQ0FBQyxDQUFDO0dBQ0o7Q0FDRjs7UUFFTyxvQkFBb0IsR0FBcEIsb0JBQW9COztBQUU1QixpQ0FBaUIsY0FBYyxFQUFFLG9CQUFvQixDQUFDLENBQUM7Ozs7Ozs7OztpQ0N6RWYsMEJBQTBCOzs2QkFDbkMscUJBQXFCOzs0QkFDekIsbUJBQW1COzt5QkFDRixnQkFBZ0I7OzhCQUNwQyxzQkFBc0I7OytCQUN5Qyx3QkFBd0I7O0FBRS9HLElBQU0sdUJBQXVCLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQztBQUM5QyxJQUFNLGVBQWUsR0FBRyxZQUFZLENBQUM7Ozs7Ozs7Ozs7Ozs7OztBQWVyQyxTQUFTLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLGNBQWMsRUFBRTtBQUM3RSxNQUFNLFlBQVksR0FBRywrQkFBaUIsUUFBUSxDQUFDLENBQUM7QUFDaEQsTUFBTSxLQUFLLEdBQUcsV0FBVyxFQUFFLENBQUM7O0FBRTVCLE1BQUksT0FBTyxjQUFjLENBQUMsZUFBZSxLQUFLLFdBQVcsRUFBRTtBQUN6RCxrQkFBYyxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUM7R0FDdkM7QUFDRCxNQUFJLE9BQU8sY0FBYyxDQUFDLGlCQUFpQixLQUFLLFdBQVcsRUFBRTtBQUMzRCxrQkFBYyxDQUFDLGlCQUFpQixHQUFHLEtBQUssQ0FBQztHQUMxQztBQUNELGdDQUFNLEVBQUUsQ0FBQyxDQUFDOztBQUVWLE1BQUksS0FBSyxLQUFLLGNBQWMsQ0FBQyxlQUFlLElBQUkscUNBQWlCLEtBQUssRUFBRSxjQUFjLENBQUMsZUFBZSxDQUFDLEVBQUU7QUFDdkcsU0FBSyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7QUFDckIsTUFBRSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztHQUN2QixNQUNJLElBQUksS0FBSyxLQUFLLGNBQWMsQ0FBQyxpQkFBaUIsSUFBSSxxQ0FBaUIsS0FBSyxFQUFFLGNBQWMsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFO0FBQ2hILE1BQUUsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7R0FDdkIsTUFDSSxJQUFJLEtBQUssS0FBSyxJQUFJLEVBQUU7O0FBQ3ZCLHFDQUFTLEtBQUssRUFBRSxTQUFTLENBQUMsQ0FBQztBQUMzQixNQUFFLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO0dBQ3ZCLE1BQ0k7QUFDSCxTQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7QUFDN0IscUNBQVMsS0FBSyxFQUFFLGVBQWUsQ0FBQyxDQUFDO0FBQ2pDLE1BQUUsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDdEIsTUFBRSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7R0FDeEQ7O0FBRUQsTUFBSSxjQUFjLENBQUMsUUFBUSxFQUFFO0FBQzNCLGdCQUFZLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxjQUFjLENBQUMsQ0FBQztHQUMvRCxNQUFNO0FBQ0wsZ0JBQVksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsV0FBVyxtQ0FBa0IsQ0FBQztBQUNuRSxnQkFBWSxDQUFDLGdCQUFnQixDQUFDLEtBQUssRUFBRSxTQUFTLG1DQUFrQixDQUFDO0FBQ2pFLGdCQUFZLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLFFBQVEsRUFBRSxVQUFDLEtBQUssRUFBSztBQUN4RCxjQUFRLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsTUFBTSxDQUFDLE9BQU8sR0FBRyxjQUFjLENBQUMsZUFBZSxHQUFHLGNBQWMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0tBQ2hJLENBQUMsQ0FBQztHQUNKOztBQUVELE1BQUksQ0FBQyx1QkFBdUIsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUU7QUFDMUMsMkJBQXVCLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUM1QyxZQUFRLENBQUMsT0FBTyxDQUFDLGVBQWUsRUFBRSxlQUFlLENBQUMsQ0FBQztHQUNwRDs7Ozs7Ozs7QUFRRCxXQUFTLGVBQWUsQ0FBQyxLQUFLLEVBQUU7QUFDOUIsUUFBTSxXQUFXLEdBQUcsQ0FDbEIsMEJBQVUsS0FBSyxFQUNmLDBCQUFVLEtBQUssRUFDZiwwQkFBVSxNQUFNLEVBQ2hCLDBCQUFVLFNBQVMsQ0FDcEIsQ0FBQzs7QUFFRixRQUFJLFdBQVcsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsb0RBQThCLEtBQUssQ0FBQyxFQUFFO0FBQ3RGLDhCQUF3QixDQUFDLFlBQVc7QUFDbEMsdURBQXlCLEtBQUssQ0FBQyxDQUFDO0FBQ2hDLGFBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztPQUN4QixDQUFDLENBQUM7S0FDSjtBQUNELFFBQUksS0FBSyxDQUFDLE9BQU8sSUFBSSwwQkFBVSxLQUFLLElBQUksS0FBSyxDQUFDLE9BQU8sSUFBSSwwQkFBVSxLQUFLLEVBQUU7QUFDeEUsb0JBQWMsRUFBRSxDQUFDO0tBQ2xCO0FBQ0QsUUFBSSxLQUFLLENBQUMsT0FBTyxJQUFJLDBCQUFVLE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxJQUFJLDBCQUFVLFNBQVMsRUFBRTtBQUM3RSxvQkFBYyxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQ3ZCO0dBQ0Y7Ozs7Ozs7O0FBUUQsV0FBUyxjQUFjLEdBQWlCO1FBQWhCLE9BQU8seURBQUcsSUFBSTs7QUFDcEMsNEJBQXdCLENBQUMsVUFBUyxVQUFVLEVBQUU7QUFDNUMsV0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRTs7QUFFckQsWUFBSSxpQ0FBUyxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUUsZUFBZSxDQUFDLElBQUksT0FBTyxLQUFLLElBQUksRUFBRTtBQUNoRSxpQkFBTztTQUNSO0FBQ0Qsc0JBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUM7T0FDeEM7S0FDRixDQUFDLENBQUM7R0FDSjs7Ozs7Ozs7O0FBU0QsV0FBUyxjQUFjLENBQUMsUUFBUSxFQUFrQjtRQUFoQixPQUFPLHlEQUFHLElBQUk7O0FBQzlDLFFBQUksT0FBTyxLQUFLLElBQUksRUFBRTtBQUNwQixjQUFRLENBQUMsT0FBTyxHQUFHLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQztLQUN0QyxNQUFNO0FBQ0wsY0FBUSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7S0FDNUI7QUFDRCxnQkFBWSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUM7R0FDNUM7Ozs7Ozs7O0FBUUQsV0FBUyx3QkFBd0IsQ0FBQyxRQUFRLEVBQUU7QUFDMUMsUUFBTSxRQUFRLEdBQUcsUUFBUSxDQUFDLGdCQUFnQixFQUFFLENBQUM7QUFDN0MsUUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLGdCQUFnQixFQUFFLENBQUM7QUFDNUMsUUFBTSxXQUFXLEdBQUcsUUFBUSxDQUFDLG9CQUFvQixFQUFFLENBQUM7O0FBRXBELFNBQUssSUFBSSxJQUFHLEdBQUcsT0FBTyxDQUFDLEdBQUcsRUFBRSxJQUFHLElBQUksV0FBVyxDQUFDLEdBQUcsRUFBRSxJQUFHLEVBQUUsRUFBRTtBQUN6RCxXQUFLLElBQUksSUFBRyxHQUFHLE9BQU8sQ0FBQyxHQUFHLEVBQUUsSUFBRyxJQUFJLFdBQVcsQ0FBQyxHQUFHLEVBQUUsSUFBRyxFQUFFLEVBQUU7QUFDekQsWUFBSSxJQUFJLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFHLEVBQUUsSUFBRyxDQUFDLENBQUM7QUFDdEMsWUFBSSxlQUFjLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQyxJQUFHLEVBQUUsSUFBRyxDQUFDLENBQUM7QUFDcEQsWUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLHNCQUFzQixDQUFDLENBQUM7O0FBRS9ELFlBQUksVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksQ0FBQyxlQUFjLENBQUMsUUFBUSxFQUFFO0FBQ3JELGtCQUFRLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDdEI7T0FDRjtLQUNGO0dBQ0Y7Q0FDRjs7UUFFTyxnQkFBZ0IsR0FBaEIsZ0JBQWdCOztBQUV4QixpQ0FBaUIsVUFBVSxFQUFFLGdCQUFnQixDQUFDLENBQUM7Ozs7Ozs7QUFRL0MsU0FBUyxXQUFXLEdBQUc7QUFDckIsTUFBSSxLQUFLLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQzs7QUFFNUMsT0FBSyxDQUFDLFNBQVMsR0FBRyx5QkFBeUIsQ0FBQztBQUM1QyxPQUFLLENBQUMsSUFBSSxHQUFHLFVBQVUsQ0FBQztBQUN4QixPQUFLLENBQUMsWUFBWSxDQUFDLGNBQWMsRUFBRSxLQUFLLENBQUMsQ0FBQzs7QUFFMUMsU0FBTyxLQUFLLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO0NBQy9COztBQUVELFNBQVMsY0FBYyxDQUFDLEtBQUssRUFBRTtBQUM3QixPQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7Q0FDeEI7Ozs7Ozs7OztpQ0NqTDJCLDBCQUEwQjs7eUJBQ1YsZ0JBQWdCOzs7Ozs7Ozs7Ozs7O0FBYzVELFNBQVMsWUFBWSxDQUFDLFFBQVEsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLGNBQWMsRUFBRTtBQUN6RSw4QkFBWSxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQzNDLHdDQUFjLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQztDQUMxQjs7UUFFTyxZQUFZLEdBQVosWUFBWTs7QUFFcEIsaUNBQWlCLE1BQU0sRUFBRSxZQUFZLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7dUJDdEJuQixTQUFTOzs7O2lDQUNOLDBCQUEwQjs7eUJBQ0wsZ0JBQWdCOzs2QkFDcEMscUJBQXFCOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0I3QyxTQUFTLGVBQWUsQ0FBQyxRQUFRLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxjQUFjLEVBQUU7QUFDNUUsTUFBSSw4QkFBVSxLQUFLLENBQUMsRUFBRTtBQUNwQixRQUFJLE9BQU8sY0FBYyxDQUFDLFFBQVEsS0FBSyxXQUFXLEVBQUU7QUFDbEQsMkJBQVEsUUFBUSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUMzQztBQUNELFNBQUssR0FBRywwQkFBUSxLQUFLLENBQUMsQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLE1BQU0sSUFBSSxHQUFHLENBQUMsQ0FBQztBQUM1RCxxQ0FBUyxFQUFFLEVBQUUsV0FBVyxDQUFDLENBQUM7R0FDM0I7QUFDRCw4QkFBWSxNQUFNLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxjQUFjLENBQUMsQ0FBQztDQUMxRTs7UUFFTyxlQUFlLEdBQWYsZUFBZTs7QUFFdkIsaUNBQWlCLFNBQVMsRUFBRSxlQUFlLENBQUMsQ0FBQzs7Ozs7Ozs7O2lDQ2hDakIsMEJBQTBCOzt5QkFDVixnQkFBZ0I7Ozs7Ozs7Ozs7Ozs7QUFjNUQsU0FBUyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxjQUFjLEVBQUU7QUFDN0UsOEJBQVksTUFBTSxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQzs7QUFFM0MsT0FBSyxHQUFHLEVBQUUsQ0FBQyxTQUFTLENBQUM7O0FBRXJCLE1BQUksSUFBSSxDQUFDO0FBQ1QsTUFBSSxVQUFVLEdBQUcsY0FBYyxDQUFDLFVBQVUsSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDO0FBQzNELE1BQUksVUFBVSxHQUFHLGNBQWMsQ0FBQyxVQUFVLElBQUksR0FBRyxDQUFDOztBQUVsRCxPQUFLLElBQUksR0FBRyxFQUFFLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLFVBQVUsRUFBRSxJQUFJLElBQUksVUFBVSxFQUFFLEVBQUU7O0FBRXRGLHdDQUFjLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztDQUN6Qjs7UUFFTyxnQkFBZ0IsR0FBaEIsZ0JBQWdCOztBQUV4QixpQ0FBaUIsVUFBVSxFQUFFLGdCQUFnQixDQUFDLENBQUM7Ozs7Ozs7OztpQ0MvQlosMEJBQTBCOzs0QkFDckMsb0JBQW9COzt5QkFDQSxnQkFBZ0I7Ozs7Ozs7Ozs7Ozs7OztBQWU1RCxTQUFTLFlBQVksQ0FBQyxRQUFRLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxjQUFjLEVBQUU7QUFDekUsOEJBQVksTUFBTSxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQzs7QUFFM0MsTUFBSSxDQUFDLEtBQUssSUFBSSxjQUFjLENBQUMsV0FBVyxFQUFFO0FBQ3hDLFNBQUssR0FBRyxjQUFjLENBQUMsV0FBVyxDQUFDO0dBQ3BDOztBQUVELE1BQUksT0FBTyxHQUFHLDZCQUFVLEtBQUssQ0FBQyxDQUFDOztBQUUvQixNQUFHLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDLGNBQWMsRUFBRTtBQUN6QyxXQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0dBQzNEOztBQUVELE1BQUksY0FBYyxDQUFDLGdCQUFnQixFQUFFO0FBQ25DLGtDQUFNLEVBQUUsQ0FBQyxDQUFDO0FBQ1YsUUFBSSxRQUFRLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUNsRCxZQUFRLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztBQUN0QyxZQUFRLENBQUMsU0FBUyxHQUFHLGNBQWMsQ0FBQyxnQkFBZ0IsQ0FBQztBQUNyRCx1QkFBbUIsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDdkMsWUFBUSxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDbEQsTUFBRSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQztHQUMxQixNQUNJOztBQUVILDBDQUFjLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQztHQUM1QjtDQUNGOztRQUVPLFlBQVksR0FBWixZQUFZOztBQUVwQixpQ0FBaUIsTUFBTSxFQUFFLFlBQVksQ0FBQyxDQUFDOzs7Ozs7QUMvQ3ZDLENBQUMsVUFBUyxNQUFNLEVBQUU7QUFDaEIsY0FBWSxDQUFDO0FBQ2IsTUFBSSxNQUFNLENBQUMsZUFBZSxFQUFFO0FBQzFCLFdBQU87R0FDUjtBQUNELE1BQUksT0FBTyxHQUFHLE1BQU0sQ0FBQztBQUNyQixNQUFJLFVBQVUsR0FBRyxTQUFTLENBQUM7QUFDM0IsTUFBSSxPQUFPLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQztBQUM3QixNQUFJLGlCQUFpQixHQUFHLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQztBQUNqRCxNQUFJLGVBQWUsR0FBRyxPQUFPLENBQUMsY0FBYyxDQUFDO0FBQzdDLE1BQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUM7QUFDN0IsTUFBSSx5QkFBeUIsR0FBRyxPQUFPLENBQUMsd0JBQXdCLENBQUM7QUFDakUsTUFBSSxvQkFBb0IsR0FBRyxPQUFPLENBQUMsbUJBQW1CLENBQUM7QUFDdkQsTUFBSSxLQUFLLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQztBQUN6QixNQUFJLGVBQWUsR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQztBQUN2RCxNQUFJLGtCQUFrQixHQUFHLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQztBQUNsRCxNQUFJLEtBQUssR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDO0FBQ3hCLE1BQUksYUFBYSxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUM7QUFDeEMsV0FBUyxPQUFPLENBQUMsS0FBSyxFQUFFO0FBQ3RCLFdBQU87QUFDTCxrQkFBWSxFQUFFLElBQUk7QUFDbEIsZ0JBQVUsRUFBRSxLQUFLO0FBQ2pCLFdBQUssRUFBRSxLQUFLO0FBQ1osY0FBUSxFQUFFLElBQUk7S0FDZixDQUFDO0dBQ0g7QUFDRCxNQUFJLE1BQU0sR0FBRyxPQUFPLENBQUM7QUFDckIsTUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDO0FBQ2hCLFdBQVMsZUFBZSxHQUFHO0FBQ3pCLFdBQU8sS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxFQUFFLE9BQU8sR0FBRyxLQUFLLENBQUM7R0FDMUU7QUFDRCxNQUFJLHNCQUFzQixHQUFHLGVBQWUsRUFBRSxDQUFDO0FBQy9DLE1BQUkseUJBQXlCLEdBQUcsZUFBZSxFQUFFLENBQUM7QUFDbEQsTUFBSSxrQkFBa0IsR0FBRyxlQUFlLEVBQUUsQ0FBQztBQUMzQyxNQUFJLFlBQVksR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDakMsTUFBSSxZQUFZLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2pDLFdBQVMsYUFBYSxDQUFDLENBQUMsRUFBRTtBQUN4QixXQUFPLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztHQUN4QjtBQUNELFdBQVMsaUJBQWlCLEdBQUc7QUFDM0IsUUFBSSxDQUFDLEdBQUcsZUFBZSxFQUFFLENBQUM7QUFDMUIsZ0JBQVksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUM7QUFDdkIsV0FBTyxDQUFDLENBQUM7R0FDVjtBQUNELFdBQVMsWUFBWSxDQUFDLE1BQU0sRUFBRTtBQUM1QixXQUFPLE9BQU8sTUFBTSxLQUFLLFFBQVEsSUFBSSxNQUFNLFlBQVksV0FBVyxDQUFDO0dBQ3BFO0FBQ0QsV0FBUyxNQUFNLENBQUMsQ0FBQyxFQUFFO0FBQ2pCLFFBQUksWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUNqQixPQUFPLFFBQVEsQ0FBQztBQUNsQixXQUFPLE9BQU8sQ0FBQyxDQUFDO0dBQ2pCO0FBQ0QsV0FBUyxNQUFNLENBQUMsV0FBVyxFQUFFO0FBQzNCLFFBQUksS0FBSyxHQUFHLElBQUksV0FBVyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQ3pDLFFBQUksRUFBRSxJQUFJLFlBQVksTUFBTSxDQUFBLEFBQUMsRUFDM0IsT0FBTyxLQUFLLENBQUM7QUFDZixVQUFNLElBQUksU0FBUyxDQUFDLDBCQUEwQixDQUFDLENBQUM7R0FDakQ7QUFDRCxpQkFBZSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsYUFBYSxFQUFFLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ2xFLGlCQUFlLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxVQUFVLEVBQUUsTUFBTSxDQUFDLFlBQVc7QUFDOUQsUUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUM7QUFDM0MsUUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsRUFDdkIsT0FBTyxXQUFXLENBQUMsc0JBQXNCLENBQUMsQ0FBQztBQUM3QyxRQUFJLENBQUMsV0FBVyxFQUNkLE1BQU0sU0FBUyxDQUFDLGtDQUFrQyxDQUFDLENBQUM7QUFDdEQsUUFBSSxJQUFJLEdBQUcsV0FBVyxDQUFDLHlCQUF5QixDQUFDLENBQUM7QUFDbEQsUUFBSSxJQUFJLEtBQUssU0FBUyxFQUNwQixJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ1osV0FBTyxTQUFTLEdBQUcsSUFBSSxHQUFHLEdBQUcsQ0FBQztHQUMvQixDQUFDLENBQUMsQ0FBQztBQUNKLGlCQUFlLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxTQUFTLEVBQUUsTUFBTSxDQUFDLFlBQVc7QUFDN0QsUUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUM7QUFDM0MsUUFBSSxDQUFDLFdBQVcsRUFDZCxNQUFNLFNBQVMsQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDO0FBQ3RELFFBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLEVBQ3ZCLE9BQU8sV0FBVyxDQUFDLHNCQUFzQixDQUFDLENBQUM7QUFDN0MsV0FBTyxXQUFXLENBQUM7R0FDcEIsQ0FBQyxDQUFDLENBQUM7QUFDSixXQUFTLFdBQVcsQ0FBQyxXQUFXLEVBQUU7QUFDaEMsUUFBSSxHQUFHLEdBQUcsZUFBZSxFQUFFLENBQUM7QUFDNUIsbUJBQWUsQ0FBQyxJQUFJLEVBQUUsa0JBQWtCLEVBQUUsRUFBQyxLQUFLLEVBQUUsSUFBSSxFQUFDLENBQUMsQ0FBQztBQUN6RCxtQkFBZSxDQUFDLElBQUksRUFBRSxzQkFBc0IsRUFBRSxFQUFDLEtBQUssRUFBRSxHQUFHLEVBQUMsQ0FBQyxDQUFDO0FBQzVELG1CQUFlLENBQUMsSUFBSSxFQUFFLHlCQUF5QixFQUFFLEVBQUMsS0FBSyxFQUFFLFdBQVcsRUFBQyxDQUFDLENBQUM7QUFDdkUsVUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2IsZ0JBQVksQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUM7R0FDMUI7QUFDRCxpQkFBZSxDQUFDLFdBQVcsQ0FBQyxTQUFTLEVBQUUsYUFBYSxFQUFFLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3ZFLGlCQUFlLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRSxVQUFVLEVBQUU7QUFDakQsU0FBSyxFQUFFLE1BQU0sQ0FBQyxTQUFTLENBQUMsUUFBUTtBQUNoQyxjQUFVLEVBQUUsS0FBSztHQUNsQixDQUFDLENBQUM7QUFDSCxpQkFBZSxDQUFDLFdBQVcsQ0FBQyxTQUFTLEVBQUUsU0FBUyxFQUFFO0FBQ2hELFNBQUssRUFBRSxNQUFNLENBQUMsU0FBUyxDQUFDLE9BQU87QUFDL0IsY0FBVSxFQUFFLEtBQUs7R0FDbEIsQ0FBQyxDQUFDO0FBQ0gsTUFBSSxZQUFZLEdBQUcsaUJBQWlCLEVBQUUsQ0FBQztBQUN2QyxNQUFJLHNCQUFzQixHQUFHLEVBQUMsS0FBSyxFQUFFLFNBQVMsRUFBQyxDQUFDO0FBQ2hELE1BQUksb0JBQW9CLEdBQUc7QUFDekIsUUFBSSxFQUFFLEVBQUMsS0FBSyxFQUFFLFNBQVMsRUFBQztBQUN4QixRQUFJLEVBQUUsRUFBQyxLQUFLLEVBQUUsU0FBUyxFQUFDO0dBQ3pCLENBQUM7QUFDRixNQUFJLFdBQVcsR0FBRyxDQUFDLENBQUM7QUFDcEIsV0FBUyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUU7QUFDaEMsUUFBSSxVQUFVLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ3RDLFFBQUksVUFBVSxJQUFJLFVBQVUsQ0FBQyxJQUFJLEtBQUssTUFBTSxFQUMxQyxPQUFPLFVBQVUsQ0FBQztBQUNwQixRQUFJLGFBQWEsQ0FBQyxNQUFNLENBQUMsRUFBRTtBQUN6QiwwQkFBb0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLFdBQVcsRUFBRSxDQUFDO0FBQ2hELDBCQUFvQixDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDO0FBQ3pDLDRCQUFzQixDQUFDLEtBQUssR0FBRyxPQUFPLENBQUMsSUFBSSxFQUFFLG9CQUFvQixDQUFDLENBQUM7QUFDbkUscUJBQWUsQ0FBQyxNQUFNLEVBQUUsWUFBWSxFQUFFLHNCQUFzQixDQUFDLENBQUM7QUFDOUQsYUFBTyxzQkFBc0IsQ0FBQyxLQUFLLENBQUM7S0FDckM7QUFDRCxXQUFPLFNBQVMsQ0FBQztHQUNsQjtBQUNELFdBQVMsTUFBTSxDQUFDLE1BQU0sRUFBRTtBQUN0QixvQkFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUN6QixXQUFPLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0dBQ3ZDO0FBQ0QsV0FBUyxpQkFBaUIsQ0FBQyxNQUFNLEVBQUU7QUFDakMsb0JBQWdCLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDekIsV0FBTyxrQkFBa0IsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0dBQ2xEO0FBQ0QsV0FBUyxJQUFJLENBQUMsTUFBTSxFQUFFO0FBQ3BCLG9CQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ3pCLFdBQU8sS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7R0FDckM7QUFDRCxRQUFNLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQzlCLFdBQVMsY0FBYyxDQUFDLENBQUMsRUFBRTtBQUN6QixXQUFPLFlBQVksQ0FBQyxDQUFDLENBQUMsSUFBSSxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7R0FDM0M7QUFDRCxXQUFTLFVBQVUsQ0FBQyxJQUFJLEVBQUU7QUFDeEIsUUFBSSxZQUFZLENBQUMsSUFBSSxDQUFDLEVBQ3BCLE9BQU8sSUFBSSxDQUFDLHNCQUFzQixDQUFDLENBQUM7QUFDdEMsV0FBTyxJQUFJLENBQUM7R0FDYjtBQUNELFdBQVMsZ0JBQWdCLENBQUMsS0FBSyxFQUFFO0FBQy9CLFFBQUksRUFBRSxHQUFHLEVBQUUsQ0FBQztBQUNaLFNBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO0FBQ3JDLFVBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7QUFDN0IsVUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztPQUNuQjtLQUNGO0FBQ0QsV0FBTyxFQUFFLENBQUM7R0FDWDtBQUNELFdBQVMsbUJBQW1CLENBQUMsTUFBTSxFQUFFO0FBQ25DLFdBQU8sZ0JBQWdCLENBQUMsb0JBQW9CLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztHQUN2RDtBQUNELFdBQVMsSUFBSSxDQUFDLE1BQU0sRUFBRTtBQUNwQixXQUFPLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0dBQ3hDO0FBQ0QsV0FBUyxxQkFBcUIsQ0FBQyxNQUFNLEVBQUU7QUFDckMsUUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDO0FBQ1osUUFBSSxLQUFLLEdBQUcsb0JBQW9CLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDekMsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDckMsVUFBSSxNQUFNLEdBQUcsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3BDLFVBQUksTUFBTSxFQUFFO0FBQ1YsVUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztPQUNqQjtLQUNGO0FBQ0QsV0FBTyxFQUFFLENBQUM7R0FDWDtBQUNELFdBQVMsd0JBQXdCLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRTtBQUM5QyxXQUFPLHlCQUF5QixDQUFDLE1BQU0sRUFBRSxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztHQUM1RDtBQUNELFdBQVMsY0FBYyxDQUFDLElBQUksRUFBRTtBQUM1QixXQUFPLGVBQWUsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0dBQ3JEO0FBQ0QsV0FBUyxTQUFTLENBQUMsSUFBSSxFQUFFO0FBQ3ZCLFdBQU8sTUFBTSxDQUFDLE9BQU8sSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztHQUN2RDtBQUNELFdBQVMsY0FBYyxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFO0FBQ2hELFFBQUksWUFBWSxDQUFDLElBQUksQ0FBQyxFQUFFO0FBQ3RCLFVBQUksR0FBRyxJQUFJLENBQUMsc0JBQXNCLENBQUMsQ0FBQztLQUNyQztBQUNELG1CQUFlLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxVQUFVLENBQUMsQ0FBQztBQUMxQyxXQUFPLE1BQU0sQ0FBQztHQUNmO0FBQ0QsV0FBUyxjQUFjLENBQUMsTUFBTSxFQUFFO0FBQzlCLG1CQUFlLENBQUMsTUFBTSxFQUFFLGdCQUFnQixFQUFFLEVBQUMsS0FBSyxFQUFFLGNBQWMsRUFBQyxDQUFDLENBQUM7QUFDbkUsbUJBQWUsQ0FBQyxNQUFNLEVBQUUscUJBQXFCLEVBQUUsRUFBQyxLQUFLLEVBQUUsbUJBQW1CLEVBQUMsQ0FBQyxDQUFDO0FBQzdFLG1CQUFlLENBQUMsTUFBTSxFQUFFLDBCQUEwQixFQUFFLEVBQUMsS0FBSyxFQUFFLHdCQUF3QixFQUFDLENBQUMsQ0FBQztBQUN2RixtQkFBZSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsZ0JBQWdCLEVBQUUsRUFBQyxLQUFLLEVBQUUsY0FBYyxFQUFDLENBQUMsQ0FBQztBQUM3RSxtQkFBZSxDQUFDLE1BQU0sRUFBRSxRQUFRLEVBQUUsRUFBQyxLQUFLLEVBQUUsTUFBTSxFQUFDLENBQUMsQ0FBQztBQUNuRCxtQkFBZSxDQUFDLE1BQU0sRUFBRSxtQkFBbUIsRUFBRSxFQUFDLEtBQUssRUFBRSxpQkFBaUIsRUFBQyxDQUFDLENBQUM7QUFDekUsbUJBQWUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBQyxDQUFDLENBQUM7QUFDL0MsbUJBQWUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLEVBQUMsS0FBSyxFQUFFLElBQUksRUFBQyxDQUFDLENBQUM7R0FDaEQ7QUFDRCxXQUFTLFVBQVUsQ0FBQyxNQUFNLEVBQUU7QUFDMUIsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDekMsVUFBSSxLQUFLLEdBQUcsb0JBQW9CLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDL0MsV0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDckMsWUFBSSxJQUFJLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3BCLFlBQUksY0FBYyxDQUFDLElBQUksQ0FBQyxFQUN0QixTQUFTO0FBQ1gsU0FBQyxVQUFTLEdBQUcsRUFBRSxJQUFJLEVBQUU7QUFDbkIseUJBQWUsQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFO0FBQzVCLGVBQUcsRUFBRSxlQUFXO0FBQ2QscUJBQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ2xCO0FBQ0Qsc0JBQVUsRUFBRSxJQUFJO1dBQ2pCLENBQUMsQ0FBQztTQUNKLENBQUEsQ0FBRSxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7T0FDNUI7S0FDRjtBQUNELFdBQU8sTUFBTSxDQUFDO0dBQ2Y7QUFDRCxXQUFTLFFBQVEsQ0FBQyxDQUFDLEVBQUU7QUFDbkIsV0FBTyxDQUFDLElBQUksSUFBSSxLQUFLLE9BQU8sQ0FBQyxLQUFLLFFBQVEsSUFBSSxPQUFPLENBQUMsS0FBSyxVQUFVLENBQUEsQUFBQyxDQUFDO0dBQ3hFO0FBQ0QsV0FBUyxRQUFRLENBQUMsQ0FBQyxFQUFFO0FBQ25CLFFBQUksQ0FBQyxJQUFJLElBQUksRUFDWCxNQUFNLFVBQVUsRUFBRSxDQUFDO0FBQ3JCLFdBQU8sT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0dBQ25CO0FBQ0QsV0FBUyxvQkFBb0IsQ0FBQyxRQUFRLEVBQUU7QUFDdEMsUUFBSSxRQUFRLElBQUksSUFBSSxFQUFFO0FBQ3BCLFlBQU0sSUFBSSxTQUFTLENBQUMsd0NBQXdDLENBQUMsQ0FBQztLQUMvRDtBQUNELFdBQU8sUUFBUSxDQUFDO0dBQ2pCO0FBQ0QsV0FBUyxjQUFjLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRTtBQUN0QyxRQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRTtBQUNsQixZQUFNLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztBQUN2QixZQUFNLENBQUMscUJBQXFCLEdBQUcscUJBQXFCLENBQUM7S0FDdEQ7QUFDRCxRQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUU7QUFDM0IsWUFBTSxDQUFDLE1BQU0sQ0FBQyxRQUFRLEdBQUcsTUFBTSxDQUFDLGlCQUFpQixDQUFDLENBQUM7S0FDcEQ7R0FDRjtBQUNELFdBQVMsWUFBWSxDQUFDLE1BQU0sRUFBRTtBQUM1QixrQkFBYyxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztBQUMvQixVQUFNLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQyxPQUFPLElBQUksRUFBRSxDQUFDO0FBQ3RDLFVBQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQztBQUN4RCxrQkFBYyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztHQUMvQjtBQUNELGNBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUNyQixRQUFNLENBQUMsZUFBZSxHQUFHO0FBQ3ZCLHdCQUFvQixFQUFFLG9CQUFvQjtBQUMxQyxxQkFBaUIsRUFBRSxpQkFBaUI7QUFDcEMsb0JBQWdCLEVBQUUsaUJBQWlCO0FBQ25DLGtCQUFjLEVBQUUsZUFBZTtBQUMvQixjQUFVLEVBQUUsVUFBVTtBQUN0QixvQkFBZ0IsRUFBRSxnQkFBZ0I7QUFDbEMsNEJBQXdCLEVBQUUseUJBQXlCO0FBQ25ELHVCQUFtQixFQUFFLG9CQUFvQjtBQUN6QyxZQUFRLEVBQUUsUUFBUTtBQUNsQixpQkFBYSxFQUFFLGFBQWE7QUFDNUIsa0JBQWMsRUFBRSxjQUFjO0FBQzlCLFFBQUksRUFBRSxLQUFLO0FBQ1gsZ0JBQVksRUFBRSxZQUFZO0FBQzFCLFlBQVEsRUFBRSxRQUFRO0FBQ2xCLGNBQVUsRUFBRSxVQUFVO0FBQ3RCLGNBQVEsTUFBTTtHQUNmLENBQUM7Q0FDSCxDQUFBLENBQUUsTUFBTSxDQUFDLENBQUM7QUFDWCxDQUFDLFlBQVc7QUFDVixjQUFZLENBQUM7QUFDYixNQUFJLFdBQVcsR0FBRyxlQUFlLENBQUMsVUFBVSxDQUFDOztBQUU3QyxXQUFTLE1BQU0sR0FBRztBQUNoQixRQUFJLEVBQUUsR0FBRyxFQUFFO1FBQ1QsQ0FBQyxHQUFHLENBQUM7UUFDTCxVQUFVLENBQUM7QUFDYixTQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUN6QyxVQUFJLGFBQWEsR0FBRyxlQUFlLENBQUMsb0JBQW9CLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdkUsVUFBSSxPQUFPLGFBQWEsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEtBQUssVUFBVSxFQUFFO0FBQ3JFLGNBQU0sSUFBSSxTQUFTLENBQUMsb0NBQW9DLENBQUMsQ0FBQztPQUMzRDtBQUNELFVBQUksSUFBSSxHQUFHLGFBQWEsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQztBQUN6RCxhQUFPLENBQUMsQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFBLENBQUUsSUFBSSxFQUFFO0FBQ3ZDLFVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUM7T0FDNUI7S0FDRjtBQUNELFdBQU8sRUFBRSxDQUFDO0dBQ1g7QUFDRCxpQkFBZSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7Q0FDakMsQ0FBQSxFQUFHLENBQUM7QUFDTCxDQUFDLFlBQVc7QUFDVixjQUFZLENBQUM7QUFDYixNQUFJLE9BQU8sR0FBRyxNQUFNLENBQUM7QUFDckIsTUFBSSxVQUFVLEdBQUcsU0FBUyxDQUFDO0FBQzNCLE1BQUksT0FBTyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUM7QUFDN0IsTUFBSSxpQkFBaUIsR0FBRyxlQUFlLENBQUMsZ0JBQWdCLENBQUM7QUFDekQsTUFBSSxlQUFlLEdBQUcsZUFBZSxDQUFDLGNBQWMsQ0FBQztBQUNyRCxNQUFJLHlCQUF5QixHQUFHLGVBQWUsQ0FBQyx3QkFBd0IsQ0FBQztBQUN6RSxNQUFJLGVBQWUsR0FBRyxNQUFNLENBQUMsY0FBYyxDQUFDO0FBQzVDLE1BQUksV0FBVyxHQUFHLGVBQWUsQ0FBQyxVQUFVLENBQUM7QUFDN0MsTUFBSSxJQUFJLEdBQUcsTUFBTTtNQUNmLG1CQUFtQixHQUFHLElBQUksQ0FBQyxtQkFBbUI7TUFDOUMscUJBQXFCLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixDQUFDO0FBQ3JELFdBQVMsZUFBZSxDQUFDLFVBQVUsRUFBRSxJQUFJLEVBQUU7QUFDekMsUUFBSSxLQUFLLEdBQUcsZUFBZSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ3hDLE9BQUc7QUFDRCxVQUFJLE1BQU0sR0FBRyx5QkFBeUIsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDcEQsVUFBSSxNQUFNLEVBQ1IsT0FBTyxNQUFNLENBQUM7QUFDaEIsV0FBSyxHQUFHLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUNoQyxRQUFRLEtBQUssRUFBRTtBQUNoQixXQUFPLFNBQVMsQ0FBQztHQUNsQjtBQUNELFdBQVMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFO0FBQzlCLFdBQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztHQUN2QjtBQUNELFdBQVMsU0FBUyxDQUFDLElBQUksRUFBRSxVQUFVLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRTtBQUMvQyxXQUFPLFFBQVEsQ0FBQyxJQUFJLEVBQUUsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7R0FDM0Q7QUFDRCxXQUFTLFFBQVEsQ0FBQyxJQUFJLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRTtBQUN4QyxRQUFJLFVBQVUsR0FBRyxlQUFlLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ25ELFFBQUksVUFBVSxFQUFFO0FBQ2QsVUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLEVBQ2pCLE9BQU8sVUFBVSxDQUFDLEtBQUssQ0FBQztBQUMxQixhQUFPLFVBQVUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ2xDO0FBQ0QsV0FBTyxTQUFTLENBQUM7R0FDbEI7QUFDRCxXQUFTLFFBQVEsQ0FBQyxJQUFJLEVBQUUsVUFBVSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUU7QUFDL0MsUUFBSSxVQUFVLEdBQUcsZUFBZSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNuRCxRQUFJLFVBQVUsSUFBSSxVQUFVLENBQUMsR0FBRyxFQUFFO0FBQ2hDLGdCQUFVLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDakMsYUFBTyxLQUFLLENBQUM7S0FDZDtBQUNELFVBQU0sVUFBVSxDQUFFLHVCQUF1QixHQUFHLElBQUksR0FBRyxJQUFJLENBQUUsQ0FBQztHQUMzRDtBQUNELFdBQVMsY0FBYyxDQUFDLE1BQU0sRUFBRTtBQUM5QixRQUFJLFdBQVcsR0FBRyxFQUFFLENBQUM7QUFDckIsUUFBSSxLQUFLLEdBQUcsbUJBQW1CLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDeEMsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDckMsVUFBSSxJQUFJLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3BCLGlCQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcseUJBQXlCLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO0tBQzdEO0FBQ0QsUUFBSSxPQUFPLEdBQUcscUJBQXFCLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDNUMsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7QUFDdkMsVUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3hCLGlCQUFXLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcseUJBQXlCLENBQUMsTUFBTSxFQUFFLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0tBQzNGO0FBQ0QsV0FBTyxXQUFXLENBQUM7R0FDcEI7QUFDRCxXQUFTLFdBQVcsQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUU7QUFDM0QsbUJBQWUsQ0FBQyxNQUFNLEVBQUUsYUFBYSxFQUFFO0FBQ3JDLFdBQUssRUFBRSxJQUFJO0FBQ1gsa0JBQVksRUFBRSxJQUFJO0FBQ2xCLGdCQUFVLEVBQUUsS0FBSztBQUNqQixjQUFRLEVBQUUsSUFBSTtLQUNmLENBQUMsQ0FBQztBQUNILFFBQUksU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7QUFDeEIsVUFBSSxPQUFPLFVBQVUsS0FBSyxVQUFVLEVBQ2xDLElBQUksQ0FBQyxTQUFTLEdBQUcsVUFBVSxDQUFDO0FBQzlCLFVBQUksQ0FBQyxTQUFTLEdBQUcsT0FBTyxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsRUFBRSxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztLQUM5RSxNQUFNO0FBQ0wsVUFBSSxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUM7S0FDekI7QUFDRCxtQkFBZSxDQUFDLElBQUksRUFBRSxXQUFXLEVBQUU7QUFDakMsa0JBQVksRUFBRSxLQUFLO0FBQ25CLGNBQVEsRUFBRSxLQUFLO0tBQ2hCLENBQUMsQ0FBQztBQUNILFdBQU8saUJBQWlCLENBQUMsSUFBSSxFQUFFLGNBQWMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO0dBQzlEO0FBQ0QsV0FBUyxjQUFjLENBQUMsVUFBVSxFQUFFO0FBQ2xDLFFBQUksT0FBTyxVQUFVLEtBQUssVUFBVSxFQUFFO0FBQ3BDLFVBQUksU0FBUyxHQUFHLFVBQVUsQ0FBQyxTQUFTLENBQUM7QUFDckMsVUFBSSxPQUFPLENBQUMsU0FBUyxDQUFDLEtBQUssU0FBUyxJQUFJLFNBQVMsS0FBSyxJQUFJLEVBQ3hELE9BQU8sVUFBVSxDQUFDLFNBQVMsQ0FBQztBQUM5QixZQUFNLElBQUksVUFBVSxDQUFDLDJDQUEyQyxDQUFDLENBQUM7S0FDbkU7QUFDRCxRQUFJLFVBQVUsS0FBSyxJQUFJLEVBQ3JCLE9BQU8sSUFBSSxDQUFDO0FBQ2QsVUFBTSxJQUFJLFVBQVUsQ0FBRSwwREFBMEQsR0FBRyxPQUFPLFVBQVUsR0FBRyxHQUFHLENBQUUsQ0FBQztHQUM5RztBQUNELFdBQVMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUU7QUFDaEQsUUFBSSxlQUFlLENBQUMsVUFBVSxDQUFDLEtBQUssSUFBSSxFQUN0QyxTQUFTLENBQUMsSUFBSSxFQUFFLFVBQVUsRUFBRSxhQUFhLEVBQUUsSUFBSSxDQUFDLENBQUM7R0FDcEQ7QUFDRCxpQkFBZSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7QUFDMUMsaUJBQWUsQ0FBQyxnQkFBZ0IsR0FBRyxnQkFBZ0IsQ0FBQztBQUNwRCxpQkFBZSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7QUFDdEMsaUJBQWUsQ0FBQyxnQkFBZ0IsR0FBRyxnQkFBZ0IsQ0FBQztBQUNwRCxpQkFBZSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7QUFDcEMsaUJBQWUsQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0NBQ3JDLENBQUEsRUFBRyxDQUFDOzs7Ozs7Ozs7O2lDQ2pYTSx1QkFBdUI7OzRCQUNlLGdCQUFnQjs7K0JBQ0oscUJBQXFCOzsrQ0FDOUMsd0NBQXdDOzs4Q0FDekMsc0NBQXNDOzt5Q0FDL0MsaUNBQWlDOzs7QUFJM0QsWUFBWSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7Ozs7OztBQU1uQyxTQUFTLFNBQVMsQ0FBQyxRQUFRLEVBQUU7QUFDM0IsTUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDOztBQUVoQixNQUFJLENBQUMsWUFBWSxHQUFHLGdDQUFtQixRQUFRLENBQUMsQ0FBQztBQUNqRCxNQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztBQUN6QixNQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQzs7QUFFdkMsTUFBSSxhQUFhLEdBQUcsUUFBUSxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7O0FBRS9ELE1BQUksYUFBYSxFQUFFO0FBQ2pCLFlBQVEsQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDLG9CQUFvQixFQUFFLGFBQWEsQ0FBQyxDQUFDO0dBQ3hFOztBQUVELG1DQUFTLFFBQVEsQ0FBQyxXQUFXLEVBQUUsY0FBYyxDQUFDLENBQUM7OztBQUcvQyxNQUFJLEtBQUssR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzVDLG1DQUFTLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQzs7QUFFMUIsTUFBSSxRQUFRLENBQUMsV0FBVyxFQUFFLENBQUMsY0FBYyxFQUFFO0FBQ3pDLHFDQUFTLEtBQUssRUFBRSxRQUFRLENBQUMsV0FBVyxFQUFFLENBQUMsY0FBYyxDQUFDLENBQUM7R0FDeEQ7QUFDRCxNQUFJLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDN0MsT0FBSyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDOUIsTUFBSSxDQUFDLEtBQUssR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzdDLE9BQUssQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDOztBQUU5QixVQUFRLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQzs7QUFFdkIsVUFBUSxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLENBQUM7O0FBRXRFLE1BQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxXQUFXLEVBQUUsVUFBUyxLQUFLLEVBQUU7QUFDcEYsUUFBSSxDQUFDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUU7QUFDOUMsd0JBQWtCLEVBQUUsQ0FBQztBQUNyQixXQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7QUFDdkIsWUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDO0tBQ2hCO0dBQ0YsQ0FBQyxDQUFDOztBQUVILE1BQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLGVBQWUsRUFBRSxPQUFPLEVBQUUsVUFBUyxLQUFLLEVBQUU7QUFDcEYsUUFBSSxRQUFRLENBQUMsU0FBUyxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRTtBQUN4RCxjQUFRLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDO0tBQzdCO0dBQ0YsQ0FBQyxDQUFDOztBQUVILE1BQUksV0FBVyxDQUFDO0FBQ2hCLE1BQUksQ0FBQyxXQUFXLEdBQUcsWUFBVztBQUM1QixXQUFPLFdBQVcsQ0FBQztHQUNwQixDQUFDOztBQUVGLE1BQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsUUFBUSxDQUFDLGVBQWUsRUFBRSxTQUFTLEVBQUUsVUFBUyxLQUFLLEVBQUU7QUFDdEYsUUFBSSxRQUFRLENBQUMsU0FBUyxDQUFDLFlBQVksRUFBRSxJQUFJLEtBQUssQ0FBQyxLQUFLLEtBQUssQ0FBQyxFQUFFOztBQUMxRCxjQUFRLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDO0tBQzdCOztBQUVELGVBQVcsR0FBRyxLQUFLLENBQUM7O0FBRXBCLFFBQUksdUNBQWUsUUFBUSxDQUFDLGFBQWEsQ0FBQyxFQUFFO0FBQzFDLGNBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQztLQUNyQjtHQUNGLENBQUMsQ0FBQzs7QUFFSCxNQUFJLENBQUMsWUFBWSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsQ0FBQyxlQUFlLEVBQUUsV0FBVyxFQUFFLFVBQVMsS0FBSyxFQUFFO0FBQ3hGLFFBQUksSUFBSSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7QUFDeEIsUUFBSSxNQUFNLEdBQUcsS0FBSyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDO0FBQ3RDLFFBQUksTUFBTSxHQUFHLEtBQUssQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQzs7QUFFdEMsUUFBSSxXQUFXLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFO0FBQ3hDLGFBQU87S0FDUjs7O0FBR0QsUUFBSSxJQUFJLEtBQUssUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRTtBQUM1QyxhQUFPLElBQUksS0FBSyxRQUFRLENBQUMsZUFBZSxFQUFFO0FBQ3hDLFlBQUksSUFBSSxLQUFLLElBQUksRUFBRTtBQUNqQixjQUFJLEtBQUssQ0FBQyxvQkFBb0IsRUFBRTtBQUM5QixrQkFBTTtXQUNQOztBQUVELGlCQUFPO1NBQ1I7QUFDRCxZQUFJLElBQUksS0FBSyxRQUFRLENBQUMsV0FBVyxFQUFFOztBQUVqQyxpQkFBTztTQUNSO0FBQ0QsWUFBSSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7T0FDeEI7S0FDRixNQUFNO0FBQ0wsVUFBSSxjQUFjLEdBQUcsMkNBQW1CLENBQUM7O0FBRXpDLFVBQUksUUFBUSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sR0FBRyxjQUFjLEVBQUUsTUFBTSxDQUFDLEtBQUssUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLE1BQU0sSUFDaEcsUUFBUSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxNQUFNLEdBQUcsY0FBYyxDQUFDLEtBQUssUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRTtBQUNoRyxlQUFPO09BQ1I7S0FDRjs7O0FBR0QsUUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLHFCQUFxQixFQUFFO0FBQ3ZDLGNBQVEsQ0FBQyxZQUFZLEVBQUUsQ0FBQztLQUN6QixNQUFNO0FBQ0wsY0FBUSxDQUFDLGFBQWEsRUFBRSxDQUFDO0tBQzFCO0dBQ0YsQ0FBQyxDQUFDOztBQUdILE1BQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLGFBQWEsRUFBRSxVQUFTLEtBQUssRUFBRTtBQUN2RSxRQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsaUJBQWlCLEVBQUU7QUFDbkMsYUFBTztLQUNSOzs7O0FBSUQsU0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO0dBQ3hCLENBQUMsQ0FBQzs7QUFFSCxNQUFJLGtCQUFrQixHQUFHLFNBQXJCLGtCQUFrQixHQUFjOztBQUVsQyxRQUFJLE1BQU0sQ0FBQyxZQUFZLEVBQUU7QUFDdkIsVUFBSSxNQUFNLENBQUMsWUFBWSxFQUFFLENBQUMsS0FBSyxFQUFFOztBQUMvQixjQUFNLENBQUMsWUFBWSxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUM7T0FDL0IsTUFBTSxJQUFJLE1BQU0sQ0FBQyxZQUFZLEVBQUUsQ0FBQyxlQUFlLEVBQUU7O0FBQ2hELGNBQU0sQ0FBQyxZQUFZLEVBQUUsQ0FBQyxlQUFlLEVBQUUsQ0FBQztPQUN6QztLQUNGLE1BQU0sSUFBSSxRQUFRLENBQUMsU0FBUyxFQUFFOztBQUM3QixjQUFRLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFDO0tBQzVCO0dBQ0YsQ0FBQzs7QUFFRixNQUFJLFVBQVUsR0FBRyxDQUNmLHlEQUF5QjtBQUN2QixhQUFTLEVBQUUsU0FBUztBQUNwQixVQUFNLEVBQUU7QUFDTixXQUFLLEVBQUUsQ0FBQztBQUNSLFdBQUssRUFBRSxTQUFTOztBQUVoQixtQkFBYSxFQUFFLHlCQUFXO0FBQ3hCLGVBQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRSxDQUFDO09BQzdGO0FBQ0QscUNBQStCLEVBQUUsMkNBQVc7QUFDMUMsZUFBTyxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsVUFBVSxFQUFFLENBQUM7T0FDakU7S0FDRjtHQUNGLENBQUMsRUFDRix5REFBeUI7QUFDdkIsYUFBUyxFQUFFLE1BQU07QUFDakIsVUFBTSxFQUFFO0FBQ04sV0FBSyxFQUFFLENBQUM7QUFDUixXQUFLLEVBQUUsU0FBUzs7QUFFaEIsbUJBQWEsRUFBRSx5QkFBVztBQUN4QixlQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxJQUFJLFFBQVEsQ0FBQyxTQUFTLENBQUMsVUFBVSxFQUFFLENBQUM7T0FDNUY7QUFDRCxxQ0FBK0IsRUFBRSwyQ0FBVztBQUMxQyxlQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxJQUFJLFFBQVEsQ0FBQyxTQUFTLENBQUMsVUFBVSxFQUFFLENBQUM7T0FDaEU7S0FDRjtHQUNGLENBQUMsRUFDRix5REFBeUI7QUFDdkIsYUFBUyxFQUFFLFdBQVc7QUFDdEIseUJBQXFCLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxtQkFBbUI7QUFDeEQsNEJBQXdCLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxtQkFBbUI7R0FDNUQsQ0FBQyxFQUNGLHlEQUF5QjtBQUN2QixhQUFTLEVBQUUsTUFBTTtBQUNqQixVQUFNLEVBQUU7QUFDTixXQUFLLEVBQUUsQ0FBQztBQUNSLFdBQUssRUFBRSxLQUFLOztLQUViO0dBQ0YsQ0FBQyxDQUFDLENBQUM7QUFDTixZQUFVLENBQUMsT0FBTyxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNuQyxZQUFVLENBQUMsSUFBSSxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNoQyxZQUFVLENBQUMsU0FBUyxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNyQyxZQUFVLENBQUMsSUFBSSxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7QUFFaEMsTUFBSSxpQkFBaUIsR0FBRztBQUN0QixTQUFLLEVBQUUsaUJBQVc7QUFDaEIsYUFBTyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQztLQUM1QjtBQUNELHlCQUFxQixFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxDQUFDLFNBQVMsRUFBRTtBQUNuSCxTQUFLLEVBQUUsS0FBSztBQUNaLFlBQVEsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVE7QUFDaEMsUUFBSSxFQUFFLFFBQVEsQ0FBQyxhQUFhO0FBQzVCLGFBQVMsRUFBRSxRQUFRLENBQUMsU0FBUztBQUM3QixnQkFBWSxFQUFFLFFBQVEsQ0FBQyxTQUFTO0FBQ2hDLG9CQUFnQixFQUFFLDRCQUFXO0FBQzNCLGFBQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQztLQUN2QztBQUNELGdCQUFZLEVBQUUsd0JBQVc7QUFDdkIsYUFBTyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQztLQUNuQztBQUNELGlCQUFhLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhO0FBQzFDLGNBQVUsRUFBRSxzQkFBVztBQUNyQixVQUFJLEdBQUcsR0FBRyxFQUFFLENBQUM7QUFDYixVQUFJLFFBQVEsQ0FBQyxhQUFhLEVBQUUsRUFBRTtBQUM1QixXQUFHLENBQUMsSUFBSSxDQUFDLFVBQVMsS0FBSyxFQUFFLEVBQUUsRUFBRTtBQUMzQixjQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztTQUNqQyxDQUFDLENBQUM7T0FDSjtBQUNELGtCQUFZLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsNEJBQTRCLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDcEUsYUFBTyxHQUFHLENBQUM7S0FDWjtBQUNELGlCQUFhLEVBQUUseUJBQVc7O0FBRXhCLFVBQUksR0FBRyxHQUFHLEVBQUUsQ0FBQztBQUNiLFVBQUksUUFBUSxDQUFDLGFBQWEsRUFBRSxFQUFFO0FBQzVCLFdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBUyxLQUFLLEVBQUUsRUFBRSxFQUFFO0FBQzNCLGNBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1NBQ2pDLENBQUMsQ0FBQztPQUNKO0FBQ0Qsa0JBQVksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSwrQkFBK0IsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUN2RSxhQUFPLEdBQUcsQ0FBQztLQUNaO0FBQ0QsZUFBVyxFQUFFLFFBQVEsQ0FBQyxXQUFXO0FBQ2pDLGFBQVMsRUFBRSxRQUFRLENBQUMsWUFBWTtBQUNoQyxnQkFBWSxFQUFFLHNCQUFTLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRSxFQUFFOztBQUVuQyxVQUFJLElBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUM7VUFDckMsY0FBYyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUM7VUFDcEQsUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLGNBQWMsQ0FBQyxDQUFDOztBQUUzRCxVQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQzs7QUFFdEQsY0FBUSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxjQUFjLENBQUMsQ0FBQztBQUNuRSxrQkFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxlQUFlLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxjQUFjLENBQUMsQ0FBQztLQUVuRztBQUNELGNBQVUsRUFBRSxVQUFVO0FBQ3RCLDZCQUF5QixFQUFFLHFDQUFXO0FBQ3BDLGFBQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQztLQUN4QztBQUNELG1CQUFlLEVBQUUseUJBQVMsS0FBSyxFQUFFLE1BQU0sRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQy9DLGNBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQztBQUNsQixVQUFJLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQzs7QUFFbkIsaUJBQVcsR0FBRyxJQUFJLENBQUM7O0FBRW5CLGtCQUFZLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsdUJBQXVCLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQzs7QUFFN0UsVUFBSSxDQUFDLG9EQUE4QixLQUFLLENBQUMsRUFBRTtBQUN6QyxZQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUFJLFFBQVEsQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxFQUFFOztTQUVuRSxNQUFNLElBQUksS0FBSyxDQUFDLFFBQVEsRUFBRTtBQUN6QixnQkFBSSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRTtBQUN0QyxzQkFBUSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDeEM7V0FDRixNQUFNO0FBQ0wsZ0JBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQSxLQUFNLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFBLEFBQUMsRUFBRTtBQUM5RSxrQkFBSSxNQUFNLENBQUMsR0FBRyxHQUFHLENBQUMsRUFBRTtBQUNsQix3QkFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsU0FBUyxFQUFFLEdBQUcsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUN6RSx3QkFBUSxDQUFDLFNBQVMsQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7ZUFDcEQ7QUFDRCxrQkFBSSxNQUFNLENBQUMsR0FBRyxHQUFHLENBQUMsRUFBRTtBQUNsQix3QkFBUSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsR0FBRyxFQUFFLFFBQVEsQ0FBQyxTQUFTLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUN6RSx3QkFBUSxDQUFDLFNBQVMsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7ZUFDcEQ7YUFDRixNQUFNO0FBQ0wsb0JBQU0sQ0FBQyxHQUFHLEdBQUcsTUFBTSxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUM7QUFDN0Msb0JBQU0sQ0FBQyxHQUFHLEdBQUcsTUFBTSxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUM7O0FBRTdDLHNCQUFRLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQzs7QUFFekMsc0JBQVEsQ0FBQyxTQUFTLENBQUMsa0JBQWtCLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO2FBQ3JEO1dBQ0Y7O0FBRUQsb0JBQVksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxzQkFBc0IsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDOztBQUU1RSxZQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUM7T0FDekI7S0FDRjs7Ozs7O0FBTUQsbUJBQWUsRUFBRSx5QkFBUyxLQUFLLEVBQUUsTUFBTSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDL0MsVUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7QUFDbkIsVUFBSSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsRUFBRTs7QUFDdEMsWUFBSSxXQUFXLEVBQUU7Ozs7QUFJZixrQkFBUSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDeEM7T0FDRixNQUFNO0FBQ0wsWUFBSSxXQUFXLEVBQUU7O0FBRWYsY0FBSSxNQUFNLENBQUMsR0FBRyxHQUFHLENBQUMsRUFBRTtBQUNsQixnQkFBSSxRQUFRLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUU7QUFDMUMsc0JBQVEsQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLDJEQUEwQixRQUFRLENBQUMsU0FBUyxFQUFFLEdBQUcsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ2hHLHNCQUFRLENBQUMsU0FBUyxDQUFDLGtCQUFrQixDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQzthQUVwRCxNQUFNO0FBQ0wsc0JBQVEsQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLDJEQUEwQixNQUFNLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO2FBQ25GO1dBRUY7OztBQUdELGNBQUksTUFBTSxDQUFDLEdBQUcsR0FBRyxDQUFDLEVBQUU7QUFDbEIsZ0JBQUksUUFBUSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFO0FBQzFDLHNCQUFRLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQywyREFBMEIsTUFBTSxDQUFDLEdBQUcsRUFBRSxRQUFRLENBQUMsU0FBUyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNoRyxzQkFBUSxDQUFDLFNBQVMsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7YUFFcEQsTUFBTTtBQUNMLHNCQUFRLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQywyREFBMEIsTUFBTSxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzthQUNuRjtXQUNGO1NBQ0Y7T0FDRjs7QUFFRCxrQkFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLHNCQUFzQixFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDNUUsVUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDO0tBQ3pCO0FBQ0QseUJBQXFCLEVBQUUsK0JBQVMsS0FBSyxFQUFFO0FBQ3JDLFdBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztBQUN2QixrQkFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLDRCQUE0QixFQUFFLEtBQUssQ0FBQyxDQUFDO0tBQ3ZFO0FBQ0QsY0FBVSxFQUFFLG9CQUFTLEtBQUssRUFBRTtBQUMxQixVQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQzFCO0FBQ0QsVUFBTSxFQUFFLGdCQUFTLEtBQUssRUFBRTtBQUN0QixVQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQ3BCO0FBQ0Qsc0JBQWtCLEVBQUUsOEJBQVc7QUFDN0IsY0FBUSxDQUFDLFFBQVEsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0tBQzVDO0FBQ0Qsd0JBQW9CLEVBQUUsZ0NBQVc7QUFDL0IsY0FBUSxDQUFDLFFBQVEsQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO0tBQzlDO0FBQ0QsdUJBQW1CLEVBQUUsNkJBQVMsT0FBTyxFQUFFLGVBQWUsRUFBRTtBQUN0RCxjQUFRLENBQUMsUUFBUSxDQUFDLG1CQUFtQixFQUFFLE9BQU8sRUFBRSxlQUFlLENBQUMsQ0FBQztLQUNsRTtBQUNELHVCQUFtQixFQUFFLCtCQUFXO0FBQzlCLGNBQVEsQ0FBQyxRQUFRLENBQUMsbUJBQW1CLENBQUMsQ0FBQztLQUN4QztBQUNELHlCQUFxQixFQUFFLGlDQUFXO0FBQ2hDLGNBQVEsQ0FBQyxRQUFRLENBQUMscUJBQXFCLENBQUMsQ0FBQztLQUMxQztBQUNELGlDQUE2QixFQUFFLHVDQUFTLElBQUksRUFBRTtBQUM1QyxVQUFJLElBQUksR0FBRyxRQUFRLENBQUMsU0FBUyxFQUFFLENBQUM7QUFDaEMsVUFBSSxjQUFjLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQywwQkFBMEIsQ0FBQzs7QUFFOUQsVUFBSSxjQUFjLEtBQUssTUFBTSxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxFQUFFO0FBQzNELHNCQUFjLEdBQUcsRUFBRSxDQUFDO09BQ3JCO0FBQ0QsVUFBSSxPQUFPLGNBQWMsS0FBSyxRQUFRLEVBQUU7QUFDdEMsWUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLEdBQUcsY0FBYyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQzVELFlBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFHLGNBQWMsRUFBRSxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUM7T0FDaEU7QUFDRCxVQUFJLGNBQWMsS0FBSyxNQUFNLEVBQUU7QUFDN0IsWUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7QUFDekQsWUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQyxDQUFDOztBQUUzQyxZQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsR0FBRyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDcEQsWUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxFQUFFLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQztPQUN4RDtBQUNELGNBQVEsQ0FBQyxRQUFRLENBQUMsb0NBQW9DLEVBQUUsSUFBSSxDQUFDLENBQUM7S0FDL0Q7QUFDRCxvQ0FBZ0MsRUFBRSwwQ0FBUyxJQUFJLEVBQUU7QUFDL0MsVUFBSSxJQUFJLEdBQUcsUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFDO0FBQ2hDLFVBQUksY0FBYyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsNkJBQTZCLENBQUM7O0FBRWpFLFVBQUksY0FBYyxLQUFLLE1BQU0sSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLGdCQUFnQixFQUFFO0FBQy9ELHNCQUFjLEdBQUcsRUFBRSxDQUFDO09BQ3JCO0FBQ0QsVUFBSSxPQUFPLGNBQWMsS0FBSyxRQUFRLEVBQUU7QUFDdEMsWUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxXQUFXLEdBQUcsY0FBYyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ2xFLFlBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLGNBQWMsRUFBRSxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUM7T0FDdEU7QUFDRCxVQUFJLGNBQWMsS0FBSyxNQUFNLEVBQUU7QUFDN0IsWUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUM7QUFDbEUsWUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQyxDQUFDOztBQUUzQyxZQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDdkQsWUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLEdBQUcsTUFBTSxFQUFFLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQztPQUM5RDtBQUNELGNBQVEsQ0FBQyxRQUFRLENBQUMsdUNBQXVDLEVBQUUsSUFBSSxDQUFDLENBQUM7S0FDbEU7R0FDRixDQUFDOztBQUVGLGNBQVksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSx1QkFBdUIsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDOztBQUU3RSxNQUFJLENBQUMsRUFBRSxHQUFHLDJDQUFnQixpQkFBaUIsQ0FBQyxDQUFDO0FBQzdDLE1BQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQzs7QUFFeEIsTUFBSSxDQUFDLFlBQVksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsV0FBVyxFQUFFLFVBQVMsS0FBSyxFQUFFOztBQUV4RixRQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsUUFBUSxJQUFJLEtBQUssQ0FBQyxLQUFLLEtBQUssQ0FBQyxFQUFFO0FBQ2xFLDRDQUFnQixLQUFLLENBQUMsQ0FBQzs7S0FFeEI7R0FDRixDQUFDLENBQUM7O0FBRUgsTUFBSSxDQUFDLFlBQVksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsYUFBYSxFQUFFLFVBQVMsS0FBSyxFQUFFOztBQUUxRixRQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsUUFBUSxJQUFJLEtBQUssQ0FBQyxLQUFLLEtBQUssQ0FBQyxFQUFFO0FBQ2xFLDRDQUFnQixLQUFLLENBQUMsQ0FBQzs7S0FFeEI7R0FDRixDQUFDLENBQUM7O0FBR0gsTUFBSSxDQUFDLFlBQVksQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsZUFBZSxFQUFFLE9BQU8sRUFBRSxZQUFXO0FBQy9FLFFBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxvQkFBb0IsRUFBRTtBQUN0QyxVQUFJLElBQUksQ0FBQyxFQUFFLENBQUMsZUFBZSxFQUFFO0FBQzNCLFlBQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQztBQUNyQyxZQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7T0FDZjtLQUNGO0dBQ0YsQ0FBQyxDQUFDO0NBQ0o7O0FBRUQsU0FBUyxDQUFDLFNBQVMsQ0FBQyxzQkFBc0IsR0FBRyxVQUFTLEVBQUUsRUFBRTtBQUN4RCxNQUFJLGdDQUFRLEVBQUUsQ0FBQyxFQUFFO0FBQ2YsV0FBTyxJQUFJLENBQUM7R0FDYjtBQUNELE1BQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsSUFBSSxrQ0FBVSxFQUFFLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO0FBQ2hFLFdBQU8sSUFBSSxDQUFDO0dBQ2I7O0FBRUQsU0FBTyxLQUFLLENBQUM7Q0FDZCxDQUFDOztBQUVGLFNBQVMsQ0FBQyxTQUFTLENBQUMsWUFBWSxHQUFHLFlBQVc7QUFDNUMsTUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLEVBQUUsQ0FBQzs7QUFFbkQsU0FBTyxZQUFZLElBQUksWUFBWSxDQUFDLFFBQVEsRUFBRSxDQUFDO0NBQ2hELENBQUM7O0FBRUYsU0FBUyxDQUFDLFNBQVMsQ0FBQyxZQUFZLEdBQUcsVUFBUyxLQUFLLEVBQUU7QUFDakQsTUFBSSxLQUFLLEVBQUU7O0FBRVQsZ0JBQVksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsY0FBYyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLENBQUM7R0FDdEY7Q0FDRixDQUFDOztBQUVGLFNBQVMsQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLFVBQVMsS0FBSyxFQUFFO0FBQzNDLE1BQUksS0FBSyxFQUFFOztBQUVULGdCQUFZLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLGFBQWEsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0dBQ3JGO0NBQ0YsQ0FBQzs7QUFFRixTQUFTLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxZQUFXO0FBQ3RDLE1BQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsQ0FBQztBQUM3QyxNQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsR0FBRyxLQUFLLENBQUM7QUFDdEMsTUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO0NBQ2xDLENBQUM7Ozs7Ozs7QUFPRixTQUFTLENBQUMsU0FBUyxDQUFDLGVBQWUsR0FBRyxVQUFTLE1BQU0sRUFBRSxPQUFPLEVBQUU7QUFDOUQsTUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDOztBQUUxQyxNQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUU7O0FBQ1YsV0FBTyxJQUFJLENBQUM7R0FDYixNQUFNO0FBQ0wsV0FBTyxFQUFFLENBQUM7R0FDWDtDQUNGLENBQUM7Ozs7OztBQU1GLFNBQVMsQ0FBQyxTQUFTLENBQUMsY0FBYyxHQUFHLFVBQVMsTUFBTSxFQUFFO0FBQ3BELE1BQUksQ0FBQyxFQUFFLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0NBQ2hDLENBQUM7Ozs7Ozs7QUFPRixTQUFTLENBQUMsU0FBUyxDQUFDLGVBQWUsR0FBRyxVQUFTLEdBQUcsRUFBRSxFQUFFLEVBQUU7QUFDdEQsTUFBSSxFQUFFLENBQUMsVUFBVSxFQUFFO0FBQ2pCLFFBQUksU0FBUyxHQUFHLEVBQUUsQ0FBQyxVQUFVLENBQUM7O0FBRTlCLFFBQUksQ0FBQyxpQ0FBUyxTQUFTLEVBQUUsVUFBVSxDQUFDLEVBQUU7QUFDcEMsb0NBQU0sRUFBRSxDQUFDLENBQUM7QUFDVixVQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQzs7QUFFOUIsYUFBTztLQUNSO0FBQ0QsUUFBSSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUFDLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLENBQUM7R0FFL0YsTUFBTTtBQUNMLFFBQUksR0FBRyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDeEMsUUFBSSxJQUFJLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQzs7QUFFMUMsT0FBRyxDQUFDLFNBQVMsR0FBRyxVQUFVLENBQUM7QUFDM0IsUUFBSSxDQUFDLFNBQVMsR0FBRyxXQUFXLENBQUM7QUFDN0IsUUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsQ0FBQzs7QUFFN0QsT0FBRyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN0QixNQUFFLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0dBQ3JCO0FBQ0QsY0FBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxtQkFBbUIsRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUM7Q0FDckUsQ0FBQzs7Ozs7OztBQU9GLFNBQVMsQ0FBQyxTQUFTLENBQUMsZUFBZSxHQUFHLFVBQVMsR0FBRyxFQUFFLEVBQUUsRUFBRTtBQUN0RCxNQUFJLEVBQUUsQ0FBQyxVQUFVLEVBQUU7QUFDakIsUUFBSSxTQUFTLEdBQUcsRUFBRSxDQUFDLFVBQVUsQ0FBQzs7QUFFOUIsUUFBSSxDQUFDLGlDQUFTLFNBQVMsRUFBRSxVQUFVLENBQUMsRUFBRTtBQUNwQyxvQ0FBTSxFQUFFLENBQUMsQ0FBQztBQUNWLFVBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDOztBQUU5QixhQUFPO0tBQ1I7QUFDRCxRQUFJLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUMsRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsQ0FBQztHQUUvRixNQUFNO0FBQ0wsUUFBSSxHQUFHLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN4QyxRQUFJLElBQUksR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDOztBQUUxQyxPQUFHLENBQUMsU0FBUyxHQUFHLFVBQVUsQ0FBQztBQUMzQixRQUFJLENBQUMsU0FBUyxHQUFHLFdBQVcsQ0FBQztBQUM3QixRQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDOztBQUU3RCxPQUFHLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3RCLE1BQUUsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7R0FDckI7QUFDRCxjQUFZLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLG1CQUFtQixFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztDQUNyRSxDQUFDOzs7Ozs7Ozs7O0FBVUYsU0FBUyxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsR0FBRyxVQUFTLE9BQU8sRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFO0FBQ3ZFLE1BQUksS0FBSyxHQUFHLENBQUMsQ0FBQyxFQUFFO0FBQ2QsMENBQWMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0dBRXhDLE1BQU07O0FBRUwsMENBQWMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNqRCxxQ0FBUyxPQUFPLEVBQUUsY0FBYyxDQUFDLENBQUM7R0FDbkM7Q0FDRixDQUFDOzs7Ozs7Ozs7QUFTRixTQUFTLENBQUMsU0FBUyxDQUFDLDBCQUEwQixHQUFHLFVBQVMsVUFBVSxFQUFFO0FBQ3BFLE1BQUksY0FBYyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGlCQUFpQixFQUFFLENBQUM7QUFDNUQsTUFBSSxRQUFRLEdBQUcsY0FBYyxHQUFHLFVBQVUsQ0FBQztBQUMzQyxTQUFPLFFBQVEsR0FBRyxDQUFDLEdBQUcsUUFBUSxHQUFHLENBQUMsQ0FBQztDQUNwQyxDQUFDOzs7Ozs7Ozs7QUFTRixTQUFTLENBQUMsU0FBUyxDQUFDLDJCQUEyQixHQUFHLFVBQVMsU0FBUyxFQUFFO0FBQ3BFLE1BQUksZUFBZSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGtCQUFrQixFQUFFLENBQUM7QUFDOUQsTUFBSSxTQUFTLEdBQUcsZUFBZSxHQUFHLFNBQVMsQ0FBQztBQUM1QyxTQUFPLFNBQVMsR0FBRyxDQUFDLEdBQUcsU0FBUyxHQUFHLENBQUMsQ0FBQztDQUN0QyxDQUFDOztBQUVGLFNBQVMsQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLEdBQUcsWUFBVztBQUNoRCxTQUFPLElBQUksQ0FBQyxFQUFFLEtBQUssSUFBSSxDQUFDLFFBQVEsQ0FBQztDQUNsQyxDQUFDOztBQUVGLFNBQVMsQ0FBQyxTQUFTLENBQUMsT0FBTyxHQUFHLFlBQVc7QUFDdkMsTUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUNsQixNQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxDQUFDO0NBQzdCLENBQUM7O1FBRU0sU0FBUyxHQUFULFNBQVM7Ozs7OzRCQ3ZtQk8sb0JBQW9COzs7Ozs7Ozs7O0FBVTVDLFlBQVksQ0FBQyxxQkFBcUIsR0FBRyxVQUFVLEtBQUssRUFBRSxRQUFRLEVBQUU7QUFDOUQsTUFBSSxJQUFJLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7QUFDOUIsUUFBSyxPQUFPLElBQUksQ0FBQyxNQUFNLEtBQUssVUFBVSxFQUFHO0FBQ3ZDLFVBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQztLQUM5QyxNQUFNO0FBQ0wsYUFBTyxDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDdkM7R0FDRixNQUFNO0FBQ0wsWUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO0dBQ2hCO0NBQ0YsQ0FBQzs7Ozs7Ozs7QUFRRixTQUFTLE9BQU8sQ0FBQyxLQUFLLEVBQUUsUUFBUSxFQUFFO0FBQ2hDLE1BQUksV0FBVyxHQUFJLEtBQUssQ0FBQztBQUN6QixNQUFJLFlBQVksR0FBRyxPQUFPLFdBQVcsS0FBSyxRQUFRLEdBQUcsV0FBVyxDQUFDLFdBQVcsRUFBRSxHQUFHLElBQUksQ0FBQzs7QUFFdEYsU0FBTyxVQUFVLE1BQU0sRUFBRTtBQUN2QixRQUFJLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDbEIsU0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUNuRCxVQUFJLFdBQVcsS0FBSyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUU7QUFDN0IsYUFBSyxHQUFHLElBQUksQ0FBQztBQUNiLGNBQU07T0FDUCxNQUNJLElBQUksWUFBWSxLQUFLLDZCQUFVLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxFQUFFOztBQUU1RCxhQUFLLEdBQUcsSUFBSSxDQUFDO0FBQ2IsY0FBTTtPQUNQO0tBQ0Y7O0FBRUQsWUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0dBQ2pCLENBQUM7Q0FDSDs7Ozs7OztzQkNoRGtCLFFBQVE7Ozs7dUJBQ0gsY0FBYzs7Ozs7Ozs7Ozs7QUFXdEMsWUFBWSxDQUFDLGFBQWEsR0FBRyxVQUFTLEtBQUssRUFBRSxRQUFRLEVBQUU7QUFDckQsTUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDO0FBQ2pCLE1BQUksVUFBVSxHQUFHLHdCQUFVLE1BQU0sRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7O0FBRWxELE1BQUksS0FBSyxLQUFLLElBQUksRUFBRTtBQUNsQixTQUFLLEdBQUcsRUFBRSxDQUFDO0dBQ1o7QUFDRCxNQUFJLFdBQVcsR0FBRyx5QkFBTyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDOztBQUVwRCxNQUFJLGFBQWEsR0FBRyx5QkFBTyxLQUFLLEVBQUUsSUFBSSxDQUFDLFVBQVUsSUFBSSxVQUFVLENBQUMsaUJBQWlCLEVBQUUsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7O0FBRW5HLE1BQUksQ0FBQyxXQUFXLEVBQUU7QUFDaEIsU0FBSyxHQUFHLEtBQUssQ0FBQztHQUNmO0FBQ0QsTUFBSSxDQUFDLFdBQVcsSUFBSSxhQUFhLEVBQUU7QUFDakMsU0FBSyxHQUFHLElBQUksQ0FBQztHQUNkOztBQUVELE1BQUksV0FBVyxJQUFJLENBQUMsYUFBYSxFQUFFO0FBQ2pDLFFBQUksSUFBSSxDQUFDLGFBQWEsS0FBSyxJQUFJLEVBQUU7O0FBQy9CLFVBQUksY0FBYyxHQUFHLGFBQWEsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDOztBQUUzRCxVQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUUsY0FBYyxFQUFFLGVBQWUsQ0FBQyxDQUFDO0FBQ2pGLFdBQUssR0FBRyxJQUFJLENBQUM7S0FDZCxNQUFNO0FBQ0wsV0FBSyxHQUFHLEtBQUssQ0FBQztLQUNmO0dBQ0Y7O0FBRUQsVUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0NBQ2pCLENBQUM7Ozs7Ozs7OztBQVNGLElBQUksYUFBYSxHQUFHLFNBQVMsYUFBYSxDQUFDLEtBQUssRUFBRSxVQUFVLEVBQUU7QUFDNUQsTUFBSSxJQUFJLEdBQUcseUJBQU8sSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUNuQyxNQUFJLElBQUksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQy9CLE1BQUksT0FBTyxHQUFHLDBCQUFRLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDOzs7QUFHdEMsTUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRTtBQUM5QyxRQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFO0FBQ2xDLFVBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDbEU7R0FFRixNQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7O0FBRTFCLFFBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFBLENBQUUsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0dBQzVDOztBQUVELFNBQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztDQUNoQyxDQUFDOzs7Ozs7Ozs7Ozs7O0FDN0RGLFlBQVksQ0FBQyxnQkFBZ0IsR0FBRyxVQUFVLEtBQUssRUFBRSxRQUFRLEVBQUU7QUFDekQsTUFBSSxLQUFLLEtBQUssSUFBSSxFQUFFO0FBQ2xCLFNBQUssR0FBRyxFQUFFLENBQUM7R0FDWjtBQUNELFVBQVEsQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztDQUM1QyxDQUFDIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qKlxuICogU2hlZXRDbGlwIC0gU3ByZWFkc2hlZXQgQ2xpcGJvYXJkIFBhcnNlclxuICogdmVyc2lvbiAwLjJcbiAqXG4gKiBUaGlzIHRpbnkgbGlicmFyeSB0cmFuc2Zvcm1zIEphdmFTY3JpcHQgYXJyYXlzIHRvIHN0cmluZ3MgdGhhdCBhcmUgcGFzdGVhYmxlIGJ5IExpYnJlT2ZmaWNlLCBPcGVuT2ZmaWNlLFxuICogR29vZ2xlIERvY3MgYW5kIE1pY3Jvc29mdCBFeGNlbC5cbiAqXG4gKiBDb3B5cmlnaHQgMjAxMiwgTWFyY2luIFdhcnBlY2hvd3NraVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2dpdGh1Yi5jb20vd2FycGVjaC9zaGVldGNsaXAvXG4gKi9cbi8qanNsaW50IHdoaXRlOiB0cnVlKi9cbihmdW5jdGlvbiAoZ2xvYmFsKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGZ1bmN0aW9uIGNvdW50UXVvdGVzKHN0cikge1xuICAgIHJldHVybiBzdHIuc3BsaXQoJ1wiJykubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIHZhciBTaGVldENsaXAgPSB7XG4gICAgLyoqXG4gICAgICogRGVjb2RlIHNwcmVhZHNoZWV0IHN0cmluZyBpbnRvIGFycmF5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHBhcnNlOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICB2YXIgciwgckxlbiwgcm93cywgYXJyID0gW10sIGEgPSAwLCBjLCBjTGVuLCBtdWx0aWxpbmUsIGxhc3Q7XG5cbiAgICAgIHJvd3MgPSBzdHIuc3BsaXQoJ1xcbicpO1xuXG4gICAgICBpZiAocm93cy5sZW5ndGggPiAxICYmIHJvd3Nbcm93cy5sZW5ndGggLSAxXSA9PT0gJycpIHtcbiAgICAgICAgcm93cy5wb3AoKTtcbiAgICAgIH1cbiAgICAgIGZvciAociA9IDAsIHJMZW4gPSByb3dzLmxlbmd0aDsgciA8IHJMZW47IHIgKz0gMSkge1xuICAgICAgICByb3dzW3JdID0gcm93c1tyXS5zcGxpdCgnXFx0Jyk7XG5cbiAgICAgICAgZm9yIChjID0gMCwgY0xlbiA9IHJvd3Nbcl0ubGVuZ3RoOyBjIDwgY0xlbjsgYyArPSAxKSB7XG4gICAgICAgICAgaWYgKCFhcnJbYV0pIHtcbiAgICAgICAgICAgIGFyclthXSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobXVsdGlsaW5lICYmIGMgPT09IDApIHtcbiAgICAgICAgICAgIGxhc3QgPSBhcnJbYV0ubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGFyclthXVtsYXN0XSA9IGFyclthXVtsYXN0XSArICdcXG4nICsgcm93c1tyXVswXTtcblxuICAgICAgICAgICAgaWYgKG11bHRpbGluZSAmJiAoY291bnRRdW90ZXMocm93c1tyXVswXSkgJiAxKSkgeyAvLyYgMSBpcyBhIGJpdHdpc2Ugd2F5IG9mIHBlcmZvcm1pbmcgbW9kIDJcbiAgICAgICAgICAgICAgbXVsdGlsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgIGFyclthXVtsYXN0XSA9IGFyclthXVtsYXN0XS5zdWJzdHJpbmcoMCwgYXJyW2FdW2xhc3RdLmxlbmd0aCAtIDEpLnJlcGxhY2UoL1wiXCIvZywgJ1wiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGMgPT09IGNMZW4gLSAxICYmIHJvd3Nbcl1bY10uaW5kZXhPZignXCInKSA9PT0gMCAmJiAoY291bnRRdW90ZXMocm93c1tyXVtjXSkgJiAxKSkge1xuICAgICAgICAgICAgICBhcnJbYV0ucHVzaChyb3dzW3JdW2NdLnN1YnN0cmluZygxKS5yZXBsYWNlKC9cIlwiL2csICdcIicpKTtcbiAgICAgICAgICAgICAgbXVsdGlsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBhcnJbYV0ucHVzaChyb3dzW3JdW2NdLnJlcGxhY2UoL1wiXCIvZywgJ1wiJykpO1xuICAgICAgICAgICAgICBtdWx0aWxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtdWx0aWxpbmUpIHtcbiAgICAgICAgICBhICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW5jb2RlIGFycmF5IGludG8gdmFsaWQgc3ByZWFkc2hlZXQgc3RyaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJyXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgIHZhciByLCByTGVuLCBjLCBjTGVuLCBzdHIgPSAnJywgdmFsO1xuXG4gICAgICBmb3IgKHIgPSAwLCByTGVuID0gYXJyLmxlbmd0aDsgciA8IHJMZW47IHIgKz0gMSkge1xuICAgICAgICBjTGVuID0gYXJyW3JdLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGMgPSAwOyBjIDwgY0xlbjsgYyArPSAxKSB7XG4gICAgICAgICAgaWYgKGMgPiAwKSB7XG4gICAgICAgICAgICBzdHIgKz0gJ1xcdCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbCA9IGFycltyXVtjXTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHZhbC5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgICAgICAgIHN0ciArPSAnXCInICsgdmFsLnJlcGxhY2UoL1wiL2csICdcIlwiJykgKyAnXCInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHN0ciArPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHZvaWQgMCkgeyAvLyB2b2lkIDAgcmVzb2x2ZXMgdG8gdW5kZWZpbmVkXG4gICAgICAgICAgICBzdHIgKz0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RyICs9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RyICs9ICdcXG4nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfTtcblxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy5wYXJzZSA9IFNoZWV0Q2xpcC5wYXJzZTtcbiAgICBleHBvcnRzLnN0cmluZ2lmeSA9IFNoZWV0Q2xpcC5zdHJpbmdpZnk7XG4gIH0gZWxzZSB7XG4gICAgZ2xvYmFsLlNoZWV0Q2xpcCA9IFNoZWV0Q2xpcDtcbiAgfVxufSh3aW5kb3cpKTtcbiIsIi8qKlxuICogYXV0b1Jlc2l6ZSAtIHJlc2l6ZXMgYSBET00gZWxlbWVudCB0byB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiBhbm90aGVyIERPTSBlbGVtZW50XG4gKlxuICogQ29weXJpZ2h0IDIwMTQsIE1hcmNpbiBXYXJwZWNob3dza2lcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5cblxuZnVuY3Rpb24gYXV0b1Jlc2l6ZSgpIHtcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgbWluSGVpZ2h0OiAyMDAsXG4gICAgICBtYXhIZWlnaHQ6IDMwMCxcbiAgICAgIG1pbldpZHRoOiAxMDAsXG4gICAgICBtYXhXaWR0aDogMzAwXG4gICAgfSxcbiAgICBlbCxcbiAgICBib2R5ID0gZG9jdW1lbnQuYm9keSxcbiAgICB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpLFxuICAgIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdTUEFOJyksXG4gICAgb2JzZXJ2ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudCwgaGFuZGxlcikge1xuICAgICAgaWYgKHdpbmRvdy5hdHRhY2hFdmVudCkge1xuICAgICAgICBlbGVtZW50LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgaGFuZGxlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVuT2JzZXJ2ZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBldmVudCwgaGFuZGxlcikge1xuICAgICAgaWYgKHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVzaXplID0gZnVuY3Rpb24gKG5ld0NoYXIpIHtcbiAgICAgIHZhciB3aWR0aCwgc2Nyb2xsSGVpZ2h0O1xuXG4gICAgICBpZiAoIW5ld0NoYXIpIHtcbiAgICAgICAgbmV3Q2hhciA9IFwiXCI7XG4gICAgICB9IGVsc2UgaWYgKCEvXlthLXpBLVogXFwuLFxcXFxcXC9cXHwwLTldJC8udGVzdChuZXdDaGFyKSkge1xuICAgICAgICBuZXdDaGFyID0gXCIuXCI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0LnRleHRDb250ZW50ICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGV4dC50ZXh0Q29udGVudCA9IGVsLnZhbHVlICsgbmV3Q2hhcjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0ZXh0LmRhdGEgPSBlbC52YWx1ZSArIG5ld0NoYXI7IC8vSUU4XG4gICAgICB9XG4gICAgICBzcGFuLnN0eWxlLmZvbnRTaXplID0gSGFuZHNvbnRhYmxlLkRvbS5nZXRDb21wdXRlZFN0eWxlKGVsKS5mb250U2l6ZTtcbiAgICAgIHNwYW4uc3R5bGUuZm9udEZhbWlseSA9IEhhbmRzb250YWJsZS5Eb20uZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZm9udEZhbWlseTtcbiAgICAgIHNwYW4uc3R5bGUud2hpdGVTcGFjZSA9IFwicHJlXCI7XG5cbiAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoc3Bhbik7XG4gICAgICB3aWR0aCA9IHNwYW4uY2xpZW50V2lkdGggKyAyO1xuICAgICAgYm9keS5yZW1vdmVDaGlsZChzcGFuKTtcblxuICAgICAgZWwuc3R5bGUuaGVpZ2h0ID0gZGVmYXVsdHMubWluSGVpZ2h0ICsgJ3B4JztcblxuICAgICAgaWYgKGRlZmF1bHRzLm1pbldpZHRoID4gd2lkdGgpIHtcbiAgICAgICAgZWwuc3R5bGUud2lkdGggPSBkZWZhdWx0cy5taW5XaWR0aCArICdweCc7XG5cbiAgICAgIH0gZWxzZSBpZiAod2lkdGggPiBkZWZhdWx0cy5tYXhXaWR0aCkge1xuICAgICAgICBlbC5zdHlsZS53aWR0aCA9IGRlZmF1bHRzLm1heFdpZHRoICsgJ3B4JztcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICB9XG4gICAgICBzY3JvbGxIZWlnaHQgPSBlbC5zY3JvbGxIZWlnaHQgPyBlbC5zY3JvbGxIZWlnaHQgLSAxIDogMDtcblxuICAgICAgaWYgKGRlZmF1bHRzLm1pbkhlaWdodCA+IHNjcm9sbEhlaWdodCkge1xuICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSBkZWZhdWx0cy5taW5IZWlnaHQgKyAncHgnO1xuXG4gICAgICB9IGVsc2UgaWYgKGRlZmF1bHRzLm1heEhlaWdodCA8IHNjcm9sbEhlaWdodCkge1xuICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSBkZWZhdWx0cy5tYXhIZWlnaHQgKyAncHgnO1xuICAgICAgICBlbC5zdHlsZS5vdmVyZmxvd1kgPSAndmlzaWJsZSc7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IHNjcm9sbEhlaWdodCArICdweCc7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZWxheWVkUmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2luZG93LnNldFRpbWVvdXQocmVzaXplLCAwKTtcbiAgICB9LFxuICAgIGV4dGVuZERlZmF1bHRzID0gZnVuY3Rpb24gKGNvbmZpZykge1xuXG4gICAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5taW5IZWlnaHQpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5taW5IZWlnaHQgPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgZGVmYXVsdHMubWluSGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBtaW5IZWlnaHQgPSBwYXJzZUludChjb25maWcubWluSGVpZ2h0KTtcbiAgICAgICAgICBpZiAoIWlzTmFOKG1pbkhlaWdodCkpIHtcbiAgICAgICAgICAgIGRlZmF1bHRzLm1pbkhlaWdodCA9IG1pbkhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmZpZyAmJiBjb25maWcubWF4SGVpZ2h0KSB7XG4gICAgICAgIGlmIChjb25maWcubWF4SGVpZ2h0ID09ICdpbmhlcml0Jykge1xuICAgICAgICAgIGRlZmF1bHRzLm1heEhlaWdodCA9IGVsLmNsaWVudEhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWF4SGVpZ2h0ID0gcGFyc2VJbnQoY29uZmlnLm1heEhlaWdodCk7XG4gICAgICAgICAgaWYgKCFpc05hTihtYXhIZWlnaHQpKSB7XG4gICAgICAgICAgICBkZWZhdWx0cy5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcgJiYgY29uZmlnLm1pbldpZHRoKSB7XG4gICAgICAgIGlmIChjb25maWcubWluV2lkdGggPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgZGVmYXVsdHMubWluV2lkdGggPSBlbC5jbGllbnRXaWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWluV2lkdGggPSBwYXJzZUludChjb25maWcubWluV2lkdGgpO1xuICAgICAgICAgIGlmICghaXNOYU4obWluV2lkdGgpKSB7XG4gICAgICAgICAgICBkZWZhdWx0cy5taW5XaWR0aCA9IG1pbldpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5tYXhXaWR0aCkge1xuICAgICAgICBpZiAoY29uZmlnLm1heFdpZHRoID09ICdpbmhlcml0Jykge1xuICAgICAgICAgIGRlZmF1bHRzLm1heFdpZHRoID0gZWwuY2xpZW50V2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1heFdpZHRoID0gcGFyc2VJbnQoY29uZmlnLm1heFdpZHRoKTtcbiAgICAgICAgICBpZiAoIWlzTmFOKG1heFdpZHRoKSkge1xuICAgICAgICAgICAgZGVmYXVsdHMubWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIXNwYW4uZmlyc3RDaGlsZCkge1xuICAgICAgICBzcGFuLmNsYXNzTmFtZSA9IFwiYXV0b1Jlc2l6ZVwiO1xuICAgICAgICBzcGFuLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICAgICAgc3Bhbi5hcHBlbmRDaGlsZCh0ZXh0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGluaXQgPSBmdW5jdGlvbiAoZWxfLCBjb25maWcsIGRvT2JzZXJ2ZSkge1xuICAgICAgZWwgPSBlbF87XG4gICAgICBleHRlbmREZWZhdWx0cyhjb25maWcpO1xuXG4gICAgICBpZiAoZWwubm9kZU5hbWUgPT0gJ1RFWFRBUkVBJykge1xuXG4gICAgICAgIGVsLnN0eWxlLnJlc2l6ZSA9ICdub25lJztcbiAgICAgICAgZWwuc3R5bGUub3ZlcmZsb3dZID0gJyc7XG4gICAgICAgIGVsLnN0eWxlLmhlaWdodCA9IGRlZmF1bHRzLm1pbkhlaWdodCArICdweCc7XG4gICAgICAgIGVsLnN0eWxlLm1pbldpZHRoID0gZGVmYXVsdHMubWluV2lkdGggKyAncHgnO1xuICAgICAgICBlbC5zdHlsZS5tYXhXaWR0aCA9IGRlZmF1bHRzLm1heFdpZHRoICsgJ3B4JztcbiAgICAgICAgZWwuc3R5bGUub3ZlcmZsb3dZID0gJ2hpZGRlbic7XG4gICAgICB9XG5cbiAgICAgIGlmKGRvT2JzZXJ2ZSkge1xuICAgICAgICBvYnNlcnZlKGVsLCAnY2hhbmdlJywgcmVzaXplKTtcbiAgICAgICAgb2JzZXJ2ZShlbCwgJ2N1dCcsIGRlbGF5ZWRSZXNpemUpO1xuICAgICAgICBvYnNlcnZlKGVsLCAncGFzdGUnLCBkZWxheWVkUmVzaXplKTtcbiAgICAgICAgb2JzZXJ2ZShlbCwgJ2Ryb3AnLCBkZWxheWVkUmVzaXplKTtcbiAgICAgICAgb2JzZXJ2ZShlbCwgJ2tleWRvd24nLCBkZWxheWVkUmVzaXplKTtcbiAgICAgIH1cblxuICAgICAgcmVzaXplKCk7XG4gICAgfTtcblxuICByZXR1cm4ge1xuICAgIGluaXQ6IGZ1bmN0aW9uIChlbF8sIGNvbmZpZywgZG9PYnNlcnZlKSB7XG4gICAgICBpbml0KGVsXywgY29uZmlnLCBkb09ic2VydmUpO1xuICAgIH0sXG4gICAgdW5PYnNlcnZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB1bk9ic2VydmUoZWwsICdjaGFuZ2UnLCByZXNpemUpO1xuICAgICAgdW5PYnNlcnZlKGVsLCAnY3V0JywgZGVsYXllZFJlc2l6ZSk7XG4gICAgICB1bk9ic2VydmUoZWwsICdwYXN0ZScsIGRlbGF5ZWRSZXNpemUpO1xuICAgICAgdW5PYnNlcnZlKGVsLCAnZHJvcCcsIGRlbGF5ZWRSZXNpemUpO1xuICAgICAgdW5PYnNlcnZlKGVsLCAna2V5ZG93bicsIGRlbGF5ZWRSZXNpemUpO1xuICAgIH0sXG4gICAgcmVzaXplOiByZXNpemVcbiAgfTtcbn1cblxuaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGF1dG9SZXNpemU7XG59XG4iLCIvKiFcbiAqIENvcHlyaWdodCAoQykgMjAxMSBieSBBbmRyZWEgR2lhbW1hcmNoaSwgQFdlYlJlZmxlY3Rpb25cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG4oZnVuY3Rpb24oZXhwb3J0cykge1xuICAndXNlIHN0cmljdCc7XG4gIC8vc2hhcmVkIHBvaW50ZXJcbiAgdmFyIGk7XG4gIC8vc2hvcnRjdXRzXG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSxcbiAgICBpcyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBpc05hTihhKSA/IGlzTmFOKGIpIDogYSA9PT0gYjtcbiAgICB9O1xuXG5cbiAgLy9Qb2x5ZmlsbCBnbG9iYWwgb2JqZWN0c1xuICBpZiAodHlwZW9mIFdlYWtNYXAgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLldlYWtNYXAgPSBjcmVhdGVDb2xsZWN0aW9uKHtcbiAgICAgIC8vIFdlYWtNYXAjZGVsZXRlKGtleTp2b2lkKik6Ym9vbGVhblxuICAgICAgJ2RlbGV0ZSc6IHNoYXJlZERlbGV0ZSxcbiAgICAgIC8vIFdlYWtNYXAjY2xlYXIoKTpcbiAgICAgIGNsZWFyOiBzaGFyZWRDbGVhcixcbiAgICAgIC8vIFdlYWtNYXAjZ2V0KGtleTp2b2lkKik6dm9pZCpcbiAgICAgIGdldDogc2hhcmVkR2V0LFxuICAgICAgLy8gV2Vha01hcCNoYXMoa2V5OnZvaWQqKTpib29sZWFuXG4gICAgICBoYXM6IG1hcEhhcyxcbiAgICAgIC8vIFdlYWtNYXAjc2V0KGtleTp2b2lkKiwgdmFsdWU6dm9pZCopOnZvaWRcbiAgICAgIHNldDogc2hhcmVkU2V0XG4gICAgfSwgdHJ1ZSk7XG4gIH1cblxuICBpZiAodHlwZW9mIE1hcCA9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMuTWFwID0gY3JlYXRlQ29sbGVjdGlvbih7XG4gICAgICAvLyBXZWFrTWFwI2RlbGV0ZShrZXk6dm9pZCopOmJvb2xlYW5cbiAgICAgICdkZWxldGUnOiBzaGFyZWREZWxldGUsXG4gICAgICAvLzp3YXMgTWFwI2dldChrZXk6dm9pZCpbLCBkM2ZhdWx0OnZvaWQqXSk6dm9pZCpcbiAgICAgIC8vIE1hcCNoYXMoa2V5OnZvaWQqKTpib29sZWFuXG4gICAgICBoYXM6IG1hcEhhcyxcbiAgICAgIC8vIE1hcCNnZXQoa2V5OnZvaWQqKTpib29sZWFuXG4gICAgICBnZXQ6IHNoYXJlZEdldCxcbiAgICAgIC8vIE1hcCNzZXQoa2V5OnZvaWQqLCB2YWx1ZTp2b2lkKik6dm9pZFxuICAgICAgc2V0OiBzaGFyZWRTZXQsXG4gICAgICAvLyBNYXAja2V5cyh2b2lkKTpJdGVyYXRvclxuICAgICAga2V5czogc2hhcmVkS2V5cyxcbiAgICAgIC8vIE1hcCN2YWx1ZXModm9pZCk6SXRlcmF0b3JcbiAgICAgIHZhbHVlczogc2hhcmVkVmFsdWVzLFxuICAgICAgLy8gTWFwI2VudHJpZXModm9pZCk6SXRlcmF0b3JcbiAgICAgIGVudHJpZXM6IG1hcEVudHJpZXMsXG4gICAgICAvLyBNYXAjZm9yRWFjaChjYWxsYmFjazpGdW5jdGlvbiwgY29udGV4dDp2b2lkKik6dm9pZCA9PT4gY2FsbGJhY2suY2FsbChjb250ZXh0LCBrZXksIHZhbHVlLCBtYXBPYmplY3QpID09PSBub3QgaW4gc3BlY3NgXG4gICAgICBmb3JFYWNoOiBzaGFyZWRGb3JFYWNoLFxuICAgICAgLy8gTWFwI2NsZWFyKCk6XG4gICAgICBjbGVhcjogc2hhcmVkQ2xlYXJcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgU2V0ID09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy5TZXQgPSBjcmVhdGVDb2xsZWN0aW9uKHtcbiAgICAgIC8vIFNldCNoYXModmFsdWU6dm9pZCopOmJvb2xlYW5cbiAgICAgIGhhczogc2V0SGFzLFxuICAgICAgLy8gU2V0I2FkZCh2YWx1ZTp2b2lkKik6Ym9vbGVhblxuICAgICAgYWRkOiBzaGFyZWRBZGQsXG4gICAgICAvLyBTZXQjZGVsZXRlKGtleTp2b2lkKik6Ym9vbGVhblxuICAgICAgJ2RlbGV0ZSc6IHNoYXJlZERlbGV0ZSxcbiAgICAgIC8vIFNldCNjbGVhcigpOlxuICAgICAgY2xlYXI6IHNoYXJlZENsZWFyLFxuICAgICAgLy8gU2V0I2tleXModm9pZCk6SXRlcmF0b3JcbiAgICAgIGtleXM6IHNoYXJlZFZhbHVlcywgLy8gc3BlY3MgYWN0dWFsbHkgc2F5IFwidGhlIHNhbWUgZnVuY3Rpb24gb2JqZWN0IGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSB2YWx1ZXMgcHJvcGVydHlcIlxuICAgICAgLy8gU2V0I3ZhbHVlcyh2b2lkKTpJdGVyYXRvclxuICAgICAgdmFsdWVzOiBzaGFyZWRWYWx1ZXMsXG4gICAgICAvLyBTZXQjZW50cmllcyh2b2lkKTpJdGVyYXRvclxuICAgICAgZW50cmllczogc2V0RW50cmllcyxcbiAgICAgIC8vIFNldCNmb3JFYWNoKGNhbGxiYWNrOkZ1bmN0aW9uLCBjb250ZXh0OnZvaWQqKTp2b2lkID09PiBjYWxsYmFjay5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCkgPT09IG5vdCBpbiBzcGVjc1xuICAgICAgZm9yRWFjaDogc2hhcmVkRm9yRWFjaFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBXZWFrU2V0ID09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy5XZWFrU2V0ID0gY3JlYXRlQ29sbGVjdGlvbih7XG4gICAgICAvLyBXZWFrU2V0I2RlbGV0ZShrZXk6dm9pZCopOmJvb2xlYW5cbiAgICAgICdkZWxldGUnOiBzaGFyZWREZWxldGUsXG4gICAgICAvLyBXZWFrU2V0I2FkZCh2YWx1ZTp2b2lkKik6Ym9vbGVhblxuICAgICAgYWRkOiBzaGFyZWRBZGQsXG4gICAgICAvLyBXZWFrU2V0I2NsZWFyKCk6XG4gICAgICBjbGVhcjogc2hhcmVkQ2xlYXIsXG4gICAgICAvLyBXZWFrU2V0I2hhcyh2YWx1ZTp2b2lkKik6Ym9vbGVhblxuICAgICAgaGFzOiBzZXRIYXNcbiAgICB9LCB0cnVlKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEVTNiBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBhIGNvbGxlY3Rpb24gY2xhc3NcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbGxlY3Rpb24ocHJvdG8sIG9iamVjdE9ubHkpIHtcbiAgICBmdW5jdGlvbiBDb2xsZWN0aW9uKGEpIHtcbiAgICAgIGlmICghdGhpcyB8fCB0aGlzLmNvbnN0cnVjdG9yICE9PSBDb2xsZWN0aW9uKSByZXR1cm4gbmV3IENvbGxlY3Rpb24oYSk7XG4gICAgICB0aGlzLl9rZXlzID0gW107XG4gICAgICB0aGlzLl92YWx1ZXMgPSBbXTtcbiAgICAgIHRoaXMuX2l0cCA9IFtdOyAvLyBpdGVyYXRpb24gcG9pbnRlcnNcbiAgICAgIHRoaXMub2JqZWN0T25seSA9IG9iamVjdE9ubHk7XG5cbiAgICAgIC8vcGFyc2UgaW5pdGlhbCBpdGVyYWJsZSBhcmd1bWVudCBwYXNzZWRcbiAgICAgIGlmIChhKSBpbml0LmNhbGwodGhpcywgYSk7XG4gICAgfVxuXG4gICAgLy9kZWZpbmUgc2l6ZSBmb3Igbm9uIG9iamVjdC1vbmx5IGNvbGxlY3Rpb25zXG4gICAgaWYgKCFvYmplY3RPbmx5KSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eShwcm90bywgJ3NpemUnLCB7XG4gICAgICAgIGdldDogc2hhcmVkU2l6ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy9zZXQgcHJvdG90eXBlXG4gICAgcHJvdG8uY29uc3RydWN0b3IgPSBDb2xsZWN0aW9uO1xuICAgIENvbGxlY3Rpb24ucHJvdG90eXBlID0gcHJvdG87XG5cbiAgICByZXR1cm4gQ29sbGVjdGlvbjtcbiAgfVxuXG5cbiAgLyoqIHBhcnNlIGluaXRpYWwgaXRlcmFibGUgYXJndW1lbnQgcGFzc2VkICovXG4gIGZ1bmN0aW9uIGluaXQoYSkge1xuICAgIHZhciBpO1xuICAgIC8vaW5pdCBTZXQgYXJndW1lbnQsIGxpa2UgYFsxLDIsMyx7fV1gXG4gICAgaWYgKHRoaXMuYWRkKSBhLmZvckVhY2godGhpcy5hZGQsIHRoaXMpO1xuICAgIC8vaW5pdCBNYXAgYXJndW1lbnQgbGlrZSBgW1sxLDJdLCBbe30sIDRdXWBcbiAgICBlbHNlIGEuZm9yRWFjaChmdW5jdGlvbihhKSB7XG4gICAgICB0aGlzLnNldChhWzBdLCBhWzFdKVxuICAgIH0sIHRoaXMpO1xuICB9XG5cblxuICAvKiogZGVsZXRlICovXG4gIGZ1bmN0aW9uIHNoYXJlZERlbGV0ZShrZXkpIHtcbiAgICBpZiAodGhpcy5oYXMoa2V5KSkge1xuICAgICAgdGhpcy5fa2V5cy5zcGxpY2UoaSwgMSk7XG4gICAgICB0aGlzLl92YWx1ZXMuc3BsaWNlKGksIDEpO1xuICAgICAgLy8gdXBkYXRlIGl0ZXJhdGlvbiBwb2ludGVyc1xuICAgICAgdGhpcy5faXRwLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICBpZiAoaSA8IHBbMF0pIHBbMF0tLTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBBdXJvcmEgaGVyZSBkb2VzIGl0IHdoaWxlIENhbmFyeSBkb2Vzbid0XG4gICAgcmV0dXJuIC0xIDwgaTtcbiAgfTtcblxuICBmdW5jdGlvbiBzaGFyZWRHZXQoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKGtleSkgPyB0aGlzLl92YWx1ZXNbaV0gOiB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBoYXMobGlzdCwga2V5KSB7XG4gICAgaWYgKHRoaXMub2JqZWN0T25seSAmJiBrZXkgIT09IE9iamVjdChrZXkpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCB2YWx1ZSB1c2VkIGFzIHdlYWsgY29sbGVjdGlvbiBrZXlcIik7XG4gICAgLy9OYU4gb3IgMCBwYXNzZWRcbiAgICBpZiAoa2V5ICE9IGtleSB8fCBrZXkgPT09IDApIGZvciAoaSA9IGxpc3QubGVuZ3RoOyBpLS0gJiYgIWlzKGxpc3RbaV0sIGtleSk7KSB7fSBlbHNlIGkgPSBsaXN0LmluZGV4T2Yoa2V5KTtcbiAgICByZXR1cm4gLTEgPCBpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0SGFzKHZhbHVlKSB7XG4gICAgcmV0dXJuIGhhcy5jYWxsKHRoaXMsIHRoaXMuX3ZhbHVlcywgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwSGFzKHZhbHVlKSB7XG4gICAgcmV0dXJuIGhhcy5jYWxsKHRoaXMsIHRoaXMuX2tleXMsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKiBAY2hhaW5hYmxlICovXG4gIGZ1bmN0aW9uIHNoYXJlZFNldChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5oYXMoa2V5KSA/IHRoaXMuX3ZhbHVlc1tpXSA9IHZhbHVlIDogdGhpcy5fdmFsdWVzW3RoaXMuX2tleXMucHVzaChrZXkpIC0gMV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBAY2hhaW5hYmxlICovXG4gIGZ1bmN0aW9uIHNoYXJlZEFkZCh2YWx1ZSkge1xuICAgIGlmICghdGhpcy5oYXModmFsdWUpKSB0aGlzLl92YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmdW5jdGlvbiBzaGFyZWRDbGVhcigpIHtcbiAgICB0aGlzLl92YWx1ZXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIC8qKiBrZXlzLCB2YWx1ZXMsIGFuZCBpdGVyYXRlIHJlbGF0ZWQgbWV0aG9kcyAqL1xuICBmdW5jdGlvbiBzaGFyZWRLZXlzKCkge1xuICAgIHJldHVybiBzaGFyZWRJdGVyYXRvcih0aGlzLl9pdHAsIHRoaXMuX2tleXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hhcmVkVmFsdWVzKCkge1xuICAgIHJldHVybiBzaGFyZWRJdGVyYXRvcih0aGlzLl9pdHAsIHRoaXMuX3ZhbHVlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXBFbnRyaWVzKCkge1xuICAgIHJldHVybiBzaGFyZWRJdGVyYXRvcih0aGlzLl9pdHAsIHRoaXMuX2tleXMsIHRoaXMuX3ZhbHVlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRFbnRyaWVzKCkge1xuICAgIHJldHVybiBzaGFyZWRJdGVyYXRvcih0aGlzLl9pdHAsIHRoaXMuX3ZhbHVlcywgdGhpcy5fdmFsdWVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNoYXJlZEl0ZXJhdG9yKGl0cCwgYXJyYXksIGFycmF5Mikge1xuICAgIHZhciBwID0gWzBdLFxuICAgICAgZG9uZSA9IGZhbHNlO1xuICAgIGl0cC5wdXNoKHApO1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHYsIGsgPSBwWzBdO1xuICAgICAgICBpZiAoIWRvbmUgJiYgayA8IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgIHYgPSBhcnJheTIgPyBbYXJyYXlba10sIGFycmF5MltrXV0gOiBhcnJheVtrXTtcbiAgICAgICAgICBwWzBdKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgaXRwLnNwbGljZShpdHAuaW5kZXhPZihwKSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiBkb25lLFxuICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNoYXJlZFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlcy5sZW5ndGg7XG4gIH1cblxuICBmdW5jdGlvbiBzaGFyZWRGb3JFYWNoKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgdmFyIGl0ID0gdGhpcy5lbnRyaWVzKCk7XG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIHIgPSBpdC5uZXh0KCk7XG4gICAgICBpZiAoci5kb25lKSBicmVhaztcbiAgICAgIGNhbGxiYWNrLmNhbGwoY29udGV4dCwgci52YWx1ZVsxXSwgci52YWx1ZVswXSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbn0pKHR5cGVvZiBleHBvcnRzICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiBnbG9iYWwgIT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB3aW5kb3cpO1xuIiwiLy8hIG1vbWVudC5qc1xuLy8hIHZlcnNpb24gOiAyLjEwLjZcbi8vISBhdXRob3JzIDogVGltIFdvb2QsIElza3JlbiBDaGVybmV2LCBNb21lbnQuanMgY29udHJpYnV0b3JzXG4vLyEgbGljZW5zZSA6IE1JVFxuLy8hIG1vbWVudGpzLmNvbVxuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgaG9va0NhbGxiYWNrO1xuXG4gICAgZnVuY3Rpb24gdXRpbHNfaG9va3NfX2hvb2tzICgpIHtcbiAgICAgICAgcmV0dXJuIGhvb2tDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4gICAgLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG4gICAgZnVuY3Rpb24gc2V0SG9va0NhbGxiYWNrIChjYWxsYmFjaykge1xuICAgICAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FycmF5KGlucHV0KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBEYXRlIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IERhdGVdJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICAgICAgICB2YXIgcmVzID0gW10sIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGZuKGFycltpXSwgaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzT3duUHJvcChhLCBiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBiKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChiLCBpKSkge1xuICAgICAgICAgICAgICAgIGFbaV0gPSBiW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3RvU3RyaW5nJykpIHtcbiAgICAgICAgICAgIGEudG9TdHJpbmcgPSBiLnRvU3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3ZhbHVlT2YnKSkge1xuICAgICAgICAgICAgYS52YWx1ZU9mID0gYi52YWx1ZU9mO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlX3V0Y19fY3JlYXRlVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgdHJ1ZSkudXRjKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBkZWVwIGNsb25lIHRoaXMgb2JqZWN0LlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW1wdHkgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICB1bnVzZWRUb2tlbnMgICAgOiBbXSxcbiAgICAgICAgICAgIHVudXNlZElucHV0ICAgICA6IFtdLFxuICAgICAgICAgICAgb3ZlcmZsb3cgICAgICAgIDogLTIsXG4gICAgICAgICAgICBjaGFyc0xlZnRPdmVyICAgOiAwLFxuICAgICAgICAgICAgbnVsbElucHV0ICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBpbnZhbGlkTW9udGggICAgOiBudWxsLFxuICAgICAgICAgICAgaW52YWxpZEZvcm1hdCAgIDogZmFsc2UsXG4gICAgICAgICAgICB1c2VySW52YWxpZGF0ZWQgOiBmYWxzZSxcbiAgICAgICAgICAgIGlzbyAgICAgICAgICAgICA6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcbiAgICAgICAgaWYgKG0uX3BmID09IG51bGwpIHtcbiAgICAgICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9wZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZF9faXNWYWxpZChtKSB7XG4gICAgICAgIGlmIChtLl9pc1ZhbGlkID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBmbGFncyA9IGdldFBhcnNpbmdGbGFncyhtKTtcbiAgICAgICAgICAgIG0uX2lzVmFsaWQgPSAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICAgICAgZmxhZ3Mub3ZlcmZsb3cgPCAwICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmVtcHR5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkV2Vla2RheSAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5udWxsSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQ7XG5cbiAgICAgICAgICAgIGlmIChtLl9zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBtLl9pc1ZhbGlkID0gbS5faXNWYWxpZCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5jaGFyc0xlZnRPdmVyID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLnVudXNlZFRva2Vucy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYmlnSG91ciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkX19jcmVhdGVJbnZhbGlkIChmbGFncykge1xuICAgICAgICB2YXIgbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhOYU4pO1xuICAgICAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXh0ZW5kKGdldFBhcnNpbmdGbGFncyhtKSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICB2YXIgbW9tZW50UHJvcGVydGllcyA9IHV0aWxzX2hvb2tzX19ob29rcy5tb21lbnRQcm9wZXJ0aWVzID0gW107XG5cbiAgICBmdW5jdGlvbiBjb3B5Q29uZmlnKHRvLCBmcm9tKSB7XG4gICAgICAgIHZhciBpLCBwcm9wLCB2YWw7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9pc0FNb21lbnRPYmplY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5faXNBTW9tZW50T2JqZWN0ID0gZnJvbS5faXNBTW9tZW50T2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5faSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9pID0gZnJvbS5faTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX2YgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5fZiA9IGZyb20uX2Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9sICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX2wgPSBmcm9tLl9sO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fc3RyaWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX3N0cmljdCA9IGZyb20uX3N0cmljdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX3R6bSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl90em0gPSBmcm9tLl90em07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9pc1VUQyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9pc1VUQyA9IGZyb20uX2lzVVRDO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fb2Zmc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX29mZnNldCA9IGZyb20uX29mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX3BmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX3BmID0gZ2V0UGFyc2luZ0ZsYWdzKGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fbG9jYWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAoaSBpbiBtb21lbnRQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IG1vbWVudFByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICAgICAgdmFsID0gZnJvbVtwcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9bcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgICAvLyBNb21lbnQgcHJvdG90eXBlIG9iamVjdFxuICAgIGZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcbiAgICAgICAgY29weUNvbmZpZyh0aGlzLCBjb25maWcpO1xuICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoY29uZmlnLl9kICE9IG51bGwgPyBjb25maWcuX2QuZ2V0VGltZSgpIDogTmFOKTtcbiAgICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxuICAgICAgICAvLyBvYmplY3RzLlxuICAgICAgICBpZiAodXBkYXRlSW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50IChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgb2JqLl9pc0FNb21lbnRPYmplY3QgIT0gbnVsbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzRmxvb3IgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSkpIHtcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9jYWxlKCkge1xuICAgIH1cblxuICAgIHZhciBsb2NhbGVzID0ge307XG4gICAgdmFyIGdsb2JhbExvY2FsZTtcblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSA/IGtleS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ18nLCAnLScpIDoga2V5O1xuICAgIH1cblxuICAgIC8vIHBpY2sgdGhlIGxvY2FsZSBmcm9tIHRoZSBhcnJheVxuICAgIC8vIHRyeSBbJ2VuLWF1JywgJ2VuLWdiJ10gYXMgJ2VuLWF1JywgJ2VuLWdiJywgJ2VuJywgYXMgaW4gbW92ZSB0aHJvdWdoIHRoZSBsaXN0IHRyeWluZyBlYWNoXG4gICAgLy8gc3Vic3RyaW5nIGZyb20gbW9zdCBzcGVjaWZpYyB0byBsZWFzdCwgYnV0IG1vdmUgdG8gdGhlIG5leHQgYXJyYXkgaXRlbSBpZiBpdCdzIGEgbW9yZSBzcGVjaWZpYyB2YXJpYW50IHRoYW4gdGhlIGN1cnJlbnQgcm9vdFxuICAgIGZ1bmN0aW9uIGNob29zZUxvY2FsZShuYW1lcykge1xuICAgICAgICB2YXIgaSA9IDAsIGosIG5leHQsIGxvY2FsZSwgc3BsaXQ7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNwbGl0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2ldKS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgaiA9IHNwbGl0Lmxlbmd0aDtcbiAgICAgICAgICAgIG5leHQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaSArIDFdKTtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0ID8gbmV4dC5zcGxpdCgnLScpIDogbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChqID4gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQubGVuZ3RoID49IGogJiYgY29tcGFyZUFycmF5cyhzcGxpdCwgbmV4dCwgdHJ1ZSkgPj0gaiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgbmV4dCBhcnJheSBpdGVtIGlzIGJldHRlciB0aGFuIGEgc2hhbGxvd2VyIHN1YnN0cmluZyBvZiB0aGlzIG9uZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRMb2NhbGUobmFtZSkge1xuICAgICAgICB2YXIgb2xkTG9jYWxlID0gbnVsbDtcbiAgICAgICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gcmVnaXN0ZXIgYW5kIGxvYWQgYWxsIHRoZSBsb2NhbGVzIGluIE5vZGVcbiAgICAgICAgaWYgKCFsb2NhbGVzW25hbWVdICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2xvY2FsZS8nICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBkZWZpbmVMb2NhbGUgY3VycmVudGx5IGFsc28gc2V0cyB0aGUgZ2xvYmFsIGxvY2FsZSwgd2VcbiAgICAgICAgICAgICAgICAvLyB3YW50IHRvIHVuZG8gdGhhdCBmb3IgbGF6eSBsb2FkZWQgbG9jYWxlc1xuICAgICAgICAgICAgICAgIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxvY2FsZSBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsb2NhbGUuICBJZlxuICAgIC8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgZ2xvYmFsXG4gICAgLy8gbG9jYWxlIGtleS5cbiAgICBmdW5jdGlvbiBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlIChrZXksIHZhbHVlcykge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmluZUxvY2FsZSAobmFtZSwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWx1ZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlcy5hYmJyID0gbmFtZTtcbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGVzW25hbWVdIHx8IG5ldyBMb2NhbGUoKTtcbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0uc2V0KHZhbHVlcyk7XG5cbiAgICAgICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICAgICAgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZShuYW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB1c2VmdWwgZm9yIHRlc3RpbmdcbiAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBsb2NhbGU7XG5cbiAgICAgICAgaWYgKGtleSAmJiBrZXkuX2xvY2FsZSAmJiBrZXkuX2xvY2FsZS5fYWJicikge1xuICAgICAgICAgICAga2V5ID0ga2V5Ll9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleSA9IFtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNob29zZUxvY2FsZShrZXkpO1xuICAgIH1cblxuICAgIHZhciBhbGlhc2VzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRVbml0QWxpYXMgKHVuaXQsIHNob3J0aGFuZCkge1xuICAgICAgICB2YXIgbG93ZXJDYXNlID0gdW5pdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBhbGlhc2VzW2xvd2VyQ2FzZV0gPSBhbGlhc2VzW2xvd2VyQ2FzZSArICdzJ10gPSBhbGlhc2VzW3Nob3J0aGFuZF0gPSB1bml0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdW5pdHMgPT09ICdzdHJpbmcnID8gYWxpYXNlc1t1bml0c10gfHwgYWxpYXNlc1t1bml0cy50b0xvd2VyQ2FzZSgpXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVPYmplY3RVbml0cyhpbnB1dE9iamVjdCkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0ge30sXG4gICAgICAgICAgICBub3JtYWxpemVkUHJvcCxcbiAgICAgICAgICAgIHByb3A7XG5cbiAgICAgICAgZm9yIChwcm9wIGluIGlucHV0T2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChpbnB1dE9iamVjdCwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkUHJvcCA9IG5vcm1hbGl6ZVVuaXRzKHByb3ApO1xuICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVkUHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkSW5wdXRbbm9ybWFsaXplZFByb3BdID0gaW5wdXRPYmplY3RbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRJbnB1dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0U2V0ICh1bml0LCBrZWVwVGltZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdldF9zZXRfX3NldCh0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCBrZWVwVGltZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRfc2V0X19nZXQodGhpcywgdW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0X3NldF9fZ2V0IChtb20sIHVuaXQpIHtcbiAgICAgICAgcmV0dXJuIG1vbS5fZFsnZ2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldF9zZXRfX3NldCAobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXQgKHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICB2YXIgdW5pdDtcbiAgICAgICAgaWYgKHR5cGVvZiB1bml0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZvciAodW5pdCBpbiB1bml0cykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KHVuaXQsIHVuaXRzW3VuaXRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzW3VuaXRzXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgICAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuICAgICAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArIGFic051bWJlcjtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRfFlZWVlZWXxZWVlZWXxZWVlZfFlZfGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2c7XG5cbiAgICB2YXIgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZztcblxuICAgIHZhciBmb3JtYXRGdW5jdGlvbnMgPSB7fTtcblxuICAgIHZhciBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgLy8gdG9rZW46ICAgICdNJ1xuICAgIC8vIHBhZGRlZDogICBbJ01NJywgMl1cbiAgICAvLyBvcmRpbmFsOiAgJ01vJ1xuICAgIC8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuICAgIGZ1bmN0aW9uIGFkZEZvcm1hdFRva2VuICh0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0b2tlbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGFycmF5W2ldIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KSA6IGFycmF5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcbiAgICBmdW5jdGlvbiBmb3JtYXRNb21lbnQobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbS5sb2NhbGVEYXRhKCkpO1xuICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9IGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdIHx8IG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpO1xuXG4gICAgICAgIHJldHVybiBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XShtKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBhbmRGb3JtYXQoZm9ybWF0LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGkgPSA1O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2VucyhpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5sb25nRGF0ZUZvcm1hdChpbnB1dCkgfHwgaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBsb2NhbEZvcm1hdHRpbmdUb2tlbnMudGVzdChmb3JtYXQpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShsb2NhbEZvcm1hdHRpbmdUb2tlbnMsIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2Vucyk7XG4gICAgICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoMSAgICAgICAgID0gL1xcZC87ICAgICAgICAgICAgLy8gICAgICAgMCAtIDlcbiAgICB2YXIgbWF0Y2gyICAgICAgICAgPSAvXFxkXFxkLzsgICAgICAgICAgLy8gICAgICAwMCAtIDk5XG4gICAgdmFyIG1hdGNoMyAgICAgICAgID0gL1xcZHszfS87ICAgICAgICAgLy8gICAgIDAwMCAtIDk5OVxuICAgIHZhciBtYXRjaDQgICAgICAgICA9IC9cXGR7NH0vOyAgICAgICAgIC8vICAgIDAwMDAgLSA5OTk5XG4gICAgdmFyIG1hdGNoNiAgICAgICAgID0gL1srLV0/XFxkezZ9LzsgICAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuICAgIHZhciBtYXRjaDF0bzIgICAgICA9IC9cXGRcXGQ/LzsgICAgICAgICAvLyAgICAgICAwIC0gOTlcbiAgICB2YXIgbWF0Y2gxdG8zICAgICAgPSAvXFxkezEsM30vOyAgICAgICAvLyAgICAgICAwIC0gOTk5XG4gICAgdmFyIG1hdGNoMXRvNCAgICAgID0gL1xcZHsxLDR9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2gxdG82ICAgICAgPSAvWystXT9cXGR7MSw2fS87ICAvLyAtOTk5OTk5IC0gOTk5OTk5XG5cbiAgICB2YXIgbWF0Y2hVbnNpZ25lZCAgPSAvXFxkKy87ICAgICAgICAgICAvLyAgICAgICAwIC0gaW5mXG4gICAgdmFyIG1hdGNoU2lnbmVkICAgID0gL1srLV0/XFxkKy87ICAgICAgLy8gICAgLWluZiAtIGluZlxuXG4gICAgdmFyIG1hdGNoT2Zmc2V0ICAgID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpOyAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcblxuICAgIHZhciBtYXRjaFRpbWVzdGFtcCA9IC9bKy1dP1xcZCsoXFwuXFxkezEsM30pPy87IC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG5cbiAgICAvLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbiAgICB2YXIgbWF0Y2hXb3JkID0gL1swLTldKlsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSt8W1xcdTA2MDAtXFx1MDZGRlxcL10rKFxccyo/W1xcdTA2MDAtXFx1MDZGRl0rKXsxLDJ9L2k7XG5cbiAgICB2YXIgcmVnZXhlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbiAoc3RoKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMzI1XG4gICAgICAgIHJldHVybiB0eXBlb2Ygc3RoID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3RoKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4gKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcbiAgICAgICAgcmVnZXhlc1t0b2tlbl0gPSBpc0Z1bmN0aW9uKHJlZ2V4KSA/IHJlZ2V4IDogZnVuY3Rpb24gKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4KSA/IHN0cmljdFJlZ2V4IDogcmVnZXg7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuICh0b2tlbiwgY29uZmlnKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcChyZWdleGVzLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVuZXNjYXBlRm9ybWF0KHRva2VuKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVnZXhlc1t0b2tlbl0oY29uZmlnLl9zdHJpY3QsIGNvbmZpZy5fbG9jYWxlKTtcbiAgICB9XG5cbiAgICAvLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG4gICAgZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKCdcXFxcJywgJycpLnJlcGxhY2UoL1xcXFwoXFxbKXxcXFxcKFxcXSl8XFxbKFteXFxdXFxbXSopXFxdfFxcXFwoLikvZywgZnVuY3Rpb24gKG1hdGNoZWQsIHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XG4gICAgICAgIH0pLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIHZhciB0b2tlbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaSwgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2NhbGxiYWNrXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2VuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5baV1dID0gZnVuYztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xuICAgICAgICAgICAgY2FsbGJhY2soaW5wdXQsIGNvbmZpZy5fdywgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsICYmIGhhc093blByb3AodG9rZW5zLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbl0oaW5wdXQsIGNvbmZpZy5fYSwgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgWUVBUiA9IDA7XG4gICAgdmFyIE1PTlRIID0gMTtcbiAgICB2YXIgREFURSA9IDI7XG4gICAgdmFyIEhPVVIgPSAzO1xuICAgIHZhciBNSU5VVEUgPSA0O1xuICAgIHZhciBTRUNPTkQgPSA1O1xuICAgIHZhciBNSUxMSVNFQ09ORCA9IDY7XG5cbiAgICBmdW5jdGlvbiBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGggKyAxLCAwKSkuZ2V0VVRDRGF0ZSgpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdNJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTScsICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTScsICBtYXRjaFdvcmQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTU0nLCBtYXRjaFdvcmQpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ00nLCAnTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSB0b0ludChpbnB1dCkgLSAxO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ01NTScsICdNTU1NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIG1vbnRoID0gY29uZmlnLl9sb2NhbGUubW9udGhzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgICAgICBpZiAobW9udGggIT0gbnVsbCkge1xuICAgICAgICAgICAgYXJyYXlbTU9OVEhdID0gbW9udGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkTW9udGggPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPSAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHMgKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1ttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPSAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQgKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzUGFyc2UgKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdHJpY3QgJiYgIXRoaXMuX21vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKSArICd8XicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NTScgJiYgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NJyAmJiB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX21vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc2V0TW9udGggKG1vbSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRheU9mTW9udGg7XG5cbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIG91dCBvZiBoZXJlIVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSBtb20ubG9jYWxlRGF0YSgpLm1vbnRoc1BhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgIC8vIFRPRE86IEFub3RoZXIgc2lsZW50IGZhaWx1cmU/XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkYXlPZk1vbnRoID0gTWF0aC5taW4obW9tLmRhdGUoKSwgZGF5c0luTW9udGgobW9tLnllYXIoKSwgdmFsdWUpKTtcbiAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArICdNb250aCddKHZhbHVlLCBkYXlPZk1vbnRoKTtcbiAgICAgICAgcmV0dXJuIG1vbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRNb250aCAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRfc2V0X19nZXQodGhpcywgJ01vbnRoJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXlzSW5Nb250aCAoKSB7XG4gICAgICAgIHJldHVybiBkYXlzSW5Nb250aCh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja092ZXJmbG93IChtKSB7XG4gICAgICAgIHZhciBvdmVyZmxvdztcbiAgICAgICAgdmFyIGEgPSBtLl9hO1xuXG4gICAgICAgIGlmIChhICYmIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9PT0gLTIpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID1cbiAgICAgICAgICAgICAgICBhW01PTlRIXSAgICAgICA8IDAgfHwgYVtNT05USF0gICAgICAgPiAxMSAgPyBNT05USCA6XG4gICAgICAgICAgICAgICAgYVtEQVRFXSAgICAgICAgPCAxIHx8IGFbREFURV0gICAgICAgID4gZGF5c0luTW9udGgoYVtZRUFSXSwgYVtNT05USF0pID8gREFURSA6XG4gICAgICAgICAgICAgICAgYVtIT1VSXSAgICAgICAgPCAwIHx8IGFbSE9VUl0gICAgICAgID4gMjQgfHwgKGFbSE9VUl0gPT09IDI0ICYmIChhW01JTlVURV0gIT09IDAgfHwgYVtTRUNPTkRdICE9PSAwIHx8IGFbTUlMTElTRUNPTkRdICE9PSAwKSkgPyBIT1VSIDpcbiAgICAgICAgICAgICAgICBhW01JTlVURV0gICAgICA8IDAgfHwgYVtNSU5VVEVdICAgICAgPiA1OSAgPyBNSU5VVEUgOlxuICAgICAgICAgICAgICAgIGFbU0VDT05EXSAgICAgIDwgMCB8fCBhW1NFQ09ORF0gICAgICA+IDU5ICA/IFNFQ09ORCA6XG4gICAgICAgICAgICAgICAgYVtNSUxMSVNFQ09ORF0gPCAwIHx8IGFbTUlMTElTRUNPTkRdID4gOTk5ID8gTUlMTElTRUNPTkQgOlxuICAgICAgICAgICAgICAgIC0xO1xuXG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJiAob3ZlcmZsb3cgPCBZRUFSIHx8IG92ZXJmbG93ID4gREFURSkpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IERBVEU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAgICAgaWYgKHV0aWxzX2hvb2tzX19ob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPT09IGZhbHNlICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gd2FybmluZzogJyArIG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGUobXNnLCBmbikge1xuICAgICAgICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICB3YXJuKG1zZyArICdcXG4nICsgKG5ldyBFcnJvcigpKS5zdGFjayk7XG4gICAgICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSwgZm4pO1xuICAgIH1cblxuICAgIHZhciBkZXByZWNhdGlvbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCBtc2cpIHtcbiAgICAgICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1dGlsc19ob29rc19faG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID0gZmFsc2U7XG5cbiAgICB2YXIgZnJvbV9zdHJpbmdfX2lzb1JlZ2V4ID0gL15cXHMqKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OihcXGRcXGQtXFxkXFxkKXwoV1xcZFxcZCQpfChXXFxkXFxkLVxcZCl8KFxcZFxcZFxcZCkpKChUfCApKFxcZFxcZCg6XFxkXFxkKDpcXGRcXGQoXFwuXFxkKyk/KT8pPyk/KFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcblxuICAgIHZhciBpc29EYXRlcyA9IFtcbiAgICAgICAgWydZWVlZWVktTU0tREQnLCAvWystXVxcZHs2fS1cXGR7Mn0tXFxkezJ9L10sXG4gICAgICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkezJ9LVxcZHsyfS9dLFxuICAgICAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZHsyfS1cXGQvXSxcbiAgICAgICAgWydHR0dHLVtXXVdXJywgL1xcZHs0fS1XXFxkezJ9L10sXG4gICAgICAgIFsnWVlZWS1EREQnLCAvXFxkezR9LVxcZHszfS9dXG4gICAgXTtcblxuICAgIC8vIGlzbyB0aW1lIGZvcm1hdHMgYW5kIHJlZ2V4ZXNcbiAgICB2YXIgaXNvVGltZXMgPSBbXG4gICAgICAgIFsnSEg6bW06c3MuU1NTUycsIC8oVHwgKVxcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICBbJ0hIOm1tOnNzJywgLyhUfCApXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgWydISDptbScsIC8oVHwgKVxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgWydISCcsIC8oVHwgKVxcZFxcZC9dXG4gICAgXTtcblxuICAgIHZhciBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pO1xuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgICAgICB2YXIgaSwgbCxcbiAgICAgICAgICAgIHN0cmluZyA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIG1hdGNoID0gZnJvbV9zdHJpbmdfX2lzb1JlZ2V4LmV4ZWMoc3RyaW5nKTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMoc3RyaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2YgPSBpc29EYXRlc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKHN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbNl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2YgKz0gKG1hdGNoWzZdIHx8ICcgJykgKyBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmluZy5tYXRjaChtYXRjaE9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2YgKz0gJ1onO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdCBvciBmYWxsYmFja1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoY29uZmlnLl9pKTtcblxuICAgICAgICBpZiAobWF0Y2hlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoK21hdGNoZWRbMV0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50IGNvbnN0cnVjdGlvbiBmYWxscyBiYWNrIHRvIGpzIERhdGUuIFRoaXMgaXMgJyArXG4gICAgICAgICdkaXNjb3VyYWdlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHVwY29taW5nIG1ham9yICcgK1xuICAgICAgICAncmVsZWFzZS4gUGxlYXNlIHJlZmVyIHRvICcgK1xuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MDcgZm9yIG1vcmUgaW5mby4nLFxuICAgICAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZURhdGUgKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XG4gICAgICAgIC8vY2FuJ3QganVzdCBhcHBseSgpIHRvIGNyZWF0ZSBhIGRhdGU6XG4gICAgICAgIC8vaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODEzNDgvaW5zdGFudGlhdGluZy1hLWphdmFzY3JpcHQtb2JqZWN0LWJ5LWNhbGxpbmctcHJvdG90eXBlLWNvbnN0cnVjdG9yLWFwcGx5XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuXG4gICAgICAgIC8vdGhlIGRhdGUgY29uc3RydWN0b3IgZG9lc24ndCBhY2NlcHQgeWVhcnMgPCAxOTcwXG4gICAgICAgIGlmICh5IDwgMTk3MCkge1xuICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVENEYXRlICh5KSB7XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgICAgIGlmICh5IDwgMTk3MCkge1xuICAgICAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZJywgICA0XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgIDVdLCAgICAgICAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVlZJywgNiwgdHJ1ZV0sIDAsICd5ZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3llYXInLCAneScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWScsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVknLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydZWVlZWScsICdZWVlZWVknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBpbnB1dC5sZW5ndGggPT09IDIgPyB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpIDogdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiBkYXlzSW5ZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG4gICAgfTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCBmYWxzZSk7XG5cbiAgICBmdW5jdGlvbiBnZXRJc0xlYXBZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKCkpO1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCd3JywgWyd3dycsIDJdLCAnd28nLCAnd2VlaycpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdXJywgWydXVycsIDJdLCAnV28nLCAnaXNvV2VlaycpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrJywgJ3cnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWsnLCAnVycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigndycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3d3JywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1cnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdXVycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsndycsICd3dycsICdXJywgJ1dXJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAxKV0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBmaXJzdERheU9mV2VlayAgICAgICAwID0gc3VuLCA2ID0gc2F0XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgdGhlIGRheSBvZiB0aGUgd2VlayB0aGF0IHN0YXJ0cyB0aGUgd2Vla1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICh1c3VhbGx5IHN1bmRheSBvciBtb25kYXkpXG4gICAgLy8gZmlyc3REYXlPZldlZWtPZlllYXIgMCA9IHN1biwgNiA9IHNhdFxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIHRoZSBmaXJzdCB3ZWVrIGlzIHRoZSB3ZWVrIHRoYXQgY29udGFpbnMgdGhlIGZpcnN0XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgb2YgdGhpcyBkYXkgb2YgdGhlIHdlZWtcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAoZWcuIElTTyB3ZWVrcyB1c2UgdGh1cnNkYXkgKDQpKVxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBmaXJzdERheU9mV2VlaywgZmlyc3REYXlPZldlZWtPZlllYXIpIHtcbiAgICAgICAgdmFyIGVuZCA9IGZpcnN0RGF5T2ZXZWVrT2ZZZWFyIC0gZmlyc3REYXlPZldlZWssXG4gICAgICAgICAgICBkYXlzVG9EYXlPZldlZWsgPSBmaXJzdERheU9mV2Vla09mWWVhciAtIG1vbS5kYXkoKSxcbiAgICAgICAgICAgIGFkanVzdGVkTW9tZW50O1xuXG5cbiAgICAgICAgaWYgKGRheXNUb0RheU9mV2VlayA+IGVuZCkge1xuICAgICAgICAgICAgZGF5c1RvRGF5T2ZXZWVrIC09IDc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF5c1RvRGF5T2ZXZWVrIDwgZW5kIC0gNykge1xuICAgICAgICAgICAgZGF5c1RvRGF5T2ZXZWVrICs9IDc7XG4gICAgICAgIH1cblxuICAgICAgICBhZGp1c3RlZE1vbWVudCA9IGxvY2FsX19jcmVhdGVMb2NhbChtb20pLmFkZChkYXlzVG9EYXlPZldlZWssICdkJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3ZWVrOiBNYXRoLmNlaWwoYWRqdXN0ZWRNb21lbnQuZGF5T2ZZZWFyKCkgLyA3KSxcbiAgICAgICAgICAgIHllYXI6IGFkanVzdGVkTW9tZW50LnllYXIoKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWsgKG1vbSkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2VlaztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWsgPSB7XG4gICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gdGhpcy5sb2NhbGVEYXRhKCkud2Vlayh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0RERCcsIFsnRERERCcsIDNdLCAnREREbycsICdkYXlPZlllYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5T2ZZZWFyJywgJ0RERCcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignREREJywgIG1hdGNoMXRvMyk7XG4gICAgYWRkUmVnZXhUb2tlbignRERERCcsIG1hdGNoMyk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ0RERCcsICdEREREJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBmaXJzdERheU9mV2Vla09mWWVhciwgZmlyc3REYXlPZldlZWspIHtcbiAgICAgICAgdmFyIHdlZWsxSmFuID0gNiArIGZpcnN0RGF5T2ZXZWVrIC0gZmlyc3REYXlPZldlZWtPZlllYXIsIGphblggPSBjcmVhdGVVVENEYXRlKHllYXIsIDAsIDEgKyB3ZWVrMUphbiksIGQgPSBqYW5YLmdldFVUQ0RheSgpLCBkYXlPZlllYXI7XG4gICAgICAgIGlmIChkIDwgZmlyc3REYXlPZldlZWspIHtcbiAgICAgICAgICAgIGQgKz0gNztcbiAgICAgICAgfVxuXG4gICAgICAgIHdlZWtkYXkgPSB3ZWVrZGF5ICE9IG51bGwgPyAxICogd2Vla2RheSA6IGZpcnN0RGF5T2ZXZWVrO1xuXG4gICAgICAgIGRheU9mWWVhciA9IDEgKyB3ZWVrMUphbiArIDcgKiAod2VlayAtIDEpIC0gZCArIHdlZWtkYXk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXI6IGRheU9mWWVhciA+IDAgPyB5ZWFyIDogeWVhciAtIDEsXG4gICAgICAgICAgICBkYXlPZlllYXI6IGRheU9mWWVhciA+IDAgPyAgZGF5T2ZZZWFyIDogZGF5c0luWWVhcih5ZWFyIC0gMSkgKyBkYXlPZlllYXJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZlllYXIgKGlucHV0KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXIgPSBNYXRoLnJvdW5kKCh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1KSArIDE7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoKGlucHV0IC0gZGF5T2ZZZWFyKSwgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDKSB7XG4gICAgICAgICAgICByZXR1cm4gW25vdy5nZXRVVENGdWxsWWVhcigpLCBub3cuZ2V0VVRDTW9udGgoKSwgbm93LmdldFVUQ0RhdGUoKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtub3cuZ2V0RnVsbFllYXIoKSwgbm93LmdldE1vbnRoKCksIG5vdy5nZXREYXRlKCldO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxuICAgIC8vIHRoZSBhcnJheSBzaG91bGQgbWlycm9yIHRoZSBwYXJhbWV0ZXJzIGJlbG93XG4gICAgLy8gbm90ZTogYWxsIHZhbHVlcyBwYXN0IHRoZSB5ZWFyIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXG4gICAgLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUFycmF5IChjb25maWcpIHtcbiAgICAgICAgdmFyIGksIGRhdGUsIGlucHV0ID0gW10sIGN1cnJlbnREYXRlLCB5ZWFyVG9Vc2U7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAgICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgICAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyKSB7XG4gICAgICAgICAgICB5ZWFyVG9Vc2UgPSBkZWZhdWx0cyhjb25maWcuX2FbWUVBUl0sIGN1cnJlbnREYXRlW1lFQVJdKTtcblxuICAgICAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyVG9Vc2UpKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93RGF5T2ZZZWFyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoeWVhclRvVXNlLCAwLCBjb25maWcuX2RheU9mWWVhcik7XG4gICAgICAgICAgICBjb25maWcuX2FbTU9OVEhdID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgY29uZmlnLl9hW0RBVEVdID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgZGF0ZS5cbiAgICAgICAgLy8gKiBpZiBubyB5ZWFyLCBtb250aCwgZGF5IG9mIG1vbnRoIGFyZSBnaXZlbiwgZGVmYXVsdCB0byB0b2RheVxuICAgICAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxuICAgICAgICAvLyAqIGlmIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG9ubHkgeWVhclxuICAgICAgICAvLyAqIGlmIHllYXIgaXMgZ2l2ZW4sIGRvbid0IGRlZmF1bHQgYW55dGhpbmdcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSBjdXJyZW50RGF0ZVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFplcm8gb3V0IHdoYXRldmVyIHdhcyBub3QgZGVmYXVsdGVkLCBpbmNsdWRpbmcgdGltZVxuICAgICAgICBmb3IgKDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSAoY29uZmlnLl9hW2ldID09IG51bGwpID8gKGkgPT09IDIgPyAxIDogMCkgOiBjb25maWcuX2FbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgMjQ6MDA6MDAuMDAwXG4gICAgICAgIGlmIChjb25maWcuX2FbSE9VUl0gPT09IDI0ICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTlVURV0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbU0VDT05EXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtNSUxMSVNFQ09ORF0gPT09IDApIHtcbiAgICAgICAgICAgIGNvbmZpZy5fbmV4dERheSA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLl9kID0gKGNvbmZpZy5fdXNlVVRDID8gY3JlYXRlVVRDRGF0ZSA6IGNyZWF0ZURhdGUpLmFwcGx5KG51bGwsIGlucHV0KTtcbiAgICAgICAgLy8gQXBwbHkgdGltZXpvbmUgb2Zmc2V0IGZyb20gaW5wdXQuIFRoZSBhY3R1YWwgdXRjT2Zmc2V0IGNhbiBiZSBjaGFuZ2VkXG4gICAgICAgIC8vIHdpdGggcGFyc2Vab25lLlxuICAgICAgICBpZiAoY29uZmlnLl90em0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX25leHREYXkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDI0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZykge1xuICAgICAgICB2YXIgdywgd2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95LCB0ZW1wO1xuXG4gICAgICAgIHcgPSBjb25maWcuX3c7XG4gICAgICAgIGlmICh3LkdHICE9IG51bGwgfHwgdy5XICE9IG51bGwgfHwgdy5FICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRvdyA9IDE7XG4gICAgICAgICAgICBkb3kgPSA0O1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHRha2UgdGhlIGN1cnJlbnQgaXNvV2Vla1llYXIsIGJ1dCB0aGF0IGRlcGVuZHMgb25cbiAgICAgICAgICAgIC8vIGhvdyB3ZSBpbnRlcnByZXQgbm93IChsb2NhbCwgdXRjLCBmaXhlZCBvZmZzZXQpLiBTbyBjcmVhdGVcbiAgICAgICAgICAgIC8vIGEgbm93IHZlcnNpb24gb2YgY3VycmVudCBjb25maWcgKHRha2UgbG9jYWwvdXRjL29mZnNldCBmbGFncywgYW5kXG4gICAgICAgICAgICAvLyBjcmVhdGUgbm93KS5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5HRywgY29uZmlnLl9hW1lFQVJdLCB3ZWVrT2ZZZWFyKGxvY2FsX19jcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb3cgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3c7XG4gICAgICAgICAgICBkb3kgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3k7XG5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5nZywgY29uZmlnLl9hW1lFQVJdLCB3ZWVrT2ZZZWFyKGxvY2FsX19jcmVhdGVMb2NhbCgpLCBkb3csIGRveSkueWVhcik7XG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody53LCAxKTtcblxuICAgICAgICAgICAgaWYgKHcuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gd2Vla2RheSAtLSBsb3cgZGF5IG51bWJlcnMgYXJlIGNvbnNpZGVyZWQgbmV4dCB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZDtcbiAgICAgICAgICAgICAgICBpZiAod2Vla2RheSA8IGRvdykge1xuICAgICAgICAgICAgICAgICAgICArK3dlZWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh3LmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGxvY2FsIHdlZWtkYXkgLS0gY291bnRpbmcgc3RhcnRzIGZyb20gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSBkb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG95LCBkb3cpO1xuXG4gICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IHRlbXAueWVhcjtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICB9XG5cbiAgICB1dGlsc19ob29rc19faG9va3MuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmdcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYW5vdGhlciBwYXJ0IG9mIHRoZSBjcmVhdGlvbiBmbG93IHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwc1xuICAgICAgICBpZiAoY29uZmlnLl9mID09PSB1dGlsc19ob29rc19faG9va3MuSVNPXzg2MDEpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5fYSA9IFtdO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgY29uZmlnLl9pLFxuICAgICAgICAgICAgaSwgcGFyc2VkSW5wdXQsIHRva2VucywgdG9rZW4sIHNraXBwZWQsXG4gICAgICAgICAgICBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCA9IDA7XG5cbiAgICAgICAgdG9rZW5zID0gZXhwYW5kRm9ybWF0KGNvbmZpZy5fZiwgY29uZmlnLl9sb2NhbGUpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpIHx8IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgcGFyc2VkSW5wdXQgPSAoc3RyaW5nLm1hdGNoKGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSkgfHwgW10pWzBdO1xuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgc2tpcHBlZCA9IHN0cmluZy5zdWJzdHIoMCwgc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc2tpcHBlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgcGFyc2VkSW5wdXQsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmNoYXJzTGVmdE92ZXIgPSBzdHJpbmdMZW5ndGggLSB0b3RhbFBhcnNlZElucHV0TGVuZ3RoO1xuICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIF8xMmggZmxhZyBpZiBob3VyIGlzIDw9IDEyXG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID09PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdIDw9IDEyICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgbWVyaWRpZW1cbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKGNvbmZpZy5fbG9jYWxlLCBjb25maWcuX2FbSE9VUl0sIGNvbmZpZy5fbWVyaWRpZW0pO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAgKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgdmFyIGlzUG07XG5cbiAgICAgICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbGUubWVyaWRpZW1Ib3VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpIHtcbiAgICAgICAgdmFyIHRlbXBDb25maWcsXG4gICAgICAgICAgICBiZXN0TW9tZW50LFxuXG4gICAgICAgICAgICBzY29yZVRvQmVhdCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRGb3JtYXQgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25maWcuX2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XG4gICAgICAgICAgICB0ZW1wQ29uZmlnID0gY29weUNvbmZpZyh7fSwgY29uZmlnKTtcbiAgICAgICAgICAgIGlmIChjb25maWcuX3VzZVVUQyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGVtcENvbmZpZy5fdXNlVVRDID0gY29uZmlnLl91c2VVVEM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl9mID0gY29uZmlnLl9mW2ldO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdCh0ZW1wQ29uZmlnKTtcblxuICAgICAgICAgICAgaWYgKCF2YWxpZF9faXNWYWxpZCh0ZW1wQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkgaW5wdXQgdGhhdCB3YXMgbm90IHBhcnNlZCBhZGQgYSBwZW5hbHR5IGZvciB0aGF0IGZvcm1hdFxuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5jaGFyc0xlZnRPdmVyO1xuXG4gICAgICAgICAgICAvL29yIHRva2Vuc1xuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS51bnVzZWRUb2tlbnMubGVuZ3RoICogMTA7XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5zY29yZSA9IGN1cnJlbnRTY29yZTtcblxuICAgICAgICAgICAgaWYgKHNjb3JlVG9CZWF0ID09IG51bGwgfHwgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpO1xuICAgICAgICBjb25maWcuX2EgPSBbaS55ZWFyLCBpLm1vbnRoLCBpLmRheSB8fCBpLmRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXTtcblxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGcm9tQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhwcmVwYXJlQ29uZmlnKGNvbmZpZykpKTtcbiAgICAgICAgaWYgKHJlcy5fbmV4dERheSkge1xuICAgICAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgICAgICByZXMuYWRkKDEsICdkJyk7XG4gICAgICAgICAgICByZXMuX25leHREYXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVDb25maWcgKGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBmb3JtYXQgPSBjb25maWcuX2Y7XG5cbiAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKGNvbmZpZy5fbCk7XG5cbiAgICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IChmb3JtYXQgPT09IHVuZGVmaW5lZCAmJiBpbnB1dCA9PT0gJycpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRfX2NyZWF0ZUludmFsaWQoe251bGxJbnB1dDogdHJ1ZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhpbnB1dCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gaW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSW5wdXQoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlucHV0KGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2k7XG4gICAgICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCtpbnB1dCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2EgPSBtYXAoaW5wdXQuc2xpY2UoMCksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihpbnB1dCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGlucHV0KSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIGZyb20gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YobG9jYWxlKSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDIzXG4gICAgICAgIGMuX2lzQU1vbWVudE9iamVjdCA9IHRydWU7XG4gICAgICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XG4gICAgICAgIGMuX2wgPSBsb2NhbGU7XG4gICAgICAgIGMuX2kgPSBpbnB1dDtcbiAgICAgICAgYy5fZiA9IGZvcm1hdDtcbiAgICAgICAgYy5fc3RyaWN0ID0gc3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBjcmVhdGVGcm9tQ29uZmlnKGMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsX19jcmVhdGVMb2NhbCAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICAgICAgJ21vbWVudCgpLm1pbiBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTU0OCcsXG4gICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgdmFyIG90aGVyID0gbG9jYWxfX2NyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgIH1cbiAgICAgKTtcblxuICAgIHZhciBwcm90b3R5cGVNYXggPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5tYXggaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5tYXggaW5zdGVhZC4gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE1NDgnLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBsb2NhbF9fY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcbiAgICAvLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4gICAgLy9cbiAgICAvLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXG4gICAgLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbiAgICBmdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICAgICAgdmFyIHJlcywgaTtcbiAgICAgICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG4gICAgZnVuY3Rpb24gbWluICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXggKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0FmdGVyJywgYXJncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRHVyYXRpb24gKGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhkdXJhdGlvbiksXG4gICAgICAgICAgICB5ZWFycyA9IG5vcm1hbGl6ZWRJbnB1dC55ZWFyIHx8IDAsXG4gICAgICAgICAgICBxdWFydGVycyA9IG5vcm1hbGl6ZWRJbnB1dC5xdWFydGVyIHx8IDAsXG4gICAgICAgICAgICBtb250aHMgPSBub3JtYWxpemVkSW5wdXQubW9udGggfHwgMCxcbiAgICAgICAgICAgIHdlZWtzID0gbm9ybWFsaXplZElucHV0LndlZWsgfHwgMCxcbiAgICAgICAgICAgIGRheXMgPSBub3JtYWxpemVkSW5wdXQuZGF5IHx8IDAsXG4gICAgICAgICAgICBob3VycyA9IG5vcm1hbGl6ZWRJbnB1dC5ob3VyIHx8IDAsXG4gICAgICAgICAgICBtaW51dGVzID0gbm9ybWFsaXplZElucHV0Lm1pbnV0ZSB8fCAwLFxuICAgICAgICAgICAgc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5zZWNvbmQgfHwgMCxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZCB8fCAwO1xuXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9ICttaWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGhvdXJzICogMzZlNTsgLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgLy8gQmVjYXVzZSBvZiBkYXRlQWRkUmVtb3ZlIHRyZWF0cyAyNCBob3VycyBhcyBkaWZmZXJlbnQgZnJvbSBhXG4gICAgICAgIC8vIGRheSB3aGVuIHdvcmtpbmcgYXJvdW5kIERTVCwgd2UgbmVlZCB0byBzdG9yZSB0aGVtIHNlcGFyYXRlbHlcbiAgICAgICAgdGhpcy5fZGF5cyA9ICtkYXlzICtcbiAgICAgICAgICAgIHdlZWtzICogNztcbiAgICAgICAgLy8gSXQgaXMgaW1wb3NzaWJsZSB0cmFuc2xhdGUgbW9udGhzIGludG8gZGF5cyB3aXRob3V0IGtub3dpbmdcbiAgICAgICAgLy8gd2hpY2ggbW9udGhzIHlvdSBhcmUgYXJlIHRhbGtpbmcgYWJvdXQsIHNvIHdlIGhhdmUgdG8gc3RvcmVcbiAgICAgICAgLy8gaXQgc2VwYXJhdGVseS5cbiAgICAgICAgdGhpcy5fbW9udGhzID0gK21vbnRocyArXG4gICAgICAgICAgICBxdWFydGVycyAqIDMgK1xuICAgICAgICAgICAgeWVhcnMgKiAxMjtcblxuICAgICAgICB0aGlzLl9kYXRhID0ge307XG5cbiAgICAgICAgdGhpcy5fbG9jYWxlID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSgpO1xuXG4gICAgICAgIHRoaXMuX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb2Zmc2V0ICh0b2tlbiwgc2VwYXJhdG9yKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgICAgIHZhciBzaWduID0gJysnO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAtb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2lnbiArIHplcm9GaWxsKH5+KG9mZnNldCAvIDYwKSwgMikgKyBzZXBhcmF0b3IgKyB6ZXJvRmlsbCh+fihvZmZzZXQpICUgNjAsIDIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvZmZzZXQoJ1onLCAnOicpO1xuICAgIG9mZnNldCgnWlonLCAnJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdaJywgIG1hdGNoT2Zmc2V0KTtcbiAgICBhZGRSZWdleFRva2VuKCdaWicsIG1hdGNoT2Zmc2V0KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnWicsICdaWiddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl91c2VVVEMgPSB0cnVlO1xuICAgICAgICBjb25maWcuX3R6bSA9IG9mZnNldEZyb21TdHJpbmcoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gdGltZXpvbmUgY2h1bmtlclxuICAgIC8vICcrMTA6MDAnID4gWycxMCcsICAnMDAnXVxuICAgIC8vICctMTUzMCcgID4gWyctMTUnLCAnMzAnXVxuICAgIHZhciBjaHVua09mZnNldCA9IC8oW1xcK1xcLV18XFxkXFxkKS9naTtcblxuICAgIGZ1bmN0aW9uIG9mZnNldEZyb21TdHJpbmcoc3RyaW5nKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gKChzdHJpbmcgfHwgJycpLm1hdGNoKG1hdGNoT2Zmc2V0KSB8fCBbXSk7XG4gICAgICAgIHZhciBjaHVuayAgID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xuICAgICAgICB2YXIgcGFydHMgICA9IChjaHVuayArICcnKS5tYXRjaChjaHVua09mZnNldCkgfHwgWyctJywgMCwgMF07XG4gICAgICAgIHZhciBtaW51dGVzID0gKyhwYXJ0c1sxXSAqIDYwKSArIHRvSW50KHBhcnRzWzJdKTtcblxuICAgICAgICByZXR1cm4gcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuICAgIGZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICAgICAgdmFyIHJlcywgZGlmZjtcbiAgICAgICAgaWYgKG1vZGVsLl9pc1VUQykge1xuICAgICAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgICAgIGRpZmYgPSAoaXNNb21lbnQoaW5wdXQpIHx8IGlzRGF0ZShpbnB1dCkgPyAraW5wdXQgOiArbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KSkgLSAoK3Jlcyk7XG4gICAgICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXG4gICAgICAgICAgICByZXMuX2Quc2V0VGltZSgrcmVzLl9kICsgZGlmZik7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHJlcywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXRlT2Zmc2V0IChtKSB7XG4gICAgICAgIC8vIE9uIEZpcmVmb3guMjQgRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L3B1bGwvMTg3MVxuICAgICAgICByZXR1cm4gLU1hdGgucm91bmQobS5fZC5nZXRUaW1lem9uZU9mZnNldCgpIC8gMTUpICogMTU7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBtb21lbnQgaXMgbXV0YXRlZC5cbiAgICAvLyBJdCBpcyBpbnRlbmRlZCB0byBrZWVwIHRoZSBvZmZzZXQgaW4gc3luYyB3aXRoIHRoZSB0aW1lem9uZS5cbiAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcbiAgICAvLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuICAgIC8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbiAgICAvLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4gICAgLy9cbiAgICAvLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbiAgICAvLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbiAgICAvLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4gICAgLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbiAgICBmdW5jdGlvbiBnZXRTZXRPZmZzZXQgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMCxcbiAgICAgICAgICAgIGxvY2FsQWRqdXN0O1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG9mZnNldEZyb21TdHJpbmcoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGlucHV0KSA8IDE2KSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dCAqIDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1VUQyAmJiBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxBZGp1c3QgPSBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XG4gICAgICAgICAgICBpZiAobG9jYWxBZGp1c3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGxvY2FsQWRqdXN0LCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWtlZXBMb2NhbFRpbWUgfHwgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICBhZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oaW5wdXQgLSBvZmZzZXQsICdtJyksIDEsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IG9mZnNldCA6IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRab25lIChpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IC1pbnB1dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvVVRDIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb0xvY2FsIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1VUQykge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VidHJhY3QoZ2V0RGF0ZU9mZnNldCh0aGlzKSwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCAoKSB7XG4gICAgICAgIGlmICh0aGlzLl90em0pIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRoaXMuX3R6bSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2kgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldChvZmZzZXRGcm9tU3RyaW5nKHRoaXMuX2kpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNBbGlnbmVkSG91ck9mZnNldCAoaW5wdXQpIHtcbiAgICAgICAgaW5wdXQgPSBpbnB1dCA/IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCkudXRjT2Zmc2V0KCkgOiAwO1xuXG4gICAgICAgIHJldHVybiAodGhpcy51dGNPZmZzZXQoKSAtIGlucHV0KSAlIDYwID09PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQgKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2lzRFNUU2hpZnRlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGNvcHlDb25maWcoYywgdGhpcyk7XG4gICAgICAgIGMgPSBwcmVwYXJlQ29uZmlnKGMpO1xuXG4gICAgICAgIGlmIChjLl9hKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjLl9pc1VUQyA/IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhjLl9hKSA6IGxvY2FsX19jcmVhdGVMb2NhbChjLl9hKTtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZUFycmF5cyhjLl9hLCBvdGhlci50b0FycmF5KCkpID4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xvY2FsICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9pc1VUQztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0Y09mZnNldCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0YyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDA7XG4gICAgfVxuXG4gICAgdmFyIGFzcE5ldFJlZ2V4ID0gLyhcXC0pPyg/OihcXGQqKVxcLik/KFxcZCspXFw6KFxcZCspKD86XFw6KFxcZCspXFwuPyhcXGR7M30pPyk/LztcblxuICAgIC8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXG4gICAgLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuICAgIHZhciBjcmVhdGVfX2lzb1JlZ2V4ID0gL14oLSk/UCg/Oig/OihbMC05LC5dKilZKT8oPzooWzAtOSwuXSopTSk/KD86KFswLTksLl0qKUQpPyg/OlQoPzooWzAtOSwuXSopSCk/KD86KFswLTksLl0qKU0pPyg/OihbMC05LC5dKilTKT8pP3woWzAtOSwuXSopVykkLztcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24gKGlucHV0LCBrZXkpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICAgICAgc2lnbixcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIGRpZmZSZXM7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtcyA6IGlucHV0Ll9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgZCAgOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgICAgICBNICA6IGlucHV0Ll9tb250aHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbltrZXldID0gaW5wdXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uLm1pbGxpc2Vjb25kcyA9IGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gYXNwTmV0UmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeSAgOiAwLFxuICAgICAgICAgICAgICAgIGQgIDogdG9JbnQobWF0Y2hbREFURV0pICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgaCAgOiB0b0ludChtYXRjaFtIT1VSXSkgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBtICA6IHRvSW50KG1hdGNoW01JTlVURV0pICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIHMgIDogdG9JbnQobWF0Y2hbU0VDT05EXSkgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbXMgOiB0b0ludChtYXRjaFtNSUxMSVNFQ09ORF0pICogc2lnblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGNyZWF0ZV9faXNvUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeSA6IHBhcnNlSXNvKG1hdGNoWzJdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBNIDogcGFyc2VJc28obWF0Y2hbM10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGQgOiBwYXJzZUlzbyhtYXRjaFs0XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgaCA6IHBhcnNlSXNvKG1hdGNoWzVdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBtIDogcGFyc2VJc28obWF0Y2hbNl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHMgOiBwYXJzZUlzbyhtYXRjaFs3XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgdyA6IHBhcnNlSXNvKG1hdGNoWzhdLCBzaWduKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7Ly8gY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdvYmplY3QnICYmICgnZnJvbScgaW4gZHVyYXRpb24gfHwgJ3RvJyBpbiBkdXJhdGlvbikpIHtcbiAgICAgICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShsb2NhbF9fY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksIGxvY2FsX19jcmVhdGVMb2NhbChkdXJhdGlvbi50bykpO1xuXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgZHVyYXRpb24ubXMgPSBkaWZmUmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfbG9jYWxlJykpIHtcbiAgICAgICAgICAgIHJldC5fbG9jYWxlID0gaW5wdXQuX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgY3JlYXRlX19jcmVhdGVEdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvIChpbnAsIHNpZ24pIHtcbiAgICAgICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cbiAgICAgICAgLy8gY29udmVydHMgZmxvYXRzIHRvIGludHMuXG4gICAgICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cbiAgICAgICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgIC8vIGFwcGx5IHNpZ24gd2hpbGUgd2UncmUgYXQgaXRcbiAgICAgICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcyA9IHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG5cbiAgICAgICAgcmVzLm1vbnRocyA9IG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgK1xuICAgICAgICAgICAgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgICAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gKyhiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xuICAgICAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFkZGVyKGRpcmVjdGlvbiwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgICAgICAvL2ludmVydCB0aGUgYXJndW1lbnRzLCBidXQgY29tcGxhaW4gYWJvdXQgaXRcbiAgICAgICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKG5hbWUsICdtb21lbnQoKS4nICsgbmFtZSAgKyAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgKyBuYW1lICsgJyhudW1iZXIsIHBlcmlvZCkuJyk7XG4gICAgICAgICAgICAgICAgdG1wID0gdmFsOyB2YWwgPSBwZXJpb2Q7IHBlcmlvZCA9IHRtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyArdmFsIDogdmFsO1xuICAgICAgICAgICAgZHVyID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbih2YWwsIHBlcmlvZCk7XG4gICAgICAgICAgICBhZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QgKG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gZHVyYXRpb24uX2RheXMsXG4gICAgICAgICAgICBtb250aHMgPSBkdXJhdGlvbi5fbW9udGhzO1xuICAgICAgICB1cGRhdGVPZmZzZXQgPSB1cGRhdGVPZmZzZXQgPT0gbnVsbCA/IHRydWUgOiB1cGRhdGVPZmZzZXQ7XG5cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgbW9tLl9kLnNldFRpbWUoK21vbS5fZCArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF5cykge1xuICAgICAgICAgICAgZ2V0X3NldF9fc2V0KG1vbSwgJ0RhdGUnLCBnZXRfc2V0X19nZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9udGhzKSB7XG4gICAgICAgICAgICBzZXRNb250aChtb20sIGdldF9zZXRfX2dldChtb20sICdNb250aCcpICsgbW9udGhzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWRkX3N1YnRyYWN0X19hZGQgICAgICA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKTtcbiAgICB2YXIgYWRkX3N1YnRyYWN0X19zdWJ0cmFjdCA9IGNyZWF0ZUFkZGVyKC0xLCAnc3VidHJhY3QnKTtcblxuICAgIGZ1bmN0aW9uIG1vbWVudF9jYWxlbmRhcl9fY2FsZW5kYXIgKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGxvY2FsX19jcmVhdGVMb2NhbCgpLFxuICAgICAgICAgICAgc29kID0gY2xvbmVXaXRoT2Zmc2V0KG5vdywgdGhpcykuc3RhcnRPZignZGF5JyksXG4gICAgICAgICAgICBkaWZmID0gdGhpcy5kaWZmKHNvZCwgJ2RheXMnLCB0cnVlKSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGRpZmYgPCAtNiA/ICdzYW1lRWxzZScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAtMSA/ICdsYXN0V2VlaycgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAwID8gJ2xhc3REYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMSA/ICdzYW1lRGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDIgPyAnbmV4dERheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCA3ID8gJ25leHRXZWVrJyA6ICdzYW1lRWxzZSc7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChmb3JtYXRzICYmIGZvcm1hdHNbZm9ybWF0XSB8fCB0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIGxvY2FsX19jcmVhdGVMb2NhbChub3cpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGlucHV0TXM7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModHlwZW9mIHVuaXRzICE9PSAndW5kZWZpbmVkJyA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgaW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMgPiAraW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dE1zID0gaXNNb21lbnQoaW5wdXQpID8gK2lucHV0IDogK2xvY2FsX19jcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRNcyA8ICt0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBpbnB1dE1zO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHR5cGVvZiB1bml0cyAhPT0gJ3VuZGVmaW5lZCcgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuICt0aGlzIDwgK2lucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9IGlzTW9tZW50KGlucHV0KSA/ICtpbnB1dCA6ICtsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuICt0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpIDwgaW5wdXRNcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmV0d2VlbiAoZnJvbSwgdG8sIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQWZ0ZXIoZnJvbSwgdW5pdHMpICYmIHRoaXMuaXNCZWZvcmUodG8sIHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWUgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgaW5wdXRNcztcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyB8fCAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiArdGhpcyA9PT0gK2lucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9ICtsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuICsodGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpKSA8PSBpbnB1dE1zICYmIGlucHV0TXMgPD0gKyh0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpZmYgKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xuICAgICAgICB2YXIgdGhhdCA9IGNsb25lV2l0aE9mZnNldChpbnB1dCwgdGhpcyksXG4gICAgICAgICAgICB6b25lRGVsdGEgPSAodGhhdC51dGNPZmZzZXQoKSAtIHRoaXMudXRjT2Zmc2V0KCkpICogNmU0LFxuICAgICAgICAgICAgZGVsdGEsIG91dHB1dDtcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICd5ZWFyJyB8fCB1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7XG4gICAgICAgICAgICBpZiAodW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCAvIDM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgLyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgICAgICBvdXRwdXQgPSB1bml0cyA9PT0gJ3NlY29uZCcgPyBkZWx0YSAvIDFlMyA6IC8vIDEwMDBcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ21pbnV0ZScgPyBkZWx0YSAvIDZlNCA6IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgICAgIHVuaXRzID09PSAnaG91cicgPyBkZWx0YSAvIDM2ZTUgOiAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAgICAgICAgIHVuaXRzID09PSAnZGF5JyA/IChkZWx0YSAtIHpvbmVEZWx0YSkgLyA4NjRlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ3dlZWsnID8gKGRlbHRhIC0gem9uZURlbHRhKSAvIDYwNDhlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICAgICAgZGVsdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNGbG9vcihvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoRGlmZiAoYSwgYikge1xuICAgICAgICAvLyBkaWZmZXJlbmNlIGluIG1vbnRoc1xuICAgICAgICB2YXIgd2hvbGVNb250aERpZmYgPSAoKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIpICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICAgICAgYW5jaG9yMiwgYWRqdXN0O1xuXG4gICAgICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvciAtIGFuY2hvcjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgKyAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpO1xuICAgIH1cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5kZWZhdWx0Rm9ybWF0ID0gJ1lZWVktTU0tRERUSEg6bW06c3NaJztcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5sb2NhbGUoJ2VuJykuZm9ybWF0KCdkZGQgTU1NIEREIFlZWVkgSEg6bW06c3MgW0dNVF1aWicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudF9mb3JtYXRfX3RvSVNPU3RyaW5nICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLmNsb25lKCkudXRjKCk7XG4gICAgICAgIGlmICgwIDwgbS55ZWFyKCkgJiYgbS55ZWFyKCkgPD0gOTk5OSkge1xuICAgICAgICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykge1xuICAgICAgICAgICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyB+NTB4IGZhc3RlciwgdXNlIGl0IHdoZW4gd2UgY2FuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQgKGlucHV0U3RyaW5nKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSBmb3JtYXRNb21lbnQodGhpcywgaW5wdXRTdHJpbmcgfHwgdXRpbHNfaG9va3NfX2hvb2tzLmRlZmF1bHRGb3JtYXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb20gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oe3RvOiB0aGlzLCBmcm9tOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20obG9jYWxfX2NyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKHtmcm9tOiB0aGlzLCB0bzogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8obG9jYWxfX2NyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xvY2FsZURhdGEgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbmV3TG9jYWxlRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5sYW5nKCkgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlIG1vbWVudCgpLmxvY2FsZURhdGEoKSB0byBnZXQgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb24uIFVzZSBtb21lbnQoKS5sb2NhbGUoKSB0byBjaGFuZ2UgbGFuZ3VhZ2VzLicsXG4gICAgICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRGF0YSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRPZiAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgc3dpdGNoIGludGVudGlvbmFsbHkgb21pdHMgYnJlYWsga2V5d29yZHNcbiAgICAgICAgLy8gdG8gdXRpbGl6ZSBmYWxsaW5nIHRocm91Z2ggdGhlIGNhc2VzLlxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgdGhpcy5tb250aCgwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgIHRoaXMuZGF0ZSgxKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgdGhpcy5ob3VycygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICB0aGlzLm1pbnV0ZXMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICB0aGlzLnNlY29uZHMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICB0aGlzLm1pbGxpc2Vjb25kcygwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlZWtzIGFyZSBhIHNwZWNpYWwgY2FzZVxuICAgICAgICBpZiAodW5pdHMgPT09ICd3ZWVrJykge1xuICAgICAgICAgICAgdGhpcy53ZWVrZGF5KDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ2lzb1dlZWsnKSB7XG4gICAgICAgICAgICB0aGlzLmlzb1dlZWtkYXkoMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBxdWFydGVycyBhcmUgYWxzbyBzcGVjaWFsXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICB0aGlzLm1vbnRoKE1hdGguZmxvb3IodGhpcy5tb250aCgpIC8gMykgKiAzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZE9mICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2YodW5pdHMpLmFkZCgxLCAodW5pdHMgPT09ICdpc29XZWVrJyA/ICd3ZWVrJyA6IHVuaXRzKSkuc3VidHJhY3QoMSwgJ21zJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9fdHlwZV9fdmFsdWVPZiAoKSB7XG4gICAgICAgIHJldHVybiArdGhpcy5fZCAtICgodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuaXggKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigrdGhpcyAvIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvRGF0ZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQgPyBuZXcgRGF0ZSgrdGhpcykgOiB0aGlzLl9kO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQXJyYXkgKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbbS55ZWFyKCksIG0ubW9udGgoKSwgbS5kYXRlKCksIG0uaG91cigpLCBtLm1pbnV0ZSgpLCBtLnNlY29uZCgpLCBtLm1pbGxpc2Vjb25kKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvT2JqZWN0ICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcnM6IG0ueWVhcigpLFxuICAgICAgICAgICAgbW9udGhzOiBtLm1vbnRoKCksXG4gICAgICAgICAgICBkYXRlOiBtLmRhdGUoKSxcbiAgICAgICAgICAgIGhvdXJzOiBtLmhvdXJzKCksXG4gICAgICAgICAgICBtaW51dGVzOiBtLm1pbnV0ZXMoKSxcbiAgICAgICAgICAgIHNlY29uZHM6IG0uc2Vjb25kcygpLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBtLm1pbGxpc2Vjb25kcygpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50X3ZhbGlkX19pc1ZhbGlkICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkX19pc1ZhbGlkKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNpbmdGbGFncyAoKSB7XG4gICAgICAgIHJldHVybiBleHRlbmQoe30sIGdldFBhcnNpbmdGbGFncyh0aGlzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52YWxpZEF0ICgpIHtcbiAgICAgICAgcmV0dXJuIGdldFBhcnNpbmdGbGFncyh0aGlzKS5vdmVyZmxvdztcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ2dnJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnR0cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc29XZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1llYXJGb3JtYXRUb2tlbiAodG9rZW4sIGdldHRlcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbigwLCBbdG9rZW4sIHRva2VuLmxlbmd0aF0sIDAsIGdldHRlcik7XG4gICAgfVxuXG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZycsICAgICAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnZycsICAgICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0cnLCAgJ2lzb1dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHR0cnLCAnaXNvV2Vla1llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnd2Vla1llYXInLCAnZ2cnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtZZWFyJywgJ0dHJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdHJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZycsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdnZycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHRycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHRycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDIpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2cnLCAnR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIHdlZWtzSW5ZZWFyKHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKGxvY2FsX19jcmVhdGVMb2NhbChbeWVhciwgMTEsIDMxICsgZG93IC0gZG95XSksIGRvdywgZG95KS53ZWVrO1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFyIChpbnB1dCkge1xuICAgICAgICB2YXIgeWVhciA9IHdlZWtPZlllYXIodGhpcywgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LCB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3kpLnllYXI7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8geWVhciA6IHRoaXMuYWRkKChpbnB1dCAtIHllYXIpLCAneScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWtZZWFyIChpbnB1dCkge1xuICAgICAgICB2YXIgeWVhciA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkueWVhcjtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB5ZWFyIDogdGhpcy5hZGQoKGlucHV0IC0geWVhciksICd5Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJblllYXIgKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdlZWtzSW5ZZWFyICgpIHtcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdRJywgMCwgMCwgJ3F1YXJ0ZXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygncXVhcnRlcicsICdRJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcbiAgICBhZGRQYXJzZVRva2VuKCdRJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSAodG9JbnQoaW5wdXQpIC0gMSkgKiAzO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0UXVhcnRlciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMykgOiB0aGlzLm1vbnRoKChpbnB1dCAtIDEpICogMyArIHRoaXMubW9udGgoKSAlIDMpO1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdEJywgWydERCcsIDJdLCAnRG8nLCAnZGF0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXRlJywgJ0QnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0QnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdEbycsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBpc1N0cmljdCA/IGxvY2FsZS5fb3JkaW5hbFBhcnNlIDogbG9jYWxlLl9vcmRpbmFsUGFyc2VMZW5pZW50O1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XG4gICAgYWRkUGFyc2VUb2tlbignRG8nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQubWF0Y2gobWF0Y2gxdG8yKVswXSwgMTApO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzTWluKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5cyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdFJywgMCwgMCwgJ2lzb1dlZWtkYXknKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtkYXknLCAnZScpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdkJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdlJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdFJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZCcsICAgbWF0Y2hXb3JkKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGQnLCAgbWF0Y2hXb3JkKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGRkJywgbWF0Y2hXb3JkKTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlZWsuZCA9IHdlZWtkYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIHBhcnNlV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIExPQ0FMRVNcblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXMgPSAnU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXknLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXMgKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzW20uZGF5KCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNTaG9ydCAobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluID0gJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluIChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlICh3ZWVrZGF5TmFtZSkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gdGhpcy5fd2Vla2RheXNQYXJzZSB8fCBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGxvY2FsX19jcmVhdGVMb2NhbChbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICB2YXIgZGF5ID0gdGhpcy5faXNVVEMgPyB0aGlzLl9kLmdldFVUQ0RheSgpIDogdGhpcy5fZC5nZXREYXkoKTtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlucHV0ID0gcGFyc2VXZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoaW5wdXQgLSBkYXksICdkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWtkYXkgOiB0aGlzLmFkZChpbnB1dCAtIHdlZWtkYXksICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgICAgIC8vIGFzIGEgZ2V0dGVyLCByZXR1cm5zIDcgaW5zdGVhZCBvZiAwICgxLTcgcmFuZ2UgaW5zdGVhZCBvZiAwLTYpXG4gICAgICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB0aGlzLmRheSgpIHx8IDcgOiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IGlucHV0IDogaW5wdXQgLSA3KTtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSCcsIFsnSEgnLCAyXSwgMCwgJ2hvdXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbSAodG9rZW4sIGxvd2VyY2FzZSkge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1lcmlkaWVtKHRoaXMuaG91cnMoKSwgdGhpcy5taW51dGVzKCksIGxvd2VyY2FzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1lcmlkaWVtKCdhJywgdHJ1ZSk7XG4gICAgbWVyaWRpZW0oJ0EnLCBmYWxzZSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2hvdXInLCAnaCcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgZnVuY3Rpb24gbWF0Y2hNZXJpZGllbSAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLl9tZXJpZGllbVBhcnNlO1xuICAgIH1cblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignQScsICBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdIJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignaCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0hIJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2hoJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlSXNQTSAoaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IFF1aXJrcyBNb2RlICYgSUU3IFN0YW5kYXJkcyBNb2RlIGRvIG5vdCBhbGxvdyBhY2Nlc3Npbmcgc3RyaW5ncyBsaWtlIGFycmF5c1xuICAgICAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICAgICAgcmV0dXJuICgoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJyk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlID0gL1thcF1cXC4/bT9cXC4/L2k7XG4gICAgZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgIGlmIChob3VycyA+IDExKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwbScgOiAnUE0nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnYW0nIDogJ0FNJztcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgaGUgd2FudHMuIFNvIHRyeWluZyB0byBtYWludGFpbiB0aGUgc2FtZSBob3VyIChpblxuICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgIC8vIHRoaXMgcnVsZS5cbiAgICB2YXIgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaW51dGUnLCAnbScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignbScsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ21tJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWludXRlID0gbWFrZUdldFNldCgnTWludXRlcycsIGZhbHNlKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdzJywgWydzcycsIDJdLCAwLCAnc2Vjb25kJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3NlY29uZCcsICdzJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdzJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ3MnLCAnc3MnXSwgU0VDT05EKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMDApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTUycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTUycsIDNdLCAwLCAnbWlsbGlzZWNvbmQnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwMDtcbiAgICB9KTtcblxuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaWxsaXNlY29uZCcsICdtcycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUycsICAgIG1hdGNoMXRvMywgbWF0Y2gxKTtcbiAgICBhZGRSZWdleFRva2VuKCdTUycsICAgbWF0Y2gxdG8zLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTUycsICBtYXRjaDF0bzMsIG1hdGNoMyk7XG5cbiAgICB2YXIgdG9rZW47XG4gICAgZm9yICh0b2tlbiA9ICdTU1NTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRSZWdleFRva2VuKHRva2VuLCBtYXRjaFVuc2lnbmVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1zKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNSUxMSVNFQ09ORF0gPSB0b0ludCgoJzAuJyArIGlucHV0KSAqIDEwMDApO1xuICAgIH1cblxuICAgIGZvciAodG9rZW4gPSAnUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgcGFyc2VNcyk7XG4gICAgfVxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaWxsaXNlY29uZCA9IG1ha2VHZXRTZXQoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCd6JywgIDAsIDAsICd6b25lQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd6eicsIDAsIDAsICd6b25lTmFtZScpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZUFiYnIgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFpvbmVOYW1lICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ0Nvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lJyA6ICcnO1xuICAgIH1cblxuICAgIHZhciBtb21lbnRQcm90b3R5cGVfX3Byb3RvID0gTW9tZW50LnByb3RvdHlwZTtcblxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uYWRkICAgICAgICAgID0gYWRkX3N1YnRyYWN0X19hZGQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5jYWxlbmRhciAgICAgPSBtb21lbnRfY2FsZW5kYXJfX2NhbGVuZGFyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uY2xvbmUgICAgICAgID0gY2xvbmU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kaWZmICAgICAgICAgPSBkaWZmO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZW5kT2YgICAgICAgID0gZW5kT2Y7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5mb3JtYXQgICAgICAgPSBmb3JtYXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5mcm9tICAgICAgICAgPSBmcm9tO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZnJvbU5vdyAgICAgID0gZnJvbU5vdztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvICAgICAgICAgICA9IHRvO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9Ob3cgICAgICAgID0gdG9Ob3c7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5nZXQgICAgICAgICAgPSBnZXRTZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pbnZhbGlkQXQgICAgPSBpbnZhbGlkQXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0FmdGVyICAgICAgPSBpc0FmdGVyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNCZWZvcmUgICAgID0gaXNCZWZvcmU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0JldHdlZW4gICAgPSBpc0JldHdlZW47XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1NhbWUgICAgICAgPSBpc1NhbWU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1ZhbGlkICAgICAgPSBtb21lbnRfdmFsaWRfX2lzVmFsaWQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sYW5nICAgICAgICAgPSBsYW5nO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubG9jYWxlICAgICAgID0gbG9jYWxlO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubG9jYWxlRGF0YSAgID0gbG9jYWxlRGF0YTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1heCAgICAgICAgICA9IHByb3RvdHlwZU1heDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbiAgICAgICAgICA9IHByb3RvdHlwZU1pbjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnBhcnNpbmdGbGFncyA9IHBhcnNpbmdGbGFncztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnNldCAgICAgICAgICA9IGdldFNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnN0YXJ0T2YgICAgICA9IHN0YXJ0T2Y7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5zdWJ0cmFjdCAgICAgPSBhZGRfc3VidHJhY3RfX3N1YnRyYWN0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9BcnJheSAgICAgID0gdG9BcnJheTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvT2JqZWN0ICAgICA9IHRvT2JqZWN0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9EYXRlICAgICAgID0gdG9EYXRlO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9JU09TdHJpbmcgID0gbW9tZW50X2Zvcm1hdF9fdG9JU09TdHJpbmc7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b0pTT04gICAgICAgPSBtb21lbnRfZm9ybWF0X190b0lTT1N0cmluZztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvU3RyaW5nICAgICA9IHRvU3RyaW5nO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udW5peCAgICAgICAgID0gdW5peDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnZhbHVlT2YgICAgICA9IHRvX3R5cGVfX3ZhbHVlT2Y7XG5cbiAgICAvLyBZZWFyXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by55ZWFyICAgICAgID0gZ2V0U2V0WWVhcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzTGVhcFllYXIgPSBnZXRJc0xlYXBZZWFyO1xuXG4gICAgLy8gV2VlayBZZWFyXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrWWVhciAgICA9IGdldFNldFdlZWtZZWFyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2Vla1llYXIgPSBnZXRTZXRJU09XZWVrWWVhcjtcblxuICAgIC8vIFF1YXJ0ZXJcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnF1YXJ0ZXIgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnF1YXJ0ZXJzID0gZ2V0U2V0UXVhcnRlcjtcblxuICAgIC8vIE1vbnRoXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5tb250aCAgICAgICA9IGdldFNldE1vbnRoO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5c0luTW9udGggPSBnZXREYXlzSW5Nb250aDtcblxuICAgIC8vIFdlZWtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWsgICAgICAgICAgID0gbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrcyAgICAgICAgPSBnZXRTZXRXZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2VlayAgICAgICAgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtzICAgICA9IGdldFNldElTT1dlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrc0luWWVhciAgICA9IGdldFdlZWtzSW5ZZWFyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2Vla3NJblllYXIgPSBnZXRJU09XZWVrc0luWWVhcjtcblxuICAgIC8vIERheVxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF0ZSAgICAgICA9IGdldFNldERheU9mTW9udGg7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXkgICAgICAgID0gbW9tZW50UHJvdG90eXBlX19wcm90by5kYXlzICAgICAgICAgICAgID0gZ2V0U2V0RGF5T2ZXZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla2RheSAgICA9IGdldFNldExvY2FsZURheU9mV2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtkYXkgPSBnZXRTZXRJU09EYXlPZldlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXlPZlllYXIgID0gZ2V0U2V0RGF5T2ZZZWFyO1xuXG4gICAgLy8gSG91clxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaG91ciA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaG91cnMgPSBnZXRTZXRIb3VyO1xuXG4gICAgLy8gTWludXRlXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5taW51dGUgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XG5cbiAgICAvLyBTZWNvbmRcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnNlY29uZCA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc2Vjb25kcyA9IGdldFNldFNlY29uZDtcblxuICAgIC8vIE1pbGxpc2Vjb25kXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5taWxsaXNlY29uZCA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWlsbGlzZWNvbmRzID0gZ2V0U2V0TWlsbGlzZWNvbmQ7XG5cbiAgICAvLyBPZmZzZXRcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnV0Y09mZnNldCAgICAgICAgICAgID0gZ2V0U2V0T2Zmc2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udXRjICAgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1VUQztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmxvY2FsICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9Mb2NhbDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnBhcnNlWm9uZSAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5oYXNBbGlnbmVkSG91ck9mZnNldCA9IGhhc0FsaWduZWRIb3VyT2Zmc2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNEU1QgICAgICAgICAgICAgICAgPSBpc0RheWxpZ2h0U2F2aW5nVGltZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzRFNUU2hpZnRlZCAgICAgICAgID0gaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNMb2NhbCAgICAgICAgICAgICAgPSBpc0xvY2FsO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNVdGNPZmZzZXQgICAgICAgICAgPSBpc1V0Y09mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVXRjICAgICAgICAgICAgICAgID0gaXNVdGM7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1VUQyAgICAgICAgICAgICAgICA9IGlzVXRjO1xuXG4gICAgLy8gVGltZXpvbmVcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnpvbmVBYmJyID0gZ2V0Wm9uZUFiYnI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by56b25lTmFtZSA9IGdldFpvbmVOYW1lO1xuXG4gICAgLy8gRGVwcmVjYXRpb25zXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXRlcyAgPSBkZXByZWNhdGUoJ2RhdGVzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBkYXRlIGluc3RlYWQuJywgZ2V0U2V0RGF5T2ZNb250aCk7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5tb250aHMgPSBkZXByZWNhdGUoJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsIGdldFNldE1vbnRoKTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnllYXJzICA9IGRlcHJlY2F0ZSgneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsIGdldFNldFllYXIpO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uem9uZSAgID0gZGVwcmVjYXRlKCdtb21lbnQoKS56b25lIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQoKS51dGNPZmZzZXQgaW5zdGVhZC4gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE3NzknLCBnZXRTZXRab25lKTtcblxuICAgIHZhciBtb21lbnRQcm90b3R5cGUgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvO1xuXG4gICAgZnVuY3Rpb24gbW9tZW50X19jcmVhdGVVbml4IChpbnB1dCkge1xuICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50X19jcmVhdGVJblpvbmUgKCkge1xuICAgICAgICByZXR1cm4gbG9jYWxfX2NyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRDYWxlbmRhciA9IHtcbiAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbYXRdIExUJyxcbiAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVfY2FsZW5kYXJfX2NhbGVuZGFyIChrZXksIG1vbSwgbm93KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldO1xuICAgICAgICByZXR1cm4gdHlwZW9mIG91dHB1dCA9PT0gJ2Z1bmN0aW9uJyA/IG91dHB1dC5jYWxsKG1vbSwgbm93KSA6IG91dHB1dDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgICAgICBMVFMgIDogJ2g6bW06c3MgQScsXG4gICAgICAgIExUICAgOiAnaDptbSBBJyxcbiAgICAgICAgTCAgICA6ICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgTEwgICA6ICdNTU1NIEQsIFlZWVknLFxuICAgICAgICBMTEwgIDogJ01NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgICAgICBMTExMIDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvbmdEYXRlRm9ybWF0IChrZXkpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlci5yZXBsYWNlKC9NTU1NfE1NfEREfGRkZGQvZywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG4gICAgZnVuY3Rpb24gaW52YWxpZERhdGUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJztcbiAgICB2YXIgZGVmYXVsdE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICBmdW5jdGlvbiBvcmRpbmFsIChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZVBhcnNlUG9zdEZvcm1hdCAoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRSZWxhdGl2ZVRpbWUgPSB7XG4gICAgICAgIGZ1dHVyZSA6ICdpbiAlcycsXG4gICAgICAgIHBhc3QgICA6ICclcyBhZ28nLFxuICAgICAgICBzICA6ICdhIGZldyBzZWNvbmRzJyxcbiAgICAgICAgbSAgOiAnYSBtaW51dGUnLFxuICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcbiAgICAgICAgaCAgOiAnYW4gaG91cicsXG4gICAgICAgIGhoIDogJyVkIGhvdXJzJyxcbiAgICAgICAgZCAgOiAnYSBkYXknLFxuICAgICAgICBkZCA6ICclZCBkYXlzJyxcbiAgICAgICAgTSAgOiAnYSBtb250aCcsXG4gICAgICAgIE1NIDogJyVkIG1vbnRocycsXG4gICAgICAgIHkgIDogJ2EgeWVhcicsXG4gICAgICAgIHl5IDogJyVkIHllYXJzJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZV9fcmVsYXRpdmVUaW1lIChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX3JlbGF0aXZlVGltZVtzdHJpbmddO1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBvdXRwdXQgPT09ICdmdW5jdGlvbicpID9cbiAgICAgICAgICAgIG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIDpcbiAgICAgICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhc3RGdXR1cmUgKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGZvcm1hdCA9PT0gJ2Z1bmN0aW9uJyA/IGZvcm1hdChvdXRwdXQpIDogZm9ybWF0LnJlcGxhY2UoLyVzL2ksIG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlX3NldF9fc2V0IChjb25maWcpIHtcbiAgICAgICAgdmFyIHByb3AsIGk7XG4gICAgICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXG4gICAgICAgIC8vIG51bWJlciArIChwb3NzaWJseSkgc3R1ZmYgY29taW5nIGZyb20gX29yZGluYWxQYXJzZUxlbmllbnQuXG4gICAgICAgIHRoaXMuX29yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKHRoaXMuX29yZGluYWxQYXJzZS5zb3VyY2UgKyAnfCcgKyAoL1xcZHsxLDJ9Lykuc291cmNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlX19wcm90byA9IExvY2FsZS5wcm90b3R5cGU7XG5cbiAgICBwcm90b3R5cGVfX3Byb3RvLl9jYWxlbmRhciAgICAgICA9IGRlZmF1bHRDYWxlbmRhcjtcbiAgICBwcm90b3R5cGVfX3Byb3RvLmNhbGVuZGFyICAgICAgICA9IGxvY2FsZV9jYWxlbmRhcl9fY2FsZW5kYXI7XG4gICAgcHJvdG90eXBlX19wcm90by5fbG9uZ0RhdGVGb3JtYXQgPSBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQ7XG4gICAgcHJvdG90eXBlX19wcm90by5sb25nRGF0ZUZvcm1hdCAgPSBsb25nRGF0ZUZvcm1hdDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9pbnZhbGlkRGF0ZSAgICA9IGRlZmF1bHRJbnZhbGlkRGF0ZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLmludmFsaWREYXRlICAgICA9IGludmFsaWREYXRlO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX29yZGluYWwgICAgICAgID0gZGVmYXVsdE9yZGluYWw7XG4gICAgcHJvdG90eXBlX19wcm90by5vcmRpbmFsICAgICAgICAgPSBvcmRpbmFsO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX29yZGluYWxQYXJzZSAgID0gZGVmYXVsdE9yZGluYWxQYXJzZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnByZXBhcnNlICAgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnBvc3Rmb3JtYXQgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9yZWxhdGl2ZVRpbWUgICA9IGRlZmF1bHRSZWxhdGl2ZVRpbWU7XG4gICAgcHJvdG90eXBlX19wcm90by5yZWxhdGl2ZVRpbWUgICAgPSByZWxhdGl2ZV9fcmVsYXRpdmVUaW1lO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ucGFzdEZ1dHVyZSAgICAgID0gcGFzdEZ1dHVyZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnNldCAgICAgICAgICAgICA9IGxvY2FsZV9zZXRfX3NldDtcblxuICAgIC8vIE1vbnRoXG4gICAgcHJvdG90eXBlX19wcm90by5tb250aHMgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX21vbnRocyAgICAgID0gZGVmYXVsdExvY2FsZU1vbnRocztcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRoc1Nob3J0ICA9ICAgICAgICBsb2NhbGVNb250aHNTaG9ydDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9tb250aHNTaG9ydCA9IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRoc1BhcnNlICA9ICAgICAgICBsb2NhbGVNb250aHNQYXJzZTtcblxuICAgIC8vIFdlZWtcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWsgPSBsb2NhbGVXZWVrO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX3dlZWsgPSBkZWZhdWx0TG9jYWxlV2VlaztcbiAgICBwcm90b3R5cGVfX3Byb3RvLmZpcnN0RGF5T2ZZZWFyID0gbG9jYWxlRmlyc3REYXlPZlllYXI7XG4gICAgcHJvdG90eXBlX19wcm90by5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xuXG4gICAgLy8gRGF5IG9mIFdlZWtcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzICAgICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX3dlZWtkYXlzICAgICAgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXM7XG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c01pbiAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c01pbjtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrZGF5c01pbiAgID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNTaG9ydCAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNTaG9ydDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrZGF5c1Nob3J0ID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQ7XG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c1BhcnNlICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1BhcnNlO1xuXG4gICAgLy8gSG91cnNcbiAgICBwcm90b3R5cGVfX3Byb3RvLmlzUE0gPSBsb2NhbGVJc1BNO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX21lcmlkaWVtUGFyc2UgPSBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1lcmlkaWVtID0gbG9jYWxlTWVyaWRpZW07XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fZ2V0IChmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKCk7XG4gICAgICAgIHZhciB1dGMgPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoKS5zZXQoc2V0dGVyLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBsb2NhbGVbZmllbGRdKHV0YywgZm9ybWF0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0IChmb3JtYXQsIGluZGV4LCBmaWVsZCwgY291bnQsIHNldHRlcikge1xuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGlzdHNfX2dldChmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBsaXN0c19fZ2V0KGZvcm1hdCwgaSwgZmllbGQsIHNldHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdE1vbnRocyAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdChmb3JtYXQsIGluZGV4LCAnbW9udGhzJywgMTIsICdtb250aCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0TW9udGhzU2hvcnQgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QoZm9ybWF0LCBpbmRleCwgJ21vbnRoc1Nob3J0JywgMTIsICdtb250aCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0V2Vla2RheXMgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QoZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJywgNywgJ2RheScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0V2Vla2RheXNTaG9ydCAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdChmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcsIDcsICdkYXknKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdFdlZWtkYXlzTWluIChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0KGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c01pbicsIDcsICdkYXknKTtcbiAgICB9XG5cbiAgICBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKCdlbicsIHtcbiAgICAgICAgb3JkaW5hbFBhcnNlOiAvXFxkezEsMn0odGh8c3R8bmR8cmQpLyxcbiAgICAgICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRvSW50KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcbiAgICAgICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcbiAgICB1dGlsc19ob29rc19faG9va3MubGFuZyA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmcgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGUgaW5zdGVhZC4nLCBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKTtcbiAgICB1dGlsc19ob29rc19faG9va3MubGFuZ0RhdGEgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nRGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZURhdGEgaW5zdGVhZC4nLCBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKTtcblxuICAgIHZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hYnNfX2FicyAoKSB7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgICA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWF0aEFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xuICAgICAgICB0aGlzLl9kYXlzICAgICAgICAgPSBtYXRoQWJzKHRoaXMuX2RheXMpO1xuICAgICAgICB0aGlzLl9tb250aHMgICAgICAgPSBtYXRoQWJzKHRoaXMuX21vbnRocyk7XG5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgID0gbWF0aEFicyhkYXRhLm1pbGxpc2Vjb25kcyk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgICA9IG1hdGhBYnMoZGF0YS5zZWNvbmRzKTtcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgID0gbWF0aEFicyhkYXRhLm1pbnV0ZXMpO1xuICAgICAgICBkYXRhLmhvdXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEuaG91cnMpO1xuICAgICAgICBkYXRhLm1vbnRocyAgICAgICAgPSBtYXRoQWJzKGRhdGEubW9udGhzKTtcbiAgICAgICAgZGF0YS55ZWFycyAgICAgICAgID0gbWF0aEFicyhkYXRhLnllYXJzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0IChkdXJhdGlvbiwgaW5wdXQsIHZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbihpbnB1dCwgdmFsdWUpO1xuXG4gICAgICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICAgICAgZHVyYXRpb24uX2RheXMgICAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fZGF5cztcbiAgICAgICAgZHVyYXRpb24uX21vbnRocyAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fbW9udGhzO1xuXG4gICAgICAgIHJldHVybiBkdXJhdGlvbi5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgYWRkKDEsICdzJykgb3IgYWRkKGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkIChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgaW5wdXQsIHZhbHVlLCAxKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fc3VidHJhY3QgKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNDZWlsIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWJibGUgKCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuICAgICAgICB2YXIgZGF5cyAgICAgICAgID0gdGhpcy5fZGF5cztcbiAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IHRoaXMuX21vbnRocztcbiAgICAgICAgdmFyIGRhdGEgICAgICAgICA9IHRoaXMuX2RhdGE7XG4gICAgICAgIHZhciBzZWNvbmRzLCBtaW51dGVzLCBob3VycywgeWVhcnMsIG1vbnRoc0Zyb21EYXlzO1xuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcbiAgICAgICAgLy8gY2hlY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMTY2XG4gICAgICAgIGlmICghKChtaWxsaXNlY29uZHMgPj0gMCAmJiBkYXlzID49IDAgJiYgbW9udGhzID49IDApIHx8XG4gICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMCkpKSB7XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XG4gICAgICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgICAgIG1vbnRocyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXG4gICAgICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgICAgIHNlY29uZHMgICAgICAgICAgID0gYWJzRmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgPSBtaW51dGVzICUgNjA7XG5cbiAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBkYXRhLmhvdXJzICAgICAgICA9IGhvdXJzICUgMjQ7XG5cbiAgICAgICAgZGF5cyArPSBhYnNGbG9vcihob3VycyAvIDI0KTtcblxuICAgICAgICAvLyBjb252ZXJ0IGRheXMgdG8gbW9udGhzXG4gICAgICAgIG1vbnRoc0Zyb21EYXlzID0gYWJzRmxvb3IoZGF5c1RvTW9udGhzKGRheXMpKTtcbiAgICAgICAgbW9udGhzICs9IG1vbnRoc0Zyb21EYXlzO1xuICAgICAgICBkYXlzIC09IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRoc0Zyb21EYXlzKSk7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG4gICAgICAgIGRhdGEuZGF5cyAgID0gZGF5cztcbiAgICAgICAgZGF0YS5tb250aHMgPSBtb250aHM7XG4gICAgICAgIGRhdGEueWVhcnMgID0geWVhcnM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c1RvTW9udGhzIChkYXlzKSB7XG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTIgbW9udGhzID09PSA0ODAwXG4gICAgICAgIHJldHVybiBkYXlzICogNDgwMCAvIDE0NjA5NztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aHNUb0RheXMgKG1vbnRocykge1xuICAgICAgICAvLyB0aGUgcmV2ZXJzZSBvZiBkYXlzVG9Nb250aHNcbiAgICAgICAgcmV0dXJuIG1vbnRocyAqIDE0NjA5NyAvIDQ4MDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXMgKHVuaXRzKSB7XG4gICAgICAgIHZhciBkYXlzO1xuICAgICAgICB2YXIgbW9udGhzO1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICBkYXlzICAgPSB0aGlzLl9kYXlzICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgICAgIHJldHVybiB1bml0cyA9PT0gJ21vbnRoJyA/IG1vbnRocyA6IG1vbnRocyAvIDEyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaGFuZGxlIG1pbGxpc2Vjb25kcyBzZXBhcmF0ZWx5IGJlY2F1c2Ugb2YgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGlzc3VlICMxODY3KVxuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBNYXRoLnJvdW5kKG1vbnRoc1RvRGF5cyh0aGlzLl9tb250aHMpKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd3ZWVrJyAgIDogcmV0dXJuIGRheXMgLyA3ICAgICArIG1pbGxpc2Vjb25kcyAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdkYXknICAgIDogcmV0dXJuIGRheXMgICAgICAgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hvdXInICAgOiByZXR1cm4gZGF5cyAqIDI0ICAgICsgbWlsbGlzZWNvbmRzIC8gMzZlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdtaW51dGUnIDogcmV0dXJuIGRheXMgKiAxNDQwICArIG1pbGxpc2Vjb25kcyAvIDZlNDtcbiAgICAgICAgICAgICAgICBjYXNlICdzZWNvbmQnIDogcmV0dXJuIGRheXMgKiA4NjQwMCArIG1pbGxpc2Vjb25kcyAvIDEwMDA7XG4gICAgICAgICAgICAgICAgLy8gTWF0aC5mbG9vciBwcmV2ZW50cyBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyBoZXJlXG4gICAgICAgICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOiByZXR1cm4gTWF0aC5mbG9vcihkYXlzICogODY0ZTUpICsgbWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignVW5rbm93biB1bml0ICcgKyB1bml0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgdGhpcy5hcygnbXMnKT9cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hc19fdmFsdWVPZiAoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgICAgICh0aGlzLl9tb250aHMgJSAxMikgKiAyNTkyZTYgK1xuICAgICAgICAgICAgdG9JbnQodGhpcy5fbW9udGhzIC8gMTIpICogMzE1MzZlNlxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VBcyAoYWxpYXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzKGFsaWFzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgYXNNaWxsaXNlY29uZHMgPSBtYWtlQXMoJ21zJyk7XG4gICAgdmFyIGFzU2Vjb25kcyAgICAgID0gbWFrZUFzKCdzJyk7XG4gICAgdmFyIGFzTWludXRlcyAgICAgID0gbWFrZUFzKCdtJyk7XG4gICAgdmFyIGFzSG91cnMgICAgICAgID0gbWFrZUFzKCdoJyk7XG4gICAgdmFyIGFzRGF5cyAgICAgICAgID0gbWFrZUFzKCdkJyk7XG4gICAgdmFyIGFzV2Vla3MgICAgICAgID0gbWFrZUFzKCd3Jyk7XG4gICAgdmFyIGFzTW9udGhzICAgICAgID0gbWFrZUFzKCdNJyk7XG4gICAgdmFyIGFzWWVhcnMgICAgICAgID0gbWFrZUFzKCd5Jyk7XG5cbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9nZXRfX2dldCAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIHJldHVybiB0aGlzW3VuaXRzICsgJ3MnXSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXR0ZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFbbmFtZV07XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ21pbGxpc2Vjb25kcycpO1xuICAgIHZhciBzZWNvbmRzICAgICAgPSBtYWtlR2V0dGVyKCdzZWNvbmRzJyk7XG4gICAgdmFyIG1pbnV0ZXMgICAgICA9IG1ha2VHZXR0ZXIoJ21pbnV0ZXMnKTtcbiAgICB2YXIgaG91cnMgICAgICAgID0gbWFrZUdldHRlcignaG91cnMnKTtcbiAgICB2YXIgZGF5cyAgICAgICAgID0gbWFrZUdldHRlcignZGF5cycpO1xuICAgIHZhciBtb250aHMgICAgICAgPSBtYWtlR2V0dGVyKCdtb250aHMnKTtcbiAgICB2YXIgeWVhcnMgICAgICAgID0gbWFrZUdldHRlcigneWVhcnMnKTtcblxuICAgIGZ1bmN0aW9uIHdlZWtzICgpIHtcbiAgICAgICAgcmV0dXJuIGFic0Zsb29yKHRoaXMuZGF5cygpIC8gNyk7XG4gICAgfVxuXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbiAgICB2YXIgdGhyZXNob2xkcyA9IHtcbiAgICAgICAgczogNDUsICAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxuICAgICAgICBtOiA0NSwgIC8vIG1pbnV0ZXMgdG8gaG91clxuICAgICAgICBoOiAyMiwgIC8vIGhvdXJzIHRvIGRheVxuICAgICAgICBkOiAyNiwgIC8vIGRheXMgdG8gbW9udGhcbiAgICAgICAgTTogMTEgICAvLyBtb250aHMgdG8geWVhclxuICAgIH07XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vbWVudC5mbi5mcm9tLCBtb21lbnQuZm4uZnJvbU5vdywgYW5kIG1vbWVudC5kdXJhdGlvbi5mbi5odW1hbml6ZVxuICAgIGZ1bmN0aW9uIHN1YnN0aXR1dGVUaW1lQWdvKHN0cmluZywgbnVtYmVyLCB3aXRob3V0U3VmZml4LCBpc0Z1dHVyZSwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2h1bWFuaXplX19yZWxhdGl2ZVRpbWUgKHBvc05lZ0R1cmF0aW9uLCB3aXRob3V0U3VmZml4LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbihwb3NOZWdEdXJhdGlvbikuYWJzKCk7XG4gICAgICAgIHZhciBzZWNvbmRzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpO1xuICAgICAgICB2YXIgbWludXRlcyAgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKTtcbiAgICAgICAgdmFyIGhvdXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2gnKSk7XG4gICAgICAgIHZhciBkYXlzICAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdkJykpO1xuICAgICAgICB2YXIgbW9udGhzICAgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKTtcbiAgICAgICAgdmFyIHllYXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ3knKSk7XG5cbiAgICAgICAgdmFyIGEgPSBzZWNvbmRzIDwgdGhyZXNob2xkcy5zICYmIFsncycsIHNlY29uZHNdICB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPT09IDEgICAgICAgICAgJiYgWydtJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgbWludXRlcyA8IHRocmVzaG9sZHMubSAmJiBbJ21tJywgbWludXRlc10gfHxcbiAgICAgICAgICAgICAgICBob3VycyAgID09PSAxICAgICAgICAgICYmIFsnaCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPCB0aHJlc2hvbGRzLmggJiYgWydoaCcsIGhvdXJzXSAgIHx8XG4gICAgICAgICAgICAgICAgZGF5cyAgICA9PT0gMSAgICAgICAgICAmJiBbJ2QnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBkYXlzICAgIDwgdGhyZXNob2xkcy5kICYmIFsnZGQnLCBkYXlzXSAgICB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyAgPT09IDEgICAgICAgICAgJiYgWydNJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgbW9udGhzICA8IHRocmVzaG9sZHMuTSAmJiBbJ01NJywgbW9udGhzXSAgfHxcbiAgICAgICAgICAgICAgICB5ZWFycyAgID09PSAxICAgICAgICAgICYmIFsneSddICAgICAgICAgICB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgICAgIGFbMl0gPSB3aXRob3V0U3VmZml4O1xuICAgICAgICBhWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcbiAgICAgICAgYVs0XSA9IGxvY2FsZTtcbiAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGVUaW1lQWdvLmFwcGx5KG51bGwsIGEpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2h1bWFuaXplX19nZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQgKHRocmVzaG9sZCwgbGltaXQpIHtcbiAgICAgICAgaWYgKHRocmVzaG9sZHNbdGhyZXNob2xkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aHJlc2hvbGRzW3RocmVzaG9sZF07XG4gICAgICAgIH1cbiAgICAgICAgdGhyZXNob2xkc1t0aHJlc2hvbGRdID0gbGltaXQ7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1bWFuaXplICh3aXRoU3VmZml4KSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IGR1cmF0aW9uX2h1bWFuaXplX19yZWxhdGl2ZVRpbWUodGhpcywgIXdpdGhTdWZmaXgsIGxvY2FsZSk7XG5cbiAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGlzb19zdHJpbmdfX2FicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gaXNvX3N0cmluZ19fdG9JU09TdHJpbmcoKSB7XG4gICAgICAgIC8vIGZvciBJU08gc3RyaW5ncyB3ZSBkbyBub3QgdXNlIHRoZSBub3JtYWwgYnViYmxpbmcgcnVsZXM6XG4gICAgICAgIC8vICAqIG1pbGxpc2Vjb25kcyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgaG91cnNcbiAgICAgICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxuICAgICAgICAvLyAgKiBtb250aHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIHllYXJzXG4gICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB0aGVyZSBpcyBubyBjb250ZXh0LWZyZWUgY29udmVyc2lvbiBiZXR3ZWVuIGhvdXJzIGFuZCBkYXlzXG4gICAgICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxuICAgICAgICAvLyBhbmQgYWxzbyBub3QgYmV0d2VlbiBkYXlzIGFuZCBtb250aHMgKDI4LTMxIGRheXMgcGVyIG1vbnRoKVxuICAgICAgICB2YXIgc2Vjb25kcyA9IGlzb19zdHJpbmdfX2Ficyh0aGlzLl9taWxsaXNlY29uZHMpIC8gMTAwMDtcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IGlzb19zdHJpbmdfX2Ficyh0aGlzLl9kYXlzKTtcbiAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IGlzb19zdHJpbmdfX2Ficyh0aGlzLl9tb250aHMpO1xuICAgICAgICB2YXIgbWludXRlcywgaG91cnMsIHllYXJzO1xuXG4gICAgICAgIC8vIDM2MDAgc2Vjb25kcyAtPiA2MCBtaW51dGVzIC0+IDEgaG91clxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgc2Vjb25kcyAlPSA2MDtcbiAgICAgICAgbWludXRlcyAlPSA2MDtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzICA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG5cbiAgICAgICAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2RvcmRpbGxlL21vbWVudC1pc29kdXJhdGlvbi9ibG9iL21hc3Rlci9tb21lbnQuaXNvZHVyYXRpb24uanNcbiAgICAgICAgdmFyIFkgPSB5ZWFycztcbiAgICAgICAgdmFyIE0gPSBtb250aHM7XG4gICAgICAgIHZhciBEID0gZGF5cztcbiAgICAgICAgdmFyIGggPSBob3VycztcbiAgICAgICAgdmFyIG0gPSBtaW51dGVzO1xuICAgICAgICB2YXIgcyA9IHNlY29uZHM7XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMuYXNTZWNvbmRzKCk7XG5cbiAgICAgICAgaWYgKCF0b3RhbCkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxuICAgICAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxuICAgICAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICh0b3RhbCA8IDAgPyAnLScgOiAnJykgK1xuICAgICAgICAgICAgJ1AnICtcbiAgICAgICAgICAgIChZID8gWSArICdZJyA6ICcnKSArXG4gICAgICAgICAgICAoTSA/IE0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKEQgPyBEICsgJ0QnIDogJycpICtcbiAgICAgICAgICAgICgoaCB8fCBtIHx8IHMpID8gJ1QnIDogJycpICtcbiAgICAgICAgICAgIChoID8gaCArICdIJyA6ICcnKSArXG4gICAgICAgICAgICAobSA/IG0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKHMgPyBzICsgJ1MnIDogJycpO1xuICAgIH1cblxuICAgIHZhciBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hYnMgICAgICAgICAgICA9IGR1cmF0aW9uX2Fic19fYWJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYWRkICAgICAgICAgICAgPSBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZDtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnN1YnRyYWN0ICAgICAgID0gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19zdWJ0cmFjdDtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzICAgICAgICAgICAgID0gYXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNTZWNvbmRzICAgICAgPSBhc1NlY29uZHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc01pbnV0ZXMgICAgICA9IGFzTWludXRlcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzSG91cnMgICAgICAgID0gYXNIb3VycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzRGF5cyAgICAgICAgID0gYXNEYXlzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNXZWVrcyAgICAgICAgPSBhc1dlZWtzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNNb250aHMgICAgICAgPSBhc01vbnRocztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzWWVhcnMgICAgICAgID0gYXNZZWFycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnZhbHVlT2YgICAgICAgID0gZHVyYXRpb25fYXNfX3ZhbHVlT2Y7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5fYnViYmxlICAgICAgICA9IGJ1YmJsZTtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmdldCAgICAgICAgICAgID0gZHVyYXRpb25fZ2V0X19nZXQ7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5taWxsaXNlY29uZHMgICA9IG1pbGxpc2Vjb25kcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnNlY29uZHMgICAgICAgID0gc2Vjb25kcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLm1pbnV0ZXMgICAgICAgID0gbWludXRlcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmhvdXJzICAgICAgICAgID0gaG91cnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5kYXlzICAgICAgICAgICA9IGRheXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by53ZWVrcyAgICAgICAgICA9IHdlZWtzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubW9udGhzICAgICAgICAgPSBtb250aHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by55ZWFycyAgICAgICAgICA9IHllYXJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uaHVtYW5pemUgICAgICAgPSBodW1hbml6ZTtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnRvSVNPU3RyaW5nICAgID0gaXNvX3N0cmluZ19fdG9JU09TdHJpbmc7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b1N0cmluZyAgICAgICA9IGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9KU09OICAgICAgICAgPSBpc29fc3RyaW5nX190b0lTT1N0cmluZztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmxvY2FsZSAgICAgICAgID0gbG9jYWxlO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubG9jYWxlRGF0YSAgICAgPSBsb2NhbGVEYXRhO1xuXG4gICAgLy8gRGVwcmVjYXRpb25zXG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b0lzb1N0cmluZyA9IGRlcHJlY2F0ZSgndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAobm90aWNlIHRoZSBjYXBpdGFscyknLCBpc29fc3RyaW5nX190b0lTT1N0cmluZyk7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5sYW5nID0gbGFuZztcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgIGFkZEZvcm1hdFRva2VuKCdYJywgMCwgMCwgJ3VuaXgnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneCcsIDAsIDAsICd2YWx1ZU9mJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd4JywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1gnLCBtYXRjaFRpbWVzdGFtcCk7XG4gICAgYWRkUGFyc2VUb2tlbignWCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KGlucHV0LCAxMCkgKiAxMDAwKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCd4JywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy52ZXJzaW9uID0gJzIuMTAuNic7XG5cbiAgICBzZXRIb29rQ2FsbGJhY2sobG9jYWxfX2NyZWF0ZUxvY2FsKTtcblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5mbiAgICAgICAgICAgICAgICAgICAgPSBtb21lbnRQcm90b3R5cGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm1pbiAgICAgICAgICAgICAgICAgICA9IG1pbjtcbiAgICB1dGlsc19ob29rc19faG9va3MubWF4ICAgICAgICAgICAgICAgICAgID0gbWF4O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy51dGMgICAgICAgICAgICAgICAgICAgPSBjcmVhdGVfdXRjX19jcmVhdGVVVEM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnVuaXggICAgICAgICAgICAgICAgICA9IG1vbWVudF9fY3JlYXRlVW5peDtcbiAgICB1dGlsc19ob29rc19faG9va3MubW9udGhzICAgICAgICAgICAgICAgID0gbGlzdHNfX2xpc3RNb250aHM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmlzRGF0ZSAgICAgICAgICAgICAgICA9IGlzRGF0ZTtcbiAgICB1dGlsc19ob29rc19faG9va3MubG9jYWxlICAgICAgICAgICAgICAgID0gbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZTtcbiAgICB1dGlsc19ob29rc19faG9va3MuaW52YWxpZCAgICAgICAgICAgICAgID0gdmFsaWRfX2NyZWF0ZUludmFsaWQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmR1cmF0aW9uICAgICAgICAgICAgICA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb247XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmlzTW9tZW50ICAgICAgICAgICAgICA9IGlzTW9tZW50O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy53ZWVrZGF5cyAgICAgICAgICAgICAgPSBsaXN0c19fbGlzdFdlZWtkYXlzO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVpvbmUgICAgICAgICAgICAgPSBtb21lbnRfX2NyZWF0ZUluWm9uZTtcbiAgICB1dGlsc19ob29rc19faG9va3MubG9jYWxlRGF0YSAgICAgICAgICAgID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZTtcbiAgICB1dGlsc19ob29rc19faG9va3MuaXNEdXJhdGlvbiAgICAgICAgICAgID0gaXNEdXJhdGlvbjtcbiAgICB1dGlsc19ob29rc19faG9va3MubW9udGhzU2hvcnQgICAgICAgICAgID0gbGlzdHNfX2xpc3RNb250aHNTaG9ydDtcbiAgICB1dGlsc19ob29rc19faG9va3Mud2Vla2RheXNNaW4gICAgICAgICAgID0gbGlzdHNfX2xpc3RXZWVrZGF5c01pbjtcbiAgICB1dGlsc19ob29rc19faG9va3MuZGVmaW5lTG9jYWxlICAgICAgICAgID0gZGVmaW5lTG9jYWxlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy53ZWVrZGF5c1Nob3J0ICAgICAgICAgPSBsaXN0c19fbGlzdFdlZWtkYXlzU2hvcnQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm5vcm1hbGl6ZVVuaXRzICAgICAgICA9IG5vcm1hbGl6ZVVuaXRzO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQgPSBkdXJhdGlvbl9odW1hbml6ZV9fZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkO1xuXG4gICAgdmFyIF9tb21lbnQgPSB1dGlsc19ob29rc19faG9va3M7XG5cbiAgICByZXR1cm4gX21vbWVudDtcblxufSkpOyIsIi8qIVxuICogbnVtZXJhbC5qc1xuICogdmVyc2lvbiA6IDEuNS4zXG4gKiBhdXRob3IgOiBBZGFtIERyYXBlclxuICogbGljZW5zZSA6IE1JVFxuICogaHR0cDovL2FkYW13ZHJhcGVyLmdpdGh1Yi5jb20vTnVtZXJhbC1qcy9cbiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBDb25zdGFudHNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICB2YXIgbnVtZXJhbCxcbiAgICAgICAgVkVSU0lPTiA9ICcxLjUuMycsXG4gICAgICAgIC8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxhbmd1YWdlIGNvbmZpZyBmaWxlc1xuICAgICAgICBsYW5ndWFnZXMgPSB7fSxcbiAgICAgICAgY3VycmVudExhbmd1YWdlID0gJ2VuJyxcbiAgICAgICAgemVyb0Zvcm1hdCA9IG51bGwsXG4gICAgICAgIGRlZmF1bHRGb3JtYXQgPSAnMCwwJyxcbiAgICAgICAgLy8gY2hlY2sgZm9yIG5vZGVKU1xuICAgICAgICBoYXNNb2R1bGUgPSAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpO1xuXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIENvbnN0cnVjdG9yc1xuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgLy8gTnVtZXJhbCBwcm90b3R5cGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gTnVtZXJhbCAobnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gbnVtYmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGF0aW9uIG9mIHRvRml4ZWQoKSB0aGF0IHRyZWF0cyBmbG9hdHMgbW9yZSBsaWtlIGRlY2ltYWxzXG4gICAgICpcbiAgICAgKiBGaXhlcyBiaW5hcnkgcm91bmRpbmcgaXNzdWVzIChlZy4gKDAuNjE1KS50b0ZpeGVkKDIpID09PSAnMC42MScpIHRoYXQgcHJlc2VudFxuICAgICAqIHByb2JsZW1zIGZvciBhY2NvdW50aW5nLSBhbmQgZmluYW5jZS1yZWxhdGVkIHNvZnR3YXJlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvRml4ZWQgKHZhbHVlLCBwcmVjaXNpb24sIHJvdW5kaW5nRnVuY3Rpb24sIG9wdGlvbmFscykge1xuICAgICAgICB2YXIgcG93ZXIgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKSxcbiAgICAgICAgICAgIG9wdGlvbmFsc1JlZ0V4cCxcbiAgICAgICAgICAgIG91dHB1dDtcblxuICAgICAgICAvL3JvdW5kaW5nRnVuY3Rpb24gPSAocm91bmRpbmdGdW5jdGlvbiAhPT0gdW5kZWZpbmVkID8gcm91bmRpbmdGdW5jdGlvbiA6IE1hdGgucm91bmQpO1xuICAgICAgICAvLyBNdWx0aXBseSB1cCBieSBwcmVjaXNpb24sIHJvdW5kIGFjY3VyYXRlbHksIHRoZW4gZGl2aWRlIGFuZCB1c2UgbmF0aXZlIHRvRml4ZWQoKTpcbiAgICAgICAgb3V0cHV0ID0gKHJvdW5kaW5nRnVuY3Rpb24odmFsdWUgKiBwb3dlcikgLyBwb3dlcikudG9GaXhlZChwcmVjaXNpb24pO1xuXG4gICAgICAgIGlmIChvcHRpb25hbHMpIHtcbiAgICAgICAgICAgIG9wdGlvbmFsc1JlZ0V4cCA9IG5ldyBSZWdFeHAoJzB7MSwnICsgb3B0aW9uYWxzICsgJ30kJyk7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZShvcHRpb25hbHNSZWdFeHAsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBGb3JtYXR0aW5nXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLy8gZGV0ZXJtaW5lIHdoYXQgdHlwZSBvZiBmb3JtYXR0aW5nIHdlIG5lZWQgdG8gZG9cbiAgICBmdW5jdGlvbiBmb3JtYXROdW1lcmFsIChuLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIG91dHB1dDtcblxuICAgICAgICAvLyBmaWd1cmUgb3V0IHdoYXQga2luZCBvZiBmb3JtYXQgd2UgYXJlIGRlYWxpbmcgd2l0aFxuICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJyQnKSA+IC0xKSB7IC8vIGN1cnJlbmN5ISEhISFcbiAgICAgICAgICAgIG91dHB1dCA9IGZvcm1hdEN1cnJlbmN5KG4sIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0LmluZGV4T2YoJyUnKSA+IC0xKSB7IC8vIHBlcmNlbnRhZ2VcbiAgICAgICAgICAgIG91dHB1dCA9IGZvcm1hdFBlcmNlbnRhZ2UobiwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQuaW5kZXhPZignOicpID4gLTEpIHsgLy8gdGltZVxuICAgICAgICAgICAgb3V0cHV0ID0gZm9ybWF0VGltZShuLCBmb3JtYXQpO1xuICAgICAgICB9IGVsc2UgeyAvLyBwbGFpbiBvbCcgbnVtYmVycyBvciBieXRlc1xuICAgICAgICAgICAgb3V0cHV0ID0gZm9ybWF0TnVtYmVyKG4uX3ZhbHVlLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIHN0cmluZ1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIC8vIHJldmVydCB0byBudW1iZXJcbiAgICBmdW5jdGlvbiB1bmZvcm1hdE51bWVyYWwgKG4sIHN0cmluZykge1xuICAgICAgICB2YXIgc3RyaW5nT3JpZ2luYWwgPSBzdHJpbmcsXG4gICAgICAgICAgICB0aG91c2FuZFJlZ0V4cCxcbiAgICAgICAgICAgIG1pbGxpb25SZWdFeHAsXG4gICAgICAgICAgICBiaWxsaW9uUmVnRXhwLFxuICAgICAgICAgICAgdHJpbGxpb25SZWdFeHAsXG4gICAgICAgICAgICBzdWZmaXhlcyA9IFsnS0InLCAnTUInLCAnR0InLCAnVEInLCAnUEInLCAnRUInLCAnWkInLCAnWUInXSxcbiAgICAgICAgICAgIGJ5dGVzTXVsdGlwbGllciA9IGZhbHNlLFxuICAgICAgICAgICAgcG93ZXI7XG5cbiAgICAgICAgaWYgKHN0cmluZy5pbmRleE9mKCc6JykgPiAtMSkge1xuICAgICAgICAgICAgbi5fdmFsdWUgPSB1bmZvcm1hdFRpbWUoc3RyaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzdHJpbmcgPT09IHplcm9Gb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBuLl92YWx1ZSA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5kZWxpbWl0ZXJzLmRlY2ltYWwgIT09ICcuJykge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvXFwuL2csJycpLnJlcGxhY2UobGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uZGVsaW1pdGVycy5kZWNpbWFsLCAnLicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHNlZSBpZiBhYmJyZXZpYXRpb25zIGFyZSB0aGVyZSBzbyB0aGF0IHdlIGNhbiBtdWx0aXBseSB0byB0aGUgY29ycmVjdCBudW1iZXJcbiAgICAgICAgICAgICAgICB0aG91c2FuZFJlZ0V4cCA9IG5ldyBSZWdFeHAoJ1teYS16QS1aXScgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLnRob3VzYW5kICsgJyg/OlxcXFwpfChcXFxcJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmN1cnJlbmN5LnN5bWJvbCArICcpPyg/OlxcXFwpKT8pPyQnKTtcbiAgICAgICAgICAgICAgICBtaWxsaW9uUmVnRXhwID0gbmV3IFJlZ0V4cCgnW15hLXpBLVpdJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMubWlsbGlvbiArICcoPzpcXFxcKXwoXFxcXCcgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5jdXJyZW5jeS5zeW1ib2wgKyAnKT8oPzpcXFxcKSk/KT8kJyk7XG4gICAgICAgICAgICAgICAgYmlsbGlvblJlZ0V4cCA9IG5ldyBSZWdFeHAoJ1teYS16QS1aXScgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLmJpbGxpb24gKyAnKD86XFxcXCl8KFxcXFwnICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sICsgJyk/KD86XFxcXCkpPyk/JCcpO1xuICAgICAgICAgICAgICAgIHRyaWxsaW9uUmVnRXhwID0gbmV3IFJlZ0V4cCgnW15hLXpBLVpdJyArIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdLmFiYnJldmlhdGlvbnMudHJpbGxpb24gKyAnKD86XFxcXCl8KFxcXFwnICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sICsgJyk/KD86XFxcXCkpPyk/JCcpO1xuXG4gICAgICAgICAgICAgICAgLy8gc2VlIGlmIGJ5dGVzIGFyZSB0aGVyZSBzbyB0aGF0IHdlIGNhbiBtdWx0aXBseSB0byB0aGUgY29ycmVjdCBudW1iZXJcbiAgICAgICAgICAgICAgICBmb3IgKHBvd2VyID0gMDsgcG93ZXIgPD0gc3VmZml4ZXMubGVuZ3RoOyBwb3dlcisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzTXVsdGlwbGllciA9IChzdHJpbmcuaW5kZXhPZihzdWZmaXhlc1twb3dlcl0pID4gLTEpID8gTWF0aC5wb3coMTAyNCwgcG93ZXIgKyAxKSA6IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChieXRlc011bHRpcGxpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZG8gc29tZSBtYXRoIHRvIGNyZWF0ZSBvdXIgbnVtYmVyXG4gICAgICAgICAgICAgICAgbi5fdmFsdWUgPSAoKGJ5dGVzTXVsdGlwbGllcikgPyBieXRlc011bHRpcGxpZXIgOiAxKSAqICgoc3RyaW5nT3JpZ2luYWwubWF0Y2godGhvdXNhbmRSZWdFeHApKSA/IE1hdGgucG93KDEwLCAzKSA6IDEpICogKChzdHJpbmdPcmlnaW5hbC5tYXRjaChtaWxsaW9uUmVnRXhwKSkgPyBNYXRoLnBvdygxMCwgNikgOiAxKSAqICgoc3RyaW5nT3JpZ2luYWwubWF0Y2goYmlsbGlvblJlZ0V4cCkpID8gTWF0aC5wb3coMTAsIDkpIDogMSkgKiAoKHN0cmluZ09yaWdpbmFsLm1hdGNoKHRyaWxsaW9uUmVnRXhwKSkgPyBNYXRoLnBvdygxMCwgMTIpIDogMSkgKiAoKHN0cmluZy5pbmRleE9mKCclJykgPiAtMSkgPyAwLjAxIDogMSkgKiAoKChzdHJpbmcuc3BsaXQoJy0nKS5sZW5ndGggKyBNYXRoLm1pbihzdHJpbmcuc3BsaXQoJygnKS5sZW5ndGgtMSwgc3RyaW5nLnNwbGl0KCcpJykubGVuZ3RoLTEpKSAlIDIpPyAxOiAtMSkgKiBOdW1iZXIoc3RyaW5nLnJlcGxhY2UoL1teMC05XFwuXSsvZywgJycpKTtcblxuICAgICAgICAgICAgICAgIC8vIHJvdW5kIGlmIHdlIGFyZSB0YWxraW5nIGFib3V0IGJ5dGVzXG4gICAgICAgICAgICAgICAgbi5fdmFsdWUgPSAoYnl0ZXNNdWx0aXBsaWVyKSA/IE1hdGguY2VpbChuLl92YWx1ZSkgOiBuLl92YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbi5fdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0Q3VycmVuY3kgKG4sIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICB2YXIgc3ltYm9sSW5kZXggPSBmb3JtYXQuaW5kZXhPZignJCcpLFxuICAgICAgICAgICAgb3BlblBhcmVuSW5kZXggPSBmb3JtYXQuaW5kZXhPZignKCcpLFxuICAgICAgICAgICAgbWludXNTaWduSW5kZXggPSBmb3JtYXQuaW5kZXhPZignLScpLFxuICAgICAgICAgICAgc3BhY2UgPSAnJyxcbiAgICAgICAgICAgIHNwbGljZUluZGV4LFxuICAgICAgICAgICAgb3V0cHV0O1xuXG4gICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmUgb3IgYWZ0ZXIgY3VycmVuY3lcbiAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCcgJCcpID4gLTEpIHtcbiAgICAgICAgICAgIHNwYWNlID0gJyAnO1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyAkJywgJycpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdC5pbmRleE9mKCckICcpID4gLTEpIHtcbiAgICAgICAgICAgIHNwYWNlID0gJyAnO1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyQgJywgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyQnLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmb3JtYXQgdGhlIG51bWJlclxuICAgICAgICBvdXRwdXQgPSBmb3JtYXROdW1iZXIobi5fdmFsdWUsIGZvcm1hdCwgcm91bmRpbmdGdW5jdGlvbik7XG5cbiAgICAgICAgLy8gcG9zaXRpb24gdGhlIHN5bWJvbFxuICAgICAgICBpZiAoc3ltYm9sSW5kZXggPD0gMSkge1xuICAgICAgICAgICAgaWYgKG91dHB1dC5pbmRleE9mKCcoJykgPiAtMSB8fCBvdXRwdXQuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgIHNwbGljZUluZGV4ID0gMTtcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sSW5kZXggPCBvcGVuUGFyZW5JbmRleCB8fCBzeW1ib2xJbmRleCA8IG1pbnVzU2lnbkluZGV4KXtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHN5bWJvbCBhcHBlYXJzIGJlZm9yZSB0aGUgXCIoXCIgb3IgXCItXCJcbiAgICAgICAgICAgICAgICAgICAgc3BsaWNlSW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXRwdXQuc3BsaWNlKHNwbGljZUluZGV4LCAwLCBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5jdXJyZW5jeS5zeW1ib2wgKyBzcGFjZSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LmpvaW4oJycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5jdXJyZW5jeS5zeW1ib2wgKyBzcGFjZSArIG91dHB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvdXRwdXQuaW5kZXhPZignKScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5zcGxpY2UoLTEsIDAsIHNwYWNlICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQuam9pbignJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCArIHNwYWNlICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uY3VycmVuY3kuc3ltYm9sO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRQZXJjZW50YWdlIChuLCBmb3JtYXQsIHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgdmFyIHNwYWNlID0gJycsXG4gICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICB2YWx1ZSA9IG4uX3ZhbHVlICogMTAwO1xuXG4gICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmUgJVxuICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJyAlJykgPiAtMSkge1xuICAgICAgICAgICAgc3BhY2UgPSAnICc7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnICUnLCAnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnJScsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dCA9IGZvcm1hdE51bWJlcih2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKTtcblxuICAgICAgICBpZiAob3V0cHV0LmluZGV4T2YoJyknKSA+IC0xICkge1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnNwbGl0KCcnKTtcbiAgICAgICAgICAgIG91dHB1dC5zcGxpY2UoLTEsIDAsIHNwYWNlICsgJyUnKTtcbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dC5qb2luKCcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCArIHNwYWNlICsgJyUnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRUaW1lIChuKSB7XG4gICAgICAgIHZhciBob3VycyA9IE1hdGguZmxvb3Iobi5fdmFsdWUvNjAvNjApLFxuICAgICAgICAgICAgbWludXRlcyA9IE1hdGguZmxvb3IoKG4uX3ZhbHVlIC0gKGhvdXJzICogNjAgKiA2MCkpLzYwKSxcbiAgICAgICAgICAgIHNlY29uZHMgPSBNYXRoLnJvdW5kKG4uX3ZhbHVlIC0gKGhvdXJzICogNjAgKiA2MCkgLSAobWludXRlcyAqIDYwKSk7XG4gICAgICAgIHJldHVybiBob3VycyArICc6JyArICgobWludXRlcyA8IDEwKSA/ICcwJyArIG1pbnV0ZXMgOiBtaW51dGVzKSArICc6JyArICgoc2Vjb25kcyA8IDEwKSA/ICcwJyArIHNlY29uZHMgOiBzZWNvbmRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmZvcm1hdFRpbWUgKHN0cmluZykge1xuICAgICAgICB2YXIgdGltZUFycmF5ID0gc3RyaW5nLnNwbGl0KCc6JyksXG4gICAgICAgICAgICBzZWNvbmRzID0gMDtcbiAgICAgICAgLy8gdHVybiBob3VycyBhbmQgbWludXRlcyBpbnRvIHNlY29uZHMgYW5kIGFkZCB0aGVtIGFsbCB1cFxuICAgICAgICBpZiAodGltZUFycmF5Lmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgLy8gaG91cnNcbiAgICAgICAgICAgIHNlY29uZHMgPSBzZWNvbmRzICsgKE51bWJlcih0aW1lQXJyYXlbMF0pICogNjAgKiA2MCk7XG4gICAgICAgICAgICAvLyBtaW51dGVzXG4gICAgICAgICAgICBzZWNvbmRzID0gc2Vjb25kcyArIChOdW1iZXIodGltZUFycmF5WzFdKSAqIDYwKTtcbiAgICAgICAgICAgIC8vIHNlY29uZHNcbiAgICAgICAgICAgIHNlY29uZHMgPSBzZWNvbmRzICsgTnVtYmVyKHRpbWVBcnJheVsyXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGltZUFycmF5Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgLy8gbWludXRlc1xuICAgICAgICAgICAgc2Vjb25kcyA9IHNlY29uZHMgKyAoTnVtYmVyKHRpbWVBcnJheVswXSkgKiA2MCk7XG4gICAgICAgICAgICAvLyBzZWNvbmRzXG4gICAgICAgICAgICBzZWNvbmRzID0gc2Vjb25kcyArIE51bWJlcih0aW1lQXJyYXlbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOdW1iZXIoc2Vjb25kcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0TnVtYmVyICh2YWx1ZSwgZm9ybWF0LCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIHZhciBuZWdQID0gZmFsc2UsXG4gICAgICAgICAgICBzaWduZWQgPSBmYWxzZSxcbiAgICAgICAgICAgIG9wdERlYyA9IGZhbHNlLFxuICAgICAgICAgICAgYWJiciA9ICcnLFxuICAgICAgICAgICAgYWJicksgPSBmYWxzZSwgLy8gZm9yY2UgYWJicmV2aWF0aW9uIHRvIHRob3VzYW5kc1xuICAgICAgICAgICAgYWJick0gPSBmYWxzZSwgLy8gZm9yY2UgYWJicmV2aWF0aW9uIHRvIG1pbGxpb25zXG4gICAgICAgICAgICBhYmJyQiA9IGZhbHNlLCAvLyBmb3JjZSBhYmJyZXZpYXRpb24gdG8gYmlsbGlvbnNcbiAgICAgICAgICAgIGFiYnJUID0gZmFsc2UsIC8vIGZvcmNlIGFiYnJldmlhdGlvbiB0byB0cmlsbGlvbnNcbiAgICAgICAgICAgIGFiYnJGb3JjZSA9IGZhbHNlLCAvLyBmb3JjZSBhYmJyZXZpYXRpb25cbiAgICAgICAgICAgIGJ5dGVzID0gJycsXG4gICAgICAgICAgICBvcmQgPSAnJyxcbiAgICAgICAgICAgIGFicyA9IE1hdGguYWJzKHZhbHVlKSxcbiAgICAgICAgICAgIHN1ZmZpeGVzID0gWydCJywgJ0tCJywgJ01CJywgJ0dCJywgJ1RCJywgJ1BCJywgJ0VCJywgJ1pCJywgJ1lCJ10sXG4gICAgICAgICAgICBtaW4sXG4gICAgICAgICAgICBtYXgsXG4gICAgICAgICAgICBwb3dlcixcbiAgICAgICAgICAgIHcsXG4gICAgICAgICAgICBwcmVjaXNpb24sXG4gICAgICAgICAgICB0aG91c2FuZHMsXG4gICAgICAgICAgICBkID0gJycsXG4gICAgICAgICAgICBuZWcgPSBmYWxzZTtcblxuICAgICAgICAvLyBjaGVjayBpZiBudW1iZXIgaXMgemVybyBhbmQgYSBjdXN0b20gemVybyBmb3JtYXQgaGFzIGJlZW4gc2V0XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMCAmJiB6ZXJvRm9ybWF0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gemVyb0Zvcm1hdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNlZSBpZiB3ZSBzaG91bGQgdXNlIHBhcmVudGhlc2VzIGZvciBuZWdhdGl2ZSBudW1iZXIgb3IgaWYgd2Ugc2hvdWxkIHByZWZpeCB3aXRoIGEgc2lnblxuICAgICAgICAgICAgLy8gaWYgYm90aCBhcmUgcHJlc2VudCB3ZSBkZWZhdWx0IHRvIHBhcmVudGhlc2VzXG4gICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJygnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgbmVnUCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0LmluZGV4T2YoJysnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgvXFwrL2csICcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2VlIGlmIGFiYnJldmlhdGlvbiBpcyB3YW50ZWRcbiAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignYScpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBhYmJyZXZpYXRpb24gaXMgc3BlY2lmaWVkXG4gICAgICAgICAgICAgICAgYWJicksgPSBmb3JtYXQuaW5kZXhPZignYUsnKSA+PSAwO1xuICAgICAgICAgICAgICAgIGFiYnJNID0gZm9ybWF0LmluZGV4T2YoJ2FNJykgPj0gMDtcbiAgICAgICAgICAgICAgICBhYmJyQiA9IGZvcm1hdC5pbmRleE9mKCdhQicpID49IDA7XG4gICAgICAgICAgICAgICAgYWJiclQgPSBmb3JtYXQuaW5kZXhPZignYVQnKSA+PSAwO1xuICAgICAgICAgICAgICAgIGFiYnJGb3JjZSA9IGFiYnJLIHx8IGFiYnJNIHx8IGFiYnJCIHx8IGFiYnJUO1xuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHNwYWNlIGJlZm9yZSBhYmJyZXZpYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJyBhJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBhYmJyID0gJyAnO1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnIGEnLCAnJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJ2EnLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGFicyA+PSBNYXRoLnBvdygxMCwgMTIpICYmICFhYmJyRm9yY2UgfHwgYWJiclQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJpbGxpb25cbiAgICAgICAgICAgICAgICAgICAgYWJiciA9IGFiYnIgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLnRyaWxsaW9uO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gTWF0aC5wb3coMTAsIDEyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFicyA8IE1hdGgucG93KDEwLCAxMikgJiYgYWJzID49IE1hdGgucG93KDEwLCA5KSAmJiAhYWJickZvcmNlIHx8IGFiYnJCKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJpbGxpb25cbiAgICAgICAgICAgICAgICAgICAgYWJiciA9IGFiYnIgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLmJpbGxpb247XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBNYXRoLnBvdygxMCwgOSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhYnMgPCBNYXRoLnBvdygxMCwgOSkgJiYgYWJzID49IE1hdGgucG93KDEwLCA2KSAmJiAhYWJickZvcmNlIHx8IGFiYnJNKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1pbGxpb25cbiAgICAgICAgICAgICAgICAgICAgYWJiciA9IGFiYnIgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5hYmJyZXZpYXRpb25zLm1pbGxpb247XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBNYXRoLnBvdygxMCwgNik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhYnMgPCBNYXRoLnBvdygxMCwgNikgJiYgYWJzID49IE1hdGgucG93KDEwLCAzKSAmJiAhYWJickZvcmNlIHx8IGFiYnJLKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRob3VzYW5kXG4gICAgICAgICAgICAgICAgICAgIGFiYnIgPSBhYmJyICsgbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uYWJicmV2aWF0aW9ucy50aG91c2FuZDtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIE1hdGgucG93KDEwLCAzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNlZSBpZiB3ZSBhcmUgZm9ybWF0dGluZyBieXRlc1xuICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCdiJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmVcbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJyBiJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBieXRlcyA9ICcgJztcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoJyBiJywgJycpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCdiJywgJycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAocG93ZXIgPSAwOyBwb3dlciA8PSBzdWZmaXhlcy5sZW5ndGg7IHBvd2VyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gTWF0aC5wb3coMTAyNCwgcG93ZXIpO1xuICAgICAgICAgICAgICAgICAgICBtYXggPSBNYXRoLnBvdygxMDI0LCBwb3dlcisxKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPj0gbWluICYmIHZhbHVlIDwgbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBieXRlcyA9IGJ5dGVzICsgc3VmZml4ZXNbcG93ZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gbWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNlZSBpZiBvcmRpbmFsIGlzIHdhbnRlZFxuICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCdvJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBzcGFjZSBiZWZvcmVcbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJyBvJykgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBvcmQgPSAnICc7XG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKCcgbycsICcnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnbycsICcnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvcmQgPSBvcmQgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5vcmRpbmFsKHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKCdbLl0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgb3B0RGVjID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZSgnWy5dJywgJy4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdyA9IHZhbHVlLnRvU3RyaW5nKCkuc3BsaXQoJy4nKVswXTtcbiAgICAgICAgICAgIHByZWNpc2lvbiA9IGZvcm1hdC5zcGxpdCgnLicpWzFdO1xuICAgICAgICAgICAgdGhvdXNhbmRzID0gZm9ybWF0LmluZGV4T2YoJywnKTtcblxuICAgICAgICAgICAgaWYgKHByZWNpc2lvbikge1xuICAgICAgICAgICAgICAgIGlmIChwcmVjaXNpb24uaW5kZXhPZignWycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uLnJlcGxhY2UoJ10nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbi5zcGxpdCgnWycpO1xuICAgICAgICAgICAgICAgICAgICBkID0gdG9GaXhlZCh2YWx1ZSwgKHByZWNpc2lvblswXS5sZW5ndGggKyBwcmVjaXNpb25bMV0ubGVuZ3RoKSwgcm91bmRpbmdGdW5jdGlvbiwgcHJlY2lzaW9uWzFdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9IHRvRml4ZWQodmFsdWUsIHByZWNpc2lvbi5sZW5ndGgsIHJvdW5kaW5nRnVuY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHcgPSBkLnNwbGl0KCcuJylbMF07XG5cbiAgICAgICAgICAgICAgICBpZiAoZC5zcGxpdCgnLicpWzFdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkID0gbGFuZ3VhZ2VzW2N1cnJlbnRMYW5ndWFnZV0uZGVsaW1pdGVycy5kZWNpbWFsICsgZC5zcGxpdCgnLicpWzFdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGQgPSAnJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0RGVjICYmIE51bWJlcihkLnNsaWNlKDEpKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3ID0gdG9GaXhlZCh2YWx1ZSwgbnVsbCwgcm91bmRpbmdGdW5jdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZvcm1hdCBudW1iZXJcbiAgICAgICAgICAgIGlmICh3LmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdyA9IHcuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgbmVnID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRob3VzYW5kcyA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdyA9IHcudG9TdHJpbmcoKS5yZXBsYWNlKC8oXFxkKSg/PShcXGR7M30pKyg/IVxcZCkpL2csICckMScgKyBsYW5ndWFnZXNbY3VycmVudExhbmd1YWdlXS5kZWxpbWl0ZXJzLnRob3VzYW5kcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZignLicpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdyA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKChuZWdQICYmIG5lZykgPyAnKCcgOiAnJykgKyAoKCFuZWdQICYmIG5lZykgPyAnLScgOiAnJykgKyAoKCFuZWcgJiYgc2lnbmVkKSA/ICcrJyA6ICcnKSArIHcgKyBkICsgKChvcmQpID8gb3JkIDogJycpICsgKChhYmJyKSA/IGFiYnIgOiAnJykgKyAoKGJ5dGVzKSA/IGJ5dGVzIDogJycpICsgKChuZWdQICYmIG5lZykgPyAnKScgOiAnJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIFRvcCBMZXZlbCBGdW5jdGlvbnNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBudW1lcmFsID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIGlmIChudW1lcmFsLmlzTnVtZXJhbChpbnB1dCkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQudmFsdWUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gMCB8fCB0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpbnB1dCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoIU51bWJlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gbnVtZXJhbC5mbi51bmZvcm1hdChpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IE51bWVyYWwoTnVtYmVyKGlucHV0KSk7XG4gICAgfTtcblxuICAgIC8vIHZlcnNpb24gbnVtYmVyXG4gICAgbnVtZXJhbC52ZXJzaW9uID0gVkVSU0lPTjtcblxuICAgIC8vIGNvbXBhcmUgbnVtZXJhbCBvYmplY3RcbiAgICBudW1lcmFsLmlzTnVtZXJhbCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE51bWVyYWw7XG4gICAgfTtcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxhbmd1YWdlcyBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsYW5ndWFnZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsYW5ndWFnZSBrZXkuXG4gICAgbnVtZXJhbC5sYW5ndWFnZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlcykge1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRMYW5ndWFnZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXkgJiYgIXZhbHVlcykge1xuICAgICAgICAgICAgaWYoIWxhbmd1YWdlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGxhbmd1YWdlIDogJyArIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50TGFuZ3VhZ2UgPSBrZXk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWVzIHx8ICFsYW5ndWFnZXNba2V5XSkge1xuICAgICAgICAgICAgbG9hZExhbmd1YWdlKGtleSwgdmFsdWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudW1lcmFsO1xuICAgIH07XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgbG9hZGVkIGxhbmd1YWdlIGRhdGEuICBJZlxuICAgIC8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnRcbiAgICAvLyBnbG9iYWwgbGFuZ3VhZ2Ugb2JqZWN0LlxuICAgIG51bWVyYWwubGFuZ3VhZ2VEYXRhID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhbmd1YWdlc1tjdXJyZW50TGFuZ3VhZ2VdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFsYW5ndWFnZXNba2V5XSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGxhbmd1YWdlIDogJyArIGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VzW2tleV07XG4gICAgfTtcblxuICAgIG51bWVyYWwubGFuZ3VhZ2UoJ2VuJywge1xuICAgICAgICBkZWxpbWl0ZXJzOiB7XG4gICAgICAgICAgICB0aG91c2FuZHM6ICcsJyxcbiAgICAgICAgICAgIGRlY2ltYWw6ICcuJ1xuICAgICAgICB9LFxuICAgICAgICBhYmJyZXZpYXRpb25zOiB7XG4gICAgICAgICAgICB0aG91c2FuZDogJ2snLFxuICAgICAgICAgICAgbWlsbGlvbjogJ20nLFxuICAgICAgICAgICAgYmlsbGlvbjogJ2InLFxuICAgICAgICAgICAgdHJpbGxpb246ICd0J1xuICAgICAgICB9LFxuICAgICAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwO1xuICAgICAgICAgICAgcmV0dXJuICh+fiAobnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAxKSA/ICdzdCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xuICAgICAgICB9LFxuICAgICAgICBjdXJyZW5jeToge1xuICAgICAgICAgICAgc3ltYm9sOiAnJCdcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbnVtZXJhbC56ZXJvRm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICB6ZXJvRm9ybWF0ID0gdHlwZW9mKGZvcm1hdCkgPT09ICdzdHJpbmcnID8gZm9ybWF0IDogbnVsbDtcbiAgICB9O1xuXG4gICAgbnVtZXJhbC5kZWZhdWx0Rm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICBkZWZhdWx0Rm9ybWF0ID0gdHlwZW9mKGZvcm1hdCkgPT09ICdzdHJpbmcnID8gZm9ybWF0IDogJzAuMCc7XG4gICAgfTtcblxuICAgIG51bWVyYWwudmFsaWRhdGUgPSBmdW5jdGlvbih2YWwsIGN1bHR1cmUpIHtcblxuICAgICAgICB2YXIgX2RlY2ltYWxTZXAsXG4gICAgICAgICAgX3Rob3VzYW5kU2VwLFxuICAgICAgICAgIF9jdXJyU3ltYm9sLFxuICAgICAgICAgIF92YWxBcnJheSxcbiAgICAgICAgICBfYWJick9iaixcbiAgICAgICAgICBfdGhvdXNhbmRSZWdFeCxcbiAgICAgICAgICBsYW5ndWFnZURhdGEsXG4gICAgICAgICAgdGVtcDtcblxuICAgICAgICAvL2NvZXJjZSB2YWwgdG8gc3RyaW5nXG4gICAgICAgIGlmICh0eXBlb2YgdmFsICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsICs9ICcnO1xuICAgICAgICAgICAgaWYgKGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTnVtZXJhbC5qczogVmFsdWUgaXMgbm90IHN0cmluZy4gSXQgaGFzIGJlZW4gY28tZXJjZWQgdG86ICcsIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvL3RyaW0gd2hpdGVzcGFjZXMgZnJvbSBlaXRoZXIgc2lkZXNcbiAgICAgICAgdmFsID0gdmFsLnRyaW0oKTtcblxuXG4gICAgICAgIC8vaWYgdmFsIGlzIGVtcHR5IHJldHVybiBmYWxzZVxuICAgICAgICBpZiAodmFsID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9yZXBsYWNlIHRoZSBpbml0aWFsICcrJyBvciAnLScgc2lnbiBpZiBwcmVzZW50XG4gICAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKC9eWystXT8vLCAnJyk7XG5cblxuICAgICAgICAvL2dldCB0aGUgZGVjaW1hbCBhbmQgdGhvdXNhbmRzIHNlcGFyYXRvciBmcm9tIG51bWVyYWwubGFuZ3VhZ2VEYXRhXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvL2NoZWNrIGlmIHRoZSBjdWx0dXJlIGlzIHVuZGVyc3Rvb2QgYnkgbnVtZXJhbC4gaWYgbm90LCBkZWZhdWx0IGl0IHRvIGN1cnJlbnQgbGFuZ3VhZ2VcbiAgICAgICAgICAgIGxhbmd1YWdlRGF0YSA9IG51bWVyYWwubGFuZ3VhZ2VEYXRhKGN1bHR1cmUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsYW5ndWFnZURhdGEgPSBudW1lcmFsLmxhbmd1YWdlRGF0YShudW1lcmFsLmxhbmd1YWdlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9zZXR1cCB0aGUgZGVsaW1pdGVycyBhbmQgY3VycmVuY3kgc3ltYm9sIGJhc2VkIG9uIGN1bHR1cmUvbGFuZ3VhZ2VcbiAgICAgICAgX2N1cnJTeW1ib2wgPSBsYW5ndWFnZURhdGEuY3VycmVuY3kuc3ltYm9sO1xuICAgICAgICBfYWJick9iaiA9IGxhbmd1YWdlRGF0YS5hYmJyZXZpYXRpb25zO1xuICAgICAgICBfZGVjaW1hbFNlcCA9IGxhbmd1YWdlRGF0YS5kZWxpbWl0ZXJzLmRlY2ltYWw7XG4gICAgICAgIGlmIChsYW5ndWFnZURhdGEuZGVsaW1pdGVycy50aG91c2FuZHMgPT09ICcuJykge1xuICAgICAgICAgICAgX3Rob3VzYW5kU2VwID0gJ1xcXFwuJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aG91c2FuZFNlcCA9IGxhbmd1YWdlRGF0YS5kZWxpbWl0ZXJzLnRob3VzYW5kcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdmFsaWRhdGluZyBjdXJyZW5jeSBzeW1ib2xcbiAgICAgICAgdGVtcCA9IHZhbC5tYXRjaCgvXlteXFxkXFwuXFwsXSsvKTtcbiAgICAgICAgaWYgKHRlbXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vY2h1Y2sgdGhlIGN1cnJlbmN5IHN5bWJvbCBhd2F5XG4gICAgICAgICAgICB2YWwgPSB2YWwuc3Vic3RyKDEpO1xuICAgICAgICAgICAgaWYgKHRlbXBbMF0gIT09IF9jdXJyU3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy92YWxpZGF0aW5nIGFiYnJldmlhdGlvbiBzeW1ib2xcbiAgICAgICAgdGVtcCA9IHZhbC5tYXRjaCgvW15cXGRdKyQvKTtcbiAgICAgICAgaWYgKHRlbXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbCA9IHZhbC5zbGljZSgwLCAtIDEpO1xuICAgICAgICAgICAgaWYgKHRlbXBbMF0gIT09IF9hYmJyT2JqLnRob3VzYW5kICYmIHRlbXBbMF0gIT09IF9hYmJyT2JqLm1pbGxpb24gJiYgdGVtcFswXSAhPT0gX2FiYnJPYmouYmlsbGlvbiAmJiB0ZW1wWzBdICE9PSBfYWJick9iai50cmlsbGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgdmFsIGlzIGp1c3QgZGlnaXRzIHRoZSByZXR1cm4gdHJ1ZVxuICAgICAgICBpZiAoICEhIHZhbC5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIF90aG91c2FuZFJlZ0V4ID0gbmV3IFJlZ0V4cChfdGhvdXNhbmRTZXAgKyAnezJ9Jyk7XG5cbiAgICAgICAgaWYgKCF2YWwubWF0Y2goL1teXFxkLixdL2cpKSB7XG4gICAgICAgICAgICBfdmFsQXJyYXkgPSB2YWwuc3BsaXQoX2RlY2ltYWxTZXApO1xuICAgICAgICAgICAgaWYgKF92YWxBcnJheS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoX3ZhbEFycmF5Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggISEgX3ZhbEFycmF5WzBdLm1hdGNoKC9eXFxkKy4qXFxkJC8pICYmICFfdmFsQXJyYXlbMF0ubWF0Y2goX3Rob3VzYW5kUmVnRXgpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgdmFsdWVzIHdpdGhvdXQgbGVhZGluZyB6ZXJvIGVnLiAuOTg0XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdmFsQXJyYXlbMF0gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCAhX3ZhbEFycmF5WzBdLm1hdGNoKF90aG91c2FuZFJlZ0V4KSAmJiAhISBfdmFsQXJyYXlbMV0ubWF0Y2goL15cXGQrJC8pKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfdmFsQXJyYXlbMF0ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCAhISBfdmFsQXJyYXlbMF0ubWF0Y2goL15cXGQrJC8pICYmICFfdmFsQXJyYXlbMF0ubWF0Y2goX3Rob3VzYW5kUmVnRXgpICYmICEhIF92YWxBcnJheVsxXS5tYXRjaCgvXlxcZCskLykpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICggISEgX3ZhbEFycmF5WzBdLm1hdGNoKC9eXFxkKy4qXFxkJC8pICYmICFfdmFsQXJyYXlbMF0ubWF0Y2goX3Rob3VzYW5kUmVnRXgpICYmICEhIF92YWxBcnJheVsxXS5tYXRjaCgvXlxcZCskLykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIEhlbHBlcnNcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBsb2FkTGFuZ3VhZ2Uoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgbGFuZ3VhZ2VzW2tleV0gPSB2YWx1ZXM7XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBGbG9hdGluZy1wb2ludCBoZWxwZXJzXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLy8gVGhlIGZsb2F0aW5nLXBvaW50IGhlbHBlciBmdW5jdGlvbnMgYW5kIGltcGxlbWVudGF0aW9uXG4gICAgLy8gYm9ycm93cyBoZWF2aWx5IGZyb20gc2luZnVsLmpzOiBodHRwOi8vZ3VpcG4uZ2l0aHViLmlvL3NpbmZ1bC5qcy9cblxuICAgIC8qKlxuICAgICAqIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBpdFxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L1JlZHVjZSNDb21wYXRpYmlsaXR5XG4gICAgICovXG4gICAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBBcnJheS5wcm90b3R5cGUucmVkdWNlKSB7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdF9pbml0aWFsVmFsdWUpIHtcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgICAgICAgaWYgKG51bGwgPT09IHRoaXMgfHwgJ3VuZGVmaW5lZCcgPT09IHR5cGVvZiB0aGlzKSB7XG4gICAgICAgICAgICAgICAgLy8gQXQgdGhlIG1vbWVudCBhbGwgbW9kZXJuIGJyb3dzZXJzLCB0aGF0IHN1cHBvcnQgc3RyaWN0IG1vZGUsIGhhdmVcbiAgICAgICAgICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gb2YgQXJyYXkucHJvdG90eXBlLnJlZHVjZS4gRm9yIGluc3RhbmNlLCBJRThcbiAgICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBzdXBwb3J0IHN0cmljdCBtb2RlLCBzbyB0aGlzIGNoZWNrIGlzIGFjdHVhbGx5IHVzZWxlc3MuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLnJlZHVjZSBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY2FsbGJhY2sgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbmRleCxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aCA+Pj4gMCxcbiAgICAgICAgICAgICAgICBpc1ZhbHVlU2V0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICgxIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gb3B0X2luaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgICAgICBpc1ZhbHVlU2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpbmRleCA9IDA7IGxlbmd0aCA+IGluZGV4OyArK2luZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbHVlU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrKHZhbHVlLCB0aGlzW2luZGV4XSwgaW5kZXgsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsdWVTZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzVmFsdWVTZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtdWx0aXBsaWVyIG5lY2Vzc2FyeSB0byBtYWtlIHggPj0gMSxcbiAgICAgKiBlZmZlY3RpdmVseSBlbGltaW5hdGluZyBtaXNjYWxjdWxhdGlvbnMgY2F1c2VkIGJ5XG4gICAgICogZmluaXRlIHByZWNpc2lvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtdWx0aXBsaWVyKHgpIHtcbiAgICAgICAgdmFyIHBhcnRzID0geC50b1N0cmluZygpLnNwbGl0KCcuJyk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5wb3coMTAsIHBhcnRzWzFdLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSB2YXJpYWJsZSBudW1iZXIgb2YgYXJndW1lbnRzLCByZXR1cm5zIHRoZSBtYXhpbXVtXG4gICAgICogbXVsdGlwbGllciB0aGF0IG11c3QgYmUgdXNlZCB0byBub3JtYWxpemUgYW4gb3BlcmF0aW9uIGludm9sdmluZ1xuICAgICAqIGFsbCBvZiB0aGVtLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcnJlY3Rpb25GYWN0b3IoKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIGFyZ3MucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBuZXh0KSB7XG4gICAgICAgICAgICB2YXIgbXAgPSBtdWx0aXBsaWVyKHByZXYpLFxuICAgICAgICAgICAgICAgIG1uID0gbXVsdGlwbGllcihuZXh0KTtcbiAgICAgICAgcmV0dXJuIG1wID4gbW4gPyBtcCA6IG1uO1xuICAgICAgICB9LCAtSW5maW5pdHkpO1xuICAgIH1cblxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBOdW1lcmFsIFByb3RvdHlwZVxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG4gICAgbnVtZXJhbC5mbiA9IE51bWVyYWwucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGNsb25lIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWVyYWwodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZm9ybWF0IDogZnVuY3Rpb24gKGlucHV0U3RyaW5nLCByb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TnVtZXJhbCh0aGlzLFxuICAgICAgICAgICAgICAgICAgaW5wdXRTdHJpbmcgPyBpbnB1dFN0cmluZyA6IGRlZmF1bHRGb3JtYXQsXG4gICAgICAgICAgICAgICAgICAocm91bmRpbmdGdW5jdGlvbiAhPT0gdW5kZWZpbmVkKSA/IHJvdW5kaW5nRnVuY3Rpb24gOiBNYXRoLnJvdW5kXG4gICAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5mb3JtYXQgOiBmdW5jdGlvbiAoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXRTdHJpbmcpID09PSAnW29iamVjdCBOdW1iZXJdJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dFN0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmZvcm1hdE51bWVyYWwodGhpcywgaW5wdXRTdHJpbmcgPyBpbnB1dFN0cmluZyA6IGRlZmF1bHRGb3JtYXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHZhbHVlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHZhbHVlT2YgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0IDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBhZGQgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjb3JyRmFjdG9yID0gY29ycmVjdGlvbkZhY3Rvci5jYWxsKG51bGwsIHRoaXMuX3ZhbHVlLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNiYWNrKGFjY3VtLCBjdXJyLCBjdXJySSwgTykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bSArIGNvcnJGYWN0b3IgKiBjdXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBbdGhpcy5fdmFsdWUsIHZhbHVlXS5yZWR1Y2UoY2JhY2ssIDApIC8gY29yckZhY3RvcjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN1YnRyYWN0IDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY29yckZhY3RvciA9IGNvcnJlY3Rpb25GYWN0b3IuY2FsbChudWxsLCB0aGlzLl92YWx1ZSwgdmFsdWUpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBjYmFjayhhY2N1bSwgY3VyciwgY3VyckksIE8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW0gLSBjb3JyRmFjdG9yICogY3VycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gW3ZhbHVlXS5yZWR1Y2UoY2JhY2ssIHRoaXMuX3ZhbHVlICogY29yckZhY3RvcikgLyBjb3JyRmFjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbXVsdGlwbHkgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNiYWNrKGFjY3VtLCBjdXJyLCBjdXJySSwgTykge1xuICAgICAgICAgICAgICAgIHZhciBjb3JyRmFjdG9yID0gY29ycmVjdGlvbkZhY3RvcihhY2N1bSwgY3Vycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhY2N1bSAqIGNvcnJGYWN0b3IpICogKGN1cnIgKiBjb3JyRmFjdG9yKSAvXG4gICAgICAgICAgICAgICAgICAgIChjb3JyRmFjdG9yICogY29yckZhY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IFt0aGlzLl92YWx1ZSwgdmFsdWVdLnJlZHVjZShjYmFjaywgMSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBkaXZpZGUgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNiYWNrKGFjY3VtLCBjdXJyLCBjdXJySSwgTykge1xuICAgICAgICAgICAgICAgIHZhciBjb3JyRmFjdG9yID0gY29ycmVjdGlvbkZhY3RvcihhY2N1bSwgY3Vycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhY2N1bSAqIGNvcnJGYWN0b3IpIC8gKGN1cnIgKiBjb3JyRmFjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gW3RoaXMuX3ZhbHVlLCB2YWx1ZV0ucmVkdWNlKGNiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpZmZlcmVuY2UgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhudW1lcmFsKHRoaXMuX3ZhbHVlKS5zdWJ0cmFjdCh2YWx1ZSkudmFsdWUoKSk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIEV4cG9zaW5nIE51bWVyYWxcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAvLyBDb21tb25KUyBtb2R1bGUgaXMgZGVmaW5lZFxuICAgIGlmIChoYXNNb2R1bGUpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBudW1lcmFsO1xuICAgIH1cblxuICAgIC8qZ2xvYmFsIGVuZGVyOmZhbHNlICovXG4gICAgaWYgKHR5cGVvZiBlbmRlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gaGVyZSwgYHRoaXNgIG1lYW5zIGB3aW5kb3dgIGluIHRoZSBicm93c2VyLCBvciBgZ2xvYmFsYCBvbiB0aGUgc2VydmVyXG4gICAgICAgIC8vIGFkZCBgbnVtZXJhbGAgYXMgYSBnbG9iYWwgb2JqZWN0IHZpYSBhIHN0cmluZyBpZGVudGlmaWVyLFxuICAgICAgICAvLyBmb3IgQ2xvc3VyZSBDb21waWxlciAnYWR2YW5jZWQnIG1vZGVcbiAgICAgICAgdGhpc1snbnVtZXJhbCddID0gbnVtZXJhbDtcbiAgICB9XG5cbiAgICAvKmdsb2JhbCBkZWZpbmU6ZmFsc2UgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWVyYWw7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pLmNhbGwod2luZG93KTtcbiIsIi8qIVxuICogUGlrYWRheVxuICpcbiAqIENvcHlyaWdodCDCqSAyMDE0IERhdmlkIEJ1c2hlbGwgfCBCU0QgJiBNSVQgbGljZW5zZSB8IGh0dHBzOi8vZ2l0aHViLmNvbS9kYnVzaGVsbC9QaWthZGF5XG4gKi9cblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KVxue1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBtb21lbnQ7XG4gICAgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBDb21tb25KUyBtb2R1bGVcbiAgICAgICAgLy8gTG9hZCBtb21lbnQuanMgYXMgYW4gb3B0aW9uYWwgZGVwZW5kZW5jeVxuICAgICAgICB0cnkgeyBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTsgfSBjYXRjaCAoZSkge31cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KG1vbWVudCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgICBkZWZpbmUoZnVuY3Rpb24gKHJlcSlcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gTG9hZCBtb21lbnQuanMgYXMgYW4gb3B0aW9uYWwgZGVwZW5kZW5jeVxuICAgICAgICAgICAgdmFyIGlkID0gJ21vbWVudCc7XG4gICAgICAgICAgICB0cnkgeyBtb21lbnQgPSByZXEoaWQpOyB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnkobW9tZW50KTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5QaWthZGF5ID0gZmFjdG9yeShyb290Lm1vbWVudCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAobW9tZW50KVxue1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIGZlYXR1cmUgZGV0ZWN0aW9uIGFuZCBoZWxwZXIgZnVuY3Rpb25zXG4gICAgICovXG4gICAgdmFyIGhhc01vbWVudCA9IHR5cGVvZiBtb21lbnQgPT09ICdmdW5jdGlvbicsXG5cbiAgICBoYXNFdmVudExpc3RlbmVycyA9ICEhd2luZG93LmFkZEV2ZW50TGlzdGVuZXIsXG5cbiAgICBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCxcblxuICAgIHN0byA9IHdpbmRvdy5zZXRUaW1lb3V0LFxuXG4gICAgYWRkRXZlbnQgPSBmdW5jdGlvbihlbCwgZSwgY2FsbGJhY2ssIGNhcHR1cmUpXG4gICAge1xuICAgICAgICBpZiAoaGFzRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZSwgY2FsbGJhY2ssICEhY2FwdHVyZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbC5hdHRhY2hFdmVudCgnb24nICsgZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlbW92ZUV2ZW50ID0gZnVuY3Rpb24oZWwsIGUsIGNhbGxiYWNrLCBjYXB0dXJlKVxuICAgIHtcbiAgICAgICAgaWYgKGhhc0V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGUsIGNhbGxiYWNrLCAhIWNhcHR1cmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuZGV0YWNoRXZlbnQoJ29uJyArIGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBmaXJlRXZlbnQgPSBmdW5jdGlvbihlbCwgZXZlbnROYW1lLCBkYXRhKVxuICAgIHtcbiAgICAgICAgdmFyIGV2O1xuXG4gICAgICAgIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudCkge1xuICAgICAgICAgICAgZXYgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICAgICAgICAgICAgZXYuaW5pdEV2ZW50KGV2ZW50TmFtZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgZXYgPSBleHRlbmQoZXYsIGRhdGEpO1xuICAgICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChldik7XG4gICAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QpIHtcbiAgICAgICAgICAgIGV2ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKTtcbiAgICAgICAgICAgIGV2ID0gZXh0ZW5kKGV2LCBkYXRhKTtcbiAgICAgICAgICAgIGVsLmZpcmVFdmVudCgnb24nICsgZXZlbnROYW1lLCBldik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdHJpbSA9IGZ1bmN0aW9uKHN0cilcbiAgICB7XG4gICAgICAgIHJldHVybiBzdHIudHJpbSA/IHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywnJyk7XG4gICAgfSxcblxuICAgIGhhc0NsYXNzID0gZnVuY3Rpb24oZWwsIGNuKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICgnICcgKyBlbC5jbGFzc05hbWUgKyAnICcpLmluZGV4T2YoJyAnICsgY24gKyAnICcpICE9PSAtMTtcbiAgICB9LFxuXG4gICAgYWRkQ2xhc3MgPSBmdW5jdGlvbihlbCwgY24pXG4gICAge1xuICAgICAgICBpZiAoIWhhc0NsYXNzKGVsLCBjbikpIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IChlbC5jbGFzc05hbWUgPT09ICcnKSA/IGNuIDogZWwuY2xhc3NOYW1lICsgJyAnICsgY247XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbihlbCwgY24pXG4gICAge1xuICAgICAgICBlbC5jbGFzc05hbWUgPSB0cmltKCgnICcgKyBlbC5jbGFzc05hbWUgKyAnICcpLnJlcGxhY2UoJyAnICsgY24gKyAnICcsICcgJykpO1xuICAgIH0sXG5cbiAgICBpc0FycmF5ID0gZnVuY3Rpb24ob2JqKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICgvQXJyYXkvKS50ZXN0KE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopKTtcbiAgICB9LFxuXG4gICAgaXNEYXRlID0gZnVuY3Rpb24ob2JqKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICgvRGF0ZS8pLnRlc3QoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpICYmICFpc05hTihvYmouZ2V0VGltZSgpKTtcbiAgICB9LFxuXG4gICAgaXNXZWVrZW5kID0gZnVuY3Rpb24oZGF0ZSlcbiAgICB7XG4gICAgICAgIHZhciBkYXkgPSBkYXRlLmdldERheSgpO1xuICAgICAgICByZXR1cm4gZGF5ID09PSAwIHx8IGRheSA9PT0gNjtcbiAgICB9LFxuXG4gICAgaXNMZWFwWWVhciA9IGZ1bmN0aW9uKHllYXIpXG4gICAge1xuICAgICAgICAvLyBzb2x1dGlvbiBieSBNYXR0aSBWaXJra3VuZW46IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ4ODE5NTFcbiAgICAgICAgcmV0dXJuIHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMDtcbiAgICB9LFxuXG4gICAgZ2V0RGF5c0luTW9udGggPSBmdW5jdGlvbih5ZWFyLCBtb250aClcbiAgICB7XG4gICAgICAgIHJldHVybiBbMzEsIGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV1bbW9udGhdO1xuICAgIH0sXG5cbiAgICBzZXRUb1N0YXJ0T2ZEYXkgPSBmdW5jdGlvbihkYXRlKVxuICAgIHtcbiAgICAgICAgaWYgKGlzRGF0ZShkYXRlKSkgZGF0ZS5zZXRIb3VycygwLDAsMCwwKTtcbiAgICB9LFxuXG4gICAgY29tcGFyZURhdGVzID0gZnVuY3Rpb24oYSxiKVxuICAgIHtcbiAgICAgICAgLy8gd2VhayBkYXRlIGNvbXBhcmlzb24gKHVzZSBzZXRUb1N0YXJ0T2ZEYXkoZGF0ZSkgdG8gZW5zdXJlIGNvcnJlY3QgcmVzdWx0KVxuICAgICAgICByZXR1cm4gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpO1xuICAgIH0sXG5cbiAgICBleHRlbmQgPSBmdW5jdGlvbih0bywgZnJvbSwgb3ZlcndyaXRlKVxuICAgIHtcbiAgICAgICAgdmFyIHByb3AsIGhhc1Byb3A7XG4gICAgICAgIGZvciAocHJvcCBpbiBmcm9tKSB7XG4gICAgICAgICAgICBoYXNQcm9wID0gdG9bcHJvcF0gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChoYXNQcm9wICYmIHR5cGVvZiBmcm9tW3Byb3BdID09PSAnb2JqZWN0JyAmJiBmcm9tW3Byb3BdICE9PSBudWxsICYmIGZyb21bcHJvcF0ubm9kZU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0RhdGUoZnJvbVtwcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9bcHJvcF0gPSBuZXcgRGF0ZShmcm9tW3Byb3BdLmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNBcnJheShmcm9tW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcndyaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1twcm9wXSA9IGZyb21bcHJvcF0uc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b1twcm9wXSA9IGV4dGVuZCh7fSwgZnJvbVtwcm9wXSwgb3ZlcndyaXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG92ZXJ3cml0ZSB8fCAhaGFzUHJvcCkge1xuICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gZnJvbVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG87XG4gICAgfSxcblxuICAgIGFkanVzdENhbGVuZGFyID0gZnVuY3Rpb24oY2FsZW5kYXIpIHtcbiAgICAgICAgaWYgKGNhbGVuZGFyLm1vbnRoIDwgMCkge1xuICAgICAgICAgICAgY2FsZW5kYXIueWVhciAtPSBNYXRoLmNlaWwoTWF0aC5hYnMoY2FsZW5kYXIubW9udGgpLzEyKTtcbiAgICAgICAgICAgIGNhbGVuZGFyLm1vbnRoICs9IDEyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxlbmRhci5tb250aCA+IDExKSB7XG4gICAgICAgICAgICBjYWxlbmRhci55ZWFyICs9IE1hdGguZmxvb3IoTWF0aC5hYnMoY2FsZW5kYXIubW9udGgpLzEyKTtcbiAgICAgICAgICAgIGNhbGVuZGFyLm1vbnRoIC09IDEyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxlbmRhcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZGVmYXVsdHMgYW5kIGxvY2FsaXNhdGlvblxuICAgICAqL1xuICAgIGRlZmF1bHRzID0ge1xuXG4gICAgICAgIC8vIGJpbmQgdGhlIHBpY2tlciB0byBhIGZvcm0gZmllbGRcbiAgICAgICAgZmllbGQ6IG51bGwsXG5cbiAgICAgICAgLy8gYXV0b21hdGljYWxseSBzaG93L2hpZGUgdGhlIHBpY2tlciBvbiBgZmllbGRgIGZvY3VzIChkZWZhdWx0IGB0cnVlYCBpZiBgZmllbGRgIGlzIHNldClcbiAgICAgICAgYm91bmQ6IHVuZGVmaW5lZCxcblxuICAgICAgICAvLyBwb3NpdGlvbiBvZiB0aGUgZGF0ZXBpY2tlciwgcmVsYXRpdmUgdG8gdGhlIGZpZWxkIChkZWZhdWx0IHRvIGJvdHRvbSAmIGxlZnQpXG4gICAgICAgIC8vICgnYm90dG9tJyAmICdsZWZ0JyBrZXl3b3JkcyBhcmUgbm90IHVzZWQsICd0b3AnICYgJ3JpZ2h0JyBhcmUgbW9kaWZpZXIgb24gdGhlIGJvdHRvbS9sZWZ0IHBvc2l0aW9uKVxuICAgICAgICBwb3NpdGlvbjogJ2JvdHRvbSBsZWZ0JyxcblxuICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IGZpdCBpbiB0aGUgdmlld3BvcnQgZXZlbiBpZiBpdCBtZWFucyByZXBvc2l0aW9uaW5nIGZyb20gdGhlIHBvc2l0aW9uIG9wdGlvblxuICAgICAgICByZXBvc2l0aW9uOiB0cnVlLFxuXG4gICAgICAgIC8vIHRoZSBkZWZhdWx0IG91dHB1dCBmb3JtYXQgZm9yIGAudG9TdHJpbmcoKWAgYW5kIGBmaWVsZGAgdmFsdWVcbiAgICAgICAgZm9ybWF0OiAnWVlZWS1NTS1ERCcsXG5cbiAgICAgICAgLy8gdGhlIGluaXRpYWwgZGF0ZSB0byB2aWV3IHdoZW4gZmlyc3Qgb3BlbmVkXG4gICAgICAgIGRlZmF1bHREYXRlOiBudWxsLFxuXG4gICAgICAgIC8vIG1ha2UgdGhlIGBkZWZhdWx0RGF0ZWAgdGhlIGluaXRpYWwgc2VsZWN0ZWQgdmFsdWVcbiAgICAgICAgc2V0RGVmYXVsdERhdGU6IGZhbHNlLFxuXG4gICAgICAgIC8vIGZpcnN0IGRheSBvZiB3ZWVrICgwOiBTdW5kYXksIDE6IE1vbmRheSBldGMpXG4gICAgICAgIGZpcnN0RGF5OiAwLFxuXG4gICAgICAgIC8vIHRoZSBtaW5pbXVtL2VhcmxpZXN0IGRhdGUgdGhhdCBjYW4gYmUgc2VsZWN0ZWRcbiAgICAgICAgbWluRGF0ZTogbnVsbCxcbiAgICAgICAgLy8gdGhlIG1heGltdW0vbGF0ZXN0IGRhdGUgdGhhdCBjYW4gYmUgc2VsZWN0ZWRcbiAgICAgICAgbWF4RGF0ZTogbnVsbCxcblxuICAgICAgICAvLyBudW1iZXIgb2YgeWVhcnMgZWl0aGVyIHNpZGUsIG9yIGFycmF5IG9mIHVwcGVyL2xvd2VyIHJhbmdlXG4gICAgICAgIHllYXJSYW5nZTogMTAsXG5cbiAgICAgICAgLy8gc2hvdyB3ZWVrIG51bWJlcnMgYXQgaGVhZCBvZiByb3dcbiAgICAgICAgc2hvd1dlZWtOdW1iZXI6IGZhbHNlLFxuXG4gICAgICAgIC8vIHVzZWQgaW50ZXJuYWxseSAoZG9uJ3QgY29uZmlnIG91dHNpZGUpXG4gICAgICAgIG1pblllYXI6IDAsXG4gICAgICAgIG1heFllYXI6IDk5OTksXG4gICAgICAgIG1pbk1vbnRoOiB1bmRlZmluZWQsXG4gICAgICAgIG1heE1vbnRoOiB1bmRlZmluZWQsXG5cbiAgICAgICAgc3RhcnRSYW5nZTogbnVsbCxcbiAgICAgICAgZW5kUmFuZ2U6IG51bGwsXG5cbiAgICAgICAgaXNSVEw6IGZhbHNlLFxuXG4gICAgICAgIC8vIEFkZGl0aW9uYWwgdGV4dCB0byBhcHBlbmQgdG8gdGhlIHllYXIgaW4gdGhlIGNhbGVuZGFyIHRpdGxlXG4gICAgICAgIHllYXJTdWZmaXg6ICcnLFxuXG4gICAgICAgIC8vIFJlbmRlciB0aGUgbW9udGggYWZ0ZXIgeWVhciBpbiB0aGUgY2FsZW5kYXIgdGl0bGVcbiAgICAgICAgc2hvd01vbnRoQWZ0ZXJZZWFyOiBmYWxzZSxcblxuICAgICAgICAvLyBob3cgbWFueSBtb250aHMgYXJlIHZpc2libGVcbiAgICAgICAgbnVtYmVyT2ZNb250aHM6IDEsXG5cbiAgICAgICAgLy8gd2hlbiBudW1iZXJPZk1vbnRocyBpcyB1c2VkLCB0aGlzIHdpbGwgaGVscCB5b3UgdG8gY2hvb3NlIHdoZXJlIHRoZSBtYWluIGNhbGVuZGFyIHdpbGwgYmUgKGRlZmF1bHQgYGxlZnRgLCBjYW4gYmUgc2V0IHRvIGByaWdodGApXG4gICAgICAgIC8vIG9ubHkgdXNlZCBmb3IgdGhlIGZpcnN0IGRpc3BsYXkgb3Igd2hlbiBhIHNlbGVjdGVkIGRhdGUgaXMgbm90IHZpc2libGVcbiAgICAgICAgbWFpbkNhbGVuZGFyOiAnbGVmdCcsXG5cbiAgICAgICAgLy8gU3BlY2lmeSBhIERPTSBlbGVtZW50IHRvIHJlbmRlciB0aGUgY2FsZW5kYXIgaW5cbiAgICAgICAgY29udGFpbmVyOiB1bmRlZmluZWQsXG5cbiAgICAgICAgLy8gaW50ZXJuYXRpb25hbGl6YXRpb25cbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgcHJldmlvdXNNb250aCA6ICdQcmV2aW91cyBNb250aCcsXG4gICAgICAgICAgICBuZXh0TW9udGggICAgIDogJ05leHQgTW9udGgnLFxuICAgICAgICAgICAgbW9udGhzICAgICAgICA6IFsnSmFudWFyeScsJ0ZlYnJ1YXJ5JywnTWFyY2gnLCdBcHJpbCcsJ01heScsJ0p1bmUnLCdKdWx5JywnQXVndXN0JywnU2VwdGVtYmVyJywnT2N0b2JlcicsJ05vdmVtYmVyJywnRGVjZW1iZXInXSxcbiAgICAgICAgICAgIHdlZWtkYXlzICAgICAgOiBbJ1N1bmRheScsJ01vbmRheScsJ1R1ZXNkYXknLCdXZWRuZXNkYXknLCdUaHVyc2RheScsJ0ZyaWRheScsJ1NhdHVyZGF5J10sXG4gICAgICAgICAgICB3ZWVrZGF5c1Nob3J0IDogWydTdW4nLCdNb24nLCdUdWUnLCdXZWQnLCdUaHUnLCdGcmknLCdTYXQnXVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRoZW1lIENsYXNzbmFtZVxuICAgICAgICB0aGVtZTogbnVsbCxcblxuICAgICAgICAvLyBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICBvblNlbGVjdDogbnVsbCxcbiAgICAgICAgb25PcGVuOiBudWxsLFxuICAgICAgICBvbkNsb3NlOiBudWxsLFxuICAgICAgICBvbkRyYXc6IG51bGxcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiB0ZW1wbGF0aW5nIGZ1bmN0aW9ucyB0byBhYnN0cmFjdCBIVE1MIHJlbmRlcmluZ1xuICAgICAqL1xuICAgIHJlbmRlckRheU5hbWUgPSBmdW5jdGlvbihvcHRzLCBkYXksIGFiYnIpXG4gICAge1xuICAgICAgICBkYXkgKz0gb3B0cy5maXJzdERheTtcbiAgICAgICAgd2hpbGUgKGRheSA+PSA3KSB7XG4gICAgICAgICAgICBkYXkgLT0gNztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWJiciA/IG9wdHMuaTE4bi53ZWVrZGF5c1Nob3J0W2RheV0gOiBvcHRzLmkxOG4ud2Vla2RheXNbZGF5XTtcbiAgICB9LFxuXG4gICAgcmVuZGVyRGF5ID0gZnVuY3Rpb24ob3B0cylcbiAgICB7XG4gICAgICAgIGlmIChvcHRzLmlzRW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybiAnPHRkIGNsYXNzPVwiaXMtZW1wdHlcIj48L3RkPic7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgICBpZiAob3B0cy5pc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICBhcnIucHVzaCgnaXMtZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5pc1RvZGF5KSB7XG4gICAgICAgICAgICBhcnIucHVzaCgnaXMtdG9kYXknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICBhcnIucHVzaCgnaXMtc2VsZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5pc0luUmFuZ2UpIHtcbiAgICAgICAgICAgIGFyci5wdXNoKCdpcy1pbnJhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuaXNTdGFydFJhbmdlKSB7XG4gICAgICAgICAgICBhcnIucHVzaCgnaXMtc3RhcnRyYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmlzRW5kUmFuZ2UpIHtcbiAgICAgICAgICAgIGFyci5wdXNoKCdpcy1lbmRyYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnPHRkIGRhdGEtZGF5PVwiJyArIG9wdHMuZGF5ICsgJ1wiIGNsYXNzPVwiJyArIGFyci5qb2luKCcgJykgKyAnXCI+JyArXG4gICAgICAgICAgICAgICAgICc8YnV0dG9uIGNsYXNzPVwicGlrYS1idXR0b24gcGlrYS1kYXlcIiB0eXBlPVwiYnV0dG9uXCIgJyArXG4gICAgICAgICAgICAgICAgICAgICdkYXRhLXBpa2EteWVhcj1cIicgKyBvcHRzLnllYXIgKyAnXCIgZGF0YS1waWthLW1vbnRoPVwiJyArIG9wdHMubW9udGggKyAnXCIgZGF0YS1waWthLWRheT1cIicgKyBvcHRzLmRheSArICdcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuZGF5ICtcbiAgICAgICAgICAgICAgICAgJzwvYnV0dG9uPicgK1xuICAgICAgICAgICAgICAgJzwvdGQ+JztcbiAgICB9LFxuXG4gICAgcmVuZGVyV2VlayA9IGZ1bmN0aW9uIChkLCBtLCB5KSB7XG4gICAgICAgIC8vIExpZnRlZCBmcm9tIGh0dHA6Ly9qYXZhc2NyaXB0LmFib3V0LmNvbS9saWJyYXJ5L2Jsd2Vla3llYXIuaHRtLCBsaWdodGx5IG1vZGlmaWVkLlxuICAgICAgICB2YXIgb25lamFuID0gbmV3IERhdGUoeSwgMCwgMSksXG4gICAgICAgICAgICB3ZWVrTnVtID0gTWF0aC5jZWlsKCgoKG5ldyBEYXRlKHksIG0sIGQpIC0gb25lamFuKSAvIDg2NDAwMDAwKSArIG9uZWphbi5nZXREYXkoKSsxKS83KTtcbiAgICAgICAgcmV0dXJuICc8dGQgY2xhc3M9XCJwaWthLXdlZWtcIj4nICsgd2Vla051bSArICc8L3RkPic7XG4gICAgfSxcblxuICAgIHJlbmRlclJvdyA9IGZ1bmN0aW9uKGRheXMsIGlzUlRMKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICc8dHI+JyArIChpc1JUTCA/IGRheXMucmV2ZXJzZSgpIDogZGF5cykuam9pbignJykgKyAnPC90cj4nO1xuICAgIH0sXG5cbiAgICByZW5kZXJCb2R5ID0gZnVuY3Rpb24ocm93cylcbiAgICB7XG4gICAgICAgIHJldHVybiAnPHRib2R5PicgKyByb3dzLmpvaW4oJycpICsgJzwvdGJvZHk+JztcbiAgICB9LFxuXG4gICAgcmVuZGVySGVhZCA9IGZ1bmN0aW9uKG9wdHMpXG4gICAge1xuICAgICAgICB2YXIgaSwgYXJyID0gW107XG4gICAgICAgIGlmIChvcHRzLnNob3dXZWVrTnVtYmVyKSB7XG4gICAgICAgICAgICBhcnIucHVzaCgnPHRoPjwvdGg+Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgYXJyLnB1c2goJzx0aCBzY29wZT1cImNvbFwiPjxhYmJyIHRpdGxlPVwiJyArIHJlbmRlckRheU5hbWUob3B0cywgaSkgKyAnXCI+JyArIHJlbmRlckRheU5hbWUob3B0cywgaSwgdHJ1ZSkgKyAnPC9hYmJyPjwvdGg+Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICc8dGhlYWQ+JyArIChvcHRzLmlzUlRMID8gYXJyLnJldmVyc2UoKSA6IGFycikuam9pbignJykgKyAnPC90aGVhZD4nO1xuICAgIH0sXG5cbiAgICByZW5kZXJUaXRsZSA9IGZ1bmN0aW9uKGluc3RhbmNlLCBjLCB5ZWFyLCBtb250aCwgcmVmWWVhcilcbiAgICB7XG4gICAgICAgIHZhciBpLCBqLCBhcnIsXG4gICAgICAgICAgICBvcHRzID0gaW5zdGFuY2UuX28sXG4gICAgICAgICAgICBpc01pblllYXIgPSB5ZWFyID09PSBvcHRzLm1pblllYXIsXG4gICAgICAgICAgICBpc01heFllYXIgPSB5ZWFyID09PSBvcHRzLm1heFllYXIsXG4gICAgICAgICAgICBodG1sID0gJzxkaXYgY2xhc3M9XCJwaWthLXRpdGxlXCI+JyxcbiAgICAgICAgICAgIG1vbnRoSHRtbCxcbiAgICAgICAgICAgIHllYXJIdG1sLFxuICAgICAgICAgICAgcHJldiA9IHRydWUsXG4gICAgICAgICAgICBuZXh0ID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGFyciA9IFtdLCBpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIGFyci5wdXNoKCc8b3B0aW9uIHZhbHVlPVwiJyArICh5ZWFyID09PSByZWZZZWFyID8gaSAtIGMgOiAxMiArIGkgLSBjKSArICdcIicgK1xuICAgICAgICAgICAgICAgIChpID09PSBtb250aCA/ICcgc2VsZWN0ZWQnOiAnJykgK1xuICAgICAgICAgICAgICAgICgoaXNNaW5ZZWFyICYmIGkgPCBvcHRzLm1pbk1vbnRoKSB8fCAoaXNNYXhZZWFyICYmIGkgPiBvcHRzLm1heE1vbnRoKSA/ICdkaXNhYmxlZCcgOiAnJykgKyAnPicgK1xuICAgICAgICAgICAgICAgIG9wdHMuaTE4bi5tb250aHNbaV0gKyAnPC9vcHRpb24+Jyk7XG4gICAgICAgIH1cbiAgICAgICAgbW9udGhIdG1sID0gJzxkaXYgY2xhc3M9XCJwaWthLWxhYmVsXCI+JyArIG9wdHMuaTE4bi5tb250aHNbbW9udGhdICsgJzxzZWxlY3QgY2xhc3M9XCJwaWthLXNlbGVjdCBwaWthLXNlbGVjdC1tb250aFwiIHRhYmluZGV4PVwiLTFcIj4nICsgYXJyLmpvaW4oJycpICsgJzwvc2VsZWN0PjwvZGl2Pic7XG5cbiAgICAgICAgaWYgKGlzQXJyYXkob3B0cy55ZWFyUmFuZ2UpKSB7XG4gICAgICAgICAgICBpID0gb3B0cy55ZWFyUmFuZ2VbMF07XG4gICAgICAgICAgICBqID0gb3B0cy55ZWFyUmFuZ2VbMV0gKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaSA9IHllYXIgLSBvcHRzLnllYXJSYW5nZTtcbiAgICAgICAgICAgIGogPSAxICsgeWVhciArIG9wdHMueWVhclJhbmdlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChhcnIgPSBbXTsgaSA8IGogJiYgaSA8PSBvcHRzLm1heFllYXI7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPj0gb3B0cy5taW5ZZWFyKSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goJzxvcHRpb24gdmFsdWU9XCInICsgaSArICdcIicgKyAoaSA9PT0geWVhciA/ICcgc2VsZWN0ZWQnOiAnJykgKyAnPicgKyAoaSkgKyAnPC9vcHRpb24+Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWVhckh0bWwgPSAnPGRpdiBjbGFzcz1cInBpa2EtbGFiZWxcIj4nICsgeWVhciArIG9wdHMueWVhclN1ZmZpeCArICc8c2VsZWN0IGNsYXNzPVwicGlrYS1zZWxlY3QgcGlrYS1zZWxlY3QteWVhclwiIHRhYmluZGV4PVwiLTFcIj4nICsgYXJyLmpvaW4oJycpICsgJzwvc2VsZWN0PjwvZGl2Pic7XG5cbiAgICAgICAgaWYgKG9wdHMuc2hvd01vbnRoQWZ0ZXJZZWFyKSB7XG4gICAgICAgICAgICBodG1sICs9IHllYXJIdG1sICsgbW9udGhIdG1sO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHRtbCArPSBtb250aEh0bWwgKyB5ZWFySHRtbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc01pblllYXIgJiYgKG1vbnRoID09PSAwIHx8IG9wdHMubWluTW9udGggPj0gbW9udGgpKSB7XG4gICAgICAgICAgICBwcmV2ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNNYXhZZWFyICYmIChtb250aCA9PT0gMTEgfHwgb3B0cy5tYXhNb250aCA8PSBtb250aCkpIHtcbiAgICAgICAgICAgIG5leHQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjID09PSAwKSB7XG4gICAgICAgICAgICBodG1sICs9ICc8YnV0dG9uIGNsYXNzPVwicGlrYS1wcmV2JyArIChwcmV2ID8gJycgOiAnIGlzLWRpc2FibGVkJykgKyAnXCIgdHlwZT1cImJ1dHRvblwiPicgKyBvcHRzLmkxOG4ucHJldmlvdXNNb250aCArICc8L2J1dHRvbj4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjID09PSAoaW5zdGFuY2UuX28ubnVtYmVyT2ZNb250aHMgLSAxKSApIHtcbiAgICAgICAgICAgIGh0bWwgKz0gJzxidXR0b24gY2xhc3M9XCJwaWthLW5leHQnICsgKG5leHQgPyAnJyA6ICcgaXMtZGlzYWJsZWQnKSArICdcIiB0eXBlPVwiYnV0dG9uXCI+JyArIG9wdHMuaTE4bi5uZXh0TW9udGggKyAnPC9idXR0b24+JztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBodG1sICs9ICc8L2Rpdj4nO1xuICAgIH0sXG5cbiAgICByZW5kZXJUYWJsZSA9IGZ1bmN0aW9uKG9wdHMsIGRhdGEpXG4gICAge1xuICAgICAgICByZXR1cm4gJzx0YWJsZSBjZWxscGFkZGluZz1cIjBcIiBjZWxsc3BhY2luZz1cIjBcIiBjbGFzcz1cInBpa2EtdGFibGVcIj4nICsgcmVuZGVySGVhZChvcHRzKSArIHJlbmRlckJvZHkoZGF0YSkgKyAnPC90YWJsZT4nO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFBpa2FkYXkgY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBQaWthZGF5ID0gZnVuY3Rpb24ob3B0aW9ucylcbiAgICB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIG9wdHMgPSBzZWxmLmNvbmZpZyhvcHRpb25zKTtcblxuICAgICAgICBzZWxmLl9vbk1vdXNlRG93biA9IGZ1bmN0aW9uKGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghc2VsZi5fdikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFoYXNDbGFzcyh0YXJnZXQucGFyZW50Tm9kZSwgJ2lzLWRpc2FibGVkJykpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzQ2xhc3ModGFyZ2V0LCAncGlrYS1idXR0b24nKSAmJiAhaGFzQ2xhc3ModGFyZ2V0LCAnaXMtZW1wdHknKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNldERhdGUobmV3IERhdGUodGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1waWthLXllYXInKSwgdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1waWthLW1vbnRoJyksIHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGlrYS1kYXknKSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5ib3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuZmllbGQuYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChoYXNDbGFzcyh0YXJnZXQsICdwaWthLXByZXYnKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnByZXZNb250aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChoYXNDbGFzcyh0YXJnZXQsICdwaWthLW5leHQnKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm5leHRNb250aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGFzQ2xhc3ModGFyZ2V0LCAncGlrYS1zZWxlY3QnKSkge1xuICAgICAgICAgICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuX2MgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHNlbGYuX29uQ2hhbmdlID0gZnVuY3Rpb24oZSlcbiAgICAgICAge1xuICAgICAgICAgICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc0NsYXNzKHRhcmdldCwgJ3Bpa2Etc2VsZWN0LW1vbnRoJykpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmdvdG9Nb250aCh0YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGFzQ2xhc3ModGFyZ2V0LCAncGlrYS1zZWxlY3QteWVhcicpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5nb3RvWWVhcih0YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHNlbGYuX29uSW5wdXRDaGFuZ2UgPSBmdW5jdGlvbihlKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZGF0ZTtcblxuICAgICAgICAgICAgaWYgKGUuZmlyZWRCeSA9PT0gc2VsZikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNNb21lbnQpIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gbW9tZW50KG9wdHMuZmllbGQudmFsdWUsIG9wdHMuZm9ybWF0KTtcbiAgICAgICAgICAgICAgICBkYXRlID0gKGRhdGUgJiYgZGF0ZS5pc1ZhbGlkKCkpID8gZGF0ZS50b0RhdGUoKSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5wYXJzZShvcHRzLmZpZWxkLnZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNEYXRlKGRhdGUpKSB7XG4gICAgICAgICAgICAgIHNlbGYuc2V0RGF0ZShkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZi5fdikge1xuICAgICAgICAgICAgICAgIHNlbGYuc2hvdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHNlbGYuX29uSW5wdXRGb2N1cyA9IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgc2VsZi5zaG93KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsZi5fb25JbnB1dENsaWNrID0gZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICBzZWxmLnNob3coKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxmLl9vbklucHV0Qmx1ciA9IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gSUUgYWxsb3dzIHBpa2EgZGl2IHRvIGdhaW4gZm9jdXM7IGNhdGNoIGJsdXIgdGhlIGlucHV0IGZpZWxkXG4gICAgICAgICAgICB2YXIgcEVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzQ2xhc3MocEVsLCAncGlrYS1zaW5nbGUnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKChwRWwgPSBwRWwucGFyZW50Tm9kZSkpO1xuXG4gICAgICAgICAgICBpZiAoIXNlbGYuX2MpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9iID0gc3RvKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9LCA1MCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLl9jID0gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsZi5fb25DbGljayA9IGZ1bmN0aW9uKGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQsXG4gICAgICAgICAgICAgICAgcEVsID0gdGFyZ2V0O1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhhc0V2ZW50TGlzdGVuZXJzICYmIGhhc0NsYXNzKHRhcmdldCwgJ3Bpa2Etc2VsZWN0JykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRhcmdldC5vbmNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKCdvbmNoYW5nZScsICdyZXR1cm47Jyk7XG4gICAgICAgICAgICAgICAgICAgIGFkZEV2ZW50KHRhcmdldCwgJ2NoYW5nZScsIHNlbGYuX29uQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0NsYXNzKHBFbCwgJ3Bpa2Etc2luZ2xlJykgfHwgcEVsID09PSBvcHRzLnRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICgocEVsID0gcEVsLnBhcmVudE5vZGUpKTtcbiAgICAgICAgICAgIGlmIChzZWxmLl92ICYmIHRhcmdldCAhPT0gb3B0cy50cmlnZ2VyICYmIHBFbCAhPT0gb3B0cy50cmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsZi5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBzZWxmLmVsLmNsYXNzTmFtZSA9ICdwaWthLXNpbmdsZScgKyAob3B0cy5pc1JUTCA/ICcgaXMtcnRsJyA6ICcnKSArIChvcHRzLnRoZW1lID8gJyAnICsgb3B0cy50aGVtZSA6ICcnKTtcblxuICAgICAgICBhZGRFdmVudChzZWxmLmVsLCAnb250b3VjaGVuZCcgaW4gZG9jdW1lbnQgPyAndG91Y2hlbmQnIDogJ21vdXNlZG93bicsIHNlbGYuX29uTW91c2VEb3duLCB0cnVlKTtcbiAgICAgICAgYWRkRXZlbnQoc2VsZi5lbCwgJ2NoYW5nZScsIHNlbGYuX29uQ2hhbmdlKTtcblxuICAgICAgICBpZiAob3B0cy5maWVsZCkge1xuICAgICAgICAgICAgaWYgKG9wdHMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5jb250YWluZXIuYXBwZW5kQ2hpbGQoc2VsZi5lbCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdHMuYm91bmQpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNlbGYuZWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRzLmZpZWxkLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNlbGYuZWwsIG9wdHMuZmllbGQubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkRXZlbnQob3B0cy5maWVsZCwgJ2NoYW5nZScsIHNlbGYuX29uSW5wdXRDaGFuZ2UpO1xuXG4gICAgICAgICAgICBpZiAoIW9wdHMuZGVmYXVsdERhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzTW9tZW50ICYmIG9wdHMuZmllbGQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5kZWZhdWx0RGF0ZSA9IG1vbWVudChvcHRzLmZpZWxkLnZhbHVlLCBvcHRzLmZvcm1hdCkudG9EYXRlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5kZWZhdWx0RGF0ZSA9IG5ldyBEYXRlKERhdGUucGFyc2Uob3B0cy5maWVsZC52YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRzLnNldERlZmF1bHREYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWZEYXRlID0gb3B0cy5kZWZhdWx0RGF0ZTtcblxuICAgICAgICBpZiAoaXNEYXRlKGRlZkRhdGUpKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5zZXREZWZhdWx0RGF0ZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0RGF0ZShkZWZEYXRlLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5nb3RvRGF0ZShkZWZEYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuZ290b0RhdGUobmV3IERhdGUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5ib3VuZCkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICBzZWxmLmVsLmNsYXNzTmFtZSArPSAnIGlzLWJvdW5kJztcbiAgICAgICAgICAgIGFkZEV2ZW50KG9wdHMudHJpZ2dlciwgJ2NsaWNrJywgc2VsZi5fb25JbnB1dENsaWNrKTtcbiAgICAgICAgICAgIGFkZEV2ZW50KG9wdHMudHJpZ2dlciwgJ2ZvY3VzJywgc2VsZi5fb25JbnB1dEZvY3VzKTtcbiAgICAgICAgICAgIGFkZEV2ZW50KG9wdHMudHJpZ2dlciwgJ2JsdXInLCBzZWxmLl9vbklucHV0Qmx1cik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIHB1YmxpYyBQaWthZGF5IEFQSVxuICAgICAqL1xuICAgIFBpa2FkYXkucHJvdG90eXBlID0ge1xuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNvbmZpZ3VyZSBmdW5jdGlvbmFsaXR5XG4gICAgICAgICAqL1xuICAgICAgICBjb25maWc6IGZ1bmN0aW9uKG9wdGlvbnMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fbykge1xuICAgICAgICAgICAgICAgIHRoaXMuX28gPSBleHRlbmQoe30sIGRlZmF1bHRzLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9wdHMgPSBleHRlbmQodGhpcy5fbywgb3B0aW9ucywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIG9wdHMuaXNSVEwgPSAhIW9wdHMuaXNSVEw7XG5cbiAgICAgICAgICAgIG9wdHMuZmllbGQgPSAob3B0cy5maWVsZCAmJiBvcHRzLmZpZWxkLm5vZGVOYW1lKSA/IG9wdHMuZmllbGQgOiBudWxsO1xuXG4gICAgICAgICAgICBvcHRzLnRoZW1lID0gKHR5cGVvZiBvcHRzLnRoZW1lKSA9PT0gJ3N0cmluZycgJiYgb3B0cy50aGVtZSA/IG9wdHMudGhlbWUgOiBudWxsO1xuXG4gICAgICAgICAgICBvcHRzLmJvdW5kID0gISEob3B0cy5ib3VuZCAhPT0gdW5kZWZpbmVkID8gb3B0cy5maWVsZCAmJiBvcHRzLmJvdW5kIDogb3B0cy5maWVsZCk7XG5cbiAgICAgICAgICAgIG9wdHMudHJpZ2dlciA9IChvcHRzLnRyaWdnZXIgJiYgb3B0cy50cmlnZ2VyLm5vZGVOYW1lKSA/IG9wdHMudHJpZ2dlciA6IG9wdHMuZmllbGQ7XG5cbiAgICAgICAgICAgIG9wdHMuZGlzYWJsZVdlZWtlbmRzID0gISFvcHRzLmRpc2FibGVXZWVrZW5kcztcblxuICAgICAgICAgICAgb3B0cy5kaXNhYmxlRGF5Rm4gPSAodHlwZW9mIG9wdHMuZGlzYWJsZURheUZuKSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMuZGlzYWJsZURheUZuIDogbnVsbDtcblxuICAgICAgICAgICAgdmFyIG5vbSA9IHBhcnNlSW50KG9wdHMubnVtYmVyT2ZNb250aHMsIDEwKSB8fCAxO1xuICAgICAgICAgICAgb3B0cy5udW1iZXJPZk1vbnRocyA9IG5vbSA+IDQgPyA0IDogbm9tO1xuXG4gICAgICAgICAgICBpZiAoIWlzRGF0ZShvcHRzLm1pbkRhdGUpKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5taW5EYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzRGF0ZShvcHRzLm1heERhdGUpKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5tYXhEYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG9wdHMubWluRGF0ZSAmJiBvcHRzLm1heERhdGUpICYmIG9wdHMubWF4RGF0ZSA8IG9wdHMubWluRGF0ZSkge1xuICAgICAgICAgICAgICAgIG9wdHMubWF4RGF0ZSA9IG9wdHMubWluRGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMubWluRGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TWluRGF0ZShvcHRzLm1pbkRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMubWF4RGF0ZSkge1xuICAgICAgICAgICAgICAgIHNldFRvU3RhcnRPZkRheShvcHRzLm1heERhdGUpO1xuICAgICAgICAgICAgICAgIG9wdHMubWF4WWVhciAgPSBvcHRzLm1heERhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICBvcHRzLm1heE1vbnRoID0gb3B0cy5tYXhEYXRlLmdldE1vbnRoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc0FycmF5KG9wdHMueWVhclJhbmdlKSkge1xuICAgICAgICAgICAgICAgIHZhciBmYWxsYmFjayA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSAtIDEwO1xuICAgICAgICAgICAgICAgIG9wdHMueWVhclJhbmdlWzBdID0gcGFyc2VJbnQob3B0cy55ZWFyUmFuZ2VbMF0sIDEwKSB8fCBmYWxsYmFjaztcbiAgICAgICAgICAgICAgICBvcHRzLnllYXJSYW5nZVsxXSA9IHBhcnNlSW50KG9wdHMueWVhclJhbmdlWzFdLCAxMCkgfHwgZmFsbGJhY2s7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdHMueWVhclJhbmdlID0gTWF0aC5hYnMocGFyc2VJbnQob3B0cy55ZWFyUmFuZ2UsIDEwKSkgfHwgZGVmYXVsdHMueWVhclJhbmdlO1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnllYXJSYW5nZSA+IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRzLnllYXJSYW5nZSA9IDEwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvcHRzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXR1cm4gYSBmb3JtYXR0ZWQgc3RyaW5nIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbiAodXNpbmcgTW9tZW50LmpzIGlmIGF2YWlsYWJsZSlcbiAgICAgICAgICovXG4gICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbihmb3JtYXQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiAhaXNEYXRlKHRoaXMuX2QpID8gJycgOiBoYXNNb21lbnQgPyBtb21lbnQodGhpcy5fZCkuZm9ybWF0KGZvcm1hdCB8fCB0aGlzLl9vLmZvcm1hdCkgOiB0aGlzLl9kLnRvRGF0ZVN0cmluZygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXR1cm4gYSBNb21lbnQuanMgb2JqZWN0IG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbiAoaWYgYXZhaWxhYmxlKVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TW9tZW50OiBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNNb21lbnQgPyBtb21lbnQodGhpcy5fZCkgOiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGZyb20gYSBNb21lbnQuanMgb2JqZWN0IChpZiBhdmFpbGFibGUpXG4gICAgICAgICAqL1xuICAgICAgICBzZXRNb21lbnQ6IGZ1bmN0aW9uKGRhdGUsIHByZXZlbnRPblNlbGVjdClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGhhc01vbWVudCAmJiBtb21lbnQuaXNNb21lbnQoZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldERhdGUoZGF0ZS50b0RhdGUoKSwgcHJldmVudE9uU2VsZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcmV0dXJuIGEgRGF0ZSBvYmplY3Qgb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBnZXREYXRlOiBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBpc0RhdGUodGhpcy5fZCkgPyBuZXcgRGF0ZSh0aGlzLl9kLmdldFRpbWUoKSkgOiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzZXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBzZXREYXRlOiBmdW5jdGlvbihkYXRlLCBwcmV2ZW50T25TZWxlY3QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2QgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX28uZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fby5maWVsZC52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBmaXJlRXZlbnQodGhpcy5fby5maWVsZCwgJ2NoYW5nZScsIHsgZmlyZWRCeTogdGhpcyB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUucGFyc2UoZGF0ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0RhdGUoZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtaW4gPSB0aGlzLl9vLm1pbkRhdGUsXG4gICAgICAgICAgICAgICAgbWF4ID0gdGhpcy5fby5tYXhEYXRlO1xuXG4gICAgICAgICAgICBpZiAoaXNEYXRlKG1pbikgJiYgZGF0ZSA8IG1pbikge1xuICAgICAgICAgICAgICAgIGRhdGUgPSBtaW47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShtYXgpICYmIGRhdGUgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gbWF4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgc2V0VG9TdGFydE9mRGF5KHRoaXMuX2QpO1xuICAgICAgICAgICAgdGhpcy5nb3RvRGF0ZSh0aGlzLl9kKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX28uZmllbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vLmZpZWxkLnZhbHVlID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGZpcmVFdmVudCh0aGlzLl9vLmZpZWxkLCAnY2hhbmdlJywgeyBmaXJlZEJ5OiB0aGlzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwcmV2ZW50T25TZWxlY3QgJiYgdHlwZW9mIHRoaXMuX28ub25TZWxlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vLm9uU2VsZWN0LmNhbGwodGhpcywgdGhpcy5nZXREYXRlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGFuZ2UgdmlldyB0byBhIHNwZWNpZmljIGRhdGVcbiAgICAgICAgICovXG4gICAgICAgIGdvdG9EYXRlOiBmdW5jdGlvbihkYXRlKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgbmV3Q2FsZW5kYXIgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoIWlzRGF0ZShkYXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuY2FsZW5kYXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0VmlzaWJsZURhdGUgPSBuZXcgRGF0ZSh0aGlzLmNhbGVuZGFyc1swXS55ZWFyLCB0aGlzLmNhbGVuZGFyc1swXS5tb250aCwgMSksXG4gICAgICAgICAgICAgICAgICAgIGxhc3RWaXNpYmxlRGF0ZSA9IG5ldyBEYXRlKHRoaXMuY2FsZW5kYXJzW3RoaXMuY2FsZW5kYXJzLmxlbmd0aC0xXS55ZWFyLCB0aGlzLmNhbGVuZGFyc1t0aGlzLmNhbGVuZGFycy5sZW5ndGgtMV0ubW9udGgsIDEpLFxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlRGF0ZSA9IGRhdGUuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgZW5kIG9mIHRoZSBtb250aFxuICAgICAgICAgICAgICAgIGxhc3RWaXNpYmxlRGF0ZS5zZXRNb250aChsYXN0VmlzaWJsZURhdGUuZ2V0TW9udGgoKSsxKTtcbiAgICAgICAgICAgICAgICBsYXN0VmlzaWJsZURhdGUuc2V0RGF0ZShsYXN0VmlzaWJsZURhdGUuZ2V0RGF0ZSgpLTEpO1xuICAgICAgICAgICAgICAgIG5ld0NhbGVuZGFyID0gKHZpc2libGVEYXRlIDwgZmlyc3RWaXNpYmxlRGF0ZS5nZXRUaW1lKCkgfHwgbGFzdFZpc2libGVEYXRlLmdldFRpbWUoKSA8IHZpc2libGVEYXRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5ld0NhbGVuZGFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxlbmRhcnMgPSBbe1xuICAgICAgICAgICAgICAgICAgICBtb250aDogZGF0ZS5nZXRNb250aCgpLFxuICAgICAgICAgICAgICAgICAgICB5ZWFyOiBkYXRlLmdldEZ1bGxZZWFyKClcbiAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fby5tYWluQ2FsZW5kYXIgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxlbmRhcnNbMF0ubW9udGggKz0gMSAtIHRoaXMuX28ubnVtYmVyT2ZNb250aHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmFkanVzdENhbGVuZGFycygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkanVzdENhbGVuZGFyczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyc1swXSA9IGFkanVzdENhbGVuZGFyKHRoaXMuY2FsZW5kYXJzWzBdKTtcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAxOyBjIDwgdGhpcy5fby5udW1iZXJPZk1vbnRoczsgYysrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxlbmRhcnNbY10gPSBhZGp1c3RDYWxlbmRhcih7XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoOiB0aGlzLmNhbGVuZGFyc1swXS5tb250aCArIGMsXG4gICAgICAgICAgICAgICAgICAgIHllYXI6IHRoaXMuY2FsZW5kYXJzWzBdLnllYXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZHJhdygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdvdG9Ub2RheTogZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmdvdG9EYXRlKG5ldyBEYXRlKCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGFuZ2UgdmlldyB0byBhIHNwZWNpZmljIG1vbnRoICh6ZXJvLWluZGV4LCBlLmcuIDA6IEphbnVhcnkpXG4gICAgICAgICAqL1xuICAgICAgICBnb3RvTW9udGg6IGZ1bmN0aW9uKG1vbnRoKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKG1vbnRoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJzWzBdLm1vbnRoID0gcGFyc2VJbnQobW9udGgsIDEwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkanVzdENhbGVuZGFycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG5leHRNb250aDogZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyc1swXS5tb250aCsrO1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RDYWxlbmRhcnMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwcmV2TW9udGg6IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jYWxlbmRhcnNbMF0ubW9udGgtLTtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0Q2FsZW5kYXJzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoYW5nZSB2aWV3IHRvIGEgc3BlY2lmaWMgZnVsbCB5ZWFyIChlLmcuIFwiMjAxMlwiKVxuICAgICAgICAgKi9cbiAgICAgICAgZ290b1llYXI6IGZ1bmN0aW9uKHllYXIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghaXNOYU4oeWVhcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGVuZGFyc1swXS55ZWFyID0gcGFyc2VJbnQoeWVhciwgMTApO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRqdXN0Q2FsZW5kYXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoYW5nZSB0aGUgbWluRGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0TWluRGF0ZTogZnVuY3Rpb24odmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNldFRvU3RhcnRPZkRheSh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl9vLm1pbkRhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX28ubWluWWVhciAgPSB2YWx1ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgdGhpcy5fby5taW5Nb250aCA9IHZhbHVlLmdldE1vbnRoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoYW5nZSB0aGUgbWF4RGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0TWF4RGF0ZTogZnVuY3Rpb24odmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX28ubWF4RGF0ZSA9IHZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldFN0YXJ0UmFuZ2U6IGZ1bmN0aW9uKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9vLnN0YXJ0UmFuZ2UgPSB2YWx1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRFbmRSYW5nZTogZnVuY3Rpb24odmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX28uZW5kUmFuZ2UgPSB2YWx1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcmVmcmVzaCB0aGUgSFRNTFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhdzogZnVuY3Rpb24oZm9yY2UpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fdiAmJiAhZm9yY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3B0cyA9IHRoaXMuX28sXG4gICAgICAgICAgICAgICAgbWluWWVhciA9IG9wdHMubWluWWVhcixcbiAgICAgICAgICAgICAgICBtYXhZZWFyID0gb3B0cy5tYXhZZWFyLFxuICAgICAgICAgICAgICAgIG1pbk1vbnRoID0gb3B0cy5taW5Nb250aCxcbiAgICAgICAgICAgICAgICBtYXhNb250aCA9IG9wdHMubWF4TW9udGgsXG4gICAgICAgICAgICAgICAgaHRtbCA9ICcnO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5feSA8PSBtaW5ZZWFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IG1pblllYXI7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihtaW5Nb250aCkgJiYgdGhpcy5fbSA8IG1pbk1vbnRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX20gPSBtaW5Nb250aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5feSA+PSBtYXhZZWFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IG1heFllYXI7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihtYXhNb250aCkgJiYgdGhpcy5fbSA+IG1heE1vbnRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX20gPSBtYXhNb250aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgb3B0cy5udW1iZXJPZk1vbnRoczsgYysrKSB7XG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cInBpa2EtbGVuZGFyXCI+JyArIHJlbmRlclRpdGxlKHRoaXMsIGMsIHRoaXMuY2FsZW5kYXJzW2NdLnllYXIsIHRoaXMuY2FsZW5kYXJzW2NdLm1vbnRoLCB0aGlzLmNhbGVuZGFyc1swXS55ZWFyKSArIHRoaXMucmVuZGVyKHRoaXMuY2FsZW5kYXJzW2NdLnllYXIsIHRoaXMuY2FsZW5kYXJzW2NdLm1vbnRoKSArICc8L2Rpdj4nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmVsLmlubmVySFRNTCA9IGh0bWw7XG5cbiAgICAgICAgICAgIGlmIChvcHRzLmJvdW5kKSB7XG4gICAgICAgICAgICAgICAgaWYob3B0cy5maWVsZC50eXBlICE9PSAnaGlkZGVuJykge1xuICAgICAgICAgICAgICAgICAgICBzdG8oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzLnRyaWdnZXIuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX28ub25EcmF3ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHN0byhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fby5vbkRyYXcuY2FsbChzZWxmKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhZGp1c3RQb3NpdGlvbjogZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZmllbGQsIHBFbCwgd2lkdGgsIGhlaWdodCwgdmlld3BvcnRXaWR0aCwgdmlld3BvcnRIZWlnaHQsIHNjcm9sbFRvcCwgbGVmdCwgdG9wLCBjbGllbnRSZWN0O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodGhpcy5fby5jb250YWluZXIpIHJldHVybjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZpZWxkID0gdGhpcy5fby50cmlnZ2VyO1xuICAgICAgICAgICAgcEVsID0gZmllbGQ7XG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMuZWwub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmVsLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIHZpZXdwb3J0V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICB2aWV3cG9ydEhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgc2Nyb2xsVG9wID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmllbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2xpZW50UmVjdCA9IGZpZWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBjbGllbnRSZWN0LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgdG9wID0gY2xpZW50UmVjdC5ib3R0b20gKyB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBwRWwub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgICAgICB0b3AgID0gcEVsLm9mZnNldFRvcCArIHBFbC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgd2hpbGUoKHBFbCA9IHBFbC5vZmZzZXRQYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgKz0gcEVsLm9mZnNldExlZnQ7XG4gICAgICAgICAgICAgICAgICAgIHRvcCAgKz0gcEVsLm9mZnNldFRvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRlZmF1bHQgcG9zaXRpb24gaXMgYm90dG9tICYgbGVmdFxuICAgICAgICAgICAgaWYgKCh0aGlzLl9vLnJlcG9zaXRpb24gJiYgbGVmdCArIHdpZHRoID4gdmlld3BvcnRXaWR0aCkgfHxcbiAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX28ucG9zaXRpb24uaW5kZXhPZigncmlnaHQnKSA+IC0xICYmXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgLSB3aWR0aCArIGZpZWxkLm9mZnNldFdpZHRoID4gMFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0IC0gd2lkdGggKyBmaWVsZC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGhpcy5fby5yZXBvc2l0aW9uICYmIHRvcCArIGhlaWdodCA+IHZpZXdwb3J0SGVpZ2h0ICsgc2Nyb2xsVG9wKSB8fFxuICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fby5wb3NpdGlvbi5pbmRleE9mKCd0b3AnKSA+IC0xICYmXG4gICAgICAgICAgICAgICAgICAgIHRvcCAtIGhlaWdodCAtIGZpZWxkLm9mZnNldEhlaWdodCA+IDBcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0b3AgPSB0b3AgLSBoZWlnaHQgLSBmaWVsZC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZW5kZXIgSFRNTCBmb3IgYSBwYXJ0aWN1bGFyIG1vbnRoXG4gICAgICAgICAqL1xuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKHllYXIsIG1vbnRoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgb3B0cyAgID0gdGhpcy5fbyxcbiAgICAgICAgICAgICAgICBub3cgICAgPSBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgIGRheXMgICA9IGdldERheXNJbk1vbnRoKHllYXIsIG1vbnRoKSxcbiAgICAgICAgICAgICAgICBiZWZvcmUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMSkuZ2V0RGF5KCksXG4gICAgICAgICAgICAgICAgZGF0YSAgID0gW10sXG4gICAgICAgICAgICAgICAgcm93ICAgID0gW107XG4gICAgICAgICAgICBzZXRUb1N0YXJ0T2ZEYXkobm93KTtcbiAgICAgICAgICAgIGlmIChvcHRzLmZpcnN0RGF5ID4gMCkge1xuICAgICAgICAgICAgICAgIGJlZm9yZSAtPSBvcHRzLmZpcnN0RGF5O1xuICAgICAgICAgICAgICAgIGlmIChiZWZvcmUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZSArPSA3O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjZWxscyA9IGRheXMgKyBiZWZvcmUsXG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBjZWxscztcbiAgICAgICAgICAgIHdoaWxlKGFmdGVyID4gNykge1xuICAgICAgICAgICAgICAgIGFmdGVyIC09IDc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZWxscyArPSA3IC0gYWZ0ZXI7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgciA9IDA7IGkgPCBjZWxsczsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBkYXlDb25maWcsXG4gICAgICAgICAgICAgICAgICAgIGRheSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCAxICsgKGkgLSBiZWZvcmUpKSxcbiAgICAgICAgICAgICAgICAgICAgaXNTZWxlY3RlZCA9IGlzRGF0ZSh0aGlzLl9kKSA/IGNvbXBhcmVEYXRlcyhkYXksIHRoaXMuX2QpIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGlzVG9kYXkgPSBjb21wYXJlRGF0ZXMoZGF5LCBub3cpLFxuICAgICAgICAgICAgICAgICAgICBpc0VtcHR5ID0gaSA8IGJlZm9yZSB8fCBpID49IChkYXlzICsgYmVmb3JlKSxcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydFJhbmdlID0gb3B0cy5zdGFydFJhbmdlICYmIGNvbXBhcmVEYXRlcyhvcHRzLnN0YXJ0UmFuZ2UsIGRheSksXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kUmFuZ2UgPSBvcHRzLmVuZFJhbmdlICYmIGNvbXBhcmVEYXRlcyhvcHRzLmVuZFJhbmdlLCBkYXkpLFxuICAgICAgICAgICAgICAgICAgICBpc0luUmFuZ2UgPSBvcHRzLnN0YXJ0UmFuZ2UgJiYgb3B0cy5lbmRSYW5nZSAmJiBvcHRzLnN0YXJ0UmFuZ2UgPCBkYXkgJiYgZGF5IDwgb3B0cy5lbmRSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgaXNEaXNhYmxlZCA9IChvcHRzLm1pbkRhdGUgJiYgZGF5IDwgb3B0cy5taW5EYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9wdHMubWF4RGF0ZSAmJiBkYXkgPiBvcHRzLm1heERhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3B0cy5kaXNhYmxlV2Vla2VuZHMgJiYgaXNXZWVrZW5kKGRheSkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3B0cy5kaXNhYmxlRGF5Rm4gJiYgb3B0cy5kaXNhYmxlRGF5Rm4oZGF5KSksXG4gICAgICAgICAgICAgICAgICAgIGRheUNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRheTogMSArIChpIC0gYmVmb3JlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoOiBtb250aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHllYXI6IHllYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NlbGVjdGVkOiBpc1NlbGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNUb2RheTogaXNUb2RheSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VtcHR5OiBpc0VtcHR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTdGFydFJhbmdlOiBpc1N0YXJ0UmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VuZFJhbmdlOiBpc0VuZFJhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNJblJhbmdlOiBpc0luUmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJvdy5wdXNoKHJlbmRlckRheShkYXlDb25maWcpKTtcblxuICAgICAgICAgICAgICAgIGlmICgrK3IgPT09IDcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuc2hvd1dlZWtOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy51bnNoaWZ0KHJlbmRlcldlZWsoaSAtIGJlZm9yZSwgbW9udGgsIHllYXIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2gocmVuZGVyUm93KHJvdywgb3B0cy5pc1JUTCkpO1xuICAgICAgICAgICAgICAgICAgICByb3cgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgciA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlclRhYmxlKG9wdHMsIGRhdGEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzVmlzaWJsZTogZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdjtcbiAgICAgICAgfSxcblxuICAgICAgICBzaG93OiBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fdikge1xuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsICdpcy1oaWRkZW4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLl92ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXcoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fby5ib3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRFdmVudChkb2N1bWVudCwgJ2NsaWNrJywgdGhpcy5fb25DbGljayk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRqdXN0UG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9vLm9uT3BlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vLm9uT3Blbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBoaWRlOiBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy5fdjtcbiAgICAgICAgICAgIGlmICh2ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vLmJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50KGRvY3VtZW50LCAnY2xpY2snLCB0aGlzLl9vbkNsaWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5wb3NpdGlvbiA9ICdzdGF0aWMnOyAvLyByZXNldFxuICAgICAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUubGVmdCA9ICdhdXRvJztcbiAgICAgICAgICAgICAgICB0aGlzLmVsLnN0eWxlLnRvcCA9ICdhdXRvJztcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyh0aGlzLmVsLCAnaXMtaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHRoaXMuX28ub25DbG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vLm9uQ2xvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdBTUUgT1ZFUlxuICAgICAgICAgKi9cbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50KHRoaXMuZWwsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdHJ1ZSk7XG4gICAgICAgICAgICByZW1vdmVFdmVudCh0aGlzLmVsLCAnY2hhbmdlJywgdGhpcy5fb25DaGFuZ2UpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX28uZmllbGQpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVFdmVudCh0aGlzLl9vLmZpZWxkLCAnY2hhbmdlJywgdGhpcy5fb25JbnB1dENoYW5nZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX28uYm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnQodGhpcy5fby50cmlnZ2VyLCAnY2xpY2snLCB0aGlzLl9vbklucHV0Q2xpY2spO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVFdmVudCh0aGlzLl9vLnRyaWdnZXIsICdmb2N1cycsIHRoaXMuX29uSW5wdXRGb2N1cyk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50KHRoaXMuX28udHJpZ2dlciwgJ2JsdXInLCB0aGlzLl9vbklucHV0Qmx1cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHJldHVybiBQaWthZGF5O1xuXG59KSk7XG4iLCJpZiAod2luZG93LmpRdWVyeSkge1xuICAoZnVuY3Rpb24gKHdpbmRvdywgJCwgSGFuZHNvbnRhYmxlKSB7XG4gICAgJC5mbi5oYW5kc29udGFibGUgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICB2YXIgaVxuICAgICAgICAsIGlsZW5cbiAgICAgICAgLCBhcmdzXG4gICAgICAgICwgb3V0cHV0XG4gICAgICAgICwgdXNlclNldHRpbmdzXG4gICAgICAgICwgJHRoaXMgPSB0aGlzLmZpcnN0KCkgLy8gVXNlIG9ubHkgZmlyc3QgZWxlbWVudCBmcm9tIGxpc3RcbiAgICAgICAgLCBpbnN0YW5jZSA9ICR0aGlzLmRhdGEoJ2hhbmRzb250YWJsZScpO1xuXG4gICAgICAvLyBJbml0IGNhc2VcbiAgICAgIGlmICh0eXBlb2YgYWN0aW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgICB1c2VyU2V0dGluZ3MgPSBhY3Rpb24gfHwge307XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgIGluc3RhbmNlLnVwZGF0ZVNldHRpbmdzKHVzZXJTZXR0aW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaW5zdGFuY2UgPSBuZXcgSGFuZHNvbnRhYmxlLkNvcmUoJHRoaXNbMF0sIHVzZXJTZXR0aW5ncyk7XG4gICAgICAgICAgJHRoaXMuZGF0YSgnaGFuZHNvbnRhYmxlJywgaW5zdGFuY2UpO1xuICAgICAgICAgIGluc3RhbmNlLmluaXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkdGhpcztcbiAgICAgIH1cbiAgICAgIC8vIEFjdGlvbiBjYXNlXG4gICAgICBlbHNlIHtcbiAgICAgICAgYXJncyA9IFtdO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBmb3IgKGkgPSAxLCBpbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZVthY3Rpb25dICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgb3V0cHV0ID0gaW5zdGFuY2VbYWN0aW9uXS5hcHBseShpbnN0YW5jZSwgYXJncyk7XG5cbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT09ICdkZXN0cm95Jyl7XG4gICAgICAgICAgICAgICR0aGlzLnJlbW92ZURhdGEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhbmRzb250YWJsZSBkbyBub3QgcHJvdmlkZSBhY3Rpb246ICcgKyBhY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICB9XG4gICAgfTtcbiAgfSkod2luZG93LCBqUXVlcnksIEhhbmRzb250YWJsZSk7XG59XG5cblxuIiwiXG5pbXBvcnQge1xuICBnZXRDb21wdXRlZFN0eWxlLFxuICBnZXRUcmltbWluZ0NvbnRhaW5lcixcbiAgaW5uZXJXaWR0aCxcbiAgb2Zmc2V0LFxuICBvdXRlckhlaWdodCxcbiAgb3V0ZXJXaWR0aCxcbiAgICB9IGZyb20gJy4vLi4vLi4vLi4vaGVscGVycy9kb20vZWxlbWVudCc7XG5pbXBvcnQge3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbn0gZnJvbSAnLi8uLi8uLi8uLi9oZWxwZXJzL2RvbS9ldmVudCc7XG5pbXBvcnQge0V2ZW50TWFuYWdlcn0gZnJvbSAnLi8uLi8uLi8uLi9ldmVudE1hbmFnZXInO1xuaW1wb3J0IHtXYWxrb250YWJsZUNlbGxDb29yZHN9IGZyb20gJy4vY2VsbC9jb29yZHMnO1xuXG5cbmNsYXNzIFdhbGtvbnRhYmxlQm9yZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7V2Fsa29udGFibGV9IHdvdEluc3RhbmNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5nc1xuICAgKi9cbiAgY29uc3RydWN0b3Iod290SW5zdGFuY2UsIHNldHRpbmdzKSB7XG4gICAgaWYgKCFzZXR0aW5ncykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmV2ZW50TWFuYWdlciA9IG5ldyBFdmVudE1hbmFnZXIod290SW5zdGFuY2UpO1xuICAgIHRoaXMuaW5zdGFuY2UgPSB3b3RJbnN0YW5jZTtcbiAgICB0aGlzLndvdCA9IHdvdEluc3RhbmNlO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLm1vdXNlRG93biA9IGZhbHNlO1xuICAgIHRoaXMubWFpbiA9IG51bGw7XG5cbiAgICB0aGlzLnRvcCA9IG51bGw7XG4gICAgdGhpcy5sZWZ0ID0gbnVsbDtcbiAgICB0aGlzLmJvdHRvbSA9IG51bGw7XG4gICAgdGhpcy5yaWdodCA9IG51bGw7XG5cbiAgICB0aGlzLnRvcFN0eWxlID0gbnVsbDtcbiAgICB0aGlzLmxlZnRTdHlsZSA9IG51bGw7XG4gICAgdGhpcy5ib3R0b21TdHlsZSA9IG51bGw7XG4gICAgdGhpcy5yaWdodFN0eWxlID0gbnVsbDtcblxuICAgIHRoaXMuY29ybmVyRGVmYXVsdFN0eWxlID0ge1xuICAgICAgd2lkdGg6ICc1cHgnLFxuICAgICAgaGVpZ2h0OiAnNXB4JyxcbiAgICAgIGJvcmRlcldpZHRoOiAnMnB4JyxcbiAgICAgIGJvcmRlclN0eWxlOiAnc29saWQnLFxuICAgICAgYm9yZGVyQ29sb3I6ICcjRkZGJ1xuICAgIH07XG4gICAgdGhpcy5jb3JuZXIgPSBudWxsO1xuICAgIHRoaXMuY29ybmVyU3R5bGUgPSBudWxsO1xuXG4gICAgdGhpcy5jcmVhdGVCb3JkZXJzKHNldHRpbmdzKTtcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYWxsIG5lY2Vzc2FyeSBldmVudHNcbiAgICovXG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuZXZlbnRNYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIoZG9jdW1lbnQuYm9keSwgJ21vdXNlZG93bicsICgpID0+IHRoaXMub25Nb3VzZURvd24oKSk7XG4gICAgdGhpcy5ldmVudE1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcihkb2N1bWVudC5ib2R5LCAnbW91c2V1cCcsICgpID0+IHRoaXMub25Nb3VzZVVwKCkpO1xuXG4gICAgZm9yIChsZXQgYyA9IDAsIGxlbiA9IHRoaXMubWFpbi5jaGlsZE5vZGVzLmxlbmd0aDsgYyA8IGxlbjsgYysrKSB7XG4gICAgICB0aGlzLmV2ZW50TWFuYWdlci5hZGRFdmVudExpc3RlbmVyKHRoaXMubWFpbi5jaGlsZE5vZGVzW2NdLCAnbW91c2VlbnRlcicsIChldmVudCkgPT4gdGhpcy5vbk1vdXNlRW50ZXIoZXZlbnQpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTW91c2UgZG93biBsaXN0ZW5lclxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgb25Nb3VzZURvd24oKSB7XG4gICAgdGhpcy5tb3VzZURvd24gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdXNlIHVwIGxpc3RlbmVyXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBvbk1vdXNlVXAoKSB7XG4gICAgdGhpcy5tb3VzZURvd24gPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3VzZSBlbnRlciBsaXN0ZW5lclxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBEb20gZXZlbnRcbiAgICovXG4gIG9uTW91c2VFbnRlcihldmVudCkge1xuICAgIGlmICghdGhpcy5tb3VzZURvd24gfHwgIXRoaXMud290LmdldFNldHRpbmcoJ2hpZGVCb3JkZXJPbk1vdXNlRG93bk92ZXInKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihldmVudCk7XG5cbiAgICBsZXQgX3RoaXMgPSB0aGlzO1xuICAgIGxldCBib3VuZHMgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgIGZ1bmN0aW9uIGlzT3V0c2lkZShldmVudCkge1xuICAgICAgaWYgKGV2ZW50LmNsaWVudFkgPCBNYXRoLmZsb29yKGJvdW5kcy50b3ApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmNsaWVudFkgPiBNYXRoLmNlaWwoYm91bmRzLnRvcCArIGJvdW5kcy5oZWlnaHQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmNsaWVudFggPCBNYXRoLmZsb29yKGJvdW5kcy5sZWZ0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5jbGllbnRYID4gTWF0aC5jZWlsKGJvdW5kcy5sZWZ0ICsgYm91bmRzLndpZHRoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xuICAgICAgaWYgKGlzT3V0c2lkZShldmVudCkpIHtcbiAgICAgICAgX3RoaXMuZXZlbnRNYW5hZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQuYm9keSwgJ21vdXNlbW92ZScsIGhhbmRsZXIpO1xuICAgICAgICBfdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5ldmVudE1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcihkb2N1bWVudC5ib2R5LCAnbW91c2Vtb3ZlJywgaGFuZGxlcik7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGJvcmRlciBlbGVtZW50c1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3NcbiAgICovXG4gIGNyZWF0ZUJvcmRlcnMoc2V0dGluZ3MpIHtcbiAgICB0aGlzLm1haW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIGxldCBib3JkZXJEaXZzID0gWyd0b3AnLCAnbGVmdCcsICdib3R0b20nLCAncmlnaHQnLCAnY29ybmVyJ107XG4gICAgbGV0IHN0eWxlID0gdGhpcy5tYWluLnN0eWxlO1xuICAgIHN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBzdHlsZS50b3AgPSAwO1xuICAgIHN0eWxlLmxlZnQgPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgIGxldCBwb3NpdGlvbiA9IGJvcmRlckRpdnNbaV07XG4gICAgICBsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkaXYuY2xhc3NOYW1lID0gJ3d0Qm9yZGVyICcgKyAodGhpcy5zZXR0aW5ncy5jbGFzc05hbWUgfHwgJycpOyAvLyArIGJvcmRlckRpdnNbaV07XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzW3Bvc2l0aW9uXSAmJiB0aGlzLnNldHRpbmdzW3Bvc2l0aW9uXS5oaWRlKSB7XG4gICAgICAgIGRpdi5jbGFzc05hbWUgKz0gJyBoaWRkZW4nO1xuICAgICAgfVxuICAgICAgc3R5bGUgPSBkaXYuc3R5bGU7XG4gICAgICBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAodGhpcy5zZXR0aW5nc1twb3NpdGlvbl0gJiYgdGhpcy5zZXR0aW5nc1twb3NpdGlvbl0uY29sb3IpID8gdGhpcy5zZXR0aW5nc1twb3NpdGlvbl0uY29sb3IgOiBzZXR0aW5ncy5ib3JkZXIuY29sb3I7XG4gICAgICBzdHlsZS5oZWlnaHQgPSAodGhpcy5zZXR0aW5nc1twb3NpdGlvbl0gJiYgdGhpcy5zZXR0aW5nc1twb3NpdGlvbl0ud2lkdGgpID8gdGhpcy5zZXR0aW5nc1twb3NpdGlvbl0ud2lkdGggKyAncHgnIDogc2V0dGluZ3MuYm9yZGVyLndpZHRoICsgJ3B4JztcbiAgICAgIHN0eWxlLndpZHRoID0gKHRoaXMuc2V0dGluZ3NbcG9zaXRpb25dICYmIHRoaXMuc2V0dGluZ3NbcG9zaXRpb25dLndpZHRoKSA/IHRoaXMuc2V0dGluZ3NbcG9zaXRpb25dLndpZHRoICsgJ3B4JyA6IHNldHRpbmdzLmJvcmRlci53aWR0aCArICdweCc7XG5cbiAgICAgIHRoaXMubWFpbi5hcHBlbmRDaGlsZChkaXYpO1xuICAgIH1cbiAgICB0aGlzLnRvcCA9IHRoaXMubWFpbi5jaGlsZE5vZGVzWzBdO1xuICAgIHRoaXMubGVmdCA9IHRoaXMubWFpbi5jaGlsZE5vZGVzWzFdO1xuICAgIHRoaXMuYm90dG9tID0gdGhpcy5tYWluLmNoaWxkTm9kZXNbMl07XG4gICAgdGhpcy5yaWdodCA9IHRoaXMubWFpbi5jaGlsZE5vZGVzWzNdO1xuXG4gICAgdGhpcy50b3BTdHlsZSA9IHRoaXMudG9wLnN0eWxlO1xuICAgIHRoaXMubGVmdFN0eWxlID0gdGhpcy5sZWZ0LnN0eWxlO1xuICAgIHRoaXMuYm90dG9tU3R5bGUgPSB0aGlzLmJvdHRvbS5zdHlsZTtcbiAgICB0aGlzLnJpZ2h0U3R5bGUgPSB0aGlzLnJpZ2h0LnN0eWxlO1xuXG4gICAgdGhpcy5jb3JuZXIgPSB0aGlzLm1haW4uY2hpbGROb2Rlc1s0XTtcbiAgICB0aGlzLmNvcm5lci5jbGFzc05hbWUgKz0gJyBjb3JuZXInO1xuICAgIHRoaXMuY29ybmVyU3R5bGUgPSB0aGlzLmNvcm5lci5zdHlsZTtcbiAgICB0aGlzLmNvcm5lclN0eWxlLndpZHRoID0gdGhpcy5jb3JuZXJEZWZhdWx0U3R5bGUud2lkdGg7XG4gICAgdGhpcy5jb3JuZXJTdHlsZS5oZWlnaHQgPSB0aGlzLmNvcm5lckRlZmF1bHRTdHlsZS5oZWlnaHQ7XG4gICAgdGhpcy5jb3JuZXJTdHlsZS5ib3JkZXIgPSBbXG4gICAgICB0aGlzLmNvcm5lckRlZmF1bHRTdHlsZS5ib3JkZXJXaWR0aCxcbiAgICAgIHRoaXMuY29ybmVyRGVmYXVsdFN0eWxlLmJvcmRlclN0eWxlLFxuICAgICAgdGhpcy5jb3JuZXJEZWZhdWx0U3R5bGUuYm9yZGVyQ29sb3JcbiAgICBdLmpvaW4oJyAnKTtcblxuICAgIGlmIChIYW5kc29udGFibGUubW9iaWxlQnJvd3Nlcikge1xuICAgICAgdGhpcy5jcmVhdGVNdWx0aXBsZVNlbGVjdG9ySGFuZGxlcygpO1xuICAgIH1cbiAgICB0aGlzLmRpc2FwcGVhcigpO1xuXG4gICAgaWYgKCF0aGlzLndvdC53dFRhYmxlLmJvcmRlcnNIb2xkZXIpIHtcbiAgICAgIHRoaXMud290Lnd0VGFibGUuYm9yZGVyc0hvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy53b3Qud3RUYWJsZS5ib3JkZXJzSG9sZGVyLmNsYXNzTmFtZSA9ICdodEJvcmRlcnMnO1xuICAgICAgdGhpcy53b3Qud3RUYWJsZS5zcHJlYWRlci5hcHBlbmRDaGlsZCh0aGlzLndvdC53dFRhYmxlLmJvcmRlcnNIb2xkZXIpO1xuICAgIH1cbiAgICB0aGlzLndvdC53dFRhYmxlLmJvcmRlcnNIb2xkZXIuaW5zZXJ0QmVmb3JlKHRoaXMubWFpbiwgdGhpcy53b3Qud3RUYWJsZS5ib3JkZXJzSG9sZGVyLmZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBtdWx0aXBsZSBzZWxlY3RvciBoYW5kbGVyIGZvciBtb2JpbGUgZGV2aWNlc1xuICAgKi9cbiAgY3JlYXRlTXVsdGlwbGVTZWxlY3RvckhhbmRsZXMoKSB7XG4gICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVzID0ge1xuICAgICAgdG9wTGVmdDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyksXG4gICAgICB0b3BMZWZ0SGl0QXJlYTogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyksXG4gICAgICBib3R0b21SaWdodDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyksXG4gICAgICBib3R0b21SaWdodEhpdEFyZWE6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpXG4gICAgfTtcbiAgICBsZXQgd2lkdGggPSAxMDtcbiAgICBsZXQgaGl0QXJlYVdpZHRoID0gNDA7XG5cbiAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXMudG9wTGVmdC5jbGFzc05hbWUgPSAndG9wTGVmdFNlbGVjdGlvbkhhbmRsZSc7XG4gICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVzLnRvcExlZnRIaXRBcmVhLmNsYXNzTmFtZSA9ICd0b3BMZWZ0U2VsZWN0aW9uSGFuZGxlLUhpdEFyZWEnO1xuICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlcy5ib3R0b21SaWdodC5jbGFzc05hbWUgPSAnYm90dG9tUmlnaHRTZWxlY3Rpb25IYW5kbGUnO1xuICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlcy5ib3R0b21SaWdodEhpdEFyZWEuY2xhc3NOYW1lID0gJ2JvdHRvbVJpZ2h0U2VsZWN0aW9uSGFuZGxlLUhpdEFyZWEnO1xuXG4gICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVzLnN0eWxlcyA9IHtcbiAgICAgIHRvcExlZnQ6IHRoaXMuc2VsZWN0aW9uSGFuZGxlcy50b3BMZWZ0LnN0eWxlLFxuICAgICAgdG9wTGVmdEhpdEFyZWE6IHRoaXMuc2VsZWN0aW9uSGFuZGxlcy50b3BMZWZ0SGl0QXJlYS5zdHlsZSxcbiAgICAgIGJvdHRvbVJpZ2h0OiB0aGlzLnNlbGVjdGlvbkhhbmRsZXMuYm90dG9tUmlnaHQuc3R5bGUsXG4gICAgICBib3R0b21SaWdodEhpdEFyZWE6IHRoaXMuc2VsZWN0aW9uSGFuZGxlcy5ib3R0b21SaWdodEhpdEFyZWEuc3R5bGVcbiAgICB9O1xuXG4gICAgbGV0IGhpdEFyZWFTdHlsZSA9IHtcbiAgICAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZScsXG4gICAgICAnaGVpZ2h0JzogaGl0QXJlYVdpZHRoICsgJ3B4JyxcbiAgICAgICd3aWR0aCc6IGhpdEFyZWFXaWR0aCArICdweCcsXG4gICAgICAnYm9yZGVyLXJhZGl1cyc6IHBhcnNlSW50KGhpdEFyZWFXaWR0aCAvIDEuNSwgMTApICsgJ3B4J1xuICAgIH07XG5cbiAgICBmb3IgKGxldCBwcm9wIGluIGhpdEFyZWFTdHlsZSkge1xuICAgICAgaWYgKGhpdEFyZWFTdHlsZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXMuc3R5bGVzLmJvdHRvbVJpZ2h0SGl0QXJlYVtwcm9wXSA9IGhpdEFyZWFTdHlsZVtwcm9wXTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVzLnN0eWxlcy50b3BMZWZ0SGl0QXJlYVtwcm9wXSA9IGhpdEFyZWFTdHlsZVtwcm9wXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgaGFuZGxlU3R5bGUgPSB7XG4gICAgICAncG9zaXRpb24nOiAnYWJzb2x1dGUnLFxuICAgICAgJ2hlaWdodCc6IHdpZHRoICsgJ3B4JyxcbiAgICAgICd3aWR0aCc6IHdpZHRoICsgJ3B4JyxcbiAgICAgICdib3JkZXItcmFkaXVzJzogcGFyc2VJbnQod2lkdGggLyAxLjUsIDEwKSArICdweCcsXG4gICAgICAnYmFja2dyb3VuZCc6ICcjRjVGNUZGJyxcbiAgICAgICdib3JkZXInOiAnMXB4IHNvbGlkICM0Mjg1YzgnXG4gICAgfTtcblxuICAgIGZvciAobGV0IHByb3AgaW4gaGFuZGxlU3R5bGUpIHtcbiAgICAgIGlmIChoYW5kbGVTdHlsZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXMuc3R5bGVzLmJvdHRvbVJpZ2h0W3Byb3BdID0gaGFuZGxlU3R5bGVbcHJvcF07XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlcy5zdHlsZXMudG9wTGVmdFtwcm9wXSA9IGhhbmRsZVN0eWxlW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1haW4uYXBwZW5kQ2hpbGQodGhpcy5zZWxlY3Rpb25IYW5kbGVzLnRvcExlZnQpO1xuICAgIHRoaXMubWFpbi5hcHBlbmRDaGlsZCh0aGlzLnNlbGVjdGlvbkhhbmRsZXMuYm90dG9tUmlnaHQpO1xuICAgIHRoaXMubWFpbi5hcHBlbmRDaGlsZCh0aGlzLnNlbGVjdGlvbkhhbmRsZXMudG9wTGVmdEhpdEFyZWEpO1xuICAgIHRoaXMubWFpbi5hcHBlbmRDaGlsZCh0aGlzLnNlbGVjdGlvbkhhbmRsZXMuYm90dG9tUmlnaHRIaXRBcmVhKTtcbiAgfVxuXG4gIGlzUGFydFJhbmdlKHJvdywgY29sKSB7XG4gICAgaWYgKHRoaXMud290LnNlbGVjdGlvbnMuYXJlYS5jZWxsUmFuZ2UpIHtcbiAgICAgIGlmIChyb3cgIT0gdGhpcy53b3Quc2VsZWN0aW9ucy5hcmVhLmNlbGxSYW5nZS50by5yb3cgfHwgY29sICE9IHRoaXMud290LnNlbGVjdGlvbnMuYXJlYS5jZWxsUmFuZ2UudG8uY29sKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHVwZGF0ZU11bHRpcGxlU2VsZWN0aW9uSGFuZGxlc1Bvc2l0aW9uKHJvdywgY29sLCB0b3AsIGxlZnQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBsZXQgaGFuZGxlV2lkdGggPSBwYXJzZUludCh0aGlzLnNlbGVjdGlvbkhhbmRsZXMuc3R5bGVzLnRvcExlZnQud2lkdGgsIDEwKTtcbiAgICBsZXQgaGl0QXJlYVdpZHRoID0gcGFyc2VJbnQodGhpcy5zZWxlY3Rpb25IYW5kbGVzLnN0eWxlcy50b3BMZWZ0SGl0QXJlYS53aWR0aCwgMTApO1xuXG4gICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVzLnN0eWxlcy50b3BMZWZ0LnRvcCA9IHBhcnNlSW50KHRvcCAtIGhhbmRsZVdpZHRoLCAxMCkgKyBcInB4XCI7XG4gICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVzLnN0eWxlcy50b3BMZWZ0LmxlZnQgPSBwYXJzZUludChsZWZ0IC0gaGFuZGxlV2lkdGgsIDEwKSArIFwicHhcIjtcblxuICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlcy5zdHlsZXMudG9wTGVmdEhpdEFyZWEudG9wID0gcGFyc2VJbnQodG9wIC0gKGhpdEFyZWFXaWR0aCAvIDQpICogMywgMTApICsgXCJweFwiO1xuICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlcy5zdHlsZXMudG9wTGVmdEhpdEFyZWEubGVmdCA9IHBhcnNlSW50KGxlZnQgLSAoaGl0QXJlYVdpZHRoIC8gNCkgKiAzLCAxMCkgKyBcInB4XCI7XG5cbiAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXMuc3R5bGVzLmJvdHRvbVJpZ2h0LnRvcCA9IHBhcnNlSW50KHRvcCArIGhlaWdodCwgMTApICsgXCJweFwiO1xuICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlcy5zdHlsZXMuYm90dG9tUmlnaHQubGVmdCA9IHBhcnNlSW50KGxlZnQgKyB3aWR0aCwgMTApICsgXCJweFwiO1xuXG4gICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVzLnN0eWxlcy5ib3R0b21SaWdodEhpdEFyZWEudG9wID0gcGFyc2VJbnQodG9wICsgaGVpZ2h0IC0gaGl0QXJlYVdpZHRoIC8gNCwgMTApICsgXCJweFwiO1xuICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlcy5zdHlsZXMuYm90dG9tUmlnaHRIaXRBcmVhLmxlZnQgPSBwYXJzZUludChsZWZ0ICsgd2lkdGggLSBoaXRBcmVhV2lkdGggLyA0LCAxMCkgKyBcInB4XCI7XG5cbiAgICBpZiAodGhpcy5zZXR0aW5ncy5ib3JkZXIubXVsdGlwbGVTZWxlY3Rpb25IYW5kbGVzVmlzaWJsZSAmJiB0aGlzLnNldHRpbmdzLmJvcmRlci5tdWx0aXBsZVNlbGVjdGlvbkhhbmRsZXNWaXNpYmxlKCkpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlcy5zdHlsZXMudG9wTGVmdC5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVzLnN0eWxlcy50b3BMZWZ0SGl0QXJlYS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXG4gICAgICBpZiAoIXRoaXMuaXNQYXJ0UmFuZ2Uocm93LCBjb2wpKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlcy5zdHlsZXMuYm90dG9tUmlnaHQuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVzLnN0eWxlcy5ib3R0b21SaWdodEhpdEFyZWEuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlcy5zdHlsZXMuYm90dG9tUmlnaHQuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXMuc3R5bGVzLmJvdHRvbVJpZ2h0SGl0QXJlYS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlcy5zdHlsZXMudG9wTGVmdC5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXMuc3R5bGVzLmJvdHRvbVJpZ2h0LmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlcy5zdHlsZXMudG9wTGVmdEhpdEFyZWEuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVzLnN0eWxlcy5ib3R0b21SaWdodEhpdEFyZWEuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH1cblxuICAgIGlmIChyb3cgPT0gdGhpcy53b3Qud3RTZXR0aW5ncy5nZXRTZXR0aW5nKCdmaXhlZFJvd3NUb3AnKSB8fCBjb2wgPT0gdGhpcy53b3Qud3RTZXR0aW5ncy5nZXRTZXR0aW5nKCdmaXhlZENvbHVtbnNMZWZ0JykpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlcy5zdHlsZXMudG9wTGVmdC56SW5kZXggPSBcIjk5OTlcIjtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlcy5zdHlsZXMudG9wTGVmdEhpdEFyZWEuekluZGV4ID0gXCI5OTk5XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlcy5zdHlsZXMudG9wTGVmdC56SW5kZXggPSBcIlwiO1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVzLnN0eWxlcy50b3BMZWZ0SGl0QXJlYS56SW5kZXggPSBcIlwiO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTaG93IGJvcmRlciBhcm91bmQgb25lIG9yIG1hbnkgY2VsbHNcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY29ybmVyc1xuICAgKi9cbiAgYXBwZWFyKGNvcm5lcnMpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaXNNdWx0aXBsZSxcbiAgICAgIGZyb21URCxcbiAgICAgIHRvVEQsXG4gICAgICBmcm9tT2Zmc2V0LFxuICAgICAgdG9PZmZzZXQsXG4gICAgICBjb250YWluZXJPZmZzZXQsXG4gICAgICB0b3AsXG4gICAgICBtaW5Ub3AsXG4gICAgICBsZWZ0LFxuICAgICAgbWluTGVmdCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHdpZHRoLFxuICAgICAgZnJvbVJvdyxcbiAgICAgIGZyb21Db2x1bW4sXG4gICAgICB0b1JvdyxcbiAgICAgIHRvQ29sdW1uLFxuICAgICAgaWxlbjtcblxuICAgIGlmICh0aGlzLndvdC5jbG9uZU92ZXJsYXkgaW5zdGFuY2VvZiBXYWxrb250YWJsZVRvcE92ZXJsYXkgfHwgdGhpcy53b3QuY2xvbmVPdmVybGF5IGluc3RhbmNlb2YgV2Fsa29udGFibGVDb3JuZXJPdmVybGF5KSB7XG4gICAgICBpbGVuID0gdGhpcy53b3QuZ2V0U2V0dGluZygnZml4ZWRSb3dzVG9wJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlsZW4gPSB0aGlzLndvdC53dFRhYmxlLmdldFJlbmRlcmVkUm93c0NvdW50KCk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGxldCBzID0gdGhpcy53b3Qud3RUYWJsZS5yb3dGaWx0ZXIucmVuZGVyZWRUb1NvdXJjZShpKTtcblxuICAgICAgaWYgKHMgPj0gY29ybmVyc1swXSAmJiBzIDw9IGNvcm5lcnNbMl0pIHtcbiAgICAgICAgZnJvbVJvdyA9IHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSBpbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGxldCBzID0gdGhpcy53b3Qud3RUYWJsZS5yb3dGaWx0ZXIucmVuZGVyZWRUb1NvdXJjZShpKTtcblxuICAgICAgaWYgKHMgPj0gY29ybmVyc1swXSAmJiBzIDw9IGNvcm5lcnNbMl0pIHtcbiAgICAgICAgdG9Sb3cgPSBzO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbGVuID0gdGhpcy53b3Qud3RUYWJsZS5nZXRSZW5kZXJlZENvbHVtbnNDb3VudCgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGxldCBzID0gdGhpcy53b3Qud3RUYWJsZS5jb2x1bW5GaWx0ZXIucmVuZGVyZWRUb1NvdXJjZShpKTtcblxuICAgICAgaWYgKHMgPj0gY29ybmVyc1sxXSAmJiBzIDw9IGNvcm5lcnNbM10pIHtcbiAgICAgICAgZnJvbUNvbHVtbiA9IHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSBpbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGxldCBzID0gdGhpcy53b3Qud3RUYWJsZS5jb2x1bW5GaWx0ZXIucmVuZGVyZWRUb1NvdXJjZShpKTtcblxuICAgICAgaWYgKHMgPj0gY29ybmVyc1sxXSAmJiBzIDw9IGNvcm5lcnNbM10pIHtcbiAgICAgICAgdG9Db2x1bW4gPSBzO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZyb21Sb3cgPT09IHZvaWQgMCB8fCBmcm9tQ29sdW1uID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuZGlzYXBwZWFyKCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXNNdWx0aXBsZSA9IChmcm9tUm93ICE9PSB0b1JvdyB8fCBmcm9tQ29sdW1uICE9PSB0b0NvbHVtbik7XG4gICAgZnJvbVREID0gdGhpcy53b3Qud3RUYWJsZS5nZXRDZWxsKG5ldyBXYWxrb250YWJsZUNlbGxDb29yZHMoZnJvbVJvdywgZnJvbUNvbHVtbikpO1xuICAgIHRvVEQgPSBpc011bHRpcGxlID8gdGhpcy53b3Qud3RUYWJsZS5nZXRDZWxsKG5ldyBXYWxrb250YWJsZUNlbGxDb29yZHModG9Sb3csIHRvQ29sdW1uKSkgOiBmcm9tVEQ7XG4gICAgZnJvbU9mZnNldCA9IG9mZnNldChmcm9tVEQpO1xuICAgIHRvT2Zmc2V0ID0gaXNNdWx0aXBsZSA/IG9mZnNldCh0b1REKSA6IGZyb21PZmZzZXQ7XG4gICAgY29udGFpbmVyT2Zmc2V0ID0gb2Zmc2V0KHRoaXMud290Lnd0VGFibGUuVEFCTEUpO1xuXG4gICAgbWluVG9wID0gZnJvbU9mZnNldC50b3A7XG4gICAgaGVpZ2h0ID0gdG9PZmZzZXQudG9wICsgb3V0ZXJIZWlnaHQodG9URCkgLSBtaW5Ub3A7XG4gICAgbWluTGVmdCA9IGZyb21PZmZzZXQubGVmdDtcbiAgICB3aWR0aCA9IHRvT2Zmc2V0LmxlZnQgKyBvdXRlcldpZHRoKHRvVEQpIC0gbWluTGVmdDtcblxuICAgIHRvcCA9IG1pblRvcCAtIGNvbnRhaW5lck9mZnNldC50b3AgLSAxO1xuICAgIGxlZnQgPSBtaW5MZWZ0IC0gY29udGFpbmVyT2Zmc2V0LmxlZnQgLSAxO1xuICAgIGxldCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZnJvbVREKTtcblxuICAgIGlmIChwYXJzZUludChzdHlsZS5ib3JkZXJUb3BXaWR0aCwgMTApID4gMCkge1xuICAgICAgdG9wICs9IDE7XG4gICAgICBoZWlnaHQgPSBoZWlnaHQgPiAwID8gaGVpZ2h0IC0gMSA6IDA7XG4gICAgfVxuICAgIGlmIChwYXJzZUludChzdHlsZS5ib3JkZXJMZWZ0V2lkdGgsIDEwKSA+IDApIHtcbiAgICAgIGxlZnQgKz0gMTtcbiAgICAgIHdpZHRoID0gd2lkdGggPiAwID8gd2lkdGggLSAxIDogMDtcbiAgICB9XG5cbiAgICB0aGlzLnRvcFN0eWxlLnRvcCA9IHRvcCArICdweCc7XG4gICAgdGhpcy50b3BTdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XG4gICAgdGhpcy50b3BTdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICB0aGlzLnRvcFN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgdGhpcy5sZWZ0U3R5bGUudG9wID0gdG9wICsgJ3B4JztcbiAgICB0aGlzLmxlZnRTdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XG4gICAgdGhpcy5sZWZ0U3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICB0aGlzLmxlZnRTdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgIGxldCBkZWx0YSA9IE1hdGguZmxvb3IodGhpcy5zZXR0aW5ncy5ib3JkZXIud2lkdGggLyAyKTtcblxuICAgIHRoaXMuYm90dG9tU3R5bGUudG9wID0gdG9wICsgaGVpZ2h0IC0gZGVsdGEgKyAncHgnO1xuICAgIHRoaXMuYm90dG9tU3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xuICAgIHRoaXMuYm90dG9tU3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgdGhpcy5ib3R0b21TdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgIHRoaXMucmlnaHRTdHlsZS50b3AgPSB0b3AgKyAncHgnO1xuICAgIHRoaXMucmlnaHRTdHlsZS5sZWZ0ID0gbGVmdCArIHdpZHRoIC0gZGVsdGEgKyAncHgnO1xuICAgIHRoaXMucmlnaHRTdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAxICsgJ3B4JztcbiAgICB0aGlzLnJpZ2h0U3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICBpZiAoSGFuZHNvbnRhYmxlLm1vYmlsZUJyb3dzZXIgfHwgKCF0aGlzLmhhc1NldHRpbmcodGhpcy5zZXR0aW5ncy5ib3JkZXIuY29ybmVyVmlzaWJsZSkgfHwgdGhpcy5pc1BhcnRSYW5nZSh0b1JvdywgdG9Db2x1bW4pKSkge1xuICAgICAgdGhpcy5jb3JuZXJTdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvcm5lclN0eWxlLnRvcCA9IHRvcCArIGhlaWdodCAtIDQgKyAncHgnO1xuICAgICAgdGhpcy5jb3JuZXJTdHlsZS5sZWZ0ID0gbGVmdCArIHdpZHRoIC0gNCArICdweCc7XG4gICAgICB0aGlzLmNvcm5lclN0eWxlLmJvcmRlclJpZ2h0V2lkdGggPSB0aGlzLmNvcm5lckRlZmF1bHRTdHlsZS5ib3JkZXJXaWR0aDtcbiAgICAgIHRoaXMuY29ybmVyU3R5bGUud2lkdGggPSB0aGlzLmNvcm5lckRlZmF1bHRTdHlsZS53aWR0aDtcbiAgICAgIHRoaXMuY29ybmVyU3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICAgIGlmICh0b0NvbHVtbiA9PT0gdGhpcy53b3QuZ2V0U2V0dGluZygndG90YWxDb2x1bW5zJykgLSAxKSB7XG4gICAgICAgIGxldCB0cmltbWluZ0NvbnRhaW5lciA9IGdldFRyaW1taW5nQ29udGFpbmVyKHRoaXMud290Lnd0VGFibGUuVEFCTEUpO1xuICAgICAgICBsZXQgY29ybmVyT3ZlcmxhcHBpbmdDb250YWluZXIgPSB0b1RELm9mZnNldExlZnQgKyBvdXRlcldpZHRoKHRvVEQpID49IGlubmVyV2lkdGgodHJpbW1pbmdDb250YWluZXIpO1xuXG4gICAgICAgIGlmIChjb3JuZXJPdmVybGFwcGluZ0NvbnRhaW5lcikge1xuICAgICAgICAgIHRoaXMuY29ybmVyU3R5bGUubGVmdCA9IE1hdGguZmxvb3IobGVmdCArIHdpZHRoIC0gMyAtIHBhcnNlSW50KHRoaXMuY29ybmVyRGVmYXVsdFN0eWxlLndpZHRoKSAvIDIpICsgXCJweFwiO1xuICAgICAgICAgIHRoaXMuY29ybmVyU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoSGFuZHNvbnRhYmxlLm1vYmlsZUJyb3dzZXIpIHtcbiAgICAgIHRoaXMudXBkYXRlTXVsdGlwbGVTZWxlY3Rpb25IYW5kbGVzUG9zaXRpb24oZnJvbVJvdywgZnJvbUNvbHVtbiwgdG9wLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGlkZSBib3JkZXJcbiAgICovXG4gIGRpc2FwcGVhcigpIHtcbiAgICB0aGlzLnRvcFN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgdGhpcy5sZWZ0U3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB0aGlzLmJvdHRvbVN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgdGhpcy5yaWdodFN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgdGhpcy5jb3JuZXJTdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgaWYgKEhhbmRzb250YWJsZS5tb2JpbGVCcm93c2VyKSB7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXMuc3R5bGVzLnRvcExlZnQuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlcy5zdHlsZXMuYm90dG9tUmlnaHQuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGluZ1xuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGhhc1NldHRpbmcoc2V0dGluZykge1xuICAgIGlmICh0eXBlb2Ygc2V0dGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHNldHRpbmcoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gISFzZXR0aW5nO1xuICB9XG59XG5cbmV4cG9ydCB7V2Fsa29udGFibGVCb3JkZXJ9O1xuXG53aW5kb3cuV2Fsa29udGFibGVCb3JkZXIgPSBXYWxrb250YWJsZUJvcmRlcjtcbiIsIlxuY29uc3QgcHJpdmF0ZVBvb2wgPSBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgaW5kZXhlcyBvZiBjb2x1bW5zIHRvIHJlbmRlciBPUiBjb2x1bW5zIHRoYXQgYXJlIHZpc2libGUuXG4gKiBUbyByZWRvIHRoZSBjYWxjdWxhdGlvbiwgeW91IG5lZWQgdG8gY3JlYXRlIGEgbmV3IGNhbGN1bGF0b3IuXG4gKlxuICogQGNsYXNzIFdhbGtvbnRhYmxlVmlld3BvcnRDb2x1bW5zQ2FsY3VsYXRvclxuICovXG5jbGFzcyBXYWxrb250YWJsZVZpZXdwb3J0Q29sdW1uc0NhbGN1bGF0b3Ige1xuICAvKipcbiAgICogRGVmYXVsdCBjb2x1bW4gd2lkdGhcbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgREVGQVVMVF9XSURUSCgpIHtcbiAgICByZXR1cm4gNTA7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZpZXdwb3J0V2lkdGggV2lkdGggb2YgdGhlIHZpZXdwb3J0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY3JvbGxPZmZzZXQgQ3VycmVudCBob3Jpem9udGFsIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgdmlld3BvcnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsQ29sdW1ucyBUb3RhbCBudW1iZXIgb2Ygcm93c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb2x1bW5XaWR0aEZuIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIGNvbHVtbiBhdCBhIGdpdmVuIGluZGV4IChpbiBweClcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3ZlcnJpZGVGbiBGdW5jdGlvbiB0aGF0IGNoYW5nZXMgY2FsY3VsYXRlZCB0aGlzLnN0YXJ0Um93LCB0aGlzLmVuZFJvdyAodXNlZCBieSBNZXJnZUNlbGxzIHBsdWdpbilcbiAgICogQHBhcmFtIHtCb29sZWFufSBvbmx5RnVsbHlWaXNpYmxlIGlmIGB0cnVlYCwgb25seSBzdGFydFJvdyBhbmQgZW5kUm93IHdpbGwgYmUgaW5kZXhlcyBvZiByb3dzIHRoYXQgYXJlIGZ1bGx5IGluIHZpZXdwb3J0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RyZXRjaEhcbiAgICovXG4gIGNvbnN0cnVjdG9yKHZpZXdwb3J0V2lkdGgsIHNjcm9sbE9mZnNldCwgdG90YWxDb2x1bW5zLCBjb2x1bW5XaWR0aEZuLCBvdmVycmlkZUZuLCBvbmx5RnVsbHlWaXNpYmxlLCBzdHJldGNoSCkge1xuICAgIHByaXZhdGVQb29sLnNldCh0aGlzLCB7XG4gICAgICB2aWV3cG9ydFdpZHRoLFxuICAgICAgc2Nyb2xsT2Zmc2V0LFxuICAgICAgdG90YWxDb2x1bW5zLFxuICAgICAgY29sdW1uV2lkdGhGbixcbiAgICAgIG92ZXJyaWRlRm4sXG4gICAgICBvbmx5RnVsbHlWaXNpYmxlXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgcmVuZGVyZWQvdmlzaWJsZSBjb2x1bW5zXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuY291bnQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogSW5kZXggb2YgdGhlIGZpcnN0IHJlbmRlcmVkL3Zpc2libGUgY29sdW1uIChjYW4gYmUgb3ZlcndyaXR0ZW4gdXNpbmcgb3ZlcnJpZGVGbilcbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXJ0Q29sdW1uID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEluZGV4IG9mIHRoZSBsYXN0IHJlbmRlcmVkL3Zpc2libGUgY29sdW1uIChjYW4gYmUgb3ZlcndyaXR0ZW4gdXNpbmcgb3ZlcnJpZGVGbilcbiAgICAgKlxuICAgICAqIEB0eXBlIHtudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZW5kQ29sdW1uID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIG9mIHRoZSBmaXJzdCByZW5kZXJlZC92aXNpYmxlIGNvbHVtbiAoaW4gcHgpXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gbnVsbDtcblxuICAgIHRoaXMuc3RyZXRjaEFsbFJhdGlvID0gMDtcbiAgICB0aGlzLnN0cmV0Y2hMYXN0V2lkdGggPSAwO1xuICAgIHRoaXMuc3RyZXRjaCA9IHN0cmV0Y2hIO1xuICAgIHRoaXMudG90YWxUYXJnZXRXaWR0aCA9IDA7XG4gICAgdGhpcy5uZWVkVmVyaWZ5TGFzdENvbHVtbldpZHRoID0gdHJ1ZTtcbiAgICB0aGlzLnN0cmV0Y2hBbGxDb2x1bW5zV2lkdGggPSBbXTtcblxuICAgIHRoaXMuY2FsY3VsYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB2aWV3cG9ydFxuICAgKi9cbiAgY2FsY3VsYXRlKCkge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGxldCBuZWVkUmV2ZXJzZSA9IHRydWU7XG4gICAgbGV0IHN0YXJ0UG9zaXRpb25zID0gW107XG4gICAgbGV0IGNvbHVtbldpZHRoO1xuXG4gICAgbGV0IHByaXYgPSBwcml2YXRlUG9vbC5nZXQodGhpcyk7XG4gICAgbGV0IG9ubHlGdWxseVZpc2libGUgPSBwcml2Lm9ubHlGdWxseVZpc2libGU7XG4gICAgbGV0IG92ZXJyaWRlRm4gPSBwcml2Lm92ZXJyaWRlRm47XG4gICAgbGV0IHNjcm9sbE9mZnNldCA9IHByaXYuc2Nyb2xsT2Zmc2V0O1xuICAgIGxldCB0b3RhbENvbHVtbnMgPSBwcml2LnRvdGFsQ29sdW1ucztcbiAgICBsZXQgdmlld3BvcnRXaWR0aCA9IHByaXYudmlld3BvcnRXaWR0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxDb2x1bW5zOyBpKyspIHtcbiAgICAgIGNvbHVtbldpZHRoID0gdGhpcy5fZ2V0Q29sdW1uV2lkdGgoaSk7XG5cbiAgICAgIGlmIChzdW0gPD0gc2Nyb2xsT2Zmc2V0ICYmICFvbmx5RnVsbHlWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuc3RhcnRDb2x1bW4gPSBpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3VtID49IHNjcm9sbE9mZnNldCAmJiBzdW0gKyBjb2x1bW5XaWR0aCA8PSBzY3JvbGxPZmZzZXQgKyB2aWV3cG9ydFdpZHRoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0Q29sdW1uID09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0Q29sdW1uID0gaTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVuZENvbHVtbiA9IGk7XG4gICAgICB9XG4gICAgICBzdGFydFBvc2l0aW9ucy5wdXNoKHN1bSk7XG4gICAgICBzdW0gKz0gY29sdW1uV2lkdGg7XG5cbiAgICAgIGlmICghb25seUZ1bGx5VmlzaWJsZSkge1xuICAgICAgICB0aGlzLmVuZENvbHVtbiA9IGk7XG4gICAgICB9XG4gICAgICBpZiAoc3VtID49IHNjcm9sbE9mZnNldCArIHZpZXdwb3J0V2lkdGgpIHtcbiAgICAgICAgbmVlZFJldmVyc2UgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZW5kQ29sdW1uID09PSB0b3RhbENvbHVtbnMgLSAxICYmIG5lZWRSZXZlcnNlKSB7XG4gICAgICB0aGlzLnN0YXJ0Q29sdW1uID0gdGhpcy5lbmRDb2x1bW47XG5cbiAgICAgIHdoaWxlICh0aGlzLnN0YXJ0Q29sdW1uID4gMCkge1xuICAgICAgICBsZXQgdmlld3BvcnRTdW0gPSBzdGFydFBvc2l0aW9uc1t0aGlzLmVuZENvbHVtbl0gKyBjb2x1bW5XaWR0aCAtIHN0YXJ0UG9zaXRpb25zW3RoaXMuc3RhcnRDb2x1bW4gLSAxXTtcblxuICAgICAgICBpZiAodmlld3BvcnRTdW0gPD0gdmlld3BvcnRXaWR0aCB8fCAhb25seUZ1bGx5VmlzaWJsZSkge1xuICAgICAgICAgIHRoaXMuc3RhcnRDb2x1bW4tLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlld3BvcnRTdW0gPiB2aWV3cG9ydFdpZHRoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGFydENvbHVtbiAhPT0gbnVsbCAmJiBvdmVycmlkZUZuKSB7XG4gICAgICBvdmVycmlkZUZuKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uc1t0aGlzLnN0YXJ0Q29sdW1uXTtcblxuICAgIGlmICh0aGlzLnN0YXJ0UG9zaXRpb24gPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGFydENvbHVtbiAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5jb3VudCA9IHRoaXMuZW5kQ29sdW1uIC0gdGhpcy5zdGFydENvbHVtbiArIDE7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlY2FsY3VsYXRlIGNvbHVtbnMgc3RyZXRjaGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsV2lkdGhcbiAgICovXG4gIHJlZnJlc2hTdHJldGNoaW5nKHRvdGFsV2lkdGgpIHtcbiAgICBpZiAodGhpcy5zdHJldGNoID09PSAnbm9uZScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHN1bUFsbCA9IDA7XG4gICAgbGV0IGNvbHVtbldpZHRoO1xuICAgIGxldCByZW1haW5pbmdTaXplO1xuXG4gICAgbGV0IHByaXYgPSBwcml2YXRlUG9vbC5nZXQodGhpcyk7XG4gICAgbGV0IHRvdGFsQ29sdW1ucyA9IHByaXYudG90YWxDb2x1bW5zO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbENvbHVtbnM7IGkrKykge1xuICAgICAgY29sdW1uV2lkdGggPSB0aGlzLl9nZXRDb2x1bW5XaWR0aChpKTtcbiAgICAgIHN1bUFsbCArPSBjb2x1bW5XaWR0aDtcbiAgICB9XG4gICAgdGhpcy50b3RhbFRhcmdldFdpZHRoID0gdG90YWxXaWR0aDtcbiAgICByZW1haW5pbmdTaXplID0gc3VtQWxsIC0gdG90YWxXaWR0aDtcblxuICAgIGlmICh0aGlzLnN0cmV0Y2ggPT09ICdhbGwnICYmIHJlbWFpbmluZ1NpemUgPCAwKSB7XG4gICAgICB0aGlzLnN0cmV0Y2hBbGxSYXRpbyA9IHRvdGFsV2lkdGggLyBzdW1BbGw7XG4gICAgICB0aGlzLnN0cmV0Y2hBbGxDb2x1bW5zV2lkdGggPSBbXTtcbiAgICAgIHRoaXMubmVlZFZlcmlmeUxhc3RDb2x1bW5XaWR0aCA9IHRydWU7XG5cbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RyZXRjaCA9PT0gJ2xhc3QnICYmIHRvdGFsV2lkdGggIT09IEluZmluaXR5KSB7XG4gICAgICB0aGlzLnN0cmV0Y2hMYXN0V2lkdGggPSAtcmVtYWluaW5nU2l6ZSArIHRoaXMuX2dldENvbHVtbldpZHRoKHRvdGFsQ29sdW1ucyAtIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgc3RyZXRjaGVkIGNvbHVtbiB3aWR0aCBiYXNlZCBvbiBzdHJldGNoSCAoYWxsIG9yIGxhc3QpIHNldHRpbmcgcGFzc2VkIGluIGhhbmRzb250YWJsZSBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbHVtblxuICAgKiBAcGFyYW0ge051bWJlcn0gYmFzZVdpZHRoXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ8bnVsbH1cbiAgICovXG4gIGdldFN0cmV0Y2hlZENvbHVtbldpZHRoKGNvbHVtbiwgYmFzZVdpZHRoKSB7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5zdHJldGNoID09PSAnYWxsJyAmJiB0aGlzLnN0cmV0Y2hBbGxSYXRpbyAhPT0gMCkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5fZ2V0U3RyZXRjaGVkQWxsQ29sdW1uV2lkdGgoY29sdW1uLCBiYXNlV2lkdGgpO1xuXG4gICAgfSBlbHNlIGlmICh0aGlzLnN0cmV0Y2ggPT09ICdsYXN0JyAmJiB0aGlzLnN0cmV0Y2hMYXN0V2lkdGggIT09IDApIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuX2dldFN0cmV0Y2hlZExhc3RDb2x1bW5XaWR0aChjb2x1bW4pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbHVtblxuICAgKiBAcGFyYW0ge051bWJlcn0gYmFzZVdpZHRoXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0U3RyZXRjaGVkQWxsQ29sdW1uV2lkdGgoY29sdW1uLCBiYXNlV2lkdGgpIHtcbiAgICBsZXQgc3VtUmF0aW9XaWR0aCA9IDA7XG4gICAgbGV0IHByaXYgPSBwcml2YXRlUG9vbC5nZXQodGhpcyk7XG4gICAgbGV0IHRvdGFsQ29sdW1ucyA9IHByaXYudG90YWxDb2x1bW5zO1xuXG4gICAgaWYgKCF0aGlzLnN0cmV0Y2hBbGxDb2x1bW5zV2lkdGhbY29sdW1uXSkge1xuICAgICAgdGhpcy5zdHJldGNoQWxsQ29sdW1uc1dpZHRoW2NvbHVtbl0gPSBNYXRoLnJvdW5kKGJhc2VXaWR0aCAqIHRoaXMuc3RyZXRjaEFsbFJhdGlvKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdHJldGNoQWxsQ29sdW1uc1dpZHRoLmxlbmd0aCA9PT0gdG90YWxDb2x1bW5zICYmIHRoaXMubmVlZFZlcmlmeUxhc3RDb2x1bW5XaWR0aCkge1xuICAgICAgdGhpcy5uZWVkVmVyaWZ5TGFzdENvbHVtbldpZHRoID0gZmFsc2U7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdHJldGNoQWxsQ29sdW1uc1dpZHRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN1bVJhdGlvV2lkdGggKz0gdGhpcy5zdHJldGNoQWxsQ29sdW1uc1dpZHRoW2ldO1xuICAgICAgfVxuICAgICAgaWYgKHN1bVJhdGlvV2lkdGggIT09IHRoaXMudG90YWxUYXJnZXRXaWR0aCkge1xuICAgICAgICB0aGlzLnN0cmV0Y2hBbGxDb2x1bW5zV2lkdGhbdGhpcy5zdHJldGNoQWxsQ29sdW1uc1dpZHRoLmxlbmd0aCAtIDFdICs9IHRoaXMudG90YWxUYXJnZXRXaWR0aCAtIHN1bVJhdGlvV2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyZXRjaEFsbENvbHVtbnNXaWR0aFtjb2x1bW5dO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb2x1bW5cbiAgICogQHJldHVybnMge051bWJlcnxudWxsfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldFN0cmV0Y2hlZExhc3RDb2x1bW5XaWR0aChjb2x1bW4pIHtcbiAgICBsZXQgcHJpdiA9IHByaXZhdGVQb29sLmdldCh0aGlzKTtcbiAgICBsZXQgdG90YWxDb2x1bW5zID0gcHJpdi50b3RhbENvbHVtbnM7XG5cbiAgICBpZiAoY29sdW1uID09PSB0b3RhbENvbHVtbnMgLSAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJldGNoTGFzdFdpZHRoO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb2x1bW5cbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRDb2x1bW5XaWR0aChjb2x1bW4pIHtcbiAgICBsZXQgd2lkdGggPSBwcml2YXRlUG9vbC5nZXQodGhpcykuY29sdW1uV2lkdGhGbihjb2x1bW4pO1xuXG4gICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHdpZHRoID0gV2Fsa29udGFibGVWaWV3cG9ydENvbHVtbnNDYWxjdWxhdG9yLkRFRkFVTFRfV0lEVEg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdpZHRoO1xuICB9XG59XG5cbmV4cG9ydCB7V2Fsa29udGFibGVWaWV3cG9ydENvbHVtbnNDYWxjdWxhdG9yfTtcblxud2luZG93LldhbGtvbnRhYmxlVmlld3BvcnRDb2x1bW5zQ2FsY3VsYXRvciA9IFdhbGtvbnRhYmxlVmlld3BvcnRDb2x1bW5zQ2FsY3VsYXRvcjtcbiIsIlxuY29uc3QgcHJpdmF0ZVBvb2wgPSBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgaW5kZXhlcyBvZiByb3dzIHRvIHJlbmRlciBPUiByb3dzIHRoYXQgYXJlIHZpc2libGUuXG4gKiBUbyByZWRvIHRoZSBjYWxjdWxhdGlvbiwgeW91IG5lZWQgdG8gY3JlYXRlIGEgbmV3IGNhbGN1bGF0b3IuXG4gKlxuICogQGNsYXNzIFdhbGtvbnRhYmxlVmlld3BvcnRSb3dzQ2FsY3VsYXRvclxuICovXG5jbGFzcyBXYWxrb250YWJsZVZpZXdwb3J0Um93c0NhbGN1bGF0b3Ige1xuICAvKipcbiAgICogRGVmYXVsdCByb3cgaGVpZ2h0XG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERFRkFVTFRfSEVJR0hUKCkge1xuICAgIHJldHVybiAyMztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmlld3BvcnRIZWlnaHQgSGVpZ2h0IG9mIHRoZSB2aWV3cG9ydFxuICAgKiBAcGFyYW0ge051bWJlcn0gc2Nyb2xsT2Zmc2V0IEN1cnJlbnQgdmVydGljYWwgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSB2aWV3cG9ydFxuICAgKiBAcGFyYW0ge051bWJlcn0gdG90YWxSb3dzIFRvdGFsIG51bWJlciBvZiByb3dzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJvd0hlaWdodEZuIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSByb3cgYXQgYSBnaXZlbiBpbmRleCAoaW4gcHgpXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG92ZXJyaWRlRm4gRnVuY3Rpb24gdGhhdCBjaGFuZ2VzIGNhbGN1bGF0ZWQgdGhpcy5zdGFydFJvdywgdGhpcy5lbmRSb3cgKHVzZWQgYnkgTWVyZ2VDZWxscyBwbHVnaW4pXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb25seUZ1bGx5VmlzaWJsZSBpZiBgdHJ1ZWAsIG9ubHkgc3RhcnRSb3cgYW5kIGVuZFJvdyB3aWxsIGJlIGluZGV4ZXMgb2Ygcm93cyB0aGF0IGFyZSBmdWxseSBpbiB2aWV3cG9ydFxuICAgKi9cbiAgY29uc3RydWN0b3Iodmlld3BvcnRIZWlnaHQsIHNjcm9sbE9mZnNldCwgdG90YWxSb3dzLCByb3dIZWlnaHRGbiwgb3ZlcnJpZGVGbiwgb25seUZ1bGx5VmlzaWJsZSwgaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCkge1xuICAgIHByaXZhdGVQb29sLnNldCh0aGlzLCB7XG4gICAgICB2aWV3cG9ydEhlaWdodCxcbiAgICAgIHNjcm9sbE9mZnNldCxcbiAgICAgIHRvdGFsUm93cyxcbiAgICAgIHJvd0hlaWdodEZuLFxuICAgICAgb3ZlcnJpZGVGbixcbiAgICAgIG9ubHlGdWxseVZpc2libGUsXG4gICAgICBob3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgcmVuZGVyZWQvdmlzaWJsZSByb3dzXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuY291bnQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogSW5kZXggb2YgdGhlIGZpcnN0IHJlbmRlcmVkL3Zpc2libGUgcm93IChjYW4gYmUgb3ZlcndyaXR0ZW4gdXNpbmcgb3ZlcnJpZGVGbilcbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXJ0Um93ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEluZGV4IG9mIHRoZSBsYXN0IHJlbmRlcmVkL3Zpc2libGUgcm93IChjYW4gYmUgb3ZlcndyaXR0ZW4gdXNpbmcgb3ZlcnJpZGVGbilcbiAgICAgKlxuICAgICAqIEB0eXBlIHtudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZW5kUm93ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIG9mIHRoZSBmaXJzdCByZW5kZXJlZC92aXNpYmxlIHJvdyAoaW4gcHgpXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TnVtYmVyfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zdGFydFBvc2l0aW9uID0gbnVsbDtcblxuICAgIHRoaXMuY2FsY3VsYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB2aWV3cG9ydFxuICAgKi9cbiAgY2FsY3VsYXRlKCkge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGxldCBuZWVkUmV2ZXJzZSA9IHRydWU7XG4gICAgbGV0IHN0YXJ0UG9zaXRpb25zID0gW107XG5cbiAgICBsZXQgcHJpdiA9IHByaXZhdGVQb29sLmdldCh0aGlzKTtcbiAgICBsZXQgb25seUZ1bGx5VmlzaWJsZSA9IHByaXYub25seUZ1bGx5VmlzaWJsZTtcbiAgICBsZXQgb3ZlcnJpZGVGbiA9IHByaXYub3ZlcnJpZGVGbjtcbiAgICBsZXQgcm93SGVpZ2h0Rm4gPSBwcml2LnJvd0hlaWdodEZuO1xuICAgIGxldCBzY3JvbGxPZmZzZXQgPSBwcml2LnNjcm9sbE9mZnNldDtcbiAgICBsZXQgdG90YWxSb3dzID0gcHJpdi50b3RhbFJvd3M7XG4gICAgbGV0IHZpZXdwb3J0SGVpZ2h0ID0gcHJpdi52aWV3cG9ydEhlaWdodDtcbiAgICBsZXQgaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCA9IHByaXYuaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCB8fCAwO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBudW1iZXIgKHN0YXJ0IGFuZCBlbmQgaW5kZXgpIG9mIHJvd3MgbmVlZGVkXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbFJvd3M7IGkrKykge1xuICAgICAgbGV0IHJvd0hlaWdodCA9IHJvd0hlaWdodEZuKGkpO1xuXG4gICAgICBpZiAocm93SGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcm93SGVpZ2h0ID0gV2Fsa29udGFibGVWaWV3cG9ydFJvd3NDYWxjdWxhdG9yLkRFRkFVTFRfSEVJR0hUO1xuICAgICAgfVxuICAgICAgaWYgKHN1bSA8PSBzY3JvbGxPZmZzZXQgJiYgIW9ubHlGdWxseVZpc2libGUpIHtcbiAgICAgICAgdGhpcy5zdGFydFJvdyA9IGk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRoZSByb3cgaXMgd2l0aGluIHRoZSBcInZpc2libGUgcmFuZ2VcIlxuICAgICAgaWYgKHN1bSA+PSBzY3JvbGxPZmZzZXQgJiYgc3VtICsgcm93SGVpZ2h0IDw9IHNjcm9sbE9mZnNldCArIHZpZXdwb3J0SGVpZ2h0IC0gaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCkge1xuICAgICAgICBpZiAodGhpcy5zdGFydFJvdyA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuc3RhcnRSb3cgPSBpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5kUm93ID0gaTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0UG9zaXRpb25zLnB1c2goc3VtKTtcbiAgICAgIHN1bSArPSByb3dIZWlnaHQ7XG5cbiAgICAgIGlmICghb25seUZ1bGx5VmlzaWJsZSkge1xuICAgICAgICB0aGlzLmVuZFJvdyA9IGk7XG4gICAgICB9XG4gICAgICBpZiAoc3VtID49IHNjcm9sbE9mZnNldCArIHZpZXdwb3J0SGVpZ2h0IC0gaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCkge1xuICAgICAgICBuZWVkUmV2ZXJzZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL0lmIHRoZSBlc3RpbWF0aW9uIGhhcyByZWFjaGVkIHRoZSBsYXN0IHJvdyBhbmQgdGhlcmUgaXMgc3RpbGwgc29tZSBzcGFjZSBhdmFpbGFibGUgaW4gdGhlIHZpZXdwb3J0LFxuICAgIC8vd2UgbmVlZCB0byByZW5kZXIgaW4gcmV2ZXJzZSBpbiBvcmRlciB0byBmaWxsIHRoZSB3aG9sZSB2aWV3cG9ydCB3aXRoIHJvd3NcbiAgICBpZiAodGhpcy5lbmRSb3cgPT09IHRvdGFsUm93cyAtIDEgJiYgbmVlZFJldmVyc2UpIHtcbiAgICAgIHRoaXMuc3RhcnRSb3cgPSB0aGlzLmVuZFJvdztcblxuICAgICAgd2hpbGUgKHRoaXMuc3RhcnRSb3cgPiAwKSB7XG4gICAgICAgIC8vIHJvd0hlaWdodCBpcyB0aGUgaGVpZ2h0IG9mIHRoZSBsYXN0IHJvd1xuICAgICAgICBsZXQgdmlld3BvcnRTdW0gPSBzdGFydFBvc2l0aW9uc1t0aGlzLmVuZFJvd10gKyByb3dIZWlnaHQgLSBzdGFydFBvc2l0aW9uc1t0aGlzLnN0YXJ0Um93IC0gMV07XG5cbiAgICAgICAgaWYgKHZpZXdwb3J0U3VtIDw9IHZpZXdwb3J0SGVpZ2h0IC0gaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCB8fCAhb25seUZ1bGx5VmlzaWJsZSkge1xuICAgICAgICAgIHRoaXMuc3RhcnRSb3ctLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlld3BvcnRTdW0gPj0gdmlld3BvcnRIZWlnaHQgLSBob3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGFydFJvdyAhPT0gbnVsbCAmJiBvdmVycmlkZUZuKSB7XG4gICAgICBvdmVycmlkZUZuKHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uc1t0aGlzLnN0YXJ0Um93XTtcblxuICAgIGlmICh0aGlzLnN0YXJ0UG9zaXRpb24gPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGFydFJvdyAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5jb3VudCA9IHRoaXMuZW5kUm93IC0gdGhpcy5zdGFydFJvdyArIDE7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7V2Fsa29udGFibGVWaWV3cG9ydFJvd3NDYWxjdWxhdG9yfTtcblxud2luZG93LldhbGtvbnRhYmxlVmlld3BvcnRSb3dzQ2FsY3VsYXRvciA9IFdhbGtvbnRhYmxlVmlld3BvcnRSb3dzQ2FsY3VsYXRvcjtcbiIsIlxuLyoqXG4gKiBXYWxrb250YWJsZUNlbGxDb29yZHMgaG9sZHMgY2VsbCBjb29yZGluYXRlcyAocm93LCBjb2x1bW4pIGFuZCBmZXcgbWV0aG9kIHRvIHZhbGlkYXRlIHRoZW0gYW5kXG4gKiByZXRyaWV2ZSBhcyBhbiBhcnJheSBvciBhbiBvYmplY3RcbiAqXG4gKiBAY2xhc3MgV2Fsa29udGFibGVDZWxsQ29vcmRzXG4gKi9cbmNsYXNzIFdhbGtvbnRhYmxlQ2VsbENvb3JkcyB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gcm93IFJvdyBpbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gY29sIENvbHVtbiBpbmRleFxuICAgKi9cbiAgY29uc3RydWN0b3Iocm93LCBjb2wpIHtcbiAgICBpZiAodHlwZW9mIHJvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMucm93ID0gcm93O1xuICAgICAgdGhpcy5jb2wgPSBjb2w7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yb3cgPSBudWxsO1xuICAgICAgdGhpcy5jb2wgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgZ2l2ZW4gc2V0IG9mIGNvb3JkaW5hdGVzIGlzIHZhbGlkIGluIGNvbnRleHQgb2YgYSBnaXZlbiBXYWxrb250YWJsZSBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0ge1dhbGtvbnRhYmxlfSB3b3RJbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGlzVmFsaWQod290SW5zdGFuY2UpIHtcbiAgICAvLyBpcyBpdCBhIHZhbGlkIGNlbGwgaW5kZXggKDAgb3IgaGlnaGVyKVxuICAgIGlmICh0aGlzLnJvdyA8IDAgfHwgdGhpcy5jb2wgPCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGlzIHNlbGVjdGlvbiB3aXRoaW4gdG90YWwgcm93cyBhbmQgY29sdW1uc1xuICAgIGlmICh0aGlzLnJvdyA+PSB3b3RJbnN0YW5jZS5nZXRTZXR0aW5nKCd0b3RhbFJvd3MnKSB8fCB0aGlzLmNvbCA+PSB3b3RJbnN0YW5jZS5nZXRTZXR0aW5nKCd0b3RhbENvbHVtbnMnKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGNlbGwgY29vcmRzIGFyZSB0aGUgc2FtZSBhcyBjZWxsIGNvb3JkcyBnaXZlbiBhcyBhIHBhcmFtZXRlclxuICAgKlxuICAgKiBAcGFyYW0ge1dhbGtvbnRhYmxlQ2VsbENvb3Jkc30gY2VsbENvb3Jkc1xuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGlzRXF1YWwoY2VsbENvb3Jkcykge1xuICAgIGlmIChjZWxsQ29vcmRzID09PSB0aGlzKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yb3cgPT09IGNlbGxDb29yZHMucm93ICYmIHRoaXMuY29sID09PSBjZWxsQ29vcmRzLmNvbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGVzdGVkIGNvb3JkaW5hdGVzIGFyZSBwb3NpdGlvbmVkIGluIHNvdXRoLWVhc3QgZnJvbSB0aGlzIGNlbGwgY29vcmRzXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0ZXN0ZWRDb29yZHNcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBpc1NvdXRoRWFzdE9mKHRlc3RlZENvb3Jkcykge1xuICAgIHJldHVybiB0aGlzLnJvdyA+PSB0ZXN0ZWRDb29yZHMucm93ICYmIHRoaXMuY29sID49IHRlc3RlZENvb3Jkcy5jb2w7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRlc3RlZCBjb29yZGluYXRlcyBhcmUgcG9zaXRpb25lZCBpbiBub3J0aC1lYXN0IGZyb20gdGhpcyBjZWxsIGNvb3Jkc1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdGVzdGVkQ29vcmRzXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgaXNOb3J0aFdlc3RPZih0ZXN0ZWRDb29yZHMpIHtcbiAgICByZXR1cm4gdGhpcy5yb3cgPD0gdGVzdGVkQ29vcmRzLnJvdyAmJiB0aGlzLmNvbCA8PSB0ZXN0ZWRDb29yZHMuY29sO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0ZXN0ZWQgY29vcmRpbmF0ZXMgYXJlIHBvc2l0aW9uZWQgaW4gc291dGgtd2VzdCBmcm9tIHRoaXMgY2VsbCBjb29yZHNcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHRlc3RlZENvb3Jkc1xuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGlzU291dGhXZXN0T2YodGVzdGVkQ29vcmRzKSB7XG4gICAgcmV0dXJuIHRoaXMucm93ID49IHRlc3RlZENvb3Jkcy5yb3cgJiYgdGhpcy5jb2wgPD0gdGVzdGVkQ29vcmRzLmNvbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGVzdGVkIGNvb3JkaW5hdGVzIGFyZSBwb3NpdGlvbmVkIGluIG5vcnRoLWVhc3QgZnJvbSB0aGlzIGNlbGwgY29vcmRzXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0ZXN0ZWRDb29yZHNcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBpc05vcnRoRWFzdE9mKHRlc3RlZENvb3Jkcykge1xuICAgIHJldHVybiB0aGlzLnJvdyA8PSB0ZXN0ZWRDb29yZHMucm93ICYmIHRoaXMuY29sID49IHRlc3RlZENvb3Jkcy5jb2w7XG4gIH1cbn1cblxuZXhwb3J0IHtXYWxrb250YWJsZUNlbGxDb29yZHN9O1xuXG53aW5kb3cuV2Fsa29udGFibGVDZWxsQ29vcmRzID0gV2Fsa29udGFibGVDZWxsQ29vcmRzO1xuIiwiXG5pbXBvcnQge1dhbGtvbnRhYmxlQ2VsbENvb3Jkc30gZnJvbSAnLi8uLi9jZWxsL2Nvb3Jkcyc7XG5cbi8qKlxuICogQSBjZWxsIHJhbmdlIGlzIGEgc2V0IG9mIGV4YWN0bHkgdHdvIFdhbGtvbnRhYmxlQ2VsbENvb3JkcyAodGhhdCBjYW4gYmUgdGhlIHNhbWUgb3IgZGlmZmVyZW50KVxuICpcbiAqIEBjbGFzcyBXYWxrb250YWJsZUNlbGxSYW5nZVxuICovXG5jbGFzcyBXYWxrb250YWJsZUNlbGxSYW5nZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1dhbGtvbnRhYmxlQ2VsbENvb3Jkc30gaGlnaGxpZ2h0IFVzZWQgdG8gZHJhdyBib2xkIGJvcmRlciBhcm91bmQgYSBjZWxsIHdoZXJlIHNlbGVjdGlvbiB3YXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydGVkIGFuZCB0byBlZGl0IHRoZSBjZWxsIHdoZW4geW91IHByZXNzIEVudGVyXG4gICAqIEBwYXJhbSB7V2Fsa29udGFibGVDZWxsQ29vcmRzfSBmcm9tIFVzdWFsbHkgdGhlIHNhbWUgYXMgaGlnaGxpZ2h0LCBidXQgaW4gRXhjZWwgdGhlcmUgaXMgZGlzdGluY3Rpb24gLSBvbmUgY2FuIGNoYW5nZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHQgd2l0aGluIGEgc2VsZWN0aW9uXG4gICAqIEBwYXJhbSB7V2Fsa29udGFibGVDZWxsQ29vcmRzfSB0byBFbmQgc2VsZWN0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihoaWdobGlnaHQsIGZyb20sIHRvKSB7XG4gICAgdGhpcy5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG4gICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICB0aGlzLnRvID0gdG87XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGdpdmVuIGNvb3JkcyBhcmUgdmFsaWQgaW4gY29udGV4dCBvZiBhIGdpdmVuIFdhbGtvbnRhYmxlIGluc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7V2Fsa29udGFibGV9IHdvdEluc3RhbmNlXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgaXNWYWxpZCh3b3RJbnN0YW5jZSkge1xuICAgIHJldHVybiB0aGlzLmZyb20uaXNWYWxpZCh3b3RJbnN0YW5jZSkgJiYgdGhpcy50by5pc1ZhbGlkKHdvdEluc3RhbmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBjZWxsIHJhbmdlIGlzIHJlc3RyaWN0ZWQgdG8gb25lIGNlbGxcbiAgICpcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBpc1NpbmdsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tLnJvdyA9PT0gdGhpcy50by5yb3cgJiYgdGhpcy5mcm9tLmNvbCA9PT0gdGhpcy50by5jb2w7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBzZWxlY3RlZCByYW5nZSBoZWlnaHQgKGluIG51bWJlciBvZiByb3dzKVxuICAgKlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0SGVpZ2h0KCkge1xuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmZyb20ucm93LCB0aGlzLnRvLnJvdykgLSBNYXRoLm1pbih0aGlzLmZyb20ucm93LCB0aGlzLnRvLnJvdykgKyAxO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgc2VsZWN0ZWQgcmFuZ2Ugd2lkdGggKGluIG51bWJlciBvZiBjb2x1bW5zKVxuICAgKlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0V2lkdGgoKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuZnJvbS5jb2wsIHRoaXMudG8uY29sKSAtIE1hdGgubWluKHRoaXMuZnJvbS5jb2wsIHRoaXMudG8uY29sKSArIDE7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGdpdmVuIGNlbGwgY29vcmRzIGlzIHdpdGhpbiBgZnJvbWAgYW5kIGB0b2AgY2VsbCBjb29yZHMgb2YgdGhpcyByYW5nZVxuICAgKlxuICAgKiBAcGFyYW0ge1dhbGtvbnRhYmxlQ2VsbENvb3Jkc30gY2VsbENvb3Jkc1xuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGluY2x1ZGVzKGNlbGxDb29yZHMpIHtcbiAgICBsZXQgdG9wTGVmdCA9IHRoaXMuZ2V0VG9wTGVmdENvcm5lcigpO1xuICAgIGxldCBib3R0b21SaWdodCA9IHRoaXMuZ2V0Qm90dG9tUmlnaHRDb3JuZXIoKTtcblxuICAgIGlmIChjZWxsQ29vcmRzLnJvdyA8IDApIHtcbiAgICAgIGNlbGxDb29yZHMucm93ID0gMDtcbiAgICB9XG4gICAgaWYgKGNlbGxDb29yZHMuY29sIDwgMCkge1xuICAgICAgY2VsbENvb3Jkcy5jb2wgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiB0b3BMZWZ0LnJvdyA8PSBjZWxsQ29vcmRzLnJvdyAmJiBib3R0b21SaWdodC5yb3cgPj0gY2VsbENvb3Jkcy5yb3cgJiZcbiAgICAgICAgdG9wTGVmdC5jb2wgPD0gY2VsbENvb3Jkcy5jb2wgJiYgYm90dG9tUmlnaHQuY29sID49IGNlbGxDb29yZHMuY29sO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBnaXZlbiByYW5nZSBpcyB3aXRoaW4gb2YgdGhpcyByYW5nZVxuICAgKlxuICAgKiBAcGFyYW0ge1dhbGtvbnRhYmxlQ2VsbFJhbmdlfSB0ZXN0ZWRSYW5nZVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGluY2x1ZGVzUmFuZ2UodGVzdGVkUmFuZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5pbmNsdWRlcyh0ZXN0ZWRSYW5nZS5nZXRUb3BMZWZ0Q29ybmVyKCkpICYmIHRoaXMuaW5jbHVkZXModGVzdGVkUmFuZ2UuZ2V0Qm90dG9tUmlnaHRDb3JuZXIoKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGdpdmVuIHJhbmdlIGlzIGVxdWFsIHRvIHRoaXMgcmFuZ2VcbiAgICpcbiAgICogQHBhcmFtIHtXYWxrb250YWJsZUNlbGxSYW5nZX0gdGVzdGVkUmFuZ2VcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBpc0VxdWFsKHRlc3RlZFJhbmdlKSB7XG4gICAgcmV0dXJuIChNYXRoLm1pbih0aGlzLmZyb20ucm93LCB0aGlzLnRvLnJvdykgPT0gTWF0aC5taW4odGVzdGVkUmFuZ2UuZnJvbS5yb3csIHRlc3RlZFJhbmdlLnRvLnJvdykpICYmXG4gICAgICAgICAgIChNYXRoLm1heCh0aGlzLmZyb20ucm93LCB0aGlzLnRvLnJvdykgPT0gTWF0aC5tYXgodGVzdGVkUmFuZ2UuZnJvbS5yb3csIHRlc3RlZFJhbmdlLnRvLnJvdykpICYmXG4gICAgICAgICAgIChNYXRoLm1pbih0aGlzLmZyb20uY29sLCB0aGlzLnRvLmNvbCkgPT0gTWF0aC5taW4odGVzdGVkUmFuZ2UuZnJvbS5jb2wsIHRlc3RlZFJhbmdlLnRvLmNvbCkpICYmXG4gICAgICAgICAgIChNYXRoLm1heCh0aGlzLmZyb20uY29sLCB0aGlzLnRvLmNvbCkgPT0gTWF0aC5tYXgodGVzdGVkUmFuZ2UuZnJvbS5jb2wsIHRlc3RlZFJhbmdlLnRvLmNvbCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0ZXN0ZWQgcmFuZ2Ugb3ZlcmxhcHMgd2l0aCB0aGUgcmFuZ2UuXG4gICAqIFJhbmdlIEEgaXMgY29uc2lkZXJlZCB0byB0byBiZSBvdmVybGFwcGluZyB3aXRoIHJhbmdlIEIgaWYgaW50ZXJzZWN0aW9uIG9mIEEgYW5kIEIgb3IgQiBhbmQgQSBpcyBub3QgZW1wdHkuXG4gICAqXG4gICAqIEBwYXJhbSB7V2Fsa29udGFibGVDZWxsUmFuZ2V9IHRlc3RlZFJhbmdlXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgb3ZlcmxhcHModGVzdGVkUmFuZ2UpIHtcbiAgICByZXR1cm4gdGVzdGVkUmFuZ2UuaXNTb3V0aEVhc3RPZih0aGlzLmdldFRvcExlZnRDb3JuZXIoKSkgJiYgdGVzdGVkUmFuZ2UuaXNOb3J0aFdlc3RPZih0aGlzLmdldEJvdHRvbVJpZ2h0Q29ybmVyKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7V2Fsa29udGFibGVDZWxsUmFuZ2V9IHRlc3RlZENvb3Jkc1xuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGlzU291dGhFYXN0T2YodGVzdGVkQ29vcmRzKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9wTGVmdENvcm5lcigpLmlzU291dGhFYXN0T2YodGVzdGVkQ29vcmRzKSB8fCB0aGlzLmdldEJvdHRvbVJpZ2h0Q29ybmVyKCkuaXNTb3V0aEVhc3RPZih0ZXN0ZWRDb29yZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7V2Fsa29udGFibGVDZWxsUmFuZ2V9IHRlc3RlZENvb3Jkc1xuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGlzTm9ydGhXZXN0T2YodGVzdGVkQ29vcmRzKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VG9wTGVmdENvcm5lcigpLmlzTm9ydGhXZXN0T2YodGVzdGVkQ29vcmRzKSB8fCB0aGlzLmdldEJvdHRvbVJpZ2h0Q29ybmVyKCkuaXNOb3J0aFdlc3RPZih0ZXN0ZWRDb29yZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjZWxsIHRvIGEgcmFuZ2UgKG9ubHkgaWYgZXhjZWVkcyBjb3JuZXJzIG9mIHRoZSByYW5nZSkuIFJldHVybnMgaW5mb3JtYXRpb24gaWYgcmFuZ2Ugd2FzIGV4cGFuZGVkXG4gICAqXG4gICAqIEBwYXJhbSB7V2Fsa29udGFibGVDZWxsQ29vcmRzfSBjZWxsQ29vcmRzXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgZXhwYW5kKGNlbGxDb29yZHMpIHtcbiAgICBsZXQgdG9wTGVmdCA9IHRoaXMuZ2V0VG9wTGVmdENvcm5lcigpO1xuICAgIGxldCBib3R0b21SaWdodCA9IHRoaXMuZ2V0Qm90dG9tUmlnaHRDb3JuZXIoKTtcblxuICAgIGlmIChjZWxsQ29vcmRzLnJvdyA8IHRvcExlZnQucm93IHx8IGNlbGxDb29yZHMuY29sIDwgdG9wTGVmdC5jb2wgfHxcbiAgICAgICAgY2VsbENvb3Jkcy5yb3cgPiBib3R0b21SaWdodC5yb3cgfHwgY2VsbENvb3Jkcy5jb2wgPiBib3R0b21SaWdodC5jb2wpIHtcbiAgICAgIHRoaXMuZnJvbSA9IG5ldyBXYWxrb250YWJsZUNlbGxDb29yZHMoTWF0aC5taW4odG9wTGVmdC5yb3csIGNlbGxDb29yZHMucm93KSwgTWF0aC5taW4odG9wTGVmdC5jb2wsIGNlbGxDb29yZHMuY29sKSk7XG4gICAgICB0aGlzLnRvID0gbmV3IFdhbGtvbnRhYmxlQ2VsbENvb3JkcyhNYXRoLm1heChib3R0b21SaWdodC5yb3csIGNlbGxDb29yZHMucm93KSwgTWF0aC5tYXgoYm90dG9tUmlnaHQuY29sLCBjZWxsQ29vcmRzLmNvbCkpO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtXYWxrb250YWJsZUNlbGxSYW5nZX0gZXhwYW5kaW5nUmFuZ2VcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBleHBhbmRCeVJhbmdlKGV4cGFuZGluZ1JhbmdlKSB7XG4gICAgaWYgKHRoaXMuaW5jbHVkZXNSYW5nZShleHBhbmRpbmdSYW5nZSkgfHwgIXRoaXMub3ZlcmxhcHMoZXhwYW5kaW5nUmFuZ2UpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHRvcExlZnQgPSB0aGlzLmdldFRvcExlZnRDb3JuZXIoKTtcbiAgICBsZXQgYm90dG9tUmlnaHQgPSB0aGlzLmdldEJvdHRvbVJpZ2h0Q29ybmVyKCk7XG4gICAgbGV0IHRvcFJpZ2h0ID0gdGhpcy5nZXRUb3BSaWdodENvcm5lcigpO1xuICAgIGxldCBib3R0b21MZWZ0ID0gdGhpcy5nZXRCb3R0b21MZWZ0Q29ybmVyKCk7XG5cbiAgICBsZXQgZXhwYW5kaW5nVG9wTGVmdCA9IGV4cGFuZGluZ1JhbmdlLmdldFRvcExlZnRDb3JuZXIoKTtcbiAgICBsZXQgZXhwYW5kaW5nQm90dG9tUmlnaHQgPSBleHBhbmRpbmdSYW5nZS5nZXRCb3R0b21SaWdodENvcm5lcigpO1xuXG4gICAgbGV0IHJlc3VsdFRvcFJvdyA9IE1hdGgubWluKHRvcExlZnQucm93LCBleHBhbmRpbmdUb3BMZWZ0LnJvdyk7XG4gICAgbGV0IHJlc3VsdFRvcENvbCA9IE1hdGgubWluKHRvcExlZnQuY29sLCBleHBhbmRpbmdUb3BMZWZ0LmNvbCk7XG4gICAgbGV0IHJlc3VsdEJvdHRvbVJvdyA9IE1hdGgubWF4KGJvdHRvbVJpZ2h0LnJvdywgZXhwYW5kaW5nQm90dG9tUmlnaHQucm93KTtcbiAgICBsZXQgcmVzdWx0Qm90dG9tQ29sID0gTWF0aC5tYXgoYm90dG9tUmlnaHQuY29sLCBleHBhbmRpbmdCb3R0b21SaWdodC5jb2wpO1xuXG4gICAgbGV0IGZpbmFsRnJvbSA9IG5ldyBXYWxrb250YWJsZUNlbGxDb29yZHMocmVzdWx0VG9wUm93LCByZXN1bHRUb3BDb2wpLFxuICAgICAgZmluYWxUbyA9IG5ldyBXYWxrb250YWJsZUNlbGxDb29yZHMocmVzdWx0Qm90dG9tUm93LCByZXN1bHRCb3R0b21Db2wpO1xuICAgIGxldCBpc0Nvcm5lciA9IG5ldyBXYWxrb250YWJsZUNlbGxSYW5nZShmaW5hbEZyb20sIGZpbmFsRnJvbSwgZmluYWxUbykuaXNDb3JuZXIodGhpcy5mcm9tLCBleHBhbmRpbmdSYW5nZSksXG4gICAgICBvbmx5TWVyZ2UgPSBleHBhbmRpbmdSYW5nZS5pc0VxdWFsKG5ldyBXYWxrb250YWJsZUNlbGxSYW5nZShmaW5hbEZyb20sIGZpbmFsRnJvbSwgZmluYWxUbykpO1xuXG4gICAgaWYgKGlzQ29ybmVyICYmICFvbmx5TWVyZ2UpIHtcbiAgICAgIGlmICh0aGlzLmZyb20uY29sID4gZmluYWxGcm9tLmNvbCkge1xuICAgICAgICBmaW5hbEZyb20uY29sID0gcmVzdWx0Qm90dG9tQ29sO1xuICAgICAgICBmaW5hbFRvLmNvbCA9IHJlc3VsdFRvcENvbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmZyb20ucm93ID4gZmluYWxGcm9tLnJvdykge1xuICAgICAgICBmaW5hbEZyb20ucm93ID0gcmVzdWx0Qm90dG9tUm93O1xuICAgICAgICBmaW5hbFRvLnJvdyA9IHJlc3VsdFRvcFJvdztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5mcm9tID0gZmluYWxGcm9tO1xuICAgIHRoaXMudG8gPSBmaW5hbFRvO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIGdldERpcmVjdGlvbigpIHtcbiAgICBpZiAodGhpcy5mcm9tLmlzTm9ydGhXZXN0T2YodGhpcy50bykpIHsgLy8gTm9ydGhXZXN0IC0gU291dGhFYXN0XG4gICAgICByZXR1cm4gJ05XLVNFJztcblxuICAgIH0gZWxzZSBpZiAodGhpcy5mcm9tLmlzTm9ydGhFYXN0T2YodGhpcy50bykpIHsgLy8gTm9ydGhFYXN0IC0gU291dGhXZXN0XG4gICAgICByZXR1cm4gJ05FLVNXJztcblxuICAgIH0gZWxzZSBpZiAodGhpcy5mcm9tLmlzU291dGhFYXN0T2YodGhpcy50bykpIHsgLy8gU291dGhFYXN0IC0gTm9ydGhXZXN0XG4gICAgICByZXR1cm4gJ1NFLU5XJztcblxuICAgIH0gZWxzZSBpZiAodGhpcy5mcm9tLmlzU291dGhXZXN0T2YodGhpcy50bykpIHsgLy8gU291dGhXZXN0IC0gTm9ydGhFYXN0XG4gICAgICByZXR1cm4gJ1NXLU5FJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRpcmVjdGlvblxuICAgKi9cbiAgc2V0RGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICBjYXNlICdOVy1TRSc6XG4gICAgICAgIHRoaXMuZnJvbSA9IHRoaXMuZ2V0VG9wTGVmdENvcm5lcigpO1xuICAgICAgICB0aGlzLnRvID0gdGhpcy5nZXRCb3R0b21SaWdodENvcm5lcigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ05FLVNXJzpcbiAgICAgICAgdGhpcy5mcm9tID0gdGhpcy5nZXRUb3BSaWdodENvcm5lcigpO1xuICAgICAgICB0aGlzLnRvID0gdGhpcy5nZXRCb3R0b21MZWZ0Q29ybmVyKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnU0UtTlcnOlxuICAgICAgICB0aGlzLmZyb20gPSB0aGlzLmdldEJvdHRvbVJpZ2h0Q29ybmVyKCk7XG4gICAgICAgIHRoaXMudG8gPSB0aGlzLmdldFRvcExlZnRDb3JuZXIoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdTVy1ORSc6XG4gICAgICAgIHRoaXMuZnJvbSA9IHRoaXMuZ2V0Qm90dG9tTGVmdENvcm5lcigpO1xuICAgICAgICB0aGlzLnRvID0gdGhpcy5nZXRUb3BSaWdodENvcm5lcigpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRvcCBsZWZ0IGNvcm5lciBvZiB0aGlzIHJhbmdlXG4gICAqXG4gICAqIEByZXR1cm5zIHtXYWxrb250YWJsZUNlbGxDb29yZHN9XG4gICAqL1xuICBnZXRUb3BMZWZ0Q29ybmVyKCkge1xuICAgIHJldHVybiBuZXcgV2Fsa29udGFibGVDZWxsQ29vcmRzKE1hdGgubWluKHRoaXMuZnJvbS5yb3csIHRoaXMudG8ucm93KSwgTWF0aC5taW4odGhpcy5mcm9tLmNvbCwgdGhpcy50by5jb2wpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGlzIHJhbmdlXG4gICAqXG4gICAqIEByZXR1cm5zIHtXYWxrb250YWJsZUNlbGxDb29yZHN9XG4gICAqL1xuICBnZXRCb3R0b21SaWdodENvcm5lcigpIHtcbiAgICByZXR1cm4gbmV3IFdhbGtvbnRhYmxlQ2VsbENvb3JkcyhNYXRoLm1heCh0aGlzLmZyb20ucm93LCB0aGlzLnRvLnJvdyksIE1hdGgubWF4KHRoaXMuZnJvbS5jb2wsIHRoaXMudG8uY29sKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRvcCByaWdodCBjb3JuZXIgb2YgdGhpcyByYW5nZVxuICAgKlxuICAgKiBAcmV0dXJucyB7V2Fsa29udGFibGVDZWxsQ29vcmRzfVxuICAgKi9cbiAgZ2V0VG9wUmlnaHRDb3JuZXIoKSB7XG4gICAgcmV0dXJuIG5ldyBXYWxrb250YWJsZUNlbGxDb29yZHMoTWF0aC5taW4odGhpcy5mcm9tLnJvdywgdGhpcy50by5yb3cpLCBNYXRoLm1heCh0aGlzLmZyb20uY29sLCB0aGlzLnRvLmNvbCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBib3R0b20gbGVmdCBjb3JuZXIgb2YgdGhpcyByYW5nZVxuICAgKlxuICAgKiBAcmV0dXJucyB7V2Fsa29udGFibGVDZWxsQ29vcmRzfVxuICAgKi9cbiAgZ2V0Qm90dG9tTGVmdENvcm5lcigpIHtcbiAgICByZXR1cm4gbmV3IFdhbGtvbnRhYmxlQ2VsbENvb3JkcyhNYXRoLm1heCh0aGlzLmZyb20ucm93LCB0aGlzLnRvLnJvdyksIE1hdGgubWluKHRoaXMuZnJvbS5jb2wsIHRoaXMudG8uY29sKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtXYWxrb250YWJsZUNlbGxDb29yZHN9IGNvb3Jkc1xuICAgKiBAcGFyYW0ge1dhbGtvbnRhYmxlQ2VsbFJhbmdlfSBleHBhbmRlZFJhbmdlXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgaXNDb3JuZXIoY29vcmRzLCBleHBhbmRlZFJhbmdlKSB7XG4gICAgaWYgKGV4cGFuZGVkUmFuZ2UpIHtcbiAgICAgIGlmIChleHBhbmRlZFJhbmdlLmluY2x1ZGVzKGNvb3JkcykpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VG9wTGVmdENvcm5lcigpLmlzRXF1YWwobmV3IFdhbGtvbnRhYmxlQ2VsbENvb3JkcyhleHBhbmRlZFJhbmdlLmZyb20ucm93LCBleHBhbmRlZFJhbmdlLmZyb20uY29sKSkgfHxcbiAgICAgICAgICAgIHRoaXMuZ2V0VG9wUmlnaHRDb3JuZXIoKS5pc0VxdWFsKG5ldyBXYWxrb250YWJsZUNlbGxDb29yZHMoZXhwYW5kZWRSYW5nZS5mcm9tLnJvdywgZXhwYW5kZWRSYW5nZS50by5jb2wpKSB8fFxuICAgICAgICAgICAgdGhpcy5nZXRCb3R0b21MZWZ0Q29ybmVyKCkuaXNFcXVhbChuZXcgV2Fsa29udGFibGVDZWxsQ29vcmRzKGV4cGFuZGVkUmFuZ2UudG8ucm93LCBleHBhbmRlZFJhbmdlLmZyb20uY29sKSkgfHxcbiAgICAgICAgICAgIHRoaXMuZ2V0Qm90dG9tUmlnaHRDb3JuZXIoKS5pc0VxdWFsKG5ldyBXYWxrb250YWJsZUNlbGxDb29yZHMoZXhwYW5kZWRSYW5nZS50by5yb3csIGV4cGFuZGVkUmFuZ2UudG8uY29sKSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb29yZHMuaXNFcXVhbCh0aGlzLmdldFRvcExlZnRDb3JuZXIoKSkgfHwgY29vcmRzLmlzRXF1YWwodGhpcy5nZXRUb3BSaWdodENvcm5lcigpKSB8fFxuICAgICAgY29vcmRzLmlzRXF1YWwodGhpcy5nZXRCb3R0b21MZWZ0Q29ybmVyKCkpIHx8IGNvb3Jkcy5pc0VxdWFsKHRoaXMuZ2V0Qm90dG9tUmlnaHRDb3JuZXIoKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtXYWxrb250YWJsZUNlbGxDb29yZHN9IGNvb3Jkc1xuICAgKiBAcGFyYW0ge1dhbGtvbnRhYmxlQ2VsbFJhbmdlfSBleHBhbmRlZFJhbmdlXG4gICAqIEByZXR1cm5zIHtXYWxrb250YWJsZUNlbGxDb29yZHN9XG4gICAqL1xuICBnZXRPcHBvc2l0ZUNvcm5lcihjb29yZHMsIGV4cGFuZGVkUmFuZ2UpIHtcbiAgICBpZiAoIShjb29yZHMgaW5zdGFuY2VvZiBXYWxrb250YWJsZUNlbGxDb29yZHMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGV4cGFuZGVkUmFuZ2UpIHtcbiAgICAgIGlmIChleHBhbmRlZFJhbmdlLmluY2x1ZGVzKGNvb3JkcykpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VG9wTGVmdENvcm5lcigpLmlzRXF1YWwobmV3IFdhbGtvbnRhYmxlQ2VsbENvb3JkcyhleHBhbmRlZFJhbmdlLmZyb20ucm93LCBleHBhbmRlZFJhbmdlLmZyb20uY29sKSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCb3R0b21SaWdodENvcm5lcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdldFRvcFJpZ2h0Q29ybmVyKCkuaXNFcXVhbChuZXcgV2Fsa29udGFibGVDZWxsQ29vcmRzKGV4cGFuZGVkUmFuZ2UuZnJvbS5yb3csIGV4cGFuZGVkUmFuZ2UudG8uY29sKSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRCb3R0b21MZWZ0Q29ybmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ2V0Qm90dG9tTGVmdENvcm5lcigpLmlzRXF1YWwobmV3IFdhbGtvbnRhYmxlQ2VsbENvb3JkcyhleHBhbmRlZFJhbmdlLnRvLnJvdywgZXhwYW5kZWRSYW5nZS5mcm9tLmNvbCkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9wUmlnaHRDb3JuZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5nZXRCb3R0b21SaWdodENvcm5lcigpLmlzRXF1YWwobmV3IFdhbGtvbnRhYmxlQ2VsbENvb3JkcyhleHBhbmRlZFJhbmdlLnRvLnJvdywgZXhwYW5kZWRSYW5nZS50by5jb2wpKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldFRvcExlZnRDb3JuZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb29yZHMuaXNFcXVhbCh0aGlzLmdldEJvdHRvbVJpZ2h0Q29ybmVyKCkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUb3BMZWZ0Q29ybmVyKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNvb3Jkcy5pc0VxdWFsKHRoaXMuZ2V0VG9wTGVmdENvcm5lcigpKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm90dG9tUmlnaHRDb3JuZXIoKTtcblxuICAgIH0gZWxzZSBpZiAoY29vcmRzLmlzRXF1YWwodGhpcy5nZXRUb3BSaWdodENvcm5lcigpKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Qm90dG9tTGVmdENvcm5lcigpO1xuXG4gICAgfSBlbHNlIGlmIChjb29yZHMuaXNFcXVhbCh0aGlzLmdldEJvdHRvbUxlZnRDb3JuZXIoKSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRvcFJpZ2h0Q29ybmVyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7V2Fsa29udGFibGVDZWxsUmFuZ2V9IHJhbmdlXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG4gIGdldEJvcmRlcnNTaGFyZWRXaXRoKHJhbmdlKSB7XG4gICAgaWYgKCF0aGlzLmluY2x1ZGVzUmFuZ2UocmFuZ2UpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgdGhpc0JvcmRlcnMgPSB7XG4gICAgICB0b3A6IE1hdGgubWluKHRoaXMuZnJvbS5yb3csIHRoaXMudG8ucm93KSxcbiAgICAgIGJvdHRvbTogTWF0aC5tYXgodGhpcy5mcm9tLnJvdywgdGhpcy50by5yb3cpLFxuICAgICAgbGVmdDogTWF0aC5taW4odGhpcy5mcm9tLmNvbCwgdGhpcy50by5jb2wpLFxuICAgICAgcmlnaHQ6IE1hdGgubWF4KHRoaXMuZnJvbS5jb2wsIHRoaXMudG8uY29sKVxuICAgIH07XG4gICAgY29uc3QgcmFuZ2VCb3JkZXJzID0ge1xuICAgICAgdG9wOiBNYXRoLm1pbihyYW5nZS5mcm9tLnJvdywgcmFuZ2UudG8ucm93KSxcbiAgICAgIGJvdHRvbTogTWF0aC5tYXgocmFuZ2UuZnJvbS5yb3csIHJhbmdlLnRvLnJvdyksXG4gICAgICBsZWZ0OiBNYXRoLm1pbihyYW5nZS5mcm9tLmNvbCwgcmFuZ2UudG8uY29sKSxcbiAgICAgIHJpZ2h0OiBNYXRoLm1heChyYW5nZS5mcm9tLmNvbCwgcmFuZ2UudG8uY29sKVxuICAgIH07XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICBpZiAodGhpc0JvcmRlcnMudG9wID09IHJhbmdlQm9yZGVycy50b3ApIHtcbiAgICAgIHJlc3VsdC5wdXNoKCd0b3AnKTtcbiAgICB9XG4gICAgaWYgKHRoaXNCb3JkZXJzLnJpZ2h0ID09IHJhbmdlQm9yZGVycy5yaWdodCkge1xuICAgICAgcmVzdWx0LnB1c2goJ3JpZ2h0Jyk7XG4gICAgfVxuICAgIGlmICh0aGlzQm9yZGVycy5ib3R0b20gPT0gcmFuZ2VCb3JkZXJzLmJvdHRvbSkge1xuICAgICAgcmVzdWx0LnB1c2goJ2JvdHRvbScpO1xuICAgIH1cbiAgICBpZiAodGhpc0JvcmRlcnMubGVmdCA9PSByYW5nZUJvcmRlcnMubGVmdCkge1xuICAgICAgcmVzdWx0LnB1c2goJ2xlZnQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBpbm5lciBzZWxlY3RlZCBjZWxsIGNvb3JkcyBkZWZpbmVkIGJ5IHRoaXMgcmFuZ2VcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fVxuICAgKi9cbiAgZ2V0SW5uZXIoKSB7XG4gICAgbGV0IHRvcExlZnQgPSB0aGlzLmdldFRvcExlZnRDb3JuZXIoKTtcbiAgICBsZXQgYm90dG9tUmlnaHQgPSB0aGlzLmdldEJvdHRvbVJpZ2h0Q29ybmVyKCk7XG4gICAgbGV0IG91dCA9IFtdO1xuXG4gICAgZm9yIChsZXQgciA9IHRvcExlZnQucm93OyByIDw9IGJvdHRvbVJpZ2h0LnJvdzsgcisrKSB7XG4gICAgICBmb3IgKGxldCBjID0gdG9wTGVmdC5jb2w7IGMgPD0gYm90dG9tUmlnaHQuY29sOyBjKyspIHtcbiAgICAgICAgaWYgKCEodGhpcy5mcm9tLnJvdyA9PT0gciAmJiB0aGlzLmZyb20uY29sID09PSBjKSAmJiAhKHRoaXMudG8ucm93ID09PSByICYmIHRoaXMudG8uY29sID09PSBjKSkge1xuICAgICAgICAgIG91dC5wdXNoKG5ldyBXYWxrb250YWJsZUNlbGxDb29yZHMociwgYykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBzZWxlY3RlZCBjZWxsIGNvb3JkcyBkZWZpbmVkIGJ5IHRoaXMgcmFuZ2VcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fVxuICAgKi9cbiAgZ2V0QWxsKCkge1xuICAgIGxldCB0b3BMZWZ0ID0gdGhpcy5nZXRUb3BMZWZ0Q29ybmVyKCk7XG4gICAgbGV0IGJvdHRvbVJpZ2h0ID0gdGhpcy5nZXRCb3R0b21SaWdodENvcm5lcigpO1xuICAgIGxldCBvdXQgPSBbXTtcblxuICAgIGZvciAobGV0IHIgPSB0b3BMZWZ0LnJvdzsgciA8PSBib3R0b21SaWdodC5yb3c7IHIrKykge1xuICAgICAgZm9yIChsZXQgYyA9IHRvcExlZnQuY29sOyBjIDw9IGJvdHRvbVJpZ2h0LmNvbDsgYysrKSB7XG4gICAgICAgIGlmICh0b3BMZWZ0LnJvdyA9PT0gciAmJiB0b3BMZWZ0LmNvbCA9PT0gYykge1xuICAgICAgICAgIG91dC5wdXNoKHRvcExlZnQpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoYm90dG9tUmlnaHQucm93ID09PSByICYmIGJvdHRvbVJpZ2h0LmNvbCA9PT0gYykge1xuICAgICAgICAgIG91dC5wdXNoKGJvdHRvbVJpZ2h0KTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dC5wdXNoKG5ldyBXYWxrb250YWJsZUNlbGxDb29yZHMociwgYykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIGEgY2FsbGJhY2sgZnVuY3Rpb24gYWdhaW5zdCBhbGwgY2VsbHMgaW4gdGhlIHJhbmdlLiBZb3UgY2FuIGJyZWFrIHRoZSBpdGVyYXRpb24gYnkgcmV0dXJuaW5nXG4gICAqIGBmYWxzZWAgaW4gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFjayB7RnVuY3Rpb259XG4gICAqL1xuICBmb3JBbGwoY2FsbGJhY2spIHtcbiAgICBsZXQgdG9wTGVmdCA9IHRoaXMuZ2V0VG9wTGVmdENvcm5lcigpO1xuICAgIGxldCBib3R0b21SaWdodCA9IHRoaXMuZ2V0Qm90dG9tUmlnaHRDb3JuZXIoKTtcblxuICAgIGZvciAobGV0IHIgPSB0b3BMZWZ0LnJvdzsgciA8PSBib3R0b21SaWdodC5yb3c7IHIrKykge1xuICAgICAgZm9yIChsZXQgYyA9IHRvcExlZnQuY29sOyBjIDw9IGJvdHRvbVJpZ2h0LmNvbDsgYysrKSB7XG4gICAgICAgIGxldCBicmVha0l0ZXJhdGlvbiA9IGNhbGxiYWNrKHIsIGMpO1xuXG4gICAgICAgIGlmIChicmVha0l0ZXJhdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHtXYWxrb250YWJsZUNlbGxSYW5nZX07XG5cbndpbmRvdy5XYWxrb250YWJsZUNlbGxSYW5nZSA9IFdhbGtvbnRhYmxlQ2VsbFJhbmdlO1xuIiwiXG5pbXBvcnQge1xuICBhZGRDbGFzcyxcbiAgZmFzdElubmVyVGV4dCxcbiAgaXNWaXNpYmxlLFxuICByZW1vdmVDbGFzcyxcbiAgICB9IGZyb20gJy4vLi4vLi4vLi4vaGVscGVycy9kb20vZWxlbWVudCc7XG5pbXBvcnQge29iamVjdEVhY2h9IGZyb20gJy4vLi4vLi4vLi4vaGVscGVycy9vYmplY3QnO1xuaW1wb3J0IHt0b1VwcGVyQ2FzZUZpcnN0LCByYW5kb21TdHJpbmd9IGZyb20gJy4vLi4vLi4vLi4vaGVscGVycy9zdHJpbmcnO1xuaW1wb3J0IHtXYWxrb250YWJsZUV2ZW50fSBmcm9tICcuL2V2ZW50JztcbmltcG9ydCB7V2Fsa29udGFibGVPdmVybGF5c30gZnJvbSAnLi9vdmVybGF5cyc7XG5pbXBvcnQge1dhbGtvbnRhYmxlU2Nyb2xsfSBmcm9tICcuL3Njcm9sbCc7XG5pbXBvcnQge1dhbGtvbnRhYmxlU2V0dGluZ3N9IGZyb20gJy4vc2V0dGluZ3MnO1xuaW1wb3J0IHtXYWxrb250YWJsZVRhYmxlfSBmcm9tICcuL3RhYmxlJztcbmltcG9ydCB7V2Fsa29udGFibGVWaWV3cG9ydH0gZnJvbSAnLi92aWV3cG9ydCc7XG5cblxuLyoqXG4gKiBAY2xhc3MgV2Fsa29udGFibGVcbiAqL1xuY2xhc3MgV2Fsa29udGFibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgIGxldCBvcmlnaW5hbEhlYWRlcnMgPSBbXTtcblxuICAgIC8vIHRoaXMgaXMgdGhlIG5hbWVzcGFjZSBmb3IgZ2xvYmFsIGV2ZW50c1xuICAgIHRoaXMuZ3VpZCA9ICd3dF8nICsgcmFuZG9tU3RyaW5nKCk7XG5cbiAgICAvLyBib290c3RyYXAgZnJvbSBzZXR0aW5nc1xuICAgIGlmIChzZXR0aW5ncy5jbG9uZVNvdXJjZSkge1xuICAgICAgdGhpcy5jbG9uZVNvdXJjZSA9IHNldHRpbmdzLmNsb25lU291cmNlO1xuICAgICAgdGhpcy5jbG9uZU92ZXJsYXkgPSBzZXR0aW5ncy5jbG9uZU92ZXJsYXk7XG4gICAgICB0aGlzLnd0U2V0dGluZ3MgPSBzZXR0aW5ncy5jbG9uZVNvdXJjZS53dFNldHRpbmdzO1xuICAgICAgdGhpcy53dFRhYmxlID0gbmV3IFdhbGtvbnRhYmxlVGFibGUodGhpcywgc2V0dGluZ3MudGFibGUsIHNldHRpbmdzLnd0Um9vdEVsZW1lbnQpO1xuICAgICAgdGhpcy53dFNjcm9sbCA9IG5ldyBXYWxrb250YWJsZVNjcm9sbCh0aGlzKTtcbiAgICAgIHRoaXMud3RWaWV3cG9ydCA9IHNldHRpbmdzLmNsb25lU291cmNlLnd0Vmlld3BvcnQ7XG4gICAgICB0aGlzLnd0RXZlbnQgPSBuZXcgV2Fsa29udGFibGVFdmVudCh0aGlzKTtcbiAgICAgIHRoaXMuc2VsZWN0aW9ucyA9IHRoaXMuY2xvbmVTb3VyY2Uuc2VsZWN0aW9ucztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53dFNldHRpbmdzID0gbmV3IFdhbGtvbnRhYmxlU2V0dGluZ3ModGhpcywgc2V0dGluZ3MpO1xuICAgICAgdGhpcy53dFRhYmxlID0gbmV3IFdhbGtvbnRhYmxlVGFibGUodGhpcywgc2V0dGluZ3MudGFibGUpO1xuICAgICAgdGhpcy53dFNjcm9sbCA9IG5ldyBXYWxrb250YWJsZVNjcm9sbCh0aGlzKTtcbiAgICAgIHRoaXMud3RWaWV3cG9ydCA9IG5ldyBXYWxrb250YWJsZVZpZXdwb3J0KHRoaXMpO1xuICAgICAgdGhpcy53dEV2ZW50ID0gbmV3IFdhbGtvbnRhYmxlRXZlbnQodGhpcyk7XG4gICAgICB0aGlzLnNlbGVjdGlvbnMgPSB0aGlzLmdldFNldHRpbmcoJ3NlbGVjdGlvbnMnKTtcbiAgICAgIHRoaXMud3RPdmVybGF5cyA9IG5ldyBXYWxrb250YWJsZU92ZXJsYXlzKHRoaXMpO1xuICAgICAgdGhpcy5leHBvcnRTZXR0aW5nc0FzQ2xhc3NOYW1lcygpO1xuICAgIH1cblxuICAgIC8vIGZpbmQgb3JpZ2luYWwgaGVhZGVyc1xuICAgIGlmICh0aGlzLnd0VGFibGUuVEhFQUQuY2hpbGROb2Rlcy5sZW5ndGggJiYgdGhpcy53dFRhYmxlLlRIRUFELmNoaWxkTm9kZXNbMF0uY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGMgPSAwLCBjbGVuID0gdGhpcy53dFRhYmxlLlRIRUFELmNoaWxkTm9kZXNbMF0uY2hpbGROb2Rlcy5sZW5ndGg7IGMgPCBjbGVuOyBjKyspIHtcbiAgICAgICAgb3JpZ2luYWxIZWFkZXJzLnB1c2godGhpcy53dFRhYmxlLlRIRUFELmNoaWxkTm9kZXNbMF0uY2hpbGROb2Rlc1tjXS5pbm5lckhUTUwpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmdldFNldHRpbmcoJ2NvbHVtbkhlYWRlcnMnKS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoJ2NvbHVtbkhlYWRlcnMnLCBbXG4gICAgICAgICAgZnVuY3Rpb24oY29sdW1uLCBUSCkge1xuICAgICAgICAgICAgZmFzdElubmVyVGV4dChUSCwgb3JpZ2luYWxIZWFkZXJzW2NvbHVtbl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZHJhd24gPSBmYWxzZTtcbiAgICB0aGlzLmRyYXdJbnRlcnJ1cHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlIHJlcmVuZGVyIG9mIFdhbGtvbnRhYmxlXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Zhc3REcmF3PWZhbHNlXSBXaGVuIGB0cnVlYCwgdHJ5IHRvIHJlZnJlc2ggb25seSB0aGUgcG9zaXRpb25zIG9mIGJvcmRlcnMgd2l0aG91dCByZXJlbmRlcmluZ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGRhdGEuIEl0IHdpbGwgb25seSB3b3JrIGlmIFdhbGtvbnRhYmxlVGFibGUuZHJhdygpIGRvZXMgbm90IGZvcmNlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJpbmcgYW55d2F5XG4gICAqIEByZXR1cm5zIHtXYWxrb250YWJsZX1cbiAgICovXG4gIGRyYXcoZmFzdERyYXcgPSBmYWxzZSkge1xuICAgIHRoaXMuZHJhd0ludGVycnVwdGVkID0gZmFsc2U7XG5cbiAgICBpZiAoIWZhc3REcmF3ICYmICFpc1Zpc2libGUodGhpcy53dFRhYmxlLlRBQkxFKSkge1xuICAgICAgLy8gZHJhdyBpbnRlcnJ1cHRlZCBiZWNhdXNlIFRBQkxFIGlzIG5vdCB2aXNpYmxlXG4gICAgICB0aGlzLmRyYXdJbnRlcnJ1cHRlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud3RUYWJsZS5kcmF3KGZhc3REcmF3KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBURCBhdCBjb29yZHMuIElmIHRvcG1vc3QgaXMgc2V0IHRvIHRydWUsIHJldHVybnMgVEQgZnJvbSB0aGUgdG9wbW9zdCBvdmVybGF5IGxheWVyLFxuICAgKiBpZiBub3Qgc2V0IG9yIHNldCB0byBmYWxzZSwgcmV0dXJucyBURCBmcm9tIHRoZSBtYXN0ZXIgdGFibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7V2Fsa29udGFibGVDZWxsQ29vcmRzfSBjb29yZHNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbdG9wbW9zdD1mYWxzZV1cbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIGdldENlbGwoY29vcmRzLCB0b3Btb3N0ID0gZmFsc2UpIHtcbiAgICBpZiAoIXRvcG1vc3QpIHtcbiAgICAgIHJldHVybiB0aGlzLnd0VGFibGUuZ2V0Q2VsbChjb29yZHMpO1xuICAgIH1cblxuICAgIGxldCBmaXhlZFJvd3MgPSB0aGlzLnd0U2V0dGluZ3MuZ2V0U2V0dGluZygnZml4ZWRSb3dzVG9wJyk7XG4gICAgbGV0IGZpeGVkQ29sdW1ucyA9IHRoaXMud3RTZXR0aW5ncy5nZXRTZXR0aW5nKCdmaXhlZENvbHVtbnNMZWZ0Jyk7XG5cbiAgICBpZiAoY29vcmRzLnJvdyA8IGZpeGVkUm93cyAmJiBjb29yZHMuY29sIDwgZml4ZWRDb2x1bW5zKSB7XG4gICAgICByZXR1cm4gdGhpcy53dE92ZXJsYXlzLnRvcExlZnRDb3JuZXJPdmVybGF5LmNsb25lLnd0VGFibGUuZ2V0Q2VsbChjb29yZHMpO1xuXG4gICAgfSBlbHNlIGlmIChjb29yZHMucm93IDwgZml4ZWRSb3dzKSB7XG4gICAgICByZXR1cm4gdGhpcy53dE92ZXJsYXlzLnRvcE92ZXJsYXkuY2xvbmUud3RUYWJsZS5nZXRDZWxsKGNvb3Jkcyk7XG5cbiAgICB9IGVsc2UgaWYgKGNvb3Jkcy5jb2wgPCBmaXhlZENvbHVtbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnd0T3ZlcmxheXMubGVmdE92ZXJsYXkuY2xvbmUud3RUYWJsZS5nZXRDZWxsKGNvb3Jkcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMud3RUYWJsZS5nZXRDZWxsKGNvb3Jkcyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybnMge1dhbGtvbnRhYmxlfVxuICAgKi9cbiAgdXBkYXRlKHNldHRpbmdzLCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnd0U2V0dGluZ3MudXBkYXRlKHNldHRpbmdzLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogU2Nyb2xsIHRoZSB2aWV3cG9ydCB0byBhIHJvdyBhdCB0aGUgZ2l2ZW4gaW5kZXggaW4gdGhlIGRhdGEgc291cmNlXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByb3dcbiAgICogQHJldHVybnMge1dhbGtvbnRhYmxlfVxuICAgKi9cbiAgc2Nyb2xsVmVydGljYWwocm93KSB7XG4gICAgdGhpcy53dE92ZXJsYXlzLnRvcE92ZXJsYXkuc2Nyb2xsVG8ocm93KTtcbiAgICB0aGlzLmdldFNldHRpbmcoJ29uU2Nyb2xsVmVydGljYWxseScpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2Nyb2xsIHRoZSB2aWV3cG9ydCB0byBhIGNvbHVtbiBhdCB0aGUgZ2l2ZW4gaW5kZXggaW4gdGhlIGRhdGEgc291cmNlXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb2x1bW5cbiAgICogQHJldHVybnMge1dhbGtvbnRhYmxlfVxuICAgKi9cbiAgc2Nyb2xsSG9yaXpvbnRhbChjb2x1bW4pIHtcbiAgICB0aGlzLnd0T3ZlcmxheXMubGVmdE92ZXJsYXkuc2Nyb2xsVG8oY29sdW1uKTtcbiAgICB0aGlzLmdldFNldHRpbmcoJ29uU2Nyb2xsSG9yaXpvbnRhbGx5Jyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTY3JvbGxzIHRoZSB2aWV3cG9ydCB0byBhIGNlbGwgKHJlcmVuZGVycyBpZiBuZWVkZWQpXG4gICAqXG4gICAqIEBwYXJhbSB7V2Fsa29udGFibGVDZWxsQ29vcmRzfSBjb29yZHNcbiAgICogQHJldHVybnMge1dhbGtvbnRhYmxlfVxuICAgKi9cbiAgc2Nyb2xsVmlld3BvcnQoY29vcmRzKSB7XG4gICAgdGhpcy53dFNjcm9sbC5zY3JvbGxWaWV3cG9ydChjb29yZHMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge0FycmF5fVxuICAgKi9cbiAgZ2V0Vmlld3BvcnQoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHRoaXMud3RUYWJsZS5nZXRGaXJzdFZpc2libGVSb3coKSxcbiAgICAgIHRoaXMud3RUYWJsZS5nZXRGaXJzdFZpc2libGVDb2x1bW4oKSxcbiAgICAgIHRoaXMud3RUYWJsZS5nZXRMYXN0VmlzaWJsZVJvdygpLFxuICAgICAgdGhpcy53dFRhYmxlLmdldExhc3RWaXNpYmxlQ29sdW1uKClcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBvdmVybGF5IG5hbWVcbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIGdldE92ZXJsYXlOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lT3ZlcmxheSA/IHRoaXMuY2xvbmVPdmVybGF5LnR5cGUgOiAnbWFzdGVyJztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvcnQgc2V0dGluZ3MgYXMgY2xhc3MgbmFtZXMgYWRkZWQgdG8gdGhlIHBhcmVudCBlbGVtZW50IG9mIHRoZSB0YWJsZS5cbiAgICovXG4gIGV4cG9ydFNldHRpbmdzQXNDbGFzc05hbWVzKCkge1xuICAgIGxldCB0b0V4cG9ydCA9IHtcbiAgICAgIHJvd0hlYWRlcnM6IFsnYXJyYXknXSxcbiAgICAgIGNvbHVtbkhlYWRlcnM6IFsnYXJyYXknXVxuICAgIH07XG4gICAgbGV0IGFsbENsYXNzTmFtZXMgPSBbXTtcbiAgICBsZXQgbmV3Q2xhc3NOYW1lcyA9IFtdO1xuXG4gICAgb2JqZWN0RWFjaCh0b0V4cG9ydCwgKG9wdGlvblR5cGUsIGtleSkgPT4ge1xuICAgICAgaWYgKG9wdGlvblR5cGUuaW5kZXhPZignYXJyYXknKSA+IC0xICYmIHRoaXMuZ2V0U2V0dGluZyhrZXkpLmxlbmd0aCkge1xuICAgICAgICBuZXdDbGFzc05hbWVzLnB1c2goJ2h0JyArIHRvVXBwZXJDYXNlRmlyc3Qoa2V5KSk7XG4gICAgICB9XG4gICAgICBhbGxDbGFzc05hbWVzLnB1c2goJ2h0JyArIHRvVXBwZXJDYXNlRmlyc3Qoa2V5KSk7XG4gICAgfSk7XG4gICAgcmVtb3ZlQ2xhc3ModGhpcy53dFRhYmxlLnd0Um9vdEVsZW1lbnQucGFyZW50Tm9kZSwgYWxsQ2xhc3NOYW1lcyk7XG4gICAgYWRkQ2xhc3ModGhpcy53dFRhYmxlLnd0Um9vdEVsZW1lbnQucGFyZW50Tm9kZSwgbmV3Q2xhc3NOYW1lcyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0L1NldCBXYWxrb250YWJsZSBpbnN0YW5jZSBzZXR0aW5nXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHsqfSBbcGFyYW0xXVxuICAgKiBAcGFyYW0geyp9IFtwYXJhbTJdXG4gICAqIEBwYXJhbSB7Kn0gW3BhcmFtM11cbiAgICogQHBhcmFtIHsqfSBbcGFyYW00XVxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGdldFNldHRpbmcoa2V5LCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zLCBwYXJhbTQpIHtcbiAgICAvLyB0aGlzIGlzIGZhc3RlciB0aGFuIC5hcHBseSAtIGh0dHBzOi8vZ2l0aHViLmNvbS9oYW5kc29udGFibGUvaGFuZHNvbnRhYmxlL3dpa2kvSmF2YVNjcmlwdC0mLURPTS1wZXJmb3JtYW5jZS10aXBzXG4gICAgcmV0dXJuIHRoaXMud3RTZXR0aW5ncy5nZXRTZXR0aW5nKGtleSwgcGFyYW0xLCBwYXJhbTIsIHBhcmFtMywgcGFyYW00KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgc2V0dGluZyBleGlzdHNcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGhhc1NldHRpbmcoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMud3RTZXR0aW5ncy5oYXMoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95IGluc3RhbmNlXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMud3RPdmVybGF5cy5kZXN0cm95KCk7XG4gICAgdGhpcy53dEV2ZW50LmRlc3Ryb3koKTtcbiAgfVxufVxuXG5leHBvcnQge1dhbGtvbnRhYmxlfTtcblxud2luZG93LldhbGtvbnRhYmxlID0gV2Fsa29udGFibGU7XG4iLCJcbmltcG9ydCB7XG4gIGNsb3Nlc3QsXG4gIGhhc0NsYXNzLFxuICBpc0NoaWxkT2YsXG4gICAgfSBmcm9tICcuLy4uLy4uLy4uL2hlbHBlcnMvZG9tL2VsZW1lbnQnO1xuaW1wb3J0IHtldmVudE1hbmFnZXIgYXMgZXZlbnRNYW5hZ2VyT2JqZWN0fSBmcm9tICcuLy4uLy4uLy4uL2V2ZW50TWFuYWdlcic7XG5cblxuZnVuY3Rpb24gV2Fsa29udGFibGVFdmVudChpbnN0YW5jZSkge1xuICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgdmFyIGV2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlck9iamVjdChpbnN0YW5jZSk7XG5cbiAgLy9yZWZlcmVuY2UgdG8gaW5zdGFuY2VcbiAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuXG4gIHZhciBkYmxDbGlja09yaWdpbiA9IFtudWxsLCBudWxsXTtcbiAgdGhpcy5kYmxDbGlja1RpbWVvdXQgPSBbbnVsbCwgbnVsbF07XG5cbiAgdmFyIG9uTW91c2VEb3duID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY2VsbCA9IHRoYXQucGFyZW50Q2VsbChldmVudC5yZWFsVGFyZ2V0KTtcblxuICAgIGlmIChoYXNDbGFzcyhldmVudC5yZWFsVGFyZ2V0LCAnY29ybmVyJykpIHtcbiAgICAgIHRoYXQuaW5zdGFuY2UuZ2V0U2V0dGluZygnb25DZWxsQ29ybmVyTW91c2VEb3duJywgZXZlbnQsIGV2ZW50LnJlYWxUYXJnZXQpO1xuICAgIH0gZWxzZSBpZiAoY2VsbC5URCkge1xuICAgICAgaWYgKHRoYXQuaW5zdGFuY2UuaGFzU2V0dGluZygnb25DZWxsTW91c2VEb3duJykpIHtcbiAgICAgICAgdGhhdC5pbnN0YW5jZS5nZXRTZXR0aW5nKCdvbkNlbGxNb3VzZURvd24nLCBldmVudCwgY2VsbC5jb29yZHMsIGNlbGwuVEQsIHRoYXQuaW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChldmVudC5idXR0b24gIT09IDIpIHsgLy9pZiBub3QgcmlnaHQgbW91c2UgYnV0dG9uXG4gICAgICBpZiAoY2VsbC5URCkge1xuICAgICAgICBkYmxDbGlja09yaWdpblswXSA9IGNlbGwuVEQ7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGF0LmRibENsaWNrVGltZW91dFswXSk7XG4gICAgICAgIHRoYXQuZGJsQ2xpY2tUaW1lb3V0WzBdID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBkYmxDbGlja09yaWdpblswXSA9IG51bGw7XG4gICAgICAgIH0sIDEwMDApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgb25Ub3VjaE1vdmUgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHRoYXQuaW5zdGFuY2UudG91Y2hNb3ZpbmcgPSB0cnVlO1xuICB9O1xuXG4gIHZhciBsb25nVG91Y2hUaW1lb3V0O1xuXG4gIC8vLyoqXG4gIC8vICogVXBkYXRlIHRvdWNoIGV2ZW50IHRhcmdldCAtIGlmIHVzZXIgdGFwcyBvbiByZXNpemUgaGFuZGxlICdoaXQgYXJlYScsIHVwZGF0ZSB0aGUgdGFyZ2V0IHRvIHRoZSBjZWxsIGl0c2VsZlxuICAvLyAqIEBwYXJhbSBldmVudFxuICAvLyAqL1xuICAvKlxuICAgdmFyIGFkanVzdFRhcFRhcmdldCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgdmFyIGN1cnJlbnRTZWxlY3Rpb25cbiAgICwgcHJvcGVyVGFyZ2V0O1xuXG4gICBpZihoYXNDbGFzcyhldmVudC50YXJnZXQsJ1NlbGVjdGlvbkhhbmRsZScpKSB7XG4gICBpZih0aGF0Lmluc3RhbmNlLnNlbGVjdGlvbnNbMF0uY2VsbFJhbmdlKSB7XG4gICBjdXJyZW50U2VsZWN0aW9uID0gdGhhdC5pbnN0YW5jZS5zZWxlY3Rpb25zWzBdLmNlbGxSYW5nZS5oaWdobGlnaHQ7XG5cbiAgIHByb3BlclRhcmdldCA9IHRoYXQuaW5zdGFuY2UuZ2V0Q2VsbChjdXJyZW50U2VsZWN0aW9uLCB0cnVlKTtcbiAgIH1cbiAgIH1cblxuICAgaWYocHJvcGVyVGFyZ2V0KSB7XG4gICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXZlbnQsJ3RhcmdldCcse1xuICAgdmFsdWU6IHByb3BlclRhcmdldFxuICAgfSk7XG4gICB9XG5cbiAgIHJldHVybiBldmVudDtcbiAgIH07Ki9cblxuICB2YXIgb25Ub3VjaFN0YXJ0ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcztcblxuICAgIGV2ZW50TWFuYWdlci5hZGRFdmVudExpc3RlbmVyKHRoaXMsICd0b3VjaG1vdmUnLCBvblRvdWNoTW92ZSk7XG5cbiAgICAvL3RoaXMuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBvblRvdWNoTW92ZSwgZmFsc2UpO1xuXG4gICAgLy8gdG91Y2gtYW5kLWhvbGQgZXZlbnRcbiAgICAvL2xvbmdUb3VjaFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAvLyAgaWYoIXRoYXQuaW5zdGFuY2UudG91Y2hNb3ZpbmcpIHtcbiAgICAvLyAgICB0aGF0Lmluc3RhbmNlLmxvbmdUb3VjaCA9IHRydWU7XG4gICAgLy9cbiAgICAvLyAgICB2YXIgdGFyZ2V0Q29vcmRzID0gb2Zmc2V0KGV2ZW50LnRhcmdldCk7XG4gICAgLy8gICAgdmFyIGNvbnRleHRNZW51RXZlbnQgPSBuZXcgTW91c2VFdmVudCgnY29udGV4dG1lbnUnLCB7XG4gICAgLy8gICAgICBjbGllbnRYOiB0YXJnZXRDb29yZHMubGVmdCArIGV2ZW50LnRhcmdldC5vZmZzZXRXaWR0aCxcbiAgICAvLyAgICAgIGNsaWVudFk6IHRhcmdldENvb3Jkcy50b3AgKyBldmVudC50YXJnZXQub2Zmc2V0SGVpZ2h0LFxuICAgIC8vICAgICAgYnV0dG9uOiAyXG4gICAgLy8gICAgfSk7XG4gICAgLy9cbiAgICAvLyAgICB0aGF0Lmluc3RhbmNlLnd0VGFibGUuaG9sZGVyLnBhcmVudE5vZGUucGFyZW50Tm9kZS5kaXNwYXRjaEV2ZW50KGNvbnRleHRNZW51RXZlbnQpO1xuICAgIC8vICB9XG4gICAgLy99LDIwMCk7XG5cbiAgICAvLyBQcmV2ZW50IGNlbGwgc2VsZWN0aW9uIHdoZW4gc2Nyb2xsaW5nIHdpdGggdG91Y2ggZXZlbnQgLSBub3QgdGhlIGJlc3Qgc29sdXRpb24gcGVyZm9ybWFuY2Utd2lzZVxuICAgIHRoYXQuY2hlY2tJZlRvdWNoTW92ZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhhdC5pbnN0YW5jZS50b3VjaE1vdmluZyA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGF0Lmluc3RhbmNlLnRvdWNoTW92aW5nID0gdm9pZCAwO1xuXG4gICAgICAgIGV2ZW50TWFuYWdlci5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIG9uVG91Y2hNb3ZlLCBmYWxzZSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9ldmVudCA9IGFkanVzdFRhcFRhcmdldChldmVudCk7XG5cbiAgICAgICAgb25Nb3VzZURvd24oZXZlbnQpO1xuICAgICAgfVxuICAgIH0sIDMwKTtcblxuICAgIC8vZXZlbnRNYW5hZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhhdC5pbnN0YW5jZS53dFRhYmxlLmhvbGRlciwgXCJtb3VzZWRvd25cIiwgb25Nb3VzZURvd24pO1xuICB9O1xuXG4gIHZhciBsYXN0TW91c2VPdmVyO1xuICB2YXIgb25Nb3VzZU92ZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciB0YWJsZSwgdGQ7XG5cbiAgICBpZiAodGhhdC5pbnN0YW5jZS5oYXNTZXR0aW5nKCdvbkNlbGxNb3VzZU92ZXInKSkge1xuICAgICAgdGFibGUgPSB0aGF0Lmluc3RhbmNlLnd0VGFibGUuVEFCTEU7XG4gICAgICB0ZCA9IGNsb3Nlc3QoZXZlbnQucmVhbFRhcmdldCwgWydURCcsICdUSCddLCB0YWJsZSk7XG5cbiAgICAgIGlmICh0ZCAmJiB0ZCAhPT0gbGFzdE1vdXNlT3ZlciAmJiBpc0NoaWxkT2YodGQsIHRhYmxlKSkge1xuICAgICAgICBsYXN0TW91c2VPdmVyID0gdGQ7XG4gICAgICAgIHRoYXQuaW5zdGFuY2UuZ2V0U2V0dGluZygnb25DZWxsTW91c2VPdmVyJywgZXZlbnQsIHRoYXQuaW5zdGFuY2Uud3RUYWJsZS5nZXRDb29yZHModGQpLCB0ZCwgdGhhdC5pbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qICB2YXIgbGFzdE1vdXNlT3V0O1xuICAgdmFyIG9uTW91c2VPdXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgIGlmICh0aGF0Lmluc3RhbmNlLmhhc1NldHRpbmcoJ29uQ2VsbE1vdXNlT3V0JykpIHtcbiAgIHZhciBUQUJMRSA9IHRoYXQuaW5zdGFuY2Uud3RUYWJsZS5UQUJMRTtcbiAgIHZhciBURCA9IGNsb3Nlc3QoZXZlbnQudGFyZ2V0LCBbJ1REJywgJ1RIJ10sIFRBQkxFKTtcbiAgIGlmIChURCAmJiBURCAhPT0gbGFzdE1vdXNlT3V0ICYmIGlzQ2hpbGRPZihURCwgVEFCTEUpKSB7XG4gICBsYXN0TW91c2VPdXQgPSBURDtcbiAgIGlmIChURC5ub2RlTmFtZSA9PT0gJ1REJykge1xuICAgdGhhdC5pbnN0YW5jZS5nZXRTZXR0aW5nKCdvbkNlbGxNb3VzZU91dCcsIGV2ZW50LCB0aGF0Lmluc3RhbmNlLnd0VGFibGUuZ2V0Q29vcmRzKFREKSwgVEQpO1xuICAgfVxuICAgfVxuICAgfVxuICAgfTsqL1xuXG4gIHZhciBvbk1vdXNlVXAgPSBmdW5jdGlvbihldmVudCkge1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDIpIHsgLy9pZiBub3QgcmlnaHQgbW91c2UgYnV0dG9uXG4gICAgICB2YXIgY2VsbCA9IHRoYXQucGFyZW50Q2VsbChldmVudC5yZWFsVGFyZ2V0KTtcblxuICAgICAgaWYgKGNlbGwuVEQgPT09IGRibENsaWNrT3JpZ2luWzBdICYmIGNlbGwuVEQgPT09IGRibENsaWNrT3JpZ2luWzFdKSB7XG4gICAgICAgIGlmIChoYXNDbGFzcyhldmVudC5yZWFsVGFyZ2V0LCAnY29ybmVyJykpIHtcbiAgICAgICAgICB0aGF0Lmluc3RhbmNlLmdldFNldHRpbmcoJ29uQ2VsbENvcm5lckRibENsaWNrJywgZXZlbnQsIGNlbGwuY29vcmRzLCBjZWxsLlRELCB0aGF0Lmluc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGF0Lmluc3RhbmNlLmdldFNldHRpbmcoJ29uQ2VsbERibENsaWNrJywgZXZlbnQsIGNlbGwuY29vcmRzLCBjZWxsLlRELCB0aGF0Lmluc3RhbmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRibENsaWNrT3JpZ2luWzBdID0gbnVsbDtcbiAgICAgICAgZGJsQ2xpY2tPcmlnaW5bMV0gPSBudWxsO1xuICAgICAgfSBlbHNlIGlmIChjZWxsLlREID09PSBkYmxDbGlja09yaWdpblswXSkge1xuICAgICAgICBkYmxDbGlja09yaWdpblsxXSA9IGNlbGwuVEQ7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGF0LmRibENsaWNrVGltZW91dFsxXSk7XG4gICAgICAgIHRoYXQuZGJsQ2xpY2tUaW1lb3V0WzFdID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBkYmxDbGlja09yaWdpblsxXSA9IG51bGw7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG5cbiAgdmFyIG9uVG91Y2hFbmQgPSBmdW5jdGlvbihldmVudCkge1xuICAgIGNsZWFyVGltZW91dChsb25nVG91Y2hUaW1lb3V0KTtcbiAgICAvL3RoYXQuaW5zdGFuY2UubG9uZ1RvdWNoID09IHZvaWQgMDtcblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBvbk1vdXNlVXAoZXZlbnQpO1xuXG4gICAgLy9ldmVudE1hbmFnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGF0Lmluc3RhbmNlLnd0VGFibGUuaG9sZGVyLCBcIm1vdXNldXBcIiwgb25Nb3VzZVVwKTtcbiAgfTtcblxuICBldmVudE1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmluc3RhbmNlLnd0VGFibGUuaG9sZGVyLCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuXG4gIGV2ZW50TWFuYWdlci5hZGRFdmVudExpc3RlbmVyKHRoaXMuaW5zdGFuY2Uud3RUYWJsZS5UQUJMRSwgJ21vdXNlb3ZlcicsIG9uTW91c2VPdmVyKTtcblxuICBldmVudE1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmluc3RhbmNlLnd0VGFibGUuaG9sZGVyLCAnbW91c2V1cCcsIG9uTW91c2VVcCk7XG5cblxuICAvLyBjaGVjayBpZiBmdWxsIEhPVCBpbnN0YW5jZSwgb3IgZGV0YWNoZWQgV09UIEFORCBydW4gb24gbW9iaWxlIGRldmljZVxuICBpZiAodGhpcy5pbnN0YW5jZS53dFRhYmxlLmhvbGRlci5wYXJlbnROb2RlLnBhcmVudE5vZGUgJiYgSGFuZHNvbnRhYmxlLm1vYmlsZUJyb3dzZXIgJiYgIXRoYXQuaW5zdGFuY2Uud3RUYWJsZS5pc1dvcmtpbmdPbkNsb25lKCkpIHtcbiAgICB2YXIgY2xhc3NTZWxlY3RvciA9IFwiLlwiICsgdGhpcy5pbnN0YW5jZS53dFRhYmxlLmhvbGRlci5wYXJlbnROb2RlLmNsYXNzTmFtZS5zcGxpdChcIiBcIikuam9pbihcIi5cIik7XG5cbiAgICBldmVudE1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmluc3RhbmNlLnd0VGFibGUuaG9sZGVyLCAndG91Y2hzdGFydCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB0aGF0Lmluc3RhbmNlLnRvdWNoQXBwbGllZCA9IHRydWU7XG4gICAgICBpZiAoaXNDaGlsZE9mKGV2ZW50LnRhcmdldCwgY2xhc3NTZWxlY3RvcikpIHtcbiAgICAgICAgb25Ub3VjaFN0YXJ0LmNhbGwoZXZlbnQudGFyZ2V0LCBldmVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZXZlbnRNYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5pbnN0YW5jZS53dFRhYmxlLmhvbGRlciwgJ3RvdWNoZW5kJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHRoYXQuaW5zdGFuY2UudG91Y2hBcHBsaWVkID0gZmFsc2U7XG4gICAgICBpZiAoaXNDaGlsZE9mKGV2ZW50LnRhcmdldCwgY2xhc3NTZWxlY3RvcikpIHtcbiAgICAgICAgb25Ub3VjaEVuZC5jYWxsKGV2ZW50LnRhcmdldCwgZXZlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCF0aGF0Lmluc3RhbmNlLm1vbWVudHVtU2Nyb2xsaW5nKSB7XG4gICAgICB0aGF0Lmluc3RhbmNlLm1vbWVudHVtU2Nyb2xsaW5nID0ge307XG4gICAgfVxuICAgIGV2ZW50TWFuYWdlci5hZGRFdmVudExpc3RlbmVyKHRoaXMuaW5zdGFuY2Uud3RUYWJsZS5ob2xkZXIsICdzY3JvbGwnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoYXQuaW5zdGFuY2UubW9tZW50dW1TY3JvbGxpbmcuX3RpbWVvdXQpO1xuXG4gICAgICBpZiAoIXRoYXQuaW5zdGFuY2UubW9tZW50dW1TY3JvbGxpbmcub25nb2luZykge1xuICAgICAgICB0aGF0Lmluc3RhbmNlLmdldFNldHRpbmcoJ29uQmVmb3JlVG91Y2hTY3JvbGwnKTtcbiAgICAgIH1cbiAgICAgIHRoYXQuaW5zdGFuY2UubW9tZW50dW1TY3JvbGxpbmcub25nb2luZyA9IHRydWU7XG5cbiAgICAgIHRoYXQuaW5zdGFuY2UubW9tZW50dW1TY3JvbGxpbmcuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoYXQuaW5zdGFuY2UudG91Y2hBcHBsaWVkKSB7XG4gICAgICAgICAgdGhhdC5pbnN0YW5jZS5tb21lbnR1bVNjcm9sbGluZy5vbmdvaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICB0aGF0Lmluc3RhbmNlLmdldFNldHRpbmcoJ29uQWZ0ZXJNb21lbnR1bVNjcm9sbCcpO1xuICAgICAgICB9XG4gICAgICB9LCAyMDApO1xuICAgIH0pO1xuICB9XG5cbiAgZXZlbnRNYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIod2luZG93LCAncmVzaXplJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoYXQuaW5zdGFuY2UuZ2V0U2V0dGluZygnc3RyZXRjaEgnKSAhPT0gJ25vbmUnKSB7XG4gICAgICB0aGF0Lmluc3RhbmNlLmRyYXcoKTtcbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmRibENsaWNrVGltZW91dFswXSk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZGJsQ2xpY2tUaW1lb3V0WzFdKTtcblxuICAgIGV2ZW50TWFuYWdlci5kZXN0cm95KCk7XG4gIH07XG59XG5cbldhbGtvbnRhYmxlRXZlbnQucHJvdG90eXBlLnBhcmVudENlbGwgPSBmdW5jdGlvbihlbGVtKSB7XG4gIHZhciBjZWxsID0ge307XG4gIHZhciBUQUJMRSA9IHRoaXMuaW5zdGFuY2Uud3RUYWJsZS5UQUJMRTtcbiAgdmFyIFREID0gY2xvc2VzdChlbGVtLCBbJ1REJywgJ1RIJ10sIFRBQkxFKTtcblxuICBpZiAoVEQgJiYgaXNDaGlsZE9mKFRELCBUQUJMRSkpIHtcbiAgICBjZWxsLmNvb3JkcyA9IHRoaXMuaW5zdGFuY2Uud3RUYWJsZS5nZXRDb29yZHMoVEQpO1xuICAgIGNlbGwuVEQgPSBURDtcblxuICB9IGVsc2UgaWYgKGhhc0NsYXNzKGVsZW0sICd3dEJvcmRlcicpICYmIGhhc0NsYXNzKGVsZW0sICdjdXJyZW50JykpIHtcbiAgICBjZWxsLmNvb3JkcyA9IHRoaXMuaW5zdGFuY2Uuc2VsZWN0aW9ucy5jdXJyZW50LmNlbGxSYW5nZS5oaWdobGlnaHQ7IC8vc2VsZWN0aW9ucy5jdXJyZW50IGlzIGN1cnJlbnQgc2VsZWN0ZWQgY2VsbFxuICAgIGNlbGwuVEQgPSB0aGlzLmluc3RhbmNlLnd0VGFibGUuZ2V0Q2VsbChjZWxsLmNvb3Jkcyk7XG5cbiAgfSBlbHNlIGlmIChoYXNDbGFzcyhlbGVtLCAnd3RCb3JkZXInKSAmJiBoYXNDbGFzcyhlbGVtLCAnYXJlYScpKSB7XG4gICAgaWYgKHRoaXMuaW5zdGFuY2Uuc2VsZWN0aW9ucy5hcmVhLmNlbGxSYW5nZSkge1xuICAgICAgY2VsbC5jb29yZHMgPSB0aGlzLmluc3RhbmNlLnNlbGVjdGlvbnMuYXJlYS5jZWxsUmFuZ2UudG87IC8vc2VsZWN0aW9ucy5hcmVhIGlzIGFyZWEgc2VsZWN0ZWQgY2VsbHNcbiAgICAgIGNlbGwuVEQgPSB0aGlzLmluc3RhbmNlLnd0VGFibGUuZ2V0Q2VsbChjZWxsLmNvb3Jkcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNlbGw7XG59O1xuXG5leHBvcnQge1dhbGtvbnRhYmxlRXZlbnR9O1xuXG53aW5kb3cuV2Fsa29udGFibGVFdmVudCA9IFdhbGtvbnRhYmxlRXZlbnQ7XG4iLCJcbi8qKlxuICogQGNsYXNzIFdhbGtvbnRhYmxlQ29sdW1uRmlsdGVyXG4gKi9cbmNsYXNzIFdhbGtvbnRhYmxlQ29sdW1uRmlsdGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRvdGFsXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudFRIXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvZmZzZXQsIHRvdGFsLCBjb3VudFRIKSB7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgIHRoaXMuY291bnRUSCA9IGNvdW50VEg7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGluZGV4XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuICBvZmZzZXR0ZWQoaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggKyB0aGlzLm9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gaW5kZXhcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG4gIHVuT2Zmc2V0dGVkKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4IC0gdGhpcy5vZmZzZXQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGluZGV4XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuICByZW5kZXJlZFRvU291cmNlKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMub2Zmc2V0dGVkKGluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gaW5kZXhcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG4gIHNvdXJjZVRvUmVuZGVyZWQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy51bk9mZnNldHRlZChpbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGluZGV4XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuICBvZmZzZXR0ZWRUSChpbmRleCkge1xuICAgIHJldHVybiBpbmRleCAtIHRoaXMuY291bnRUSDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gaW5kZXhcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG4gIHVuT2Zmc2V0dGVkVEgoaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggKyB0aGlzLmNvdW50VEg7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGluZGV4XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuICB2aXNpYmxlUm93SGVhZGVkQ29sdW1uVG9Tb3VyY2VDb2x1bW4oaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlZFRvU291cmNlKHRoaXMub2Zmc2V0dGVkVEgoaW5kZXgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gaW5kZXhcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG4gIHNvdXJjZUNvbHVtblRvVmlzaWJsZVJvd0hlYWRlZENvbHVtbihpbmRleCkge1xuICAgIHJldHVybiB0aGlzLnVuT2Zmc2V0dGVkVEgodGhpcy5zb3VyY2VUb1JlbmRlcmVkKGluZGV4KSk7XG4gIH1cbn1cblxuZXhwb3J0IHtXYWxrb250YWJsZUNvbHVtbkZpbHRlcn07XG5cbndpbmRvdy5XYWxrb250YWJsZUNvbHVtbkZpbHRlciA9IFdhbGtvbnRhYmxlQ29sdW1uRmlsdGVyO1xuIiwiXG4vKipcbiAqIEBjbGFzcyBXYWxrb250YWJsZVJvd0ZpbHRlclxuICovXG5jbGFzcyBXYWxrb250YWJsZVJvd0ZpbHRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0b3RhbFxuICAgKiBAcGFyYW0ge051bWJlcn0gY291bnRUSFxuICAgKi9cbiAgY29uc3RydWN0b3Iob2Zmc2V0LCB0b3RhbCwgY291bnRUSCkge1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICB0aGlzLmNvdW50VEggPSBjb3VudFRIO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBpbmRleFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgb2Zmc2V0dGVkKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ICsgdGhpcy5vZmZzZXQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGluZGV4XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuICB1bk9mZnNldHRlZChpbmRleCkge1xuICAgIHJldHVybiBpbmRleCAtIHRoaXMub2Zmc2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBpbmRleFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgcmVuZGVyZWRUb1NvdXJjZShpbmRleCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldHRlZChpbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGluZGV4XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuICBzb3VyY2VUb1JlbmRlcmVkKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMudW5PZmZzZXR0ZWQoaW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBpbmRleFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgb2Zmc2V0dGVkVEgoaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggLSB0aGlzLmNvdW50VEg7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGluZGV4XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuICB1bk9mZnNldHRlZFRIKGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ICsgdGhpcy5jb3VudFRIO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBpbmRleFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgdmlzaWJsZUNvbEhlYWRlZFJvd1RvU291cmNlUm93KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZWRUb1NvdXJjZSh0aGlzLm9mZnNldHRlZFRIKGluZGV4KSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGluZGV4XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuICBzb3VyY2VSb3dUb1Zpc2libGVDb2xIZWFkZWRSb3coaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy51bk9mZnNldHRlZFRIKHRoaXMuc291cmNlVG9SZW5kZXJlZChpbmRleCkpO1xuICB9XG59XG5cbmV4cG9ydCB7V2Fsa29udGFibGVSb3dGaWx0ZXJ9O1xuXG53aW5kb3cuV2Fsa29udGFibGVSb3dGaWx0ZXIgPSBXYWxrb250YWJsZVJvd0ZpbHRlcjtcbiIsIlxuaW1wb3J0IHtcbiAgZ2V0U2Nyb2xsYWJsZUVsZW1lbnQsXG4gIGdldFRyaW1taW5nQ29udGFpbmVyLFxuICAgIH0gZnJvbSAnLi8uLi8uLi8uLi8uLi9oZWxwZXJzL2RvbS9lbGVtZW50JztcbmltcG9ydCB7ZGVmaW5lR2V0dGVyfSBmcm9tICcuLy4uLy4uLy4uLy4uL2hlbHBlcnMvb2JqZWN0JztcbmltcG9ydCB7ZXZlbnRNYW5hZ2VyIGFzIGV2ZW50TWFuYWdlck9iamVjdH0gZnJvbSAnLi8uLi8uLi8uLi8uLi9ldmVudE1hbmFnZXInO1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvdmVybGF5IG92ZXIgdGhlIG9yaWdpbmFsIFdhbGtvbnRhYmxlIGluc3RhbmNlLiBUaGUgb3ZlcmxheSByZW5kZXJzIHRoZSBjbG9uZSBvZiB0aGUgb3JpZ2luYWwgV2Fsa29udGFibGVcbiAqIGFuZCAob3B0aW9uYWxseSkgaW1wbGVtZW50cyBiZWhhdmlvciBuZWVkZWQgZm9yIG5hdGl2ZSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBzY3JvbGxpbmcuXG4gKlxuICogQGNsYXNzIFdhbGtvbnRhYmxlT3ZlcmxheVxuICovXG5jbGFzcyBXYWxrb250YWJsZU92ZXJsYXkge1xuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgQ0xPTkVfVE9QKCkge1xuICAgIHJldHVybiAndG9wJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBDTE9ORV9MRUZUKCkge1xuICAgIHJldHVybiAnbGVmdCc7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgQ0xPTkVfQ09STkVSKCkge1xuICAgIHJldHVybiAnY29ybmVyJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBDTE9ORV9ERUJVRygpIHtcbiAgICByZXR1cm4gJ2RlYnVnJztcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGFsbCBhdmFpbGFibGVzIGNsb25lIHR5cGVzXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBnZXQgQ0xPTkVfVFlQRVMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFdhbGtvbnRhYmxlT3ZlcmxheS5DTE9ORV9UT1AsXG4gICAgICBXYWxrb250YWJsZU92ZXJsYXkuQ0xPTkVfTEVGVCxcbiAgICAgIFdhbGtvbnRhYmxlT3ZlcmxheS5DTE9ORV9DT1JORVIsXG4gICAgICBXYWxrb250YWJsZU92ZXJsYXkuQ0xPTkVfREVCVUdcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7V2Fsa29udGFibGV9IHdvdEluc3RhbmNlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3b3RJbnN0YW5jZSkge1xuICAgIGRlZmluZUdldHRlcih0aGlzLCAnd290Jywgd290SW5zdGFuY2UsIHtcbiAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgIH0pO1xuXG4gICAgLy8gbGVnYWN5IHN1cHBvcnQsIGRlcHJlY2F0ZWQgaW4gdGhlIGZ1dHVyZVxuICAgIHRoaXMuaW5zdGFuY2UgPSB0aGlzLndvdDtcblxuICAgIHRoaXMudHlwZSA9ICcnO1xuICAgIHRoaXMuVEFCTEUgPSB0aGlzLndvdC53dFRhYmxlLlRBQkxFO1xuICAgIHRoaXMuaGlkZXIgPSB0aGlzLndvdC53dFRhYmxlLmhpZGVyO1xuICAgIHRoaXMuc3ByZWFkZXIgPSB0aGlzLndvdC53dFRhYmxlLnNwcmVhZGVyO1xuICAgIHRoaXMuaG9sZGVyID0gdGhpcy53b3Qud3RUYWJsZS5ob2xkZXI7XG4gICAgdGhpcy53dFJvb3RFbGVtZW50ID0gdGhpcy53b3Qud3RUYWJsZS53dFJvb3RFbGVtZW50O1xuICAgIHRoaXMudHJpbW1pbmdDb250YWluZXIgPSBnZXRUcmltbWluZ0NvbnRhaW5lcih0aGlzLmhpZGVyLnBhcmVudE5vZGUucGFyZW50Tm9kZSk7XG4gICAgdGhpcy5tYWluVGFibGVTY3JvbGxhYmxlRWxlbWVudCA9IGdldFNjcm9sbGFibGVFbGVtZW50KHRoaXMud290Lnd0VGFibGUuVEFCTEUpO1xuICAgIHRoaXMubmVlZEZ1bGxSZW5kZXIgPSB0aGlzLnNob3VsZEJlUmVuZGVyZWQoKTtcbiAgICB0aGlzLmFyZUVsZW1lbnRTaXplc0FkanVzdGVkID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIG92ZXJsYXkgc2hvdWxkIGJlIGZ1bGx5IHJlbmRlcmVkXG4gICAqXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgc2hvdWxkQmVSZW5kZXJlZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgY2xvbmUgb2YgdGFibGUgZm9yIG92ZXJsYXlcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRpcmVjdGlvbiBDYW4gYmUgYFdhbGtvbnRhYmxlT3ZlcmxheS5DTE9ORV9UT1BgLCBgV2Fsa29udGFibGVPdmVybGF5LkNMT05FX0xFRlRgLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGBXYWxrb250YWJsZU92ZXJsYXkuQ0xPTkVfQ09STkVSYCwgYFdhbGtvbnRhYmxlT3ZlcmxheS5DTE9ORV9ERUJVR2BcbiAgICogQHJldHVybnMge1dhbGtvbnRhYmxlfVxuICAgKi9cbiAgbWFrZUNsb25lKGRpcmVjdGlvbikge1xuICAgIGlmIChXYWxrb250YWJsZU92ZXJsYXkuQ0xPTkVfVFlQRVMuaW5kZXhPZihkaXJlY3Rpb24pID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbG9uZSB0eXBlIFwiJyArIGRpcmVjdGlvbiArICdcIiBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cbiAgICBsZXQgY2xvbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgICBsZXQgY2xvbmVkVGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdUQUJMRScpO1xuXG4gICAgY2xvbmUuY2xhc3NOYW1lID0gJ2h0X2Nsb25lXycgKyBkaXJlY3Rpb24gKyAnIGhhbmRzb250YWJsZSc7XG4gICAgY2xvbmUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGNsb25lLnN0eWxlLnRvcCA9IDA7XG4gICAgY2xvbmUuc3R5bGUubGVmdCA9IDA7XG4gICAgY2xvbmUuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcblxuICAgIGNsb25lZFRhYmxlLmNsYXNzTmFtZSA9IHRoaXMud290Lnd0VGFibGUuVEFCTEUuY2xhc3NOYW1lO1xuICAgIGNsb25lLmFwcGVuZENoaWxkKGNsb25lZFRhYmxlKTtcblxuICAgIHRoaXMudHlwZSA9IGRpcmVjdGlvbjtcbiAgICB0aGlzLndvdC53dFRhYmxlLnd0Um9vdEVsZW1lbnQucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChjbG9uZSk7XG5cbiAgICByZXR1cm4gbmV3IFdhbGtvbnRhYmxlKHtcbiAgICAgIGNsb25lU291cmNlOiB0aGlzLndvdCxcbiAgICAgIGNsb25lT3ZlcmxheTogdGhpcyxcbiAgICAgIHRhYmxlOiBjbG9uZWRUYWJsZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZnJlc2gvUmVkcmF3IG92ZXJsYXlcbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBbZmFzdERyYXc9ZmFsc2VdXG4gICAqL1xuICByZWZyZXNoKGZhc3REcmF3ID0gZmFsc2UpIHtcbiAgICAvLyBXaGVuIGhvdCBzZXR0aW5ncyBhcmUgY2hhbmdlZCB3ZSBhbGxvdyB0byByZWZyZXNoIG92ZXJsYXkgb25jZSBiZWZvcmUgYmxvY2tpbmdcbiAgICB2YXIgbmV4dEN5Y2xlUmVuZGVyRmxhZyA9IHRoaXMuc2hvdWxkQmVSZW5kZXJlZCgpO1xuXG4gICAgaWYgKHRoaXMuY2xvbmUgJiYgKHRoaXMubmVlZEZ1bGxSZW5kZXIgfHwgbmV4dEN5Y2xlUmVuZGVyRmxhZykpIHtcbiAgICAgIHRoaXMuY2xvbmUuZHJhdyhmYXN0RHJhdyk7XG4gICAgfVxuICAgIHRoaXMubmVlZEZ1bGxSZW5kZXIgPSBuZXh0Q3ljbGVSZW5kZXJGbGFnO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgb3ZlcmxheSBpbnN0YW5jZVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICBldmVudE1hbmFnZXJPYmplY3QodGhpcy5jbG9uZSkuZGVzdHJveSgpO1xuICB9XG59XG5cbmV4cG9ydCB7V2Fsa29udGFibGVPdmVybGF5fTtcblxud2luZG93LldhbGtvbnRhYmxlT3ZlcmxheSA9IFdhbGtvbnRhYmxlT3ZlcmxheTtcbiIsIlxuaW1wb3J0IHtcbiAgb3V0ZXJIZWlnaHQsXG4gIG91dGVyV2lkdGgsXG4gIHNldE92ZXJsYXlQb3NpdGlvbixcbiAgICB9IGZyb20gJy4vLi4vLi4vLi4vLi4vaGVscGVycy9kb20vZWxlbWVudCc7XG5pbXBvcnQge1dhbGtvbnRhYmxlT3ZlcmxheX0gZnJvbSAnLi9fYmFzZSc7XG5cblxuLyoqXG4gKiBAY2xhc3MgV2Fsa29udGFibGVDb3JuZXJPdmVybGF5XG4gKi9cbmNsYXNzIFdhbGtvbnRhYmxlQ29ybmVyT3ZlcmxheSBleHRlbmRzIFdhbGtvbnRhYmxlT3ZlcmxheSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1dhbGtvbnRhYmxlfSB3b3RJbnN0YW5jZVxuICAgKi9cbiAgY29uc3RydWN0b3Iod290SW5zdGFuY2UpIHtcbiAgICBzdXBlcih3b3RJbnN0YW5jZSk7XG4gICAgdGhpcy5jbG9uZSA9IHRoaXMubWFrZUNsb25lKFdhbGtvbnRhYmxlT3ZlcmxheS5DTE9ORV9DT1JORVIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBvdmVybGF5IHNob3VsZCBiZSBmdWxseSByZW5kZXJlZFxuICAgKlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIHNob3VsZEJlUmVuZGVyZWQoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvdC5nZXRTZXR0aW5nKCdmaXhlZFJvd3NUb3AnKSB8fCB0aGlzLndvdC5nZXRTZXR0aW5nKCdjb2x1bW5IZWFkZXJzJykubGVuZ3RoKSAmJlxuICAgICAgICAodGhpcy53b3QuZ2V0U2V0dGluZygnZml4ZWRDb2x1bW5zTGVmdCcpIHx8IHRoaXMud290LmdldFNldHRpbmcoJ3Jvd0hlYWRlcnMnKS5sZW5ndGgpID8gdHJ1ZSA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGNvcm5lciBvdmVybGF5IHBvc2l0aW9uXG4gICAqL1xuICByZXNldEZpeGVkUG9zaXRpb24oKSB7XG4gICAgaWYgKCF0aGlzLndvdC53dFRhYmxlLmhvbGRlci5wYXJlbnROb2RlKSB7XG4gICAgICAvLyByZW1vdmVkIGZyb20gRE9NXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBvdmVybGF5Um9vdCA9IHRoaXMuY2xvbmUud3RUYWJsZS5ob2xkZXIucGFyZW50Tm9kZTtcbiAgICBsZXQgdGFibGVIZWlnaHQgPSBvdXRlckhlaWdodCh0aGlzLmNsb25lLnd0VGFibGUuVEFCTEUpO1xuICAgIGxldCB0YWJsZVdpZHRoID0gb3V0ZXJXaWR0aCh0aGlzLmNsb25lLnd0VGFibGUuVEFCTEUpO1xuXG4gICAgaWYgKHRoaXMudHJpbW1pbmdDb250YWluZXIgPT09IHdpbmRvdykge1xuICAgICAgbGV0IGJveCA9IHRoaXMud290Lnd0VGFibGUuaGlkZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBsZXQgdG9wID0gTWF0aC5jZWlsKGJveC50b3ApO1xuICAgICAgbGV0IGxlZnQgPSBNYXRoLmNlaWwoYm94LmxlZnQpO1xuICAgICAgbGV0IGJvdHRvbSA9IE1hdGguY2VpbChib3guYm90dG9tKTtcbiAgICAgIGxldCByaWdodCA9IE1hdGguY2VpbChib3gucmlnaHQpO1xuICAgICAgbGV0IGZpbmFsTGVmdDtcbiAgICAgIGxldCBmaW5hbFRvcDtcblxuICAgICAgaWYgKGxlZnQgPCAwICYmIChyaWdodCAtIG92ZXJsYXlSb290Lm9mZnNldFdpZHRoKSA+IDApIHtcbiAgICAgICAgZmluYWxMZWZ0ID0gLWxlZnQgKyAncHgnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmluYWxMZWZ0ID0gJzAnO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9wIDwgMCAmJiAoYm90dG9tIC0gb3ZlcmxheVJvb3Qub2Zmc2V0SGVpZ2h0KSA+IDApIHtcbiAgICAgICAgZmluYWxUb3AgPSAtdG9wICsgJ3B4JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbmFsVG9wID0gJzAnO1xuICAgICAgfVxuICAgICAgc2V0T3ZlcmxheVBvc2l0aW9uKG92ZXJsYXlSb290LCBmaW5hbExlZnQsIGZpbmFsVG9wKTtcbiAgICB9XG4gICAgb3ZlcmxheVJvb3Quc3R5bGUuaGVpZ2h0ID0gKHRhYmxlSGVpZ2h0ID09PSAwID8gdGFibGVIZWlnaHQgOiB0YWJsZUhlaWdodCArIDQpICsgJ3B4JztcbiAgICBvdmVybGF5Um9vdC5zdHlsZS53aWR0aCA9ICh0YWJsZVdpZHRoID09PSAwID8gdGFibGVXaWR0aCA6IHRhYmxlV2lkdGggKyA0KSArICdweCc7XG4gIH1cbn1cblxuZXhwb3J0IHtXYWxrb250YWJsZUNvcm5lck92ZXJsYXl9O1xuXG53aW5kb3cuV2Fsa29udGFibGVDb3JuZXJPdmVybGF5ID0gV2Fsa29udGFibGVDb3JuZXJPdmVybGF5O1xuIiwiXG5pbXBvcnQge2FkZENsYXNzfSBmcm9tICcuLy4uLy4uLy4uLy4uL2hlbHBlcnMvZG9tL2VsZW1lbnQnO1xuaW1wb3J0IHtXYWxrb250YWJsZU92ZXJsYXl9IGZyb20gJy4vX2Jhc2UnO1xuXG4vKipcbiAqIEEgb3ZlcmxheSB0aGF0IHJlbmRlcnMgQUxMIGF2YWlsYWJsZSByb3dzICYgY29sdW1ucyBwb3NpdGlvbmVkIG9uIHRvcCBvZiB0aGUgb3JpZ2luYWwgV2Fsa29udGFibGUgaW5zdGFuY2UgYW5kIGFsbCBvdGhlciBvdmVybGF5cy5cbiAqIFVzZWQgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcyB0byBzZWUgaWYgdGhlIG90aGVyIG92ZXJsYXlzICh0aGF0IHJlbmRlciBvbmx5IHBhcnQgb2YgdGhlIHJvd3MgJiBjb2x1bW5zKSBhcmUgcG9zaXRpb25lZCBjb3JyZWN0bHlcbiAqXG4gKiBAY2xhc3MgV2Fsa29udGFibGVEZWJ1Z092ZXJsYXlcbiAqL1xuY2xhc3MgV2Fsa29udGFibGVEZWJ1Z092ZXJsYXkgZXh0ZW5kcyBXYWxrb250YWJsZU92ZXJsYXkge1xuICAvKipcbiAgICogQHBhcmFtIHtXYWxrb250YWJsZX0gd290SW5zdGFuY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdvdEluc3RhbmNlKSB7XG4gICAgc3VwZXIod290SW5zdGFuY2UpO1xuXG4gICAgdGhpcy5jbG9uZSA9IHRoaXMubWFrZUNsb25lKFdhbGtvbnRhYmxlT3ZlcmxheS5DTE9ORV9ERUJVRyk7XG4gICAgdGhpcy5jbG9uZS53dFRhYmxlLmhvbGRlci5zdHlsZS5vcGFjaXR5ID0gMC40O1xuICAgIHRoaXMuY2xvbmUud3RUYWJsZS5ob2xkZXIuc3R5bGUudGV4dFNoYWRvdyA9ICcwIDAgMnB4ICNmZjAwMDAnO1xuXG4gICAgYWRkQ2xhc3ModGhpcy5jbG9uZS53dFRhYmxlLmhvbGRlci5wYXJlbnROb2RlLCAnd3REZWJ1Z1Zpc2libGUnKTtcbiAgfVxufVxuXG5leHBvcnQge1dhbGtvbnRhYmxlRGVidWdPdmVybGF5fTtcblxud2luZG93LldhbGtvbnRhYmxlRGVidWdPdmVybGF5ID0gV2Fsa29udGFibGVEZWJ1Z092ZXJsYXk7XG4iLCJcbmltcG9ydCB7XG4gIGFkZENsYXNzLFxuICBnZXRTY3JvbGxiYXJXaWR0aCxcbiAgZ2V0U2Nyb2xsTGVmdCxcbiAgZ2V0V2luZG93U2Nyb2xsVG9wLFxuICBoYXNDbGFzcyxcbiAgb3V0ZXJXaWR0aCxcbiAgcmVtb3ZlQ2xhc3MsXG4gIHNldE92ZXJsYXlQb3NpdGlvbixcbiAgICB9IGZyb20gJy4vLi4vLi4vLi4vLi4vaGVscGVycy9kb20vZWxlbWVudCc7XG5pbXBvcnQge1dhbGtvbnRhYmxlT3ZlcmxheX0gZnJvbSAnLi9fYmFzZSc7XG5cblxuLyoqXG4gKiBAY2xhc3MgV2Fsa29udGFibGVMZWZ0T3ZlcmxheVxuICovXG5jbGFzcyBXYWxrb250YWJsZUxlZnRPdmVybGF5IGV4dGVuZHMgV2Fsa29udGFibGVPdmVybGF5IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7V2Fsa29udGFibGV9IHdvdEluc3RhbmNlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3b3RJbnN0YW5jZSkge1xuICAgIHN1cGVyKHdvdEluc3RhbmNlKTtcbiAgICB0aGlzLmNsb25lID0gdGhpcy5tYWtlQ2xvbmUoV2Fsa29udGFibGVPdmVybGF5LkNMT05FX0xFRlQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBvdmVybGF5IHNob3VsZCBiZSBmdWxseSByZW5kZXJlZFxuICAgKlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIHNob3VsZEJlUmVuZGVyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMud290LmdldFNldHRpbmcoJ2ZpeGVkQ29sdW1uc0xlZnQnKSB8fCB0aGlzLndvdC5nZXRTZXR0aW5nKCdyb3dIZWFkZXJzJykubGVuZ3RoID8gdHJ1ZSA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGxlZnQgb3ZlcmxheSBwb3NpdGlvblxuICAgKi9cbiAgcmVzZXRGaXhlZFBvc2l0aW9uKCkge1xuICAgIGlmICghdGhpcy5uZWVkRnVsbFJlbmRlciB8fCAhdGhpcy53b3Qud3RUYWJsZS5ob2xkZXIucGFyZW50Tm9kZSkge1xuICAgICAgLy8gcmVtb3ZlZCBmcm9tIERPTVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgb3ZlcmxheVJvb3QgPSB0aGlzLmNsb25lLnd0VGFibGUuaG9sZGVyLnBhcmVudE5vZGU7XG4gICAgbGV0IGhlYWRlclBvc2l0aW9uID0gMDtcblxuICAgIGlmICh0aGlzLnRyaW1taW5nQ29udGFpbmVyID09PSB3aW5kb3cpIHtcbiAgICAgIGxldCBib3ggPSB0aGlzLndvdC53dFRhYmxlLmhpZGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgbGV0IGxlZnQgPSBNYXRoLmNlaWwoYm94LmxlZnQpO1xuICAgICAgbGV0IHJpZ2h0ID0gTWF0aC5jZWlsKGJveC5yaWdodCk7XG4gICAgICBsZXQgZmluYWxMZWZ0O1xuICAgICAgbGV0IGZpbmFsVG9wO1xuXG4gICAgICBmaW5hbFRvcCA9IHRoaXMud290Lnd0VGFibGUuaGlkZXIuc3R5bGUudG9wO1xuICAgICAgZmluYWxUb3AgPSBmaW5hbFRvcCA9PT0gJycgPyAwIDogZmluYWxUb3A7XG5cbiAgICAgIGlmIChsZWZ0IDwgMCAmJiAocmlnaHQgLSBvdmVybGF5Um9vdC5vZmZzZXRXaWR0aCkgPiAwKSB7XG4gICAgICAgIGZpbmFsTGVmdCA9IC1sZWZ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmluYWxMZWZ0ID0gMDtcbiAgICAgIH1cbiAgICAgIGhlYWRlclBvc2l0aW9uID0gZmluYWxMZWZ0O1xuICAgICAgZmluYWxMZWZ0ID0gZmluYWxMZWZ0ICsgJ3B4JztcblxuICAgICAgc2V0T3ZlcmxheVBvc2l0aW9uKG92ZXJsYXlSb290LCBmaW5hbExlZnQsIGZpbmFsVG9wKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkZXJQb3NpdGlvbiA9IHRoaXMuZ2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICB9XG4gICAgdGhpcy5hZGp1c3RIZWFkZXJCb3JkZXJzUG9zaXRpb24oaGVhZGVyUG9zaXRpb24pO1xuXG4gICAgdGhpcy5hZGp1c3RFbGVtZW50c1NpemUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtYWluIG92ZXJsYXkncyBob3Jpem9udGFsIHNjcm9sbCBwb3NpdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zXG4gICAqL1xuICBzZXRTY3JvbGxQb3NpdGlvbihwb3MpIHtcbiAgICBpZiAodGhpcy5tYWluVGFibGVTY3JvbGxhYmxlRWxlbWVudCA9PT0gd2luZG93KSB7XG4gICAgICB3aW5kb3cuc2Nyb2xsVG8ocG9zLCBnZXRXaW5kb3dTY3JvbGxUb3AoKSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYWluVGFibGVTY3JvbGxhYmxlRWxlbWVudC5zY3JvbGxMZWZ0ID0gcG9zO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VycyBvblNjcm9sbCBob29rIGNhbGxiYWNrXG4gICAqL1xuICBvblNjcm9sbCgpIHtcbiAgICB0aGlzLndvdC5nZXRTZXR0aW5nKCdvblNjcm9sbEhvcml6b250YWxseScpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdG90YWwgc3VtIGNlbGxzIHdpZHRoXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcm9tIENvbHVtbiBpbmRleCB3aGljaCBjYWxjdWxhdGVzIHN0YXJ0ZWQgZnJvbVxuICAgKiBAcGFyYW0ge051bWJlcn0gdG8gQ29sdW1uIGluZGV4IHdoZXJlIGNhbGN1bGF0aW9uIGlzIGZpbmlzaGVkXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFdpZHRoIHN1bVxuICAgKi9cbiAgc3VtQ2VsbFNpemVzKGZyb20sIHRvKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgbGV0IGRlZmF1bHRDb2x1bW5XaWR0aCA9IHRoaXMud290Lnd0U2V0dGluZ3MuZGVmYXVsdENvbHVtbldpZHRoO1xuXG4gICAgd2hpbGUgKGZyb20gPCB0bykge1xuICAgICAgc3VtICs9IHRoaXMud290Lnd0VGFibGUuZ2V0U3RyZXRjaGVkQ29sdW1uV2lkdGgoZnJvbSkgfHwgZGVmYXVsdENvbHVtbldpZHRoO1xuICAgICAgZnJvbSsrO1xuICAgIH1cblxuICAgIHJldHVybiBzdW07XG4gIH1cblxuICAvKipcbiAgICogQWRqdXN0IG92ZXJsYXkgcm9vdCBlbGVtZW50LCBjaGlsZHMgYW5kIG1hc3RlciB0YWJsZSBlbGVtZW50IHNpemVzICh3aWR0aCwgaGVpZ2h0KS5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2U9ZmFsc2VdXG4gICAqL1xuICBhZGp1c3RFbGVtZW50c1NpemUoZm9yY2UgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLm5lZWRGdWxsUmVuZGVyIHx8IGZvcmNlKSB7XG4gICAgICB0aGlzLmFkanVzdFJvb3RFbGVtZW50U2l6ZSgpO1xuICAgICAgdGhpcy5hZGp1c3RSb290Q2hpbGRzU2l6ZSgpO1xuXG4gICAgICBpZiAoIWZvcmNlKSB7XG4gICAgICAgIHRoaXMuYXJlRWxlbWVudFNpemVzQWRqdXN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGp1c3Qgb3ZlcmxheSByb290IGVsZW1lbnQgc2l6ZSAod2lkdGggYW5kIGhlaWdodCkuXG4gICAqL1xuICBhZGp1c3RSb290RWxlbWVudFNpemUoKSB7XG4gICAgbGV0IG1hc3RlckhvbGRlciA9IHRoaXMud290Lnd0VGFibGUuaG9sZGVyO1xuICAgIGxldCBzY3JvbGxiYXJIZWlnaHQgPSBtYXN0ZXJIb2xkZXIuY2xpZW50SGVpZ2h0ICE9PSBtYXN0ZXJIb2xkZXIub2Zmc2V0SGVpZ2h0ID8gZ2V0U2Nyb2xsYmFyV2lkdGgoKSA6IDA7XG4gICAgbGV0IG92ZXJsYXlSb290ID0gdGhpcy5jbG9uZS53dFRhYmxlLmhvbGRlci5wYXJlbnROb2RlO1xuICAgIGxldCBvdmVybGF5Um9vdFN0eWxlID0gb3ZlcmxheVJvb3Quc3R5bGU7XG4gICAgbGV0IHRhYmxlV2lkdGg7XG5cbiAgICBpZiAodGhpcy50cmltbWluZ0NvbnRhaW5lciAhPT0gd2luZG93KSB7XG4gICAgICBvdmVybGF5Um9vdFN0eWxlLmhlaWdodCA9IHRoaXMud290Lnd0Vmlld3BvcnQuZ2V0V29ya3NwYWNlSGVpZ2h0KCkgLSBzY3JvbGxiYXJIZWlnaHQgKyAncHgnO1xuICAgIH1cbiAgICB0aGlzLmNsb25lLnd0VGFibGUuaG9sZGVyLnN0eWxlLmhlaWdodCA9IG92ZXJsYXlSb290U3R5bGUuaGVpZ2h0O1xuXG4gICAgdGFibGVXaWR0aCA9IG91dGVyV2lkdGgodGhpcy5jbG9uZS53dFRhYmxlLlRBQkxFKTtcbiAgICBvdmVybGF5Um9vdFN0eWxlLndpZHRoID0gKHRhYmxlV2lkdGggPT09IDAgPyB0YWJsZVdpZHRoIDogdGFibGVXaWR0aCArIDQpICsgJ3B4JztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGp1c3Qgb3ZlcmxheSByb290IGNoaWxkcyBzaXplXG4gICAqL1xuICBhZGp1c3RSb290Q2hpbGRzU2l6ZSgpIHtcbiAgICBsZXQgc2Nyb2xsYmFyV2lkdGggPSBnZXRTY3JvbGxiYXJXaWR0aCgpO1xuXG4gICAgdGhpcy5jbG9uZS53dFRhYmxlLmhpZGVyLnN0eWxlLmhlaWdodCA9IHRoaXMuaGlkZXIuc3R5bGUuaGVpZ2h0O1xuICAgIHRoaXMuY2xvbmUud3RUYWJsZS5ob2xkZXIuc3R5bGUuaGVpZ2h0ID0gdGhpcy5jbG9uZS53dFRhYmxlLmhvbGRlci5wYXJlbnROb2RlLnN0eWxlLmhlaWdodDtcblxuICAgIGlmIChzY3JvbGxiYXJXaWR0aCA9PT0gMCkge1xuICAgICAgc2Nyb2xsYmFyV2lkdGggPSAzMDtcbiAgICB9XG4gICAgdGhpcy5jbG9uZS53dFRhYmxlLmhvbGRlci5zdHlsZS53aWR0aCA9IHBhcnNlSW50KHRoaXMuY2xvbmUud3RUYWJsZS5ob2xkZXIucGFyZW50Tm9kZS5zdHlsZS53aWR0aCwgMTApICsgc2Nyb2xsYmFyV2lkdGggKyAncHgnO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkanVzdCB0aGUgb3ZlcmxheSBkaW1lbnNpb25zIGFuZCBwb3NpdGlvblxuICAgKi9cbiAgYXBwbHlUb0RPTSgpIHtcbiAgICBsZXQgdG90YWwgPSB0aGlzLndvdC5nZXRTZXR0aW5nKCd0b3RhbENvbHVtbnMnKTtcblxuICAgIGlmICghdGhpcy5hcmVFbGVtZW50U2l6ZXNBZGp1c3RlZCkge1xuICAgICAgdGhpcy5hZGp1c3RFbGVtZW50c1NpemUoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLndvdC53dFZpZXdwb3J0LmNvbHVtbnNSZW5kZXJDYWxjdWxhdG9yLnN0YXJ0UG9zaXRpb24gPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnNwcmVhZGVyLnN0eWxlLmxlZnQgPSB0aGlzLndvdC53dFZpZXdwb3J0LmNvbHVtbnNSZW5kZXJDYWxjdWxhdG9yLnN0YXJ0UG9zaXRpb24gKyAncHgnO1xuXG4gICAgfSBlbHNlIGlmICh0b3RhbCA9PT0gMCkge1xuICAgICAgdGhpcy5zcHJlYWRlci5zdHlsZS5sZWZ0ID0gJzAnO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IHZhbHVlIG9mIHRoZSBjb2x1bW5zUmVuZGVyQ2FsY3VsYXRvcicpO1xuICAgIH1cbiAgICB0aGlzLnNwcmVhZGVyLnN0eWxlLnJpZ2h0ID0gJyc7XG5cbiAgICBpZiAodGhpcy5uZWVkRnVsbFJlbmRlcikge1xuICAgICAgdGhpcy5zeW5jT3ZlcmxheU9mZnNldCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTeW5jaHJvbml6ZSBjYWxjdWxhdGVkIHRvcCBwb3NpdGlvbiB0byBhbiBlbGVtZW50XG4gICAqL1xuICBzeW5jT3ZlcmxheU9mZnNldCgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMud290Lnd0Vmlld3BvcnQucm93c1JlbmRlckNhbGN1bGF0b3Iuc3RhcnRQb3NpdGlvbiA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuY2xvbmUud3RUYWJsZS5zcHJlYWRlci5zdHlsZS50b3AgPSB0aGlzLndvdC53dFZpZXdwb3J0LnJvd3NSZW5kZXJDYWxjdWxhdG9yLnN0YXJ0UG9zaXRpb24gKyAncHgnO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xvbmUud3RUYWJsZS5zcHJlYWRlci5zdHlsZS50b3AgPSAnJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2Nyb2xscyBob3Jpem9udGFsbHkgdG8gYSBjb2x1bW4gYXQgdGhlIGxlZnQgZWRnZSBvZiB0aGUgdmlld3BvcnRcbiAgICpcbiAgICogQHBhcmFtIHNvdXJjZUNvbCB7TnVtYmVyfSBDb2x1bW4gaW5kZXggd2hpY2ggeW91IHdhbnQgdG8gc2Nyb2xsIHRvXG4gICAqIEBwYXJhbSBbYmV5b25kUmVuZGVyZWQ9ZmFsc2VdIHtCb29sZWFufSBpZiBgdHJ1ZWAsIHNjcm9sbHMgYWNjb3JkaW5nIHRvIHRoZSBib3R0b20gZWRnZSAodG9wIGVkZ2UgaXMgYnkgZGVmYXVsdClcbiAgICovXG4gIHNjcm9sbFRvKHNvdXJjZUNvbCwgYmV5b25kUmVuZGVyZWQpIHtcbiAgICBsZXQgbmV3WCA9IHRoaXMuZ2V0VGFibGVQYXJlbnRPZmZzZXQoKTtcbiAgICBsZXQgc291cmNlSW5zdGFuY2UgPSB0aGlzLndvdC5jbG9uZVNvdXJjZSA/IHRoaXMud290LmNsb25lU291cmNlIDogdGhpcy53b3Q7XG4gICAgbGV0IG1haW5Ib2xkZXIgPSBzb3VyY2VJbnN0YW5jZS53dFRhYmxlLmhvbGRlcjtcbiAgICBsZXQgc2Nyb2xsYmFyQ29tcGVuc2F0aW9uID0gMDtcblxuICAgIGlmIChiZXlvbmRSZW5kZXJlZCAmJiBtYWluSG9sZGVyLm9mZnNldFdpZHRoICE9PSBtYWluSG9sZGVyLmNsaWVudFdpZHRoKSB7XG4gICAgICBzY3JvbGxiYXJDb21wZW5zYXRpb24gPSBnZXRTY3JvbGxiYXJXaWR0aCgpO1xuICAgIH1cbiAgICBpZiAoYmV5b25kUmVuZGVyZWQpIHtcbiAgICAgIG5ld1ggKz0gdGhpcy5zdW1DZWxsU2l6ZXMoMCwgc291cmNlQ29sICsgMSk7XG4gICAgICBuZXdYIC09IHRoaXMud290Lnd0Vmlld3BvcnQuZ2V0Vmlld3BvcnRXaWR0aCgpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1ggKz0gdGhpcy5zdW1DZWxsU2l6ZXModGhpcy53b3QuZ2V0U2V0dGluZygnZml4ZWRDb2x1bW5zTGVmdCcpLCBzb3VyY2VDb2wpO1xuICAgIH1cbiAgICBuZXdYICs9IHNjcm9sbGJhckNvbXBlbnNhdGlvbjtcblxuICAgIHRoaXMuc2V0U2Nyb2xsUG9zaXRpb24obmV3WCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0YWJsZSBwYXJlbnQgbGVmdCBwb3NpdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0VGFibGVQYXJlbnRPZmZzZXQoKSB7XG4gICAgaWYgKHRoaXMudHJpbW1pbmdDb250YWluZXIgPT09IHdpbmRvdykge1xuICAgICAgcmV0dXJuIHRoaXMud290Lnd0VGFibGUuaG9sZGVyT2Zmc2V0LmxlZnQ7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG1haW4gb3ZlcmxheSdzIGhvcml6b250YWwgc2Nyb2xsIHBvc2l0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IE1haW4gdGFibGUncyB2ZXJ0aWNhbCBzY3JvbGwgcG9zaXRpb25cbiAgICovXG4gIGdldFNjcm9sbFBvc2l0aW9uKCkge1xuICAgIHJldHVybiBnZXRTY3JvbGxMZWZ0KHRoaXMubWFpblRhYmxlU2Nyb2xsYWJsZUVsZW1lbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgY3NzIGNsYXNzZXMgdG8gaGlkZSB0aGUgaGVhZGVyIGJvcmRlcidzIGhlYWRlciAoY2VsbC1zZWxlY3Rpb24gYm9yZGVyIGhpZGluZyBpc3N1ZSlcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIEhlYWRlciBYIHBvc2l0aW9uIGlmIHRyaW1taW5nIGNvbnRhaW5lciBpcyB3aW5kb3cgb3Igc2Nyb2xsIHRvcCBpZiBub3RcbiAgICovXG4gIGFkanVzdEhlYWRlckJvcmRlcnNQb3NpdGlvbihwb3NpdGlvbikge1xuICAgIGxldCBtYXN0ZXJQYXJlbnQgPSB0aGlzLndvdC53dFRhYmxlLmhvbGRlci5wYXJlbnROb2RlO1xuICAgIGxldCByb3dIZWFkZXJzID0gdGhpcy53b3QuZ2V0U2V0dGluZygncm93SGVhZGVycycpO1xuICAgIGxldCBmaXhlZENvbHVtbnNMZWZ0ID0gdGhpcy53b3QuZ2V0U2V0dGluZygnZml4ZWRDb2x1bW5zTGVmdCcpO1xuXG4gICAgaWYgKGZpeGVkQ29sdW1uc0xlZnQgJiYgIXJvd0hlYWRlcnMubGVuZ3RoKSB7XG4gICAgICBhZGRDbGFzcyhtYXN0ZXJQYXJlbnQsICdpbm5lckJvcmRlckxlZnQnKTtcblxuICAgIH0gZWxzZSBpZiAoIWZpeGVkQ29sdW1uc0xlZnQgJiYgcm93SGVhZGVycy5sZW5ndGgpIHtcbiAgICAgIGxldCBwcmV2aW91c1N0YXRlID0gaGFzQ2xhc3MobWFzdGVyUGFyZW50LCAnaW5uZXJCb3JkZXJMZWZ0Jyk7XG5cbiAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICBhZGRDbGFzcyhtYXN0ZXJQYXJlbnQsICdpbm5lckJvcmRlckxlZnQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUNsYXNzKG1hc3RlclBhcmVudCwgJ2lubmVyQm9yZGVyTGVmdCcpO1xuICAgICAgfVxuICAgICAgaWYgKCFwcmV2aW91c1N0YXRlICYmIHBvc2l0aW9uIHx8IHByZXZpb3VzU3RhdGUgJiYgIXBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMud290Lnd0T3ZlcmxheXMuYWRqdXN0RWxlbWVudHNTaXplKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7V2Fsa29udGFibGVMZWZ0T3ZlcmxheX07XG5cbndpbmRvdy5XYWxrb250YWJsZUxlZnRPdmVybGF5ID0gV2Fsa29udGFibGVMZWZ0T3ZlcmxheTtcbiIsIlxuaW1wb3J0IHtcbiAgYWRkQ2xhc3MsXG4gIGdldFNjcm9sbGJhcldpZHRoLFxuICBnZXRTY3JvbGxUb3AsXG4gIGdldFdpbmRvd1Njcm9sbExlZnQsXG4gIGhhc0NsYXNzLFxuICBvdXRlckhlaWdodCxcbiAgcmVtb3ZlQ2xhc3MsXG4gIHNldE92ZXJsYXlQb3NpdGlvbixcbiAgICB9IGZyb20gJy4vLi4vLi4vLi4vLi4vaGVscGVycy9kb20vZWxlbWVudCc7XG5pbXBvcnQge1dhbGtvbnRhYmxlT3ZlcmxheX0gZnJvbSAnLi9fYmFzZSc7XG5cblxuLyoqXG4gKiBAY2xhc3MgV2Fsa29udGFibGVUb3BPdmVybGF5XG4gKi9cbmNsYXNzIFdhbGtvbnRhYmxlVG9wT3ZlcmxheSBleHRlbmRzIFdhbGtvbnRhYmxlT3ZlcmxheSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1dhbGtvbnRhYmxlfSB3b3RJbnN0YW5jZVxuICAgKi9cbiAgY29uc3RydWN0b3Iod290SW5zdGFuY2UpIHtcbiAgICBzdXBlcih3b3RJbnN0YW5jZSk7XG4gICAgdGhpcy5jbG9uZSA9IHRoaXMubWFrZUNsb25lKFdhbGtvbnRhYmxlT3ZlcmxheS5DTE9ORV9UT1ApO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBvdmVybGF5IHNob3VsZCBiZSBmdWxseSByZW5kZXJlZFxuICAgKlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIHNob3VsZEJlUmVuZGVyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMud290LmdldFNldHRpbmcoJ2ZpeGVkUm93c1RvcCcpIHx8IHRoaXMud290LmdldFNldHRpbmcoJ2NvbHVtbkhlYWRlcnMnKS5sZW5ndGggPyB0cnVlIDogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgdG9wIG92ZXJsYXkgcG9zaXRpb25cbiAgICovXG4gIHJlc2V0Rml4ZWRQb3NpdGlvbigpIHtcbiAgICBpZiAoIXRoaXMubmVlZEZ1bGxSZW5kZXIgfHwgIXRoaXMud290Lnd0VGFibGUuaG9sZGVyLnBhcmVudE5vZGUpIHtcbiAgICAgIC8vIHJlbW92ZWQgZnJvbSBET01cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IG92ZXJsYXlSb290ID0gdGhpcy5jbG9uZS53dFRhYmxlLmhvbGRlci5wYXJlbnROb2RlO1xuICAgIGxldCBoZWFkZXJQb3NpdGlvbiA9IDA7XG5cbiAgICBpZiAodGhpcy53b3Qud3RPdmVybGF5cy5sZWZ0T3ZlcmxheS50cmltbWluZ0NvbnRhaW5lciA9PT0gd2luZG93KSB7XG4gICAgICBsZXQgYm94ID0gdGhpcy53b3Qud3RUYWJsZS5oaWRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGxldCB0b3AgPSBNYXRoLmNlaWwoYm94LnRvcCk7XG4gICAgICBsZXQgYm90dG9tID0gTWF0aC5jZWlsKGJveC5ib3R0b20pO1xuICAgICAgbGV0IGZpbmFsTGVmdDtcbiAgICAgIGxldCBmaW5hbFRvcDtcblxuICAgICAgZmluYWxMZWZ0ID0gdGhpcy53b3Qud3RUYWJsZS5oaWRlci5zdHlsZS5sZWZ0O1xuICAgICAgZmluYWxMZWZ0ID0gZmluYWxMZWZ0ID09PSAnJyA/IDAgOiBmaW5hbExlZnQ7XG5cbiAgICAgIGlmICh0b3AgPCAwICYmIChib3R0b20gLSBvdmVybGF5Um9vdC5vZmZzZXRIZWlnaHQpID4gMCkge1xuICAgICAgICBmaW5hbFRvcCA9IC10b3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaW5hbFRvcCA9IDA7XG4gICAgICB9XG4gICAgICBoZWFkZXJQb3NpdGlvbiA9IGZpbmFsVG9wO1xuICAgICAgZmluYWxUb3AgPSBmaW5hbFRvcCArICdweCc7XG5cbiAgICAgIHNldE92ZXJsYXlQb3NpdGlvbihvdmVybGF5Um9vdCwgZmluYWxMZWZ0LCBmaW5hbFRvcCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZGVyUG9zaXRpb24gPSB0aGlzLmdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMuYWRqdXN0SGVhZGVyQm9yZGVyc1Bvc2l0aW9uKGhlYWRlclBvc2l0aW9uKTtcblxuICAgIHRoaXMuYWRqdXN0RWxlbWVudHNTaXplKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbWFpbiBvdmVybGF5J3MgdmVydGljYWwgc2Nyb2xsIHBvc2l0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NcbiAgICovXG4gIHNldFNjcm9sbFBvc2l0aW9uKHBvcykge1xuICAgIGlmICh0aGlzLm1haW5UYWJsZVNjcm9sbGFibGVFbGVtZW50ID09PSB3aW5kb3cpIHtcbiAgICAgIHdpbmRvdy5zY3JvbGxUbyhnZXRXaW5kb3dTY3JvbGxMZWZ0KCksIHBvcyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYWluVGFibGVTY3JvbGxhYmxlRWxlbWVudC5zY3JvbGxUb3AgPSBwb3M7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIG9uU2Nyb2xsIGhvb2sgY2FsbGJhY2tcbiAgICovXG4gIG9uU2Nyb2xsKCkge1xuICAgIHRoaXMud290LmdldFNldHRpbmcoJ29uU2Nyb2xsVmVydGljYWxseScpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdG90YWwgc3VtIGNlbGxzIGhlaWdodFxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gZnJvbSBSb3cgaW5kZXggd2hpY2ggY2FsY3VsYXRlcyBzdGFydGVkIGZyb21cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRvIFJvdyBpbmRleCB3aGVyZSBjYWxjdWxhdGlvbiBpcyBmaW5pc2hlZFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBIZWlnaHQgc3VtXG4gICAqL1xuICBzdW1DZWxsU2l6ZXMoZnJvbSwgdG8pIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBsZXQgZGVmYXVsdFJvd0hlaWdodCA9IHRoaXMud290Lnd0U2V0dGluZ3Muc2V0dGluZ3MuZGVmYXVsdFJvd0hlaWdodDtcblxuICAgIHdoaWxlIChmcm9tIDwgdG8pIHtcbiAgICAgIHN1bSArPSB0aGlzLndvdC53dFRhYmxlLmdldFJvd0hlaWdodChmcm9tKSB8fCBkZWZhdWx0Um93SGVpZ2h0O1xuICAgICAgZnJvbSsrO1xuICAgIH1cblxuICAgIHJldHVybiBzdW07XG4gIH1cblxuICAvKipcbiAgICogQWRqdXN0IG92ZXJsYXkgcm9vdCBlbGVtZW50LCBjaGlsZHMgYW5kIG1hc3RlciB0YWJsZSBlbGVtZW50IHNpemVzICh3aWR0aCwgaGVpZ2h0KS5cbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBbZm9yY2U9ZmFsc2VdXG4gICAqL1xuICBhZGp1c3RFbGVtZW50c1NpemUoZm9yY2UgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLm5lZWRGdWxsUmVuZGVyIHx8IGZvcmNlKSB7XG4gICAgICB0aGlzLmFkanVzdFJvb3RFbGVtZW50U2l6ZSgpO1xuICAgICAgdGhpcy5hZGp1c3RSb290Q2hpbGRzU2l6ZSgpO1xuXG4gICAgICBpZiAoIWZvcmNlKSB7XG4gICAgICAgIHRoaXMuYXJlRWxlbWVudFNpemVzQWRqdXN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGp1c3Qgb3ZlcmxheSByb290IGVsZW1lbnQgc2l6ZSAod2lkdGggYW5kIGhlaWdodCkuXG4gICAqL1xuICBhZGp1c3RSb290RWxlbWVudFNpemUoKSB7XG4gICAgbGV0IG1hc3RlckhvbGRlciA9IHRoaXMud290Lnd0VGFibGUuaG9sZGVyO1xuICAgIGxldCBzY3JvbGxiYXJXaWR0aCA9IG1hc3RlckhvbGRlci5jbGllbnRXaWR0aCAhPT0gbWFzdGVySG9sZGVyLm9mZnNldFdpZHRoID8gZ2V0U2Nyb2xsYmFyV2lkdGgoKSA6IDA7XG4gICAgbGV0IG92ZXJsYXlSb290ID0gdGhpcy5jbG9uZS53dFRhYmxlLmhvbGRlci5wYXJlbnROb2RlO1xuICAgIGxldCBvdmVybGF5Um9vdFN0eWxlID0gb3ZlcmxheVJvb3Quc3R5bGU7XG4gICAgbGV0IHRhYmxlSGVpZ2h0O1xuXG4gICAgaWYgKHRoaXMudHJpbW1pbmdDb250YWluZXIgIT09IHdpbmRvdykge1xuICAgICAgb3ZlcmxheVJvb3RTdHlsZS53aWR0aCA9IHRoaXMud290Lnd0Vmlld3BvcnQuZ2V0V29ya3NwYWNlV2lkdGgoKSAtIHNjcm9sbGJhcldpZHRoICsgJ3B4JztcbiAgICB9XG4gICAgdGhpcy5jbG9uZS53dFRhYmxlLmhvbGRlci5zdHlsZS53aWR0aCA9IG92ZXJsYXlSb290U3R5bGUud2lkdGg7XG5cbiAgICB0YWJsZUhlaWdodCA9IG91dGVySGVpZ2h0KHRoaXMuY2xvbmUud3RUYWJsZS5UQUJMRSk7XG4gICAgb3ZlcmxheVJvb3RTdHlsZS5oZWlnaHQgPSAodGFibGVIZWlnaHQgPT09IDAgPyB0YWJsZUhlaWdodCA6IHRhYmxlSGVpZ2h0ICsgNCkgKyAncHgnO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkanVzdCBvdmVybGF5IHJvb3QgY2hpbGRzIHNpemVcbiAgICovXG4gIGFkanVzdFJvb3RDaGlsZHNTaXplKCkge1xuICAgIGxldCBzY3JvbGxiYXJXaWR0aCA9IGdldFNjcm9sbGJhcldpZHRoKCk7XG5cbiAgICB0aGlzLmNsb25lLnd0VGFibGUuaGlkZXIuc3R5bGUud2lkdGggPSB0aGlzLmhpZGVyLnN0eWxlLndpZHRoO1xuICAgIHRoaXMuY2xvbmUud3RUYWJsZS5ob2xkZXIuc3R5bGUud2lkdGggPSB0aGlzLmNsb25lLnd0VGFibGUuaG9sZGVyLnBhcmVudE5vZGUuc3R5bGUud2lkdGg7XG5cbiAgICBpZiAoc2Nyb2xsYmFyV2lkdGggPT09IDApIHtcbiAgICAgIHNjcm9sbGJhcldpZHRoID0gMzA7XG4gICAgfVxuICAgIHRoaXMuY2xvbmUud3RUYWJsZS5ob2xkZXIuc3R5bGUuaGVpZ2h0ID0gcGFyc2VJbnQodGhpcy5jbG9uZS53dFRhYmxlLmhvbGRlci5wYXJlbnROb2RlLnN0eWxlLmhlaWdodCwgMTApICsgc2Nyb2xsYmFyV2lkdGggKyAncHgnO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkanVzdCB0aGUgb3ZlcmxheSBkaW1lbnNpb25zIGFuZCBwb3NpdGlvblxuICAgKi9cbiAgYXBwbHlUb0RPTSgpIHtcbiAgICBsZXQgdG90YWwgPSB0aGlzLndvdC5nZXRTZXR0aW5nKCd0b3RhbFJvd3MnKTtcblxuICAgIGlmICghdGhpcy5hcmVFbGVtZW50U2l6ZXNBZGp1c3RlZCkge1xuICAgICAgdGhpcy5hZGp1c3RFbGVtZW50c1NpemUoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0aGlzLndvdC53dFZpZXdwb3J0LnJvd3NSZW5kZXJDYWxjdWxhdG9yLnN0YXJ0UG9zaXRpb24gPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnNwcmVhZGVyLnN0eWxlLnRvcCA9IHRoaXMud290Lnd0Vmlld3BvcnQucm93c1JlbmRlckNhbGN1bGF0b3Iuc3RhcnRQb3NpdGlvbiArICdweCc7XG5cbiAgICB9IGVsc2UgaWYgKHRvdGFsID09PSAwKSB7XG4gICAgICAvLyBjYW4gaGFwcGVuIGlmIHRoZXJlIGFyZSAwIHJvd3NcbiAgICAgIHRoaXMuc3ByZWFkZXIuc3R5bGUudG9wID0gJzAnO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29ycmVjdCB2YWx1ZSBvZiB0aGUgcm93c1JlbmRlckNhbGN1bGF0b3JcIik7XG4gICAgfVxuICAgIHRoaXMuc3ByZWFkZXIuc3R5bGUuYm90dG9tID0gJyc7XG5cbiAgICBpZiAodGhpcy5uZWVkRnVsbFJlbmRlcikge1xuICAgICAgdGhpcy5zeW5jT3ZlcmxheU9mZnNldCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTeW5jaHJvbml6ZSBjYWxjdWxhdGVkIGxlZnQgcG9zaXRpb24gdG8gYW4gZWxlbWVudFxuICAgKi9cbiAgc3luY092ZXJsYXlPZmZzZXQoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLndvdC53dFZpZXdwb3J0LmNvbHVtbnNSZW5kZXJDYWxjdWxhdG9yLnN0YXJ0UG9zaXRpb24gPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmNsb25lLnd0VGFibGUuc3ByZWFkZXIuc3R5bGUubGVmdCA9IHRoaXMud290Lnd0Vmlld3BvcnQuY29sdW1uc1JlbmRlckNhbGN1bGF0b3Iuc3RhcnRQb3NpdGlvbiArICdweCc7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbG9uZS53dFRhYmxlLnNwcmVhZGVyLnN0eWxlLmxlZnQgPSAnJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2Nyb2xscyB2ZXJ0aWNhbGx5IHRvIGEgcm93XG4gICAqXG4gICAqIEBwYXJhbSBzb3VyY2VSb3cge051bWJlcn0gUm93IGluZGV4IHdoaWNoIHlvdSB3YW50IHRvIHNjcm9sbCB0b1xuICAgKiBAcGFyYW0gW2JvdHRvbUVkZ2U9ZmFsc2VdIHtCb29sZWFufSBpZiBgdHJ1ZWAsIHNjcm9sbHMgYWNjb3JkaW5nIHRvIHRoZSBib3R0b20gZWRnZSAodG9wIGVkZ2UgaXMgYnkgZGVmYXVsdClcbiAgICovXG4gIHNjcm9sbFRvKHNvdXJjZVJvdywgYm90dG9tRWRnZSkge1xuICAgIGxldCBuZXdZID0gdGhpcy5nZXRUYWJsZVBhcmVudE9mZnNldCgpO1xuICAgIGxldCBzb3VyY2VJbnN0YW5jZSA9IHRoaXMud290LmNsb25lU291cmNlID8gdGhpcy53b3QuY2xvbmVTb3VyY2UgOiB0aGlzLndvdDtcbiAgICBsZXQgbWFpbkhvbGRlciA9IHNvdXJjZUluc3RhbmNlLnd0VGFibGUuaG9sZGVyO1xuICAgIGxldCBzY3JvbGxiYXJDb21wZW5zYXRpb24gPSAwO1xuXG4gICAgaWYgKGJvdHRvbUVkZ2UgJiYgbWFpbkhvbGRlci5vZmZzZXRIZWlnaHQgIT09IG1haW5Ib2xkZXIuY2xpZW50SGVpZ2h0KSB7XG4gICAgICBzY3JvbGxiYXJDb21wZW5zYXRpb24gPSBnZXRTY3JvbGxiYXJXaWR0aCgpO1xuICAgIH1cblxuICAgIGlmIChib3R0b21FZGdlKSB7XG4gICAgICBuZXdZICs9IHRoaXMuc3VtQ2VsbFNpemVzKDAsIHNvdXJjZVJvdyArIDEpO1xuICAgICAgbmV3WSAtPSB0aGlzLndvdC53dFZpZXdwb3J0LmdldFZpZXdwb3J0SGVpZ2h0KCk7XG4gICAgICAvLyBGaXggMSBwaXhlbCBvZmZzZXQgd2hlbiBjZWxsIGlzIHNlbGVjdGVkXG4gICAgICBuZXdZICs9IDE7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3WSArPSB0aGlzLnN1bUNlbGxTaXplcyh0aGlzLndvdC5nZXRTZXR0aW5nKCdmaXhlZFJvd3NUb3AnKSwgc291cmNlUm93KTtcbiAgICB9XG4gICAgbmV3WSArPSBzY3JvbGxiYXJDb21wZW5zYXRpb247XG5cbiAgICB0aGlzLnNldFNjcm9sbFBvc2l0aW9uKG5ld1kpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGFibGUgcGFyZW50IHRvcCBwb3NpdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0VGFibGVQYXJlbnRPZmZzZXQoKSB7XG4gICAgaWYgKHRoaXMubWFpblRhYmxlU2Nyb2xsYWJsZUVsZW1lbnQgPT09IHdpbmRvdykge1xuICAgICAgcmV0dXJuIHRoaXMud290Lnd0VGFibGUuaG9sZGVyT2Zmc2V0LnRvcDtcblxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbWFpbiBvdmVybGF5J3MgdmVydGljYWwgc2Nyb2xsIHBvc2l0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IE1haW4gdGFibGUncyB2ZXJ0aWNhbCBzY3JvbGwgcG9zaXRpb25cbiAgICovXG4gIGdldFNjcm9sbFBvc2l0aW9uKCkge1xuICAgIHJldHVybiBnZXRTY3JvbGxUb3AodGhpcy5tYWluVGFibGVTY3JvbGxhYmxlRWxlbWVudCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBjc3MgY2xhc3NlcyB0byBoaWRlIHRoZSBoZWFkZXIgYm9yZGVyJ3MgaGVhZGVyIChjZWxsLXNlbGVjdGlvbiBib3JkZXIgaGlkaW5nIGlzc3VlKVxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gSGVhZGVyIFkgcG9zaXRpb24gaWYgdHJpbW1pbmcgY29udGFpbmVyIGlzIHdpbmRvdyBvciBzY3JvbGwgdG9wIGlmIG5vdFxuICAgKi9cbiAgYWRqdXN0SGVhZGVyQm9yZGVyc1Bvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgaWYgKHRoaXMud290LmdldFNldHRpbmcoJ2ZpeGVkUm93c1RvcCcpID09PSAwICYmIHRoaXMud290LmdldFNldHRpbmcoJ2NvbHVtbkhlYWRlcnMnKS5sZW5ndGggPiAwKSB7XG4gICAgICBsZXQgbWFzdGVyUGFyZW50ID0gdGhpcy53b3Qud3RUYWJsZS5ob2xkZXIucGFyZW50Tm9kZTtcbiAgICAgIGxldCBwcmV2aW91c1N0YXRlID0gaGFzQ2xhc3MobWFzdGVyUGFyZW50LCAnaW5uZXJCb3JkZXJUb3AnKTtcblxuICAgICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICAgIGFkZENsYXNzKG1hc3RlclBhcmVudCwgJ2lubmVyQm9yZGVyVG9wJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVDbGFzcyhtYXN0ZXJQYXJlbnQsICdpbm5lckJvcmRlclRvcCcpO1xuICAgICAgfVxuICAgICAgaWYgKCFwcmV2aW91c1N0YXRlICYmIHBvc2l0aW9uIHx8IHByZXZpb3VzU3RhdGUgJiYgIXBvc2l0aW9uKSB7XG4gICAgICAgIHRoaXMud290Lnd0T3ZlcmxheXMuYWRqdXN0RWxlbWVudHNTaXplKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG5hc3R5IHdvcmthcm91bmQgZm9yIGRvdWJsZSBib3JkZXIgaW4gdGhlIGhlYWRlciwgVE9ETzogZmluZCBhIHB1cmUtY3NzIHNvbHV0aW9uXG4gICAgaWYgKHRoaXMud290LmdldFNldHRpbmcoJ3Jvd0hlYWRlcnMnKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGxldCBzZWNvbmRIZWFkZXJDZWxsID0gdGhpcy5jbG9uZS53dFRhYmxlLlRIRUFELnF1ZXJ5U2VsZWN0b3IoJ3RoOm50aC1vZi10eXBlKDIpJyk7XG5cbiAgICAgIGlmIChzZWNvbmRIZWFkZXJDZWxsKSB7XG4gICAgICAgIHNlY29uZEhlYWRlckNlbGwuc3R5bGVbJ2JvcmRlci1sZWZ0LXdpZHRoJ10gPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQge1dhbGtvbnRhYmxlVG9wT3ZlcmxheX07XG5cbndpbmRvdy5XYWxrb250YWJsZVRvcE92ZXJsYXkgPSBXYWxrb250YWJsZVRvcE92ZXJsYXk7XG4iLCJcbmltcG9ydCB7XG4gIGdldFNjcm9sbGFibGVFbGVtZW50LFxuICBnZXRTY3JvbGxiYXJXaWR0aCxcbiAgZ2V0U2Nyb2xsTGVmdCxcbiAgZ2V0U2Nyb2xsVG9wLFxuICAgIH0gZnJvbSAnLi8uLi8uLi8uLi9oZWxwZXJzL2RvbS9lbGVtZW50JztcbmltcG9ydCB7aXNLZXl9IGZyb20gJy4vLi4vLi4vLi4vaGVscGVycy91bmljb2RlJztcbmltcG9ydCB7RXZlbnRNYW5hZ2VyfSBmcm9tICcuLy4uLy4uLy4uL2V2ZW50TWFuYWdlcic7XG5pbXBvcnQge1dhbGtvbnRhYmxlQ29ybmVyT3ZlcmxheX0gZnJvbSAnLi9vdmVybGF5L2Nvcm5lcic7XG5pbXBvcnQge1dhbGtvbnRhYmxlRGVidWdPdmVybGF5fSBmcm9tICcuL292ZXJsYXkvZGVidWcnO1xuaW1wb3J0IHtXYWxrb250YWJsZUxlZnRPdmVybGF5fSBmcm9tICcuL292ZXJsYXkvbGVmdCc7XG5pbXBvcnQge1dhbGtvbnRhYmxlVG9wT3ZlcmxheX0gZnJvbSAnLi9vdmVybGF5L3RvcCc7XG5cblxuLyoqXG4gKiBAY2xhc3MgV2Fsa29udGFibGVPdmVybGF5c1xuICovXG5jbGFzcyBXYWxrb250YWJsZU92ZXJsYXlzIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7V2Fsa29udGFibGV9IHdvdEluc3RhbmNlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3b3RJbnN0YW5jZSkge1xuICAgIHRoaXMud290ID0gd290SW5zdGFuY2U7XG5cbiAgICAvLyBsZWdhY3kgc3VwcG9ydFxuICAgIHRoaXMuaW5zdGFuY2UgPSB0aGlzLndvdDtcbiAgICB0aGlzLmV2ZW50TWFuYWdlciA9IG5ldyBFdmVudE1hbmFnZXIodGhpcy53b3QpO1xuXG4gICAgdGhpcy53b3QudXBkYXRlKCdzY3JvbGxiYXJXaWR0aCcsIGdldFNjcm9sbGJhcldpZHRoKCkpO1xuICAgIHRoaXMud290LnVwZGF0ZSgnc2Nyb2xsYmFySGVpZ2h0JywgZ2V0U2Nyb2xsYmFyV2lkdGgoKSk7XG5cbiAgICB0aGlzLm1haW5UYWJsZVNjcm9sbGFibGVFbGVtZW50ID0gZ2V0U2Nyb2xsYWJsZUVsZW1lbnQodGhpcy53b3Qud3RUYWJsZS5UQUJMRSk7XG5cbiAgICB0aGlzLnRvcE92ZXJsYXkgPSBuZXcgV2Fsa29udGFibGVUb3BPdmVybGF5KHRoaXMud290KTtcbiAgICB0aGlzLmxlZnRPdmVybGF5ID0gbmV3IFdhbGtvbnRhYmxlTGVmdE92ZXJsYXkodGhpcy53b3QpO1xuXG4gICAgaWYgKHRoaXMudG9wT3ZlcmxheS5uZWVkRnVsbFJlbmRlciAmJiB0aGlzLmxlZnRPdmVybGF5Lm5lZWRGdWxsUmVuZGVyKSB7XG4gICAgICB0aGlzLnRvcExlZnRDb3JuZXJPdmVybGF5ID0gbmV3IFdhbGtvbnRhYmxlQ29ybmVyT3ZlcmxheSh0aGlzLndvdCk7XG4gICAgfVxuICAgIGlmICh0aGlzLndvdC5nZXRTZXR0aW5nKCdkZWJ1ZycpKSB7XG4gICAgICB0aGlzLmRlYnVnID0gbmV3IFdhbGtvbnRhYmxlRGVidWdPdmVybGF5KHRoaXMud290KTtcbiAgICB9XG5cbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMua2V5UHJlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMuc3ByZWFkZXJMYXN0U2l6ZSA9IHtcbiAgICAgIHdpZHRoOiBudWxsLFxuICAgICAgaGVpZ2h0OiBudWxsXG4gICAgfTtcbiAgICB0aGlzLm92ZXJsYXlTY3JvbGxQb3NpdGlvbnMgPSB7XG4gICAgICAnbWFzdGVyJzoge1xuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDBcbiAgICAgIH0sXG4gICAgICAndG9wJzoge1xuICAgICAgICB0b3A6IG51bGwsXG4gICAgICAgIGxlZnQ6IDBcbiAgICAgIH0sXG4gICAgICAnbGVmdCc6IHtcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiBudWxsXG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVmcmVzaCBhbmQgcmVkcmF3IHRhYmxlXG4gICAqL1xuICByZWZyZXNoQWxsKCkge1xuICAgIGlmICghdGhpcy53b3QuZHJhd24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLndvdC53dFRhYmxlLmhvbGRlci5wYXJlbnROb2RlKSB7XG4gICAgICAvLyBXYWxrb250YWJsZSB3YXMgZGV0YWNoZWQgZnJvbSBET00sIGJ1dCB0aGlzIGhhbmRsZXIgd2FzIG5vdCByZW1vdmVkXG4gICAgICB0aGlzLmRlc3Ryb3koKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLndvdC5kcmF3KHRydWUpO1xuXG4gICAgdGhpcy50b3BPdmVybGF5Lm9uU2Nyb2xsKCk7XG4gICAgdGhpcy5sZWZ0T3ZlcmxheS5vblNjcm9sbCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFsbCBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzXG4gICAqL1xuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmV2ZW50TWFuYWdlci5hZGRFdmVudExpc3RlbmVyKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJ2tleWRvd24nLCAoZXZlbnQpID0+IHRoaXMub25LZXlEb3duKGV2ZW50KSk7XG4gICAgdGhpcy5ldmVudE1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcihkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICdrZXl1cCcsICgpID0+IHRoaXMub25LZXlVcCgpKTtcbiAgICB0aGlzLmV2ZW50TWFuYWdlci5hZGRFdmVudExpc3RlbmVyKGRvY3VtZW50LCAndmlzaWJpbGl0eWNoYW5nZScsICgpID0+IHRoaXMub25LZXlVcCgpKTtcblxuICAgIHRoaXMuZXZlbnRNYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5tYWluVGFibGVTY3JvbGxhYmxlRWxlbWVudCwgJ3Njcm9sbCcsIChldmVudCkgPT4gdGhpcy5vblRhYmxlU2Nyb2xsKGV2ZW50KSk7XG5cbiAgICBpZiAodGhpcy50b3BPdmVybGF5Lm5lZWRGdWxsUmVuZGVyKSB7XG4gICAgICB0aGlzLmV2ZW50TWFuYWdlci5hZGRFdmVudExpc3RlbmVyKHRoaXMudG9wT3ZlcmxheS5jbG9uZS53dFRhYmxlLmhvbGRlciwgJ3Njcm9sbCcsIChldmVudCkgPT4gdGhpcy5vblRhYmxlU2Nyb2xsKGV2ZW50KSk7XG4gICAgICB0aGlzLmV2ZW50TWFuYWdlci5hZGRFdmVudExpc3RlbmVyKHRoaXMudG9wT3ZlcmxheS5jbG9uZS53dFRhYmxlLmhvbGRlciwgJ3doZWVsJywgKGV2ZW50KSA9PiB0aGlzLm9uVGFibGVTY3JvbGwoZXZlbnQpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZWZ0T3ZlcmxheS5uZWVkRnVsbFJlbmRlcikge1xuICAgICAgdGhpcy5ldmVudE1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmxlZnRPdmVybGF5LmNsb25lLnd0VGFibGUuaG9sZGVyLCAnc2Nyb2xsJywgKGV2ZW50KSA9PiB0aGlzLm9uVGFibGVTY3JvbGwoZXZlbnQpKTtcbiAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5sZWZ0T3ZlcmxheS5jbG9uZS53dFRhYmxlLmhvbGRlciwgJ3doZWVsJywgKGV2ZW50KSA9PiB0aGlzLm9uVGFibGVTY3JvbGwoZXZlbnQpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50b3BPdmVybGF5LnRyaW1taW5nQ29udGFpbmVyICE9PSB3aW5kb3cgJiYgdGhpcy5sZWZ0T3ZlcmxheS50cmltbWluZ0NvbnRhaW5lciAhPT0gd2luZG93KSB7XG4gICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeT9cbiAgICAgIC8vZXZlbnRNYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIod2luZG93LCAnc2Nyb2xsJywgKGV2ZW50KSA9PiB0aGlzLnJlZnJlc2hBbGwoZXZlbnQpKTtcbiAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIod2luZG93LCAnd2hlZWwnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgbGV0IG92ZXJsYXk7XG4gICAgICAgIGxldCBkZWx0YVkgPSBldmVudC53aGVlbERlbHRhWSB8fCBldmVudC5kZWx0YVk7XG4gICAgICAgIGxldCBkZWx0YVggPSBldmVudC53aGVlbERlbHRhWCB8fCBldmVudC5kZWx0YVg7XG5cbiAgICAgICAgaWYgKHRoaXMudG9wT3ZlcmxheS5jbG9uZS53dFRhYmxlLmhvbGRlci5jb250YWlucyhldmVudC5yZWFsVGFyZ2V0KSkge1xuICAgICAgICAgIG92ZXJsYXkgPSAndG9wJztcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGVmdE92ZXJsYXkuY2xvbmUud3RUYWJsZS5ob2xkZXIuY29udGFpbnMoZXZlbnQucmVhbFRhcmdldCkpIHtcbiAgICAgICAgICBvdmVybGF5ID0gJ2xlZnQnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG92ZXJsYXkgPT0gJ3RvcCcgJiYgZGVsdGFZICE9PSAwKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChvdmVybGF5ID09ICdsZWZ0JyAmJiBkZWx0YVggIT09IDApIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2Nyb2xsIGxpc3RlbmVyXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqL1xuICBvblRhYmxlU2Nyb2xsKGV2ZW50KSB7XG4gICAgLy8gaWYgbW9iaWxlIGJyb3dzZXIsIGRvIG5vdCB1cGRhdGUgc2Nyb2xsIHBvc2l0aW9ucywgYXMgdGhlIG92ZXJsYXlzIGFyZSBoaWRkZW4gZHVyaW5nIHRoZSBzY3JvbGxcbiAgICBpZiAoSGFuZHNvbnRhYmxlLm1vYmlsZUJyb3dzZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRm9yIGtleSBwcmVzcywgc3luYyBvbmx5IG1hc3RlciAtPiBvdmVybGF5IHBvc2l0aW9uIGJlY2F1c2Ugd2hpbGUgcHJlc3NpbmcgV2Fsa29udGFibGUucmVuZGVyIGlzIHRyaWdnZXJlZFxuICAgIC8vIGJ5IGhvdC5yZWZyZXNoQm9yZGVyXG4gICAgaWYgKHRoaXMua2V5UHJlc3NlZCAmJiB0aGlzLm1haW5UYWJsZVNjcm9sbGFibGVFbGVtZW50ICE9PSB3aW5kb3cgJiZcbiAgICAgICAgIWV2ZW50LnRhcmdldC5jb250YWlucyh0aGlzLm1haW5UYWJsZVNjcm9sbGFibGVFbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3Njcm9sbCcpIHtcbiAgICAgIHRoaXMuc3luY1Njcm9sbFBvc2l0aW9ucyhldmVudCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50cmFuc2xhdGVNb3VzZVdoZWVsVG9TY3JvbGwoZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBLZXkgZG93biBsaXN0ZW5lclxuICAgKi9cbiAgb25LZXlEb3duKGV2ZW50KSB7XG4gICAgdGhpcy5rZXlQcmVzc2VkID0gaXNLZXkoZXZlbnQua2V5Q29kZSwgJ0FSUk9XX1VQfEFSUk9XX1JJR0hUfEFSUk9XX0RPV058QVJST1dfTEVGVCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEtleSB1cCBsaXN0ZW5lclxuICAgKi9cbiAgb25LZXlVcCgpIHtcbiAgICB0aGlzLmtleVByZXNzZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2xhdGUgd2hlZWwgZXZlbnQgaW50byBzY3JvbGwgZXZlbnQgYW5kIHN5bmMgc2Nyb2xsIG92ZXJsYXlzIHBvc2l0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgdHJhbnNsYXRlTW91c2VXaGVlbFRvU2Nyb2xsKGV2ZW50KSB7XG4gICAgbGV0IHRvcE92ZXJsYXkgPSB0aGlzLnRvcE92ZXJsYXkuY2xvbmUud3RUYWJsZS5ob2xkZXI7XG4gICAgbGV0IGxlZnRPdmVybGF5ID0gdGhpcy5sZWZ0T3ZlcmxheS5jbG9uZS53dFRhYmxlLmhvbGRlcjtcbiAgICBsZXQgZXZlbnRNb2NrdXAgPSB7dHlwZTogJ3doZWVsJ307XG4gICAgbGV0IHRlbXBFbGVtID0gZXZlbnQudGFyZ2V0O1xuICAgIGxldCBkZWx0YVkgPSBldmVudC53aGVlbERlbHRhWSB8fCAoLTEpICogZXZlbnQuZGVsdGFZO1xuICAgIGxldCBkZWx0YVggPSBldmVudC53aGVlbERlbHRhWCB8fCAoLTEpICogZXZlbnQuZGVsdGFYO1xuICAgIGxldCBwYXJlbnRIb2xkZXI7XG5cbiAgICB3aGlsZSAodGVtcEVsZW0gIT0gZG9jdW1lbnQgJiYgdGVtcEVsZW0gIT0gbnVsbCkge1xuICAgICAgaWYgKHRlbXBFbGVtLmNsYXNzTmFtZS5pbmRleE9mKCd3dEhvbGRlcicpID4gLTEpIHtcbiAgICAgICAgcGFyZW50SG9sZGVyID0gdGVtcEVsZW07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGVtcEVsZW0gPSB0ZW1wRWxlbS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICBldmVudE1vY2t1cC50YXJnZXQgPSBwYXJlbnRIb2xkZXI7XG5cbiAgICBpZiAocGFyZW50SG9sZGVyID09IHRvcE92ZXJsYXkpIHtcbiAgICAgIHRoaXMuc3luY1Njcm9sbFBvc2l0aW9ucyhldmVudE1vY2t1cCwgKC0wLjIpICogZGVsdGFZKTtcblxuICAgIH0gZWxzZSBpZiAocGFyZW50SG9sZGVyID09IGxlZnRPdmVybGF5KSB7XG4gICAgICB0aGlzLnN5bmNTY3JvbGxQb3NpdGlvbnMoZXZlbnRNb2NrdXAsICgtMC4yKSAqIGRlbHRhWCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN5bmNocm9uaXplIHNjcm9sbCBwb3NpdGlvbiBiZXR3ZWVuIG1hc3RlciB0YWJsZSBhbmQgb3ZlcmxheSB0YWJsZVxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fE9iamVjdH0gZXZlbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtmYWtlU2Nyb2xsVmFsdWU9bnVsbF1cbiAgICovXG4gIHN5bmNTY3JvbGxQb3NpdGlvbnMoZXZlbnQsIGZha2VTY3JvbGxWYWx1ZSA9IG51bGwpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuc3luY1Njcm9sbFdpdGhNYXN0ZXIoKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbWFzdGVyID0gdGhpcy5tYWluVGFibGVTY3JvbGxhYmxlRWxlbWVudDtcbiAgICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIGxldCB0ZW1wU2Nyb2xsVmFsdWUgPSAwO1xuICAgIGxldCBzY3JvbGxWYWx1ZUNoYW5nZWQgPSBmYWxzZTtcbiAgICBsZXQgdG9wT3ZlcmxheTtcbiAgICBsZXQgbGVmdE92ZXJsYXk7XG5cbiAgICBpZiAodGhpcy50b3BPdmVybGF5Lm5lZWRGdWxsUmVuZGVyKSB7XG4gICAgICB0b3BPdmVybGF5ID0gdGhpcy50b3BPdmVybGF5LmNsb25lLnd0VGFibGUuaG9sZGVyO1xuICAgIH1cbiAgICBpZiAodGhpcy5sZWZ0T3ZlcmxheS5uZWVkRnVsbFJlbmRlcikge1xuICAgICAgbGVmdE92ZXJsYXkgPSB0aGlzLmxlZnRPdmVybGF5LmNsb25lLnd0VGFibGUuaG9sZGVyO1xuICAgIH1cblxuICAgIGlmICh0YXJnZXQgPT09IGRvY3VtZW50KSB7XG4gICAgICB0YXJnZXQgPSB3aW5kb3c7XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldCA9PT0gbWFzdGVyKSB7XG4gICAgICB0ZW1wU2Nyb2xsVmFsdWUgPSBnZXRTY3JvbGxMZWZ0KHRhcmdldCk7XG5cbiAgICAgIC8vIGlmIHNjcm9sbGluZyB0aGUgbWFzdGVyIHRhYmxlIC0gcG9wdWxhdGUgdGhlIHNjcm9sbCB2YWx1ZXMgdG8gYm90aCB0b3AgYW5kIGxlZnQgb3ZlcmxheXNcbiAgICAgIGlmICh0aGlzLm92ZXJsYXlTY3JvbGxQb3NpdGlvbnMubWFzdGVyLmxlZnQgIT09IHRlbXBTY3JvbGxWYWx1ZSkge1xuICAgICAgICB0aGlzLm92ZXJsYXlTY3JvbGxQb3NpdGlvbnMubWFzdGVyLmxlZnQgPSB0ZW1wU2Nyb2xsVmFsdWU7XG4gICAgICAgIHNjcm9sbFZhbHVlQ2hhbmdlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHRvcE92ZXJsYXkpIHtcbiAgICAgICAgICB0b3BPdmVybGF5LnNjcm9sbExlZnQgPSB0ZW1wU2Nyb2xsVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRlbXBTY3JvbGxWYWx1ZSA9IGdldFNjcm9sbFRvcCh0YXJnZXQpO1xuXG4gICAgICBpZiAodGhpcy5vdmVybGF5U2Nyb2xsUG9zaXRpb25zLm1hc3Rlci50b3AgIT09IHRlbXBTY3JvbGxWYWx1ZSkge1xuICAgICAgICB0aGlzLm92ZXJsYXlTY3JvbGxQb3NpdGlvbnMubWFzdGVyLnRvcCA9IHRlbXBTY3JvbGxWYWx1ZTtcbiAgICAgICAgc2Nyb2xsVmFsdWVDaGFuZ2VkID0gdHJ1ZTtcblxuICAgICAgICBpZiAobGVmdE92ZXJsYXkpIHtcbiAgICAgICAgICBsZWZ0T3ZlcmxheS5zY3JvbGxUb3AgPSB0ZW1wU2Nyb2xsVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAodGFyZ2V0ID09PSB0b3BPdmVybGF5KSB7XG4gICAgICB0ZW1wU2Nyb2xsVmFsdWUgPSBnZXRTY3JvbGxMZWZ0KHRhcmdldCk7XG5cbiAgICAgIC8vIGlmIHNjcm9sbGluZyB0aGUgdG9wIG92ZXJsYXkgLSBwb3B1bGF0ZSB0aGUgaG9yaXpvbnRhbCBzY3JvbGwgdG8gdGhlIG1hc3RlciB0YWJsZVxuICAgICAgaWYgKHRoaXMub3ZlcmxheVNjcm9sbFBvc2l0aW9ucy50b3AubGVmdCAhPT0gdGVtcFNjcm9sbFZhbHVlKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheVNjcm9sbFBvc2l0aW9ucy50b3AubGVmdCA9IHRlbXBTY3JvbGxWYWx1ZTtcbiAgICAgICAgc2Nyb2xsVmFsdWVDaGFuZ2VkID0gdHJ1ZTtcblxuICAgICAgICBtYXN0ZXIuc2Nyb2xsTGVmdCA9IHRlbXBTY3JvbGxWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gXCJmYWtlXCIgc2Nyb2xsIHZhbHVlIGNhbGN1bGF0ZWQgZnJvbSB0aGUgbW91c2V3aGVlbCBldmVudFxuICAgICAgaWYgKGZha2VTY3JvbGxWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBzY3JvbGxWYWx1ZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICBtYXN0ZXIuc2Nyb2xsVG9wICs9IGZha2VTY3JvbGxWYWx1ZTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAodGFyZ2V0ID09PSBsZWZ0T3ZlcmxheSkge1xuICAgICAgdGVtcFNjcm9sbFZhbHVlID0gZ2V0U2Nyb2xsVG9wKHRhcmdldCk7XG5cbiAgICAgIC8vIGlmIHNjcm9sbGluZyB0aGUgbGVmdCBvdmVybGF5IC0gcG9wdWxhdGUgdGhlIHZlcnRpY2FsIHNjcm9sbCB0byB0aGUgbWFzdGVyIHRhYmxlXG4gICAgICBpZiAodGhpcy5vdmVybGF5U2Nyb2xsUG9zaXRpb25zLmxlZnQudG9wICE9PSB0ZW1wU2Nyb2xsVmFsdWUpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5U2Nyb2xsUG9zaXRpb25zLmxlZnQudG9wID0gdGVtcFNjcm9sbFZhbHVlO1xuICAgICAgICBzY3JvbGxWYWx1ZUNoYW5nZWQgPSB0cnVlO1xuXG4gICAgICAgIG1hc3Rlci5zY3JvbGxUb3AgPSB0ZW1wU2Nyb2xsVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFwiZmFrZVwiIHNjcm9sbCB2YWx1ZSBjYWxjdWxhdGVkIGZyb20gdGhlIG1vdXNld2hlZWwgZXZlbnRcbiAgICAgIGlmIChmYWtlU2Nyb2xsVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgc2Nyb2xsVmFsdWVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgbWFzdGVyLnNjcm9sbExlZnQgKz0gZmFrZVNjcm9sbFZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5rZXlQcmVzc2VkICYmIHNjcm9sbFZhbHVlQ2hhbmdlZCAmJiBldmVudC50eXBlID09PSAnc2Nyb2xsJykge1xuICAgICAgdGhpcy5yZWZyZXNoQWxsKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN5bmNocm9uaXplIG92ZXJsYXkgc2Nyb2xsYmFycyB3aXRoIHRoZSBtYXN0ZXIgc2Nyb2xsYmFyXG4gICAqL1xuICBzeW5jU2Nyb2xsV2l0aE1hc3RlcigpIHtcbiAgICB2YXIgbWFzdGVyID0gdGhpcy50b3BPdmVybGF5Lm1haW5UYWJsZVNjcm9sbGFibGVFbGVtZW50O1xuXG4gICAgaWYgKHRoaXMudG9wT3ZlcmxheS5uZWVkRnVsbFJlbmRlcikge1xuICAgICAgdGhpcy50b3BPdmVybGF5LmNsb25lLnd0VGFibGUuaG9sZGVyLnNjcm9sbExlZnQgPSBtYXN0ZXIuc2Nyb2xsTGVmdDtcbiAgICB9XG4gICAgaWYgKHRoaXMubGVmdE92ZXJsYXkubmVlZEZ1bGxSZW5kZXIpIHtcbiAgICAgIHRoaXMubGVmdE92ZXJsYXkuY2xvbmUud3RUYWJsZS5ob2xkZXIuc2Nyb2xsVG9wID0gbWFzdGVyLnNjcm9sbFRvcDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICpcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5ldmVudE1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMudG9wT3ZlcmxheS5kZXN0cm95KCk7XG4gICAgdGhpcy5sZWZ0T3ZlcmxheS5kZXN0cm95KCk7XG5cbiAgICBpZiAodGhpcy50b3BMZWZ0Q29ybmVyT3ZlcmxheSkge1xuICAgICAgdGhpcy50b3BMZWZ0Q29ybmVyT3ZlcmxheS5kZXN0cm95KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICB0aGlzLmRlYnVnLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Zhc3REcmF3PWZhbHNlXVxuICAgKi9cbiAgcmVmcmVzaChmYXN0RHJhdyA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMudG9wT3ZlcmxheS5hcmVFbGVtZW50U2l6ZXNBZGp1c3RlZCAmJiB0aGlzLmxlZnRPdmVybGF5LmFyZUVsZW1lbnRTaXplc0FkanVzdGVkKSB7XG4gICAgICBsZXQgY29udGFpbmVyID0gdGhpcy53b3Qud3RUYWJsZS53dFJvb3RFbGVtZW50LnBhcmVudE5vZGUgfHwgdGhpcy53b3Qud3RUYWJsZS53dFJvb3RFbGVtZW50O1xuICAgICAgbGV0IHdpZHRoID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgICAgbGV0IGhlaWdodCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG5cbiAgICAgIGlmICh3aWR0aCAhPT0gdGhpcy5zcHJlYWRlckxhc3RTaXplLndpZHRoIHx8IGhlaWdodCAhPT0gdGhpcy5zcHJlYWRlckxhc3RTaXplLmhlaWdodCkge1xuICAgICAgICB0aGlzLnNwcmVhZGVyTGFzdFNpemUud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5zcHJlYWRlckxhc3RTaXplLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5hZGp1c3RFbGVtZW50c1NpemUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sZWZ0T3ZlcmxheS5yZWZyZXNoKGZhc3REcmF3KTtcbiAgICB0aGlzLnRvcE92ZXJsYXkucmVmcmVzaChmYXN0RHJhdyk7XG5cbiAgICBpZiAodGhpcy50b3BMZWZ0Q29ybmVyT3ZlcmxheSkge1xuICAgICAgdGhpcy50b3BMZWZ0Q29ybmVyT3ZlcmxheS5yZWZyZXNoKGZhc3REcmF3KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgIHRoaXMuZGVidWcucmVmcmVzaChmYXN0RHJhdyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkanVzdCBvdmVybGF5cyBlbGVtZW50cyBzaXplIGFuZCBtYXN0ZXIgdGFibGUgc2l6ZVxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZT1mYWxzZV1cbiAgICovXG4gIGFkanVzdEVsZW1lbnRzU2l6ZShmb3JjZSA9IGZhbHNlKSB7XG4gICAgbGV0IHRvdGFsQ29sdW1ucyA9IHRoaXMud290LmdldFNldHRpbmcoJ3RvdGFsQ29sdW1ucycpO1xuICAgIGxldCB0b3RhbFJvd3MgPSB0aGlzLndvdC5nZXRTZXR0aW5nKCd0b3RhbFJvd3MnKTtcbiAgICBsZXQgaGVhZGVyUm93U2l6ZSA9IHRoaXMud290Lnd0Vmlld3BvcnQuZ2V0Um93SGVhZGVyV2lkdGgoKTtcbiAgICBsZXQgaGVhZGVyQ29sdW1uU2l6ZSA9IHRoaXMud290Lnd0Vmlld3BvcnQuZ2V0Q29sdW1uSGVhZGVySGVpZ2h0KCk7XG4gICAgbGV0IGhpZGVyU3R5bGUgPSB0aGlzLndvdC53dFRhYmxlLmhpZGVyLnN0eWxlO1xuXG4gICAgaGlkZXJTdHlsZS53aWR0aCA9IChoZWFkZXJSb3dTaXplICsgdGhpcy5sZWZ0T3ZlcmxheS5zdW1DZWxsU2l6ZXMoMCwgdG90YWxDb2x1bW5zKSkgKyAncHgnO1xuICAgIGhpZGVyU3R5bGUuaGVpZ2h0ID0gKGhlYWRlckNvbHVtblNpemUgKyB0aGlzLnRvcE92ZXJsYXkuc3VtQ2VsbFNpemVzKDAsIHRvdGFsUm93cykgKyAxKSArICdweCc7XG5cbiAgICB0aGlzLnRvcE92ZXJsYXkuYWRqdXN0RWxlbWVudHNTaXplKGZvcmNlKTtcbiAgICB0aGlzLmxlZnRPdmVybGF5LmFkanVzdEVsZW1lbnRzU2l6ZShmb3JjZSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICovXG4gIGFwcGx5VG9ET00oKSB7XG4gICAgaWYgKCF0aGlzLnRvcE92ZXJsYXkuYXJlRWxlbWVudFNpemVzQWRqdXN0ZWQgfHwgIXRoaXMubGVmdE92ZXJsYXkuYXJlRWxlbWVudFNpemVzQWRqdXN0ZWQpIHtcbiAgICAgIHRoaXMuYWRqdXN0RWxlbWVudHNTaXplKCk7XG4gICAgfVxuICAgIHRoaXMudG9wT3ZlcmxheS5hcHBseVRvRE9NKCk7XG4gICAgdGhpcy5sZWZ0T3ZlcmxheS5hcHBseVRvRE9NKCk7XG4gIH1cbn1cblxuZXhwb3J0IHtXYWxrb250YWJsZU92ZXJsYXlzfTtcblxud2luZG93LldhbGtvbnRhYmxlT3ZlcmxheXMgPSBXYWxrb250YWJsZU92ZXJsYXlzO1xuIiwiXG4vKipcbiAqIEBjbGFzcyBXYWxrb250YWJsZVNjcm9sbFxuICovXG5jbGFzcyBXYWxrb250YWJsZVNjcm9sbCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1dhbGtvbnRhYmxlfSB3b3RJbnN0YW5jZVxuICAgKi9cbiAgY29uc3RydWN0b3Iod290SW5zdGFuY2UpIHtcbiAgICB0aGlzLndvdCA9IHdvdEluc3RhbmNlO1xuXG4gICAgLy8gbGVnYWN5IHN1cHBvcnRcbiAgICB0aGlzLmluc3RhbmNlID0gd290SW5zdGFuY2U7XG4gIH1cblxuICAvKipcbiAgICogU2Nyb2xscyB2aWV3cG9ydCB0byBhIGNlbGwgYnkgbWluaW11bSBudW1iZXIgb2YgY2VsbHNcbiAgICpcbiAgICogQHBhcmFtIHtXYWxrb250YWJsZUNlbGxDb29yZHN9IGNvb3Jkc1xuICAgKi9cbiAgc2Nyb2xsVmlld3BvcnQoY29vcmRzKSB7XG4gICAgaWYgKCF0aGlzLndvdC5kcmF3bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgdG90YWxSb3dzID0gdGhpcy53b3QuZ2V0U2V0dGluZygndG90YWxSb3dzJyk7XG4gICAgbGV0IHRvdGFsQ29sdW1ucyA9IHRoaXMud290LmdldFNldHRpbmcoJ3RvdGFsQ29sdW1ucycpO1xuXG4gICAgaWYgKGNvb3Jkcy5yb3cgPCAwIHx8IGNvb3Jkcy5yb3cgPiB0b3RhbFJvd3MgLSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JvdyAnICsgY29vcmRzLnJvdyArICcgZG9lcyBub3QgZXhpc3QnKTtcbiAgICB9XG5cbiAgICBpZiAoY29vcmRzLmNvbCA8IDAgfHwgY29vcmRzLmNvbCA+IHRvdGFsQ29sdW1ucyAtIDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY29sdW1uICcgKyBjb29yZHMuY29sICsgJyBkb2VzIG5vdCBleGlzdCcpO1xuICAgIH1cblxuICAgIGlmIChjb29yZHMucm93ID4gdGhpcy5pbnN0YW5jZS53dFRhYmxlLmdldExhc3RWaXNpYmxlUm93KCkpIHtcbiAgICAgIHRoaXMud290Lnd0T3ZlcmxheXMudG9wT3ZlcmxheS5zY3JvbGxUbyhjb29yZHMucm93LCB0cnVlKTtcblxuICAgIH0gZWxzZSBpZiAoY29vcmRzLnJvdyA+PSB0aGlzLmluc3RhbmNlLmdldFNldHRpbmcoJ2ZpeGVkUm93c1RvcCcpICYmXG4gICAgICAgICAgICAgICBjb29yZHMucm93IDwgdGhpcy5pbnN0YW5jZS53dFRhYmxlLmdldEZpcnN0VmlzaWJsZVJvdygpKSB7XG4gICAgICB0aGlzLndvdC53dE92ZXJsYXlzLnRvcE92ZXJsYXkuc2Nyb2xsVG8oY29vcmRzLnJvdyk7XG4gICAgfVxuXG4gICAgaWYgKGNvb3Jkcy5jb2wgPiB0aGlzLmluc3RhbmNlLnd0VGFibGUuZ2V0TGFzdFZpc2libGVDb2x1bW4oKSkge1xuICAgICAgdGhpcy53b3Qud3RPdmVybGF5cy5sZWZ0T3ZlcmxheS5zY3JvbGxUbyhjb29yZHMuY29sLCB0cnVlKTtcblxuICAgIH0gZWxzZSBpZiAoY29vcmRzLmNvbCA+PSB0aGlzLmluc3RhbmNlLmdldFNldHRpbmcoJ2ZpeGVkQ29sdW1uc0xlZnQnKSAmJlxuICAgICAgICAgICAgICAgY29vcmRzLmNvbCA8IHRoaXMuaW5zdGFuY2Uud3RUYWJsZS5nZXRGaXJzdFZpc2libGVDb2x1bW4oKSkge1xuICAgICAgdGhpcy53b3Qud3RPdmVybGF5cy5sZWZ0T3ZlcmxheS5zY3JvbGxUbyhjb29yZHMuY29sKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHtXYWxrb250YWJsZVNjcm9sbH07XG5cbndpbmRvdy5XYWxrb250YWJsZVNjcm9sbCA9IFdhbGtvbnRhYmxlU2Nyb2xsO1xuIiwiXG5pbXBvcnQge2FkZENsYXNzfSBmcm9tICcuLy4uLy4uLy4uL2hlbHBlcnMvZG9tL2VsZW1lbnQnO1xuaW1wb3J0IHtXYWxrb250YWJsZUJvcmRlcn0gZnJvbSAnLi9ib3JkZXInO1xuaW1wb3J0IHtXYWxrb250YWJsZUNlbGxDb29yZHN9IGZyb20gJy4vY2VsbC9jb29yZHMnO1xuaW1wb3J0IHtXYWxrb250YWJsZUNlbGxSYW5nZX0gZnJvbSAnLi9jZWxsL3JhbmdlJztcblxuXG4vKipcbiAqIEBjbGFzcyBXYWxrb250YWJsZVNlbGVjdGlvblxuICovXG5jbGFzcyBXYWxrb250YWJsZVNlbGVjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3NcbiAgICogQHBhcmFtIHtXYWxrb250YWJsZUNlbGxSYW5nZX0gY2VsbFJhbmdlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzZXR0aW5ncywgY2VsbFJhbmdlKSB7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuY2VsbFJhbmdlID0gY2VsbFJhbmdlIHx8IG51bGw7XG4gICAgdGhpcy5pbnN0YW5jZUJvcmRlcnMgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFYWNoIFdhbGtvbnRhYmxlIGNsb25lIHJlcXVpcmVzIGl0J3Mgb3duIGJvcmRlciBmb3IgZXZlcnkgc2VsZWN0aW9uLiBUaGlzIG1ldGhvZCBjcmVhdGVzIGFuZCByZXR1cm5zIHNlbGVjdGlvblxuICAgKiBib3JkZXJzIHBlciBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0ge1dhbGtvbnRhYmxlfSB3b3RJbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7V2Fsa29udGFibGVCb3JkZXJ9XG4gICAqL1xuICBnZXRCb3JkZXIod290SW5zdGFuY2UpIHtcbiAgICBpZiAodGhpcy5pbnN0YW5jZUJvcmRlcnNbd290SW5zdGFuY2UuZ3VpZF0pIHtcbiAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlQm9yZGVyc1t3b3RJbnN0YW5jZS5ndWlkXTtcbiAgICB9XG4gICAgLy8gd2hlcmUgaXMgdGhpcyByZXR1cm5lZD9cbiAgICB0aGlzLmluc3RhbmNlQm9yZGVyc1t3b3RJbnN0YW5jZS5ndWlkXSA9IG5ldyBXYWxrb250YWJsZUJvcmRlcih3b3RJbnN0YW5jZSwgdGhpcy5zZXR0aW5ncyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHNlbGVjdGlvbiBpcyBlbXB0eVxuICAgKlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2VsbFJhbmdlID09PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjZWxsIGNvb3JkcyB0byB0aGUgc2VsZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7V2Fsa29udGFibGVDZWxsQ29vcmRzfSBjb29yZHNcbiAgICovXG4gIGFkZChjb29yZHMpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMuY2VsbFJhbmdlID0gbmV3IFdhbGtvbnRhYmxlQ2VsbFJhbmdlKGNvb3JkcywgY29vcmRzLCBjb29yZHMpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2VsbFJhbmdlLmV4cGFuZChjb29yZHMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBzZWxlY3Rpb24gcmFuZ2UgZnJvbSBvciB0byBwcm9wZXJ0eSBlcXVhbHMgb2xkQ29vcmRzLCByZXBsYWNlIGl0IHdpdGggbmV3Q29vcmRzLiBSZXR1cm4gYm9vbGVhblxuICAgKiBpbmZvcm1hdGlvbiBhYm91dCBzdWNjZXNzXG4gICAqXG4gICAqIEBwYXJhbSB7V2Fsa29udGFibGVDZWxsQ29vcmRzfSBvbGRDb29yZHNcbiAgICogQHBhcmFtIHtXYWxrb250YWJsZUNlbGxDb29yZHN9IG5ld0Nvb3Jkc1xuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIHJlcGxhY2Uob2xkQ29vcmRzLCBuZXdDb29yZHMpIHtcbiAgICBpZiAoIXRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICBpZiAodGhpcy5jZWxsUmFuZ2UuZnJvbS5pc0VxdWFsKG9sZENvb3JkcykpIHtcbiAgICAgICAgdGhpcy5jZWxsUmFuZ2UuZnJvbSA9IG5ld0Nvb3JkcztcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNlbGxSYW5nZS50by5pc0VxdWFsKG9sZENvb3JkcykpIHtcbiAgICAgICAgdGhpcy5jZWxsUmFuZ2UudG8gPSBuZXdDb29yZHM7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBzZWxlY3Rpb25cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuY2VsbFJhbmdlID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0b3AgbGVmdCAoVEwpIGFuZCBib3R0b20gcmlnaHQgKEJSKSBzZWxlY3Rpb24gY29vcmRpbmF0ZXNcbiAgICpcbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFycmF5IG9mIGNvb3JkaW5hdGVzIGZvciBleGFtcGxlIGBbMSwgMSwgNSwgNV1gXG4gICAqL1xuICBnZXRDb3JuZXJzKCkge1xuICAgIGxldCB0b3BMZWZ0ID0gdGhpcy5jZWxsUmFuZ2UuZ2V0VG9wTGVmdENvcm5lcigpO1xuICAgIGxldCBib3R0b21SaWdodCA9IHRoaXMuY2VsbFJhbmdlLmdldEJvdHRvbVJpZ2h0Q29ybmVyKCk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgdG9wTGVmdC5yb3csXG4gICAgICB0b3BMZWZ0LmNvbCxcbiAgICAgIGJvdHRvbVJpZ2h0LnJvdyxcbiAgICAgIGJvdHRvbVJpZ2h0LmNvbFxuICAgIF07XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBjbGFzcyBuYW1lIHRvIGNlbGwgZWxlbWVudCBhdCBnaXZlbiBjb29yZHNcbiAgICpcbiAgICogQHBhcmFtIHtXYWxrb250YWJsZX0gd290SW5zdGFuY2UgV2Fsa29udGFibGUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNvdXJjZVJvdyBDZWxsIHJvdyBjb29yZFxuICAgKiBAcGFyYW0ge051bWJlcn0gc291cmNlQ29sdW1uIENlbGwgY29sdW1uIGNvb3JkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWUgQ2xhc3MgbmFtZVxuICAgKi9cbiAgYWRkQ2xhc3NBdENvb3Jkcyh3b3RJbnN0YW5jZSwgc291cmNlUm93LCBzb3VyY2VDb2x1bW4sIGNsYXNzTmFtZSkge1xuICAgIGxldCBURCA9IHdvdEluc3RhbmNlLnd0VGFibGUuZ2V0Q2VsbChuZXcgV2Fsa29udGFibGVDZWxsQ29vcmRzKHNvdXJjZVJvdywgc291cmNlQ29sdW1uKSk7XG5cbiAgICBpZiAodHlwZW9mIFREID09PSAnb2JqZWN0Jykge1xuICAgICAgYWRkQ2xhc3MoVEQsIGNsYXNzTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB3b3RJbnN0YW5jZVxuICAgKi9cbiAgZHJhdyh3b3RJbnN0YW5jZSkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuYm9yZGVyKSB7XG4gICAgICAgIGxldCBib3JkZXIgPSB0aGlzLmdldEJvcmRlcih3b3RJbnN0YW5jZSk7XG5cbiAgICAgICAgaWYgKGJvcmRlcikge1xuICAgICAgICAgIGJvcmRlci5kaXNhcHBlYXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCByZW5kZXJlZFJvd3MgPSB3b3RJbnN0YW5jZS53dFRhYmxlLmdldFJlbmRlcmVkUm93c0NvdW50KCk7XG4gICAgbGV0IHJlbmRlcmVkQ29sdW1ucyA9IHdvdEluc3RhbmNlLnd0VGFibGUuZ2V0UmVuZGVyZWRDb2x1bW5zQ291bnQoKTtcbiAgICBsZXQgY29ybmVycyA9IHRoaXMuZ2V0Q29ybmVycygpO1xuICAgIGxldCBzb3VyY2VSb3csIHNvdXJjZUNvbCwgVEg7XG5cbiAgICBmb3IgKGxldCBjb2x1bW4gPSAwOyBjb2x1bW4gPCByZW5kZXJlZENvbHVtbnM7IGNvbHVtbisrKSB7XG4gICAgICBzb3VyY2VDb2wgPSB3b3RJbnN0YW5jZS53dFRhYmxlLmNvbHVtbkZpbHRlci5yZW5kZXJlZFRvU291cmNlKGNvbHVtbik7XG5cbiAgICAgIGlmIChzb3VyY2VDb2wgPj0gY29ybmVyc1sxXSAmJiBzb3VyY2VDb2wgPD0gY29ybmVyc1szXSkge1xuICAgICAgICBUSCA9IHdvdEluc3RhbmNlLnd0VGFibGUuZ2V0Q29sdW1uSGVhZGVyKHNvdXJjZUNvbCk7XG5cbiAgICAgICAgaWYgKFRIICYmIHRoaXMuc2V0dGluZ3MuaGlnaGxpZ2h0Q29sdW1uQ2xhc3NOYW1lKSB7XG4gICAgICAgICAgYWRkQ2xhc3MoVEgsIHRoaXMuc2V0dGluZ3MuaGlnaGxpZ2h0Q29sdW1uQ2xhc3NOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJlbmRlcmVkUm93czsgcm93KyspIHtcbiAgICAgIHNvdXJjZVJvdyA9IHdvdEluc3RhbmNlLnd0VGFibGUucm93RmlsdGVyLnJlbmRlcmVkVG9Tb3VyY2Uocm93KTtcblxuICAgICAgaWYgKHNvdXJjZVJvdyA+PSBjb3JuZXJzWzBdICYmIHNvdXJjZVJvdyA8PSBjb3JuZXJzWzJdKSB7XG4gICAgICAgIFRIID0gd290SW5zdGFuY2Uud3RUYWJsZS5nZXRSb3dIZWFkZXIoc291cmNlUm93KTtcblxuICAgICAgICBpZiAoVEggJiYgdGhpcy5zZXR0aW5ncy5oaWdobGlnaHRSb3dDbGFzc05hbWUpIHtcbiAgICAgICAgICBhZGRDbGFzcyhUSCwgdGhpcy5zZXR0aW5ncy5oaWdobGlnaHRSb3dDbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGNvbHVtbiA9IDA7IGNvbHVtbiA8IHJlbmRlcmVkQ29sdW1uczsgY29sdW1uKyspIHtcbiAgICAgICAgc291cmNlQ29sID0gd290SW5zdGFuY2Uud3RUYWJsZS5jb2x1bW5GaWx0ZXIucmVuZGVyZWRUb1NvdXJjZShjb2x1bW4pO1xuXG4gICAgICAgIGlmIChzb3VyY2VSb3cgPj0gY29ybmVyc1swXSAmJiBzb3VyY2VSb3cgPD0gY29ybmVyc1syXSAmJiBzb3VyY2VDb2wgPj0gY29ybmVyc1sxXSAmJiBzb3VyY2VDb2wgPD0gY29ybmVyc1szXSkge1xuICAgICAgICAgIC8vIHNlbGVjdGVkIGNlbGxcbiAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkQ2xhc3NBdENvb3Jkcyh3b3RJbnN0YW5jZSwgc291cmNlUm93LCBzb3VyY2VDb2wsIHRoaXMuc2V0dGluZ3MuY2xhc3NOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlUm93ID49IGNvcm5lcnNbMF0gJiYgc291cmNlUm93IDw9IGNvcm5lcnNbMl0pIHtcbiAgICAgICAgICAvLyBzZWxlY3Rpb24gaXMgaW4gdGhpcyByb3dcbiAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5oaWdobGlnaHRSb3dDbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkQ2xhc3NBdENvb3Jkcyh3b3RJbnN0YW5jZSwgc291cmNlUm93LCBzb3VyY2VDb2wsIHRoaXMuc2V0dGluZ3MuaGlnaGxpZ2h0Um93Q2xhc3NOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlQ29sID49IGNvcm5lcnNbMV0gJiYgc291cmNlQ29sIDw9IGNvcm5lcnNbM10pIHtcbiAgICAgICAgICAvLyBzZWxlY3Rpb24gaXMgaW4gdGhpcyBjb2x1bW5cbiAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5oaWdobGlnaHRDb2x1bW5DbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkQ2xhc3NBdENvb3Jkcyh3b3RJbnN0YW5jZSwgc291cmNlUm93LCBzb3VyY2VDb2wsIHRoaXMuc2V0dGluZ3MuaGlnaGxpZ2h0Q29sdW1uQ2xhc3NOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgd290SW5zdGFuY2UuZ2V0U2V0dGluZygnb25CZWZvcmVEcmF3Qm9yZGVycycsIGNvcm5lcnMsIHRoaXMuc2V0dGluZ3MuY2xhc3NOYW1lKTtcblxuICAgIGlmICh0aGlzLnNldHRpbmdzLmJvcmRlcikge1xuICAgICAgbGV0IGJvcmRlciA9IHRoaXMuZ2V0Qm9yZGVyKHdvdEluc3RhbmNlKTtcblxuICAgICAgaWYgKGJvcmRlcikge1xuICAgICAgICAvLyB3YXJuaW5nISBib3JkZXIuYXBwZWFyIG1vZGlmaWVzIGNvcm5lcnMhXG4gICAgICAgIGJvcmRlci5hcHBlYXIoY29ybmVycyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7V2Fsa29udGFibGVTZWxlY3Rpb259O1xuXG53aW5kb3cuV2Fsa29udGFibGVTZWxlY3Rpb24gPSBXYWxrb250YWJsZVNlbGVjdGlvbjtcbiIsIlxuaW1wb3J0IHtmYXN0SW5uZXJUZXh0fSBmcm9tICcuLy4uLy4uLy4uL2hlbHBlcnMvZG9tL2VsZW1lbnQnO1xuXG5cbi8qKlxuICogQGNsYXNzIFdhbGtvbnRhYmxlU2V0dGluZ3NcbiAqL1xuY2xhc3MgV2Fsa29udGFibGVTZXR0aW5ncyB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1dhbGtvbnRhYmxlfSB3b3RJbnN0YW5jZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdvdEluc3RhbmNlLCBzZXR0aW5ncykge1xuICAgIHRoaXMud290ID0gd290SW5zdGFuY2U7XG4gICAgLy8gbGVnYWN5IHN1cHBvcnRcbiAgICB0aGlzLmluc3RhbmNlID0gd290SW5zdGFuY2U7XG5cbiAgICAvLyBkZWZhdWx0IHNldHRpbmdzLiB2b2lkIDAgbWVhbnMgaXQgaXMgcmVxdWlyZWQsIG51bGwgbWVhbnMgaXQgY2FuIGJlIGVtcHR5XG4gICAgdGhpcy5kZWZhdWx0cyA9IHtcbiAgICAgIHRhYmxlOiB2b2lkIDAsXG4gICAgICBkZWJ1ZzogZmFsc2UsIC8vIHNob3dzIFdhbGtvbnRhYmxlRGVidWdPdmVybGF5XG5cbiAgICAgIC8vIHByZXNlbnRhdGlvbiBtb2RlXG4gICAgICBleHRlcm5hbFJvd0NhbGN1bGF0b3I6IGZhbHNlLFxuICAgICAgc3RyZXRjaEg6ICdub25lJywgLy8gdmFsdWVzOiBhbGwsIGxhc3QsIG5vbmVcbiAgICAgIGN1cnJlbnRSb3dDbGFzc05hbWU6IG51bGwsXG4gICAgICBjdXJyZW50Q29sdW1uQ2xhc3NOYW1lOiBudWxsLFxuXG4gICAgICAvL2RhdGEgc291cmNlXG4gICAgICBkYXRhOiB2b2lkIDAsXG4gICAgICBmaXhlZENvbHVtbnNMZWZ0OiAwLFxuICAgICAgZml4ZWRSb3dzVG9wOiAwLFxuICAgICAgLy8gdGhpcyBtdXN0IGJlIGFycmF5IG9mIGZ1bmN0aW9uczogW2Z1bmN0aW9uIChyb3csIFRIKSB7fV1cbiAgICAgIHJvd0hlYWRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9LFxuICAgICAgLy8gdGhpcyBtdXN0IGJlIGFycmF5IG9mIGZ1bmN0aW9uczogW2Z1bmN0aW9uIChjb2x1bW4sIFRIKSB7fV1cbiAgICAgIGNvbHVtbkhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9LFxuICAgICAgdG90YWxSb3dzOiB2b2lkIDAsXG4gICAgICB0b3RhbENvbHVtbnM6IHZvaWQgMCxcbiAgICAgIGNlbGxSZW5kZXJlcjogKHJvdywgY29sdW1uLCBURCkgPT4ge1xuICAgICAgICBsZXQgY2VsbERhdGEgPSB0aGlzLmdldFNldHRpbmcoJ2RhdGEnLCByb3csIGNvbHVtbik7XG5cbiAgICAgICAgZmFzdElubmVyVGV4dChURCwgY2VsbERhdGEgPT09IHZvaWQgMCB8fCBjZWxsRGF0YSA9PT0gbnVsbCA/ICcnIDogY2VsbERhdGEpO1xuICAgICAgfSxcbiAgICAgIC8vIGNvbHVtbldpZHRoOiA1MCxcbiAgICAgIGNvbHVtbldpZHRoOiBmdW5jdGlvbihjb2wpIHtcbiAgICAgICAgcmV0dXJuOyAvL3JldHVybiB1bmRlZmluZWQgbWVhbnMgdXNlIGRlZmF1bHQgc2l6ZSBmb3IgdGhlIHJlbmRlcmVkIGNlbGwgY29udGVudFxuICAgICAgfSxcbiAgICAgIHJvd0hlaWdodDogZnVuY3Rpb24ocm93KSB7XG4gICAgICAgIHJldHVybjsgLy9yZXR1cm4gdW5kZWZpbmVkIG1lYW5zIHVzZSBkZWZhdWx0IHNpemUgZm9yIHRoZSByZW5kZXJlZCBjZWxsIGNvbnRlbnRcbiAgICAgIH0sXG4gICAgICBkZWZhdWx0Um93SGVpZ2h0OiAyMyxcbiAgICAgIGRlZmF1bHRDb2x1bW5XaWR0aDogNTAsXG4gICAgICBzZWxlY3Rpb25zOiBudWxsLFxuICAgICAgaGlkZUJvcmRlck9uTW91c2VEb3duT3ZlcjogZmFsc2UsXG4gICAgICB2aWV3cG9ydFJvd0NhbGN1bGF0b3JPdmVycmlkZTogbnVsbCxcbiAgICAgIHZpZXdwb3J0Q29sdW1uQ2FsY3VsYXRvck92ZXJyaWRlOiBudWxsLFxuXG4gICAgICAvL2NhbGxiYWNrc1xuICAgICAgb25DZWxsTW91c2VEb3duOiBudWxsLFxuICAgICAgb25DZWxsTW91c2VPdmVyOiBudWxsLFxuICAgICAgLy8gICAgb25DZWxsTW91c2VPdXQ6IG51bGwsXG4gICAgICBvbkNlbGxEYmxDbGljazogbnVsbCxcbiAgICAgIG9uQ2VsbENvcm5lck1vdXNlRG93bjogbnVsbCxcbiAgICAgIG9uQ2VsbENvcm5lckRibENsaWNrOiBudWxsLFxuICAgICAgYmVmb3JlRHJhdzogbnVsbCxcbiAgICAgIG9uRHJhdzogbnVsbCxcbiAgICAgIG9uQmVmb3JlRHJhd0JvcmRlcnM6IG51bGwsXG4gICAgICBvblNjcm9sbFZlcnRpY2FsbHk6IG51bGwsXG4gICAgICBvblNjcm9sbEhvcml6b250YWxseTogbnVsbCxcbiAgICAgIG9uQmVmb3JlVG91Y2hTY3JvbGw6IG51bGwsXG4gICAgICBvbkFmdGVyTW9tZW50dW1TY3JvbGw6IG51bGwsXG5cbiAgICAgIC8vY29uc3RhbnRzXG4gICAgICBzY3JvbGxiYXJXaWR0aDogMTAsXG4gICAgICBzY3JvbGxiYXJIZWlnaHQ6IDEwLFxuXG4gICAgICByZW5kZXJBbGxSb3dzOiBmYWxzZSxcbiAgICAgIGdyb3VwczogZmFsc2VcbiAgICB9O1xuICAgIC8vIHJlZmVyZW5jZSB0byBzZXR0aW5nc1xuICAgIHRoaXMuc2V0dGluZ3MgPSB7fTtcblxuICAgIGZvciAobGV0IGkgaW4gdGhpcy5kZWZhdWx0cykge1xuICAgICAgaWYgKHRoaXMuZGVmYXVsdHMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzW2ldICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB0aGlzLnNldHRpbmdzW2ldID0gc2V0dGluZ3NbaV07XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRlZmF1bHRzW2ldID09PSB2b2lkIDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgcmVxdWlyZWQgc2V0dGluZyBcIicgKyBpICsgJ1wiIHdhcyBub3QgcHJvdmlkZWQnKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2V0dGluZ3NbaV0gPSB0aGlzLmRlZmF1bHRzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBzZXR0aW5nc1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3NcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7V2Fsa29udGFibGV9XG4gICAqL1xuICB1cGRhdGUoc2V0dGluZ3MsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgLy9zZXR0aW5ncyBpcyBvYmplY3RcbiAgICAgIGZvciAobGV0IGkgaW4gc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgdGhpcy5zZXR0aW5nc1tpXSA9IHNldHRpbmdzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy9pZiB2YWx1ZSBpcyBkZWZpbmVkIHRoZW4gc2V0dGluZ3MgaXMgdGhlIGtleVxuICAgICAgdGhpcy5zZXR0aW5nc1tzZXR0aW5nc10gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud290O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzZXR0aW5nIGJ5IG5hbWVcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKiBAcGFyYW0geyp9IHBhcmFtMVxuICAgKiBAcGFyYW0geyp9IHBhcmFtMlxuICAgKiBAcGFyYW0geyp9IHBhcmFtM1xuICAgKiBAcGFyYW0geyp9IHBhcmFtNFxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIGdldFNldHRpbmcoa2V5LCBwYXJhbTEsIHBhcmFtMiwgcGFyYW0zLCBwYXJhbTQpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuc2V0dGluZ3Nba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gdGhpcyBpcyBmYXN0ZXIgdGhhbiAuYXBwbHkgLSBodHRwczovL2dpdGh1Yi5jb20vaGFuZHNvbnRhYmxlL2hhbmRzb250YWJsZS93aWtpL0phdmFTY3JpcHQtJi1ET00tcGVyZm9ybWFuY2UtdGlwc1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3Nba2V5XShwYXJhbTEsIHBhcmFtMiwgcGFyYW0zLCBwYXJhbTQpO1xuXG4gICAgfSBlbHNlIGlmIChwYXJhbTEgIT09IHZvaWQgMCAmJiBBcnJheS5pc0FycmF5KHRoaXMuc2V0dGluZ3Nba2V5XSkpIHtcbiAgICAgIC8vIHBlcmhhcHMgdGhpcyBjYW4gYmUgcmVtb3ZlZCwgaXQgaXMgb25seSB1c2VkIGluIHRlc3RzXG4gICAgICByZXR1cm4gdGhpcy5zZXR0aW5nc1trZXldW3BhcmFtMV07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3Nba2V5XTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHNldHRpbmcgZXhpc3RzXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0ga2V5XG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgaGFzKGtleSkge1xuICAgIHJldHVybiAhIXRoaXMuc2V0dGluZ3Nba2V5XTtcbiAgfVxufVxuXG5leHBvcnQge1dhbGtvbnRhYmxlU2V0dGluZ3N9O1xuXG53aW5kb3cuV2Fsa29udGFibGVTZXR0aW5ncyA9IFdhbGtvbnRhYmxlU2V0dGluZ3M7XG4iLCJpbXBvcnQge1xuICBnZXRTdHlsZSxcbiAgZ2V0VHJpbW1pbmdDb250YWluZXIsXG4gIGhhc0NsYXNzLFxuICBpbmRleCxcbiAgb2Zmc2V0LFxuICByZW1vdmVDbGFzcyxcbiAgcmVtb3ZlVGV4dE5vZGVzLFxuICBvdmVybGF5Q29udGFpbnNFbGVtZW50XG59IGZyb20gJy4vLi4vLi4vLi4vaGVscGVycy9kb20vZWxlbWVudCc7XG5pbXBvcnQge1dhbGtvbnRhYmxlQ2VsbENvb3Jkc30gZnJvbSAnLi9jZWxsL2Nvb3Jkcyc7XG5pbXBvcnQge1dhbGtvbnRhYmxlQ2VsbFJhbmdlfSBmcm9tICcuL2NlbGwvcmFuZ2UnO1xuaW1wb3J0IHtXYWxrb250YWJsZUNvbHVtbkZpbHRlcn0gZnJvbSAnLi9maWx0ZXIvY29sdW1uJztcbmltcG9ydCB7V2Fsa29udGFibGVDb3JuZXJPdmVybGF5fSBmcm9tICcuL292ZXJsYXkvY29ybmVyJztcbmltcG9ydCB7V2Fsa29udGFibGVEZWJ1Z092ZXJsYXl9IGZyb20gJy4vb3ZlcmxheS9kZWJ1Zyc7XG5pbXBvcnQge1dhbGtvbnRhYmxlTGVmdE92ZXJsYXl9IGZyb20gJy4vb3ZlcmxheS9sZWZ0JztcbmltcG9ydCB7V2Fsa29udGFibGVSb3dGaWx0ZXJ9IGZyb20gJy4vZmlsdGVyL3Jvdyc7XG5pbXBvcnQge1dhbGtvbnRhYmxlVGFibGVSZW5kZXJlcn0gZnJvbSAnLi90YWJsZVJlbmRlcmVyJztcbmltcG9ydCB7V2Fsa29udGFibGVUb3BPdmVybGF5fSBmcm9tICcuL292ZXJsYXkvdG9wJztcblxuXG5jbGFzcyBXYWxrb250YWJsZVRhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7V2Fsa29udGFibGV9IHdvdEluc3RhbmNlXG4gICAqIEBwYXJhbSB7SFRNTFRhYmxlRWxlbWVudH0gdGFibGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdvdEluc3RhbmNlLCB0YWJsZSkge1xuICAgIHRoaXMud290ID0gd290SW5zdGFuY2U7XG4gICAgLy8gbGVnYWN5IHN1cHBvcnRcbiAgICB0aGlzLmluc3RhbmNlID0gdGhpcy53b3Q7XG4gICAgdGhpcy5UQUJMRSA9IHRhYmxlO1xuICAgIHRoaXMuVEJPRFkgPSBudWxsO1xuICAgIHRoaXMuVEhFQUQgPSBudWxsO1xuICAgIHRoaXMuQ09MR1JPVVAgPSBudWxsO1xuICAgIHRoaXMudGFibGVPZmZzZXQgPSAwO1xuICAgIHRoaXMuaG9sZGVyT2Zmc2V0ID0gMDtcblxuICAgIHJlbW92ZVRleHROb2Rlcyh0aGlzLlRBQkxFKTtcblxuICAgIHRoaXMuc3ByZWFkZXIgPSB0aGlzLmNyZWF0ZVNwcmVhZGVyKHRoaXMuVEFCTEUpO1xuICAgIHRoaXMuaGlkZXIgPSB0aGlzLmNyZWF0ZUhpZGVyKHRoaXMuc3ByZWFkZXIpO1xuICAgIHRoaXMuaG9sZGVyID0gdGhpcy5jcmVhdGVIb2xkZXIodGhpcy5oaWRlcik7XG5cbiAgICB0aGlzLnd0Um9vdEVsZW1lbnQgPSB0aGlzLmhvbGRlci5wYXJlbnROb2RlO1xuICAgIHRoaXMuYWxpZ25PdmVybGF5c1dpdGhUcmltbWluZ0NvbnRhaW5lcigpO1xuICAgIHRoaXMuZml4VGFibGVEb21UcmVlKCk7XG5cbiAgICB0aGlzLmNvbGdyb3VwQ2hpbGRyZW5MZW5ndGggPSB0aGlzLkNPTEdST1VQLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIHRoaXMudGhlYWRDaGlsZHJlbkxlbmd0aCA9IHRoaXMuVEhFQUQuZmlyc3RDaGlsZCA/IHRoaXMuVEhFQUQuZmlyc3RDaGlsZC5jaGlsZE5vZGVzLmxlbmd0aCA6IDA7XG4gICAgdGhpcy50Ym9keUNoaWxkcmVuTGVuZ3RoID0gdGhpcy5UQk9EWS5jaGlsZE5vZGVzLmxlbmd0aDtcblxuICAgIHRoaXMucm93RmlsdGVyID0gbnVsbDtcbiAgICB0aGlzLmNvbHVtbkZpbHRlciA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICovXG4gIGZpeFRhYmxlRG9tVHJlZSgpIHtcbiAgICB0aGlzLlRCT0RZID0gdGhpcy5UQUJMRS5xdWVyeVNlbGVjdG9yKCd0Ym9keScpO1xuXG4gICAgaWYgKCF0aGlzLlRCT0RZKSB7XG4gICAgICB0aGlzLlRCT0RZID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGJvZHknKTtcbiAgICAgIHRoaXMuVEFCTEUuYXBwZW5kQ2hpbGQodGhpcy5UQk9EWSk7XG4gICAgfVxuICAgIHRoaXMuVEhFQUQgPSB0aGlzLlRBQkxFLnF1ZXJ5U2VsZWN0b3IoJ3RoZWFkJyk7XG5cbiAgICBpZiAoIXRoaXMuVEhFQUQpIHtcbiAgICAgIHRoaXMuVEhFQUQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0aGVhZCcpO1xuICAgICAgdGhpcy5UQUJMRS5pbnNlcnRCZWZvcmUodGhpcy5USEVBRCwgdGhpcy5UQk9EWSk7XG4gICAgfVxuICAgIHRoaXMuQ09MR1JPVVAgPSB0aGlzLlRBQkxFLnF1ZXJ5U2VsZWN0b3IoJ2NvbGdyb3VwJyk7XG5cbiAgICBpZiAoIXRoaXMuQ09MR1JPVVApIHtcbiAgICAgIHRoaXMuQ09MR1JPVVAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2xncm91cCcpO1xuICAgICAgdGhpcy5UQUJMRS5pbnNlcnRCZWZvcmUodGhpcy5DT0xHUk9VUCwgdGhpcy5USEVBRCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMud290LmdldFNldHRpbmcoJ2NvbHVtbkhlYWRlcnMnKS5sZW5ndGggJiYgIXRoaXMuVEhFQUQuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuVEhFQUQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnVFInKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB0YWJsZVxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBjcmVhdGVTcHJlYWRlcih0YWJsZSkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRhYmxlLnBhcmVudE5vZGU7XG4gICAgbGV0IHNwcmVhZGVyO1xuXG4gICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50Lm5vZGVUeXBlICE9PSAxIHx8ICFoYXNDbGFzcyhwYXJlbnQsICd3dEhvbGRlcicpKSB7XG4gICAgICBzcHJlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgc3ByZWFkZXIuY2xhc3NOYW1lID0gJ3d0U3ByZWFkZXInO1xuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIC8vIGlmIFRBQkxFIGlzIGRldGFjaGVkIChlLmcuIGluIEphc21pbmUgdGVzdCksIGl0IGhhcyBubyBwYXJlbnROb2RlIHNvIHdlIGNhbm5vdCBhdHRhY2ggaG9sZGVyIHRvIGl0XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoc3ByZWFkZXIsIHRhYmxlKTtcbiAgICAgIH1cbiAgICAgIHNwcmVhZGVyLmFwcGVuZENoaWxkKHRhYmxlKTtcbiAgICB9XG4gICAgc3ByZWFkZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuXG4gICAgcmV0dXJuIHNwcmVhZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBzcHJlYWRlclxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBjcmVhdGVIaWRlcihzcHJlYWRlcikge1xuICAgIGNvbnN0IHBhcmVudCA9IHNwcmVhZGVyLnBhcmVudE5vZGU7XG4gICAgbGV0IGhpZGVyO1xuXG4gICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50Lm5vZGVUeXBlICE9PSAxIHx8ICFoYXNDbGFzcyhwYXJlbnQsICd3dEhvbGRlcicpKSB7XG4gICAgICBoaWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgaGlkZXIuY2xhc3NOYW1lID0gJ3d0SGlkZXInO1xuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIC8vIGlmIFRBQkxFIGlzIGRldGFjaGVkIChlLmcuIGluIEphc21pbmUgdGVzdCksIGl0IGhhcyBubyBwYXJlbnROb2RlIHNvIHdlIGNhbm5vdCBhdHRhY2ggaG9sZGVyIHRvIGl0XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoaGlkZXIsIHNwcmVhZGVyKTtcbiAgICAgIH1cbiAgICAgIGhpZGVyLmFwcGVuZENoaWxkKHNwcmVhZGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGlkZXI7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGhpZGVyXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIGNyZWF0ZUhvbGRlcihoaWRlcikge1xuICAgIGNvbnN0IHBhcmVudCA9IGhpZGVyLnBhcmVudE5vZGU7XG4gICAgbGV0IGhvbGRlcjtcblxuICAgIGlmICghcGFyZW50IHx8IHBhcmVudC5ub2RlVHlwZSAhPT0gMSB8fCAhaGFzQ2xhc3MocGFyZW50LCAnd3RIb2xkZXInKSkge1xuICAgICAgaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBob2xkZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgaG9sZGVyLmNsYXNzTmFtZSA9ICd3dEhvbGRlcic7XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgLy8gaWYgVEFCTEUgaXMgZGV0YWNoZWQgKGUuZy4gaW4gSmFzbWluZSB0ZXN0KSwgaXQgaGFzIG5vIHBhcmVudE5vZGUgc28gd2UgY2Fubm90IGF0dGFjaCBob2xkZXIgdG8gaXRcbiAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShob2xkZXIsIGhpZGVyKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5pc1dvcmtpbmdPbkNsb25lKCkpIHtcbiAgICAgICAgaG9sZGVyLnBhcmVudE5vZGUuY2xhc3NOYW1lICs9ICdodF9tYXN0ZXIgaGFuZHNvbnRhYmxlJztcbiAgICAgIH1cbiAgICAgIGhvbGRlci5hcHBlbmRDaGlsZChoaWRlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhvbGRlcjtcbiAgfVxuXG4gIGFsaWduT3ZlcmxheXNXaXRoVHJpbW1pbmdDb250YWluZXIoKSB7XG4gICAgY29uc3QgdHJpbW1pbmdFbGVtZW50ID0gZ2V0VHJpbW1pbmdDb250YWluZXIodGhpcy53dFJvb3RFbGVtZW50KTtcblxuICAgIGlmICghdGhpcy5pc1dvcmtpbmdPbkNsb25lKCkpIHtcbiAgICAgIHRoaXMuaG9sZGVyLnBhcmVudE5vZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuXG4gICAgICBpZiAodHJpbW1pbmdFbGVtZW50ID09PSB3aW5kb3cpIHtcbiAgICAgICAgdGhpcy5ob2xkZXIuc3R5bGUub3ZlcmZsb3cgPSAndmlzaWJsZSc7XG4gICAgICAgIHRoaXMud3RSb290RWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICd2aXNpYmxlJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaG9sZGVyLnN0eWxlLndpZHRoID0gZ2V0U3R5bGUodHJpbW1pbmdFbGVtZW50LCAnd2lkdGgnKTtcbiAgICAgICAgdGhpcy5ob2xkZXIuc3R5bGUuaGVpZ2h0ID0gZ2V0U3R5bGUodHJpbW1pbmdFbGVtZW50LCAnaGVpZ2h0Jyk7XG4gICAgICAgIHRoaXMuaG9sZGVyLnN0eWxlLm92ZXJmbG93ID0gJyc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNXb3JraW5nT25DbG9uZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLndvdC5jbG9uZVNvdXJjZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWRyYXdzIHRoZSB0YWJsZVxuICAgKlxuICAgKiBAcGFyYW0gZmFzdERyYXcge0Jvb2xlYW59IElmIFRSVUUsIHdpbGwgdHJ5IHRvIGF2b2lkIGZ1bGwgcmVkcmF3IGFuZCBvbmx5IHVwZGF0ZSB0aGUgYm9yZGVyIHBvc2l0aW9ucy4gSWYgRkFMU0Ugb3IgVU5ERUZJTkVELCB3aWxsIHBlcmZvcm0gYSBmdWxsIHJlZHJhd1xuICAgKiBAcmV0dXJucyB7V2Fsa29udGFibGVUYWJsZX1cbiAgICovXG4gIGRyYXcoZmFzdERyYXcpIHtcbiAgICBpZiAoIXRoaXMuaXNXb3JraW5nT25DbG9uZSgpKSB7XG4gICAgICB0aGlzLmhvbGRlck9mZnNldCA9IG9mZnNldCh0aGlzLmhvbGRlcik7XG4gICAgICBmYXN0RHJhdyA9IHRoaXMud290Lnd0Vmlld3BvcnQuY3JlYXRlUmVuZGVyQ2FsY3VsYXRvcnMoZmFzdERyYXcpO1xuICAgIH1cblxuICAgIGlmICghZmFzdERyYXcpIHtcbiAgICAgIGlmICh0aGlzLmlzV29ya2luZ09uQ2xvbmUoKSkge1xuICAgICAgICB0aGlzLnRhYmxlT2Zmc2V0ID0gdGhpcy53b3QuY2xvbmVTb3VyY2Uud3RUYWJsZS50YWJsZU9mZnNldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGFibGVPZmZzZXQgPSBvZmZzZXQodGhpcy5UQUJMRSk7XG4gICAgICB9XG4gICAgICBsZXQgc3RhcnRSb3c7XG5cbiAgICAgIGlmICh0aGlzLndvdC5jbG9uZU92ZXJsYXkgaW5zdGFuY2VvZiBXYWxrb250YWJsZURlYnVnT3ZlcmxheSB8fFxuICAgICAgICB0aGlzLndvdC5jbG9uZU92ZXJsYXkgaW5zdGFuY2VvZiBXYWxrb250YWJsZVRvcE92ZXJsYXkgfHxcbiAgICAgICAgdGhpcy53b3QuY2xvbmVPdmVybGF5IGluc3RhbmNlb2YgV2Fsa29udGFibGVDb3JuZXJPdmVybGF5KSB7XG4gICAgICAgIHN0YXJ0Um93ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0Um93ID0gdGhpcy53b3Qud3RWaWV3cG9ydC5yb3dzUmVuZGVyQ2FsY3VsYXRvci5zdGFydFJvdztcbiAgICAgIH1cbiAgICAgIGxldCBzdGFydENvbHVtbjtcblxuICAgICAgaWYgKHRoaXMud290LmNsb25lT3ZlcmxheSBpbnN0YW5jZW9mIFdhbGtvbnRhYmxlRGVidWdPdmVybGF5IHx8XG4gICAgICAgIHRoaXMud290LmNsb25lT3ZlcmxheSBpbnN0YW5jZW9mIFdhbGtvbnRhYmxlTGVmdE92ZXJsYXkgfHxcbiAgICAgICAgdGhpcy53b3QuY2xvbmVPdmVybGF5IGluc3RhbmNlb2YgV2Fsa29udGFibGVDb3JuZXJPdmVybGF5KSB7XG4gICAgICAgIHN0YXJ0Q29sdW1uID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0Q29sdW1uID0gdGhpcy53b3Qud3RWaWV3cG9ydC5jb2x1bW5zUmVuZGVyQ2FsY3VsYXRvci5zdGFydENvbHVtbjtcbiAgICAgIH1cbiAgICAgIHRoaXMucm93RmlsdGVyID0gbmV3IFdhbGtvbnRhYmxlUm93RmlsdGVyKHN0YXJ0Um93LCB0aGlzLndvdC5nZXRTZXR0aW5nKCd0b3RhbFJvd3MnKSwgdGhpcy53b3QuZ2V0U2V0dGluZygnY29sdW1uSGVhZGVycycpLmxlbmd0aCk7XG4gICAgICB0aGlzLmNvbHVtbkZpbHRlciA9IG5ldyBXYWxrb250YWJsZUNvbHVtbkZpbHRlcihzdGFydENvbHVtbiwgdGhpcy53b3QuZ2V0U2V0dGluZygndG90YWxDb2x1bW5zJyksIHRoaXMud290LmdldFNldHRpbmcoJ3Jvd0hlYWRlcnMnKS5sZW5ndGgpO1xuICAgICAgdGhpcy5fZG9EcmF3KCk7IC8vY3JlYXRlcyBjYWxjdWxhdG9yIGFmdGVyIGRyYXdcblxuICAgICAgdGhpcy5hbGlnbk92ZXJsYXlzV2l0aFRyaW1taW5nQ29udGFpbmVyKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLmlzV29ya2luZ09uQ2xvbmUoKSkge1xuICAgICAgICAvLyBpbiBjYXNlIHdlIG9ubHkgc2Nyb2xsZWQgd2l0aG91dCByZWRyYXcsIHVwZGF0ZSB2aXNpYmxlIHJvd3MgaW5mb3JtYXRpb24gaW4gb2xkUm93c0NhbGN1bGF0b3JcbiAgICAgICAgdGhpcy53b3Qud3RWaWV3cG9ydC5jcmVhdGVWaXNpYmxlQ2FsY3VsYXRvcnMoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLndvdC53dE92ZXJsYXlzKSB7XG4gICAgICAgIHRoaXMud290Lnd0T3ZlcmxheXMucmVmcmVzaCh0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZWZyZXNoU2VsZWN0aW9ucyhmYXN0RHJhdyk7XG5cbiAgICBpZiAoIXRoaXMuaXNXb3JraW5nT25DbG9uZSgpKSB7XG4gICAgICB0aGlzLndvdC53dE92ZXJsYXlzLnRvcE92ZXJsYXkucmVzZXRGaXhlZFBvc2l0aW9uKCk7XG4gICAgICB0aGlzLndvdC53dE92ZXJsYXlzLmxlZnRPdmVybGF5LnJlc2V0Rml4ZWRQb3NpdGlvbigpO1xuXG4gICAgICBpZiAodGhpcy53b3Qud3RPdmVybGF5cy50b3BMZWZ0Q29ybmVyT3ZlcmxheSkge1xuICAgICAgICB0aGlzLndvdC53dE92ZXJsYXlzLnRvcExlZnRDb3JuZXJPdmVybGF5LnJlc2V0Rml4ZWRQb3NpdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLndvdC5kcmF3biA9IHRydWU7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIF9kb0RyYXcoKSB7XG4gICAgY29uc3Qgd3RSZW5kZXJlciA9IG5ldyBXYWxrb250YWJsZVRhYmxlUmVuZGVyZXIodGhpcyk7XG5cbiAgICB3dFJlbmRlcmVyLnJlbmRlcigpO1xuICB9XG5cbiAgcmVtb3ZlQ2xhc3NGcm9tQ2VsbHMoY2xhc3NOYW1lKSB7XG4gICAgY29uc3Qgbm9kZXMgPSB0aGlzLlRBQkxFLnF1ZXJ5U2VsZWN0b3JBbGwoJy4nICsgY2xhc3NOYW1lKTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBub2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmVtb3ZlQ2xhc3Mobm9kZXNbaV0sIGNsYXNzTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmVmcmVzaFNlbGVjdGlvbnMoZmFzdERyYXcpIHtcbiAgICBpZiAoIXRoaXMud290LnNlbGVjdGlvbnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGxlbiA9IHRoaXMud290LnNlbGVjdGlvbnMubGVuZ3RoO1xuXG4gICAgaWYgKGZhc3REcmF3KSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIHRoZXJlIHdhcyBubyByZXJlbmRlciwgc28gd2UgbmVlZCB0byByZW1vdmUgY2xhc3NOYW1lcyBieSBvdXJzZWx2ZXNcbiAgICAgICAgaWYgKHRoaXMud290LnNlbGVjdGlvbnNbaV0uc2V0dGluZ3MuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVDbGFzc0Zyb21DZWxscyh0aGlzLndvdC5zZWxlY3Rpb25zW2ldLnNldHRpbmdzLmNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMud290LnNlbGVjdGlvbnNbaV0uc2V0dGluZ3MuaGlnaGxpZ2h0Um93Q2xhc3NOYW1lKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVDbGFzc0Zyb21DZWxscyh0aGlzLndvdC5zZWxlY3Rpb25zW2ldLnNldHRpbmdzLmhpZ2hsaWdodFJvd0NsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMud290LnNlbGVjdGlvbnNbaV0uc2V0dGluZ3MuaGlnaGxpZ2h0Q29sdW1uQ2xhc3NOYW1lKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVDbGFzc0Zyb21DZWxscyh0aGlzLndvdC5zZWxlY3Rpb25zW2ldLnNldHRpbmdzLmhpZ2hsaWdodENvbHVtbkNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGhpcy53b3Quc2VsZWN0aW9uc1tpXS5kcmF3KHRoaXMud290LCBmYXN0RHJhdyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjZWxsIGVsZW1lbnQgYXQgY29vcmRzLlxuICAgKlxuICAgKiBAcGFyYW0ge1dhbGtvbnRhYmxlQ2VsbENvb3Jkc30gY29vcmRzXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudHxOdW1iZXJ9IEhUTUxFbGVtZW50IG9uIHN1Y2Nlc3Mgb3IgTnVtYmVyIG9uZSBvZiB0aGUgZXhpdCBjb2RlcyBvbiBlcnJvcjpcbiAgICogIC0xIHJvdyBiZWZvcmUgdmlld3BvcnRcbiAgICogIC0yIHJvdyBhZnRlciB2aWV3cG9ydFxuICAgKi9cbiAgZ2V0Q2VsbChjb29yZHMpIHtcbiAgICBpZiAodGhpcy5pc1Jvd0JlZm9yZVJlbmRlcmVkUm93cyhjb29yZHMucm93KSkge1xuICAgICAgLy8gcm93IGJlZm9yZSByZW5kZXJlZCByb3dzXG4gICAgICByZXR1cm4gLTE7XG5cbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNSb3dBZnRlclJlbmRlcmVkUm93cyhjb29yZHMucm93KSkge1xuICAgICAgLy8gcm93IGFmdGVyIHJlbmRlcmVkIHJvd3NcbiAgICAgIHJldHVybiAtMjtcbiAgICB9XG4gICAgY29uc3QgVFIgPSB0aGlzLlRCT0RZLmNoaWxkTm9kZXNbdGhpcy5yb3dGaWx0ZXIuc291cmNlVG9SZW5kZXJlZChjb29yZHMucm93KV07XG5cbiAgICBpZiAoVFIpIHtcbiAgICAgIHJldHVybiBUUi5jaGlsZE5vZGVzW3RoaXMuY29sdW1uRmlsdGVyLnNvdXJjZUNvbHVtblRvVmlzaWJsZVJvd0hlYWRlZENvbHVtbihjb29yZHMuY29sKV07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGdldENvbHVtbkhlYWRlclxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gY29sIENvbHVtbiBpbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gW2xldmVsPTBdIEhlYWRlciBsZXZlbCAoMCA9IG1vc3QgZGlzdGFudCB0byB0aGUgdGFibGUpXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEhUTUxFbGVtZW50IG9uIHN1Y2Nlc3Mgb3IgdW5kZWZpbmVkIG9uIGVycm9yXG4gICAqL1xuICBnZXRDb2x1bW5IZWFkZXIoY29sLCBsZXZlbCA9IDApIHtcbiAgICBjb25zdCBUUiA9IHRoaXMuVEhFQUQuY2hpbGROb2Rlc1tsZXZlbF07XG5cbiAgICBpZiAoVFIpIHtcbiAgICAgIHJldHVybiBUUi5jaGlsZE5vZGVzW3RoaXMuY29sdW1uRmlsdGVyLnNvdXJjZUNvbHVtblRvVmlzaWJsZVJvd0hlYWRlZENvbHVtbihjb2wpXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogZ2V0Um93SGVhZGVyXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByb3cgUm93IGluZGV4XG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gSFRNTEVsZW1lbnQgb24gc3VjY2VzcyBvciBOdW1iZXIgb25lIG9mIHRoZSBleGl0IGNvZGVzIG9uIGVycm9yOiBgbnVsbCB0YWJsZSBkb2Vzbid0IGhhdmUgcm93IGhlYWRlcnNgXG4gICAqL1xuICBnZXRSb3dIZWFkZXIocm93KSB7XG4gICAgaWYgKHRoaXMuY29sdW1uRmlsdGVyLnNvdXJjZUNvbHVtblRvVmlzaWJsZVJvd0hlYWRlZENvbHVtbigwKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IFRSID0gdGhpcy5UQk9EWS5jaGlsZE5vZGVzW3RoaXMucm93RmlsdGVyLnNvdXJjZVRvUmVuZGVyZWQocm93KV07XG5cbiAgICBpZiAoVFIpIHtcbiAgICAgIHJldHVybiBUUi5jaGlsZE5vZGVzWzBdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGNlbGwgY29vcmRzIG9iamVjdCBmb3IgYSBnaXZlbiBURFxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxUYWJsZUNlbGxFbGVtZW50fSBURFxuICAgKiBAcmV0dXJucyB7V2Fsa29udGFibGVDZWxsQ29vcmRzfVxuICAgKi9cbiAgZ2V0Q29vcmRzKFREKSB7XG4gICAgY29uc3QgVFIgPSBURC5wYXJlbnROb2RlO1xuICAgIGxldCByb3cgPSBpbmRleChUUik7XG5cbiAgICBpZiAoVFIucGFyZW50Tm9kZSA9PT0gdGhpcy5USEVBRCkge1xuICAgICAgcm93ID0gdGhpcy5yb3dGaWx0ZXIudmlzaWJsZUNvbEhlYWRlZFJvd1RvU291cmNlUm93KHJvdyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvdyA9IHRoaXMucm93RmlsdGVyLnJlbmRlcmVkVG9Tb3VyY2Uocm93KTtcbiAgICB9XG4gICAgbGV0IGNvbCA9IHRoaXMuY29sdW1uRmlsdGVyLnZpc2libGVSb3dIZWFkZWRDb2x1bW5Ub1NvdXJjZUNvbHVtbihURC5jZWxsSW5kZXgpO1xuXG4gICAgcmV0dXJuIG5ldyBXYWxrb250YWJsZUNlbGxDb29yZHMocm93LCBjb2wpO1xuICB9XG5cbiAgZ2V0VHJGb3JSb3cocm93KSB7XG4gICAgcmV0dXJuIHRoaXMuVEJPRFkuY2hpbGROb2Rlc1t0aGlzLnJvd0ZpbHRlci5zb3VyY2VUb1JlbmRlcmVkKHJvdyldO1xuICB9XG5cbiAgZ2V0Rmlyc3RSZW5kZXJlZFJvdygpIHtcbiAgICByZXR1cm4gdGhpcy53b3Qud3RWaWV3cG9ydC5yb3dzUmVuZGVyQ2FsY3VsYXRvci5zdGFydFJvdztcbiAgfVxuXG4gIGdldEZpcnN0VmlzaWJsZVJvdygpIHtcbiAgICByZXR1cm4gdGhpcy53b3Qud3RWaWV3cG9ydC5yb3dzVmlzaWJsZUNhbGN1bGF0b3Iuc3RhcnRSb3c7XG4gIH1cblxuICBnZXRGaXJzdFJlbmRlcmVkQ29sdW1uKCkge1xuICAgIHJldHVybiB0aGlzLndvdC53dFZpZXdwb3J0LmNvbHVtbnNSZW5kZXJDYWxjdWxhdG9yLnN0YXJ0Q29sdW1uO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgLTEgaWYgbm8gcm93IGlzIHZpc2libGVcbiAgICovXG4gIGdldEZpcnN0VmlzaWJsZUNvbHVtbigpIHtcbiAgICByZXR1cm4gdGhpcy53b3Qud3RWaWV3cG9ydC5jb2x1bW5zVmlzaWJsZUNhbGN1bGF0b3Iuc3RhcnRDb2x1bW47XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyAtMSBpZiBubyByb3cgaXMgdmlzaWJsZVxuICAgKi9cbiAgZ2V0TGFzdFJlbmRlcmVkUm93KCkge1xuICAgIHJldHVybiB0aGlzLndvdC53dFZpZXdwb3J0LnJvd3NSZW5kZXJDYWxjdWxhdG9yLmVuZFJvdztcbiAgfVxuXG4gIGdldExhc3RWaXNpYmxlUm93KCkge1xuICAgIHJldHVybiB0aGlzLndvdC53dFZpZXdwb3J0LnJvd3NWaXNpYmxlQ2FsY3VsYXRvci5lbmRSb3c7XG4gIH1cblxuICBnZXRMYXN0UmVuZGVyZWRDb2x1bW4oKSB7XG4gICAgcmV0dXJuIHRoaXMud290Lnd0Vmlld3BvcnQuY29sdW1uc1JlbmRlckNhbGN1bGF0b3IuZW5kQ29sdW1uO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgLTEgaWYgbm8gY29sdW1uIGlzIHZpc2libGVcbiAgICovXG4gIGdldExhc3RWaXNpYmxlQ29sdW1uKCkge1xuICAgIHJldHVybiB0aGlzLndvdC53dFZpZXdwb3J0LmNvbHVtbnNWaXNpYmxlQ2FsY3VsYXRvci5lbmRDb2x1bW47XG4gIH1cblxuICBpc1Jvd0JlZm9yZVJlbmRlcmVkUm93cyhyb3cpIHtcbiAgICByZXR1cm4gKHRoaXMucm93RmlsdGVyLnNvdXJjZVRvUmVuZGVyZWQocm93KSA8IDAgJiYgcm93ID49IDApO1xuICB9XG5cbiAgaXNSb3dBZnRlclZpZXdwb3J0KHJvdykge1xuICAgIHJldHVybiAocm93ID4gdGhpcy5nZXRMYXN0VmlzaWJsZVJvdygpKTtcbiAgfVxuXG4gIGlzUm93QWZ0ZXJSZW5kZXJlZFJvd3Mocm93KSB7XG4gICAgcmV0dXJuIChyb3cgPiB0aGlzLmdldExhc3RSZW5kZXJlZFJvdygpKTtcbiAgfVxuXG4gIGlzQ29sdW1uQmVmb3JlVmlld3BvcnQoY29sdW1uKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sdW1uRmlsdGVyLnNvdXJjZVRvUmVuZGVyZWQoY29sdW1uKSA8IDAgJiYgY29sdW1uID49IDA7XG4gIH1cblxuICBpc0NvbHVtbkFmdGVyVmlld3BvcnQoY29sdW1uKSB7XG4gICAgcmV0dXJuIGNvbHVtbiA+IHRoaXMuZ2V0TGFzdFZpc2libGVDb2x1bW4oKTtcbiAgfVxuXG4gIGlzTGFzdFJvd0Z1bGx5VmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXN0VmlzaWJsZVJvdygpID09PSB0aGlzLmdldExhc3RSZW5kZXJlZFJvdygpO1xuICB9XG5cbiAgaXNMYXN0Q29sdW1uRnVsbHlWaXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhc3RWaXNpYmxlQ29sdW1uKCkgPT09IHRoaXMuZ2V0TGFzdFJlbmRlcmVkQ29sdW1uKCk7XG4gIH1cblxuICBnZXRSZW5kZXJlZENvbHVtbnNDb3VudCgpIHtcbiAgICBpZiAodGhpcy53b3QuY2xvbmVPdmVybGF5IGluc3RhbmNlb2YgV2Fsa29udGFibGVEZWJ1Z092ZXJsYXkpIHtcbiAgICAgIHJldHVybiB0aGlzLndvdC5nZXRTZXR0aW5nKCd0b3RhbENvbHVtbnMnKTtcblxuICAgIH0gZWxzZSBpZiAodGhpcy53b3QuY2xvbmVPdmVybGF5IGluc3RhbmNlb2YgV2Fsa29udGFibGVMZWZ0T3ZlcmxheSB8fCB0aGlzLndvdC5jbG9uZU92ZXJsYXkgaW5zdGFuY2VvZiBXYWxrb250YWJsZUNvcm5lck92ZXJsYXkpIHtcbiAgICAgIHJldHVybiB0aGlzLndvdC5nZXRTZXR0aW5nKCdmaXhlZENvbHVtbnNMZWZ0Jyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMud290Lnd0Vmlld3BvcnQuY29sdW1uc1JlbmRlckNhbGN1bGF0b3IuY291bnQ7XG4gICAgfVxuICB9XG5cbiAgZ2V0UmVuZGVyZWRSb3dzQ291bnQoKSB7XG4gICAgaWYgKHRoaXMud290LmNsb25lT3ZlcmxheSBpbnN0YW5jZW9mIFdhbGtvbnRhYmxlRGVidWdPdmVybGF5KSB7XG4gICAgICByZXR1cm4gdGhpcy53b3QuZ2V0U2V0dGluZygndG90YWxSb3dzJyk7XG5cbiAgICB9IGVsc2UgaWYgKHRoaXMud290LmNsb25lT3ZlcmxheSBpbnN0YW5jZW9mIFdhbGtvbnRhYmxlVG9wT3ZlcmxheSB8fFxuICAgICAgdGhpcy53b3QuY2xvbmVPdmVybGF5IGluc3RhbmNlb2YgV2Fsa29udGFibGVDb3JuZXJPdmVybGF5KSB7XG4gICAgICByZXR1cm4gdGhpcy53b3QuZ2V0U2V0dGluZygnZml4ZWRSb3dzVG9wJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMud290Lnd0Vmlld3BvcnQucm93c1JlbmRlckNhbGN1bGF0b3IuY291bnQ7XG4gIH1cblxuICBnZXRWaXNpYmxlUm93c0NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLndvdC53dFZpZXdwb3J0LnJvd3NWaXNpYmxlQ2FsY3VsYXRvci5jb3VudDtcbiAgfVxuXG4gIGFsbFJvd3NJblZpZXdwb3J0KCkge1xuICAgIHJldHVybiB0aGlzLndvdC5nZXRTZXR0aW5nKCd0b3RhbFJvd3MnKSA9PSB0aGlzLmdldFZpc2libGVSb3dzQ291bnQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYW55IG9mIHRoZSByb3cncyBjZWxscyBjb250ZW50IGV4Y2VlZHMgaXRzIGluaXRpYWwgaGVpZ2h0LCBhbmQgaWYgc28sIHJldHVybnMgdGhlIG92ZXJzaXplZCBoZWlnaHRcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNvdXJjZVJvd1xuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0Um93SGVpZ2h0KHNvdXJjZVJvdykge1xuICAgIGxldCBoZWlnaHQgPSB0aGlzLndvdC53dFNldHRpbmdzLnNldHRpbmdzLnJvd0hlaWdodChzb3VyY2VSb3cpO1xuICAgIGxldCBvdmVyc2l6ZWRIZWlnaHQgPSB0aGlzLndvdC53dFZpZXdwb3J0Lm92ZXJzaXplZFJvd3Nbc291cmNlUm93XTtcblxuICAgIGlmIChvdmVyc2l6ZWRIZWlnaHQgIT09IHZvaWQgMCkge1xuICAgICAgaGVpZ2h0ID0gaGVpZ2h0ID8gTWF0aC5tYXgoaGVpZ2h0LCBvdmVyc2l6ZWRIZWlnaHQpIDogb3ZlcnNpemVkSGVpZ2h0O1xuICAgIH1cblxuICAgIHJldHVybiBoZWlnaHQ7XG4gIH1cblxuICBnZXRDb2x1bW5IZWFkZXJIZWlnaHQobGV2ZWwpIHtcbiAgICBsZXQgaGVpZ2h0ID0gdGhpcy53b3Qud3RTZXR0aW5ncy5zZXR0aW5ncy5kZWZhdWx0Um93SGVpZ2h0O1xuICAgIGxldCBvdmVyc2l6ZWRIZWlnaHQgPSB0aGlzLndvdC53dFZpZXdwb3J0Lm92ZXJzaXplZENvbHVtbkhlYWRlcnNbbGV2ZWxdO1xuXG4gICAgaWYgKG92ZXJzaXplZEhlaWdodCAhPT0gdm9pZCAwKSB7XG4gICAgICBoZWlnaHQgPSBoZWlnaHQgPyBNYXRoLm1heChoZWlnaHQsIG92ZXJzaXplZEhlaWdodCkgOiBvdmVyc2l6ZWRIZWlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhlaWdodDtcbiAgfVxuXG4gIGdldFZpc2libGVDb2x1bW5zQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMud290Lnd0Vmlld3BvcnQuY29sdW1uc1Zpc2libGVDYWxjdWxhdG9yLmNvdW50O1xuICB9XG5cbiAgYWxsQ29sdW1uc0luVmlld3BvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMud290LmdldFNldHRpbmcoJ3RvdGFsQ29sdW1ucycpID09IHRoaXMuZ2V0VmlzaWJsZUNvbHVtbnNDb3VudCgpO1xuICB9XG5cbiAgZ2V0Q29sdW1uV2lkdGgoc291cmNlQ29sdW1uKSB7XG4gICAgbGV0IHdpZHRoID0gdGhpcy53b3Qud3RTZXR0aW5ncy5zZXR0aW5ncy5jb2x1bW5XaWR0aDtcblxuICAgIGlmICh0eXBlb2Ygd2lkdGggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdpZHRoID0gd2lkdGgoc291cmNlQ29sdW1uKTtcblxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpZHRoID09PSAnb2JqZWN0Jykge1xuICAgICAgd2lkdGggPSB3aWR0aFtzb3VyY2VDb2x1bW5dO1xuICAgIH1cblxuICAgIHJldHVybiB3aWR0aCB8fCB0aGlzLndvdC53dFNldHRpbmdzLnNldHRpbmdzLmRlZmF1bHRDb2x1bW5XaWR0aDtcbiAgfVxuXG4gIGdldFN0cmV0Y2hlZENvbHVtbldpZHRoKHNvdXJjZUNvbHVtbikge1xuICAgIGxldCB3aWR0aCA9IHRoaXMuZ2V0Q29sdW1uV2lkdGgoc291cmNlQ29sdW1uKTtcbiAgICBsZXQgY2FsY3VsYXRvciA9IHRoaXMud290Lnd0Vmlld3BvcnQuY29sdW1uc1JlbmRlckNhbGN1bGF0b3I7XG5cbiAgICBpZiAoY2FsY3VsYXRvcikge1xuICAgICAgbGV0IHN0cmV0Y2hlZFdpZHRoID0gY2FsY3VsYXRvci5nZXRTdHJldGNoZWRDb2x1bW5XaWR0aChzb3VyY2VDb2x1bW4sIHdpZHRoKTtcblxuICAgICAgaWYgKHN0cmV0Y2hlZFdpZHRoKSB7XG4gICAgICAgIHdpZHRoID0gc3RyZXRjaGVkV2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHdpZHRoO1xuICB9XG59XG5cblxuZXhwb3J0IHtXYWxrb250YWJsZVRhYmxlfTtcblxud2luZG93LldhbGtvbnRhYmxlVGFibGUgPSBXYWxrb250YWJsZVRhYmxlO1xuIiwiXG5pbXBvcnQge1xuICBhZGRDbGFzcyxcbiAgZW1wdHksXG4gIGdldFNjcm9sbGJhcldpZHRoLFxuICBoYXNDbGFzcyxcbiAgaW5uZXJIZWlnaHQsXG4gICAgfSBmcm9tICcuLy4uLy4uLy4uL2hlbHBlcnMvZG9tL2VsZW1lbnQnO1xuXG4vKipcbiAqIEBjbGFzcyBXYWxrb250YWJsZVRhYmxlUmVuZGVyZXJcbiAqL1xuY2xhc3MgV2Fsa29udGFibGVUYWJsZVJlbmRlcmVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7V2Fsa29udGFibGVUYWJsZX0gd3RUYWJsZVxuICAgKi9cbiAgY29uc3RydWN0b3Iod3RUYWJsZSkge1xuICAgIHRoaXMud3RUYWJsZSA9IHd0VGFibGU7XG4gICAgdGhpcy53b3QgPSB3dFRhYmxlLmluc3RhbmNlO1xuICAgIC8vIGxlZ2FjeSBzdXBwb3J0XG4gICAgdGhpcy5pbnN0YW5jZSA9IHd0VGFibGUuaW5zdGFuY2U7XG5cbiAgICB0aGlzLnJvd0ZpbHRlciA9IHd0VGFibGUucm93RmlsdGVyO1xuICAgIHRoaXMuY29sdW1uRmlsdGVyID0gd3RUYWJsZS5jb2x1bW5GaWx0ZXI7XG5cbiAgICB0aGlzLlRBQkxFID0gd3RUYWJsZS5UQUJMRTtcbiAgICB0aGlzLlRIRUFEID0gd3RUYWJsZS5USEVBRDtcbiAgICB0aGlzLlRCT0RZID0gd3RUYWJsZS5UQk9EWTtcbiAgICB0aGlzLkNPTEdST1VQID0gd3RUYWJsZS5DT0xHUk9VUDtcblxuICAgIHRoaXMucm93SGVhZGVycyA9IFtdO1xuICAgIHRoaXMucm93SGVhZGVyQ291bnQgPSAwO1xuICAgIHRoaXMuY29sdW1uSGVhZGVycyA9IFtdO1xuICAgIHRoaXMuY29sdW1uSGVhZGVyQ291bnQgPSAwO1xuICAgIHRoaXMuZml4ZWRSb3dzVG9wID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy53dFRhYmxlLmlzV29ya2luZ09uQ2xvbmUoKSkge1xuICAgICAgdGhpcy53b3QuZ2V0U2V0dGluZygnYmVmb3JlRHJhdycsIHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMucm93SGVhZGVycyA9IHRoaXMud290LmdldFNldHRpbmcoJ3Jvd0hlYWRlcnMnKTtcbiAgICB0aGlzLnJvd0hlYWRlckNvdW50ID0gdGhpcy5yb3dIZWFkZXJzLmxlbmd0aDtcbiAgICB0aGlzLmZpeGVkUm93c1RvcCA9IHRoaXMud290LmdldFNldHRpbmcoJ2ZpeGVkUm93c1RvcCcpO1xuICAgIHRoaXMuY29sdW1uSGVhZGVycyA9IHRoaXMud290LmdldFNldHRpbmcoJ2NvbHVtbkhlYWRlcnMnKTtcbiAgICB0aGlzLmNvbHVtbkhlYWRlckNvdW50ID0gdGhpcy5jb2x1bW5IZWFkZXJzLmxlbmd0aDtcblxuICAgIGxldCBjb2x1bW5zVG9SZW5kZXIgPSB0aGlzLnd0VGFibGUuZ2V0UmVuZGVyZWRDb2x1bW5zQ291bnQoKTtcbiAgICBsZXQgcm93c1RvUmVuZGVyID0gdGhpcy53dFRhYmxlLmdldFJlbmRlcmVkUm93c0NvdW50KCk7XG4gICAgbGV0IHRvdGFsQ29sdW1ucyA9IHRoaXMud290LmdldFNldHRpbmcoJ3RvdGFsQ29sdW1ucycpO1xuICAgIGxldCB0b3RhbFJvd3MgPSB0aGlzLndvdC5nZXRTZXR0aW5nKCd0b3RhbFJvd3MnKTtcbiAgICBsZXQgd29ya3NwYWNlV2lkdGg7XG4gICAgbGV0IGFkanVzdGVkID0gZmFsc2U7XG5cbiAgICBpZiAodG90YWxDb2x1bW5zID4gMCkge1xuICAgICAgLy8gcHJlcGFyZSBDT0wgYW5kIFRIIGVsZW1lbnRzIGZvciByZW5kZXJpbmdcbiAgICAgIHRoaXMuYWRqdXN0QXZhaWxhYmxlTm9kZXMoKTtcbiAgICAgIGFkanVzdGVkID0gdHJ1ZTtcblxuICAgICAgLy8gYWRqdXN0IGNvbHVtbiB3aWR0aHMgYWNjb3JkaW5nIHRvIHVzZXIgd2lkdGhzIHNldHRpbmdzXG4gICAgICB0aGlzLnJlbmRlckNvbHVtbkhlYWRlcnMoKTtcblxuICAgICAgLy9SZW5kZXIgdGFibGUgcm93c1xuICAgICAgdGhpcy5yZW5kZXJSb3dzKHRvdGFsUm93cywgcm93c1RvUmVuZGVyLCBjb2x1bW5zVG9SZW5kZXIpO1xuXG4gICAgICBpZiAoIXRoaXMud3RUYWJsZS5pc1dvcmtpbmdPbkNsb25lKCkpIHtcbiAgICAgICAgd29ya3NwYWNlV2lkdGggPSB0aGlzLndvdC53dFZpZXdwb3J0LmdldFdvcmtzcGFjZVdpZHRoKCk7XG4gICAgICAgIHRoaXMud290Lnd0Vmlld3BvcnQuY29udGFpbmVyV2lkdGggPSBudWxsO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGp1c3RDb2x1bW5IZWFkZXJIZWlnaHRzKCk7XG4gICAgICB0aGlzLmFkanVzdENvbHVtbldpZHRocyhjb2x1bW5zVG9SZW5kZXIpO1xuICAgICAgdGhpcy5tYXJrT3ZlcnNpemVkQ29sdW1ucygpO1xuICAgIH1cblxuICAgIGlmICghYWRqdXN0ZWQpIHtcbiAgICAgIHRoaXMuYWRqdXN0QXZhaWxhYmxlTm9kZXMoKTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVSZWR1bmRhbnRSb3dzKHJvd3NUb1JlbmRlcik7XG5cbiAgICBpZiAoIXRoaXMud3RUYWJsZS5pc1dvcmtpbmdPbkNsb25lKCkpIHtcbiAgICAgIHRoaXMubWFya092ZXJzaXplZFJvd3MoKTtcblxuICAgICAgdGhpcy53b3Qud3RWaWV3cG9ydC5jcmVhdGVWaXNpYmxlQ2FsY3VsYXRvcnMoKTtcbiAgICAgIHRoaXMud290Lnd0T3ZlcmxheXMucmVmcmVzaChmYWxzZSk7XG4gICAgICB0aGlzLndvdC53dE92ZXJsYXlzLmFwcGx5VG9ET00oKTtcblxuICAgICAgaWYgKHdvcmtzcGFjZVdpZHRoICE9PSB0aGlzLndvdC53dFZpZXdwb3J0LmdldFdvcmtzcGFjZVdpZHRoKCkpIHtcbiAgICAgICAgLy93b3Jrc3BhY2Ugd2lkdGggY2hhbmdlZCB0aG91Z2ggdG8gc2hvd24vaGlkZGVuIHZlcnRpY2FsIHNjcm9sbGJhci4gTGV0J3MgcmVhcHBseSBzdHJldGNoaW5nXG4gICAgICAgIHRoaXMud290Lnd0Vmlld3BvcnQuY29udGFpbmVyV2lkdGggPSBudWxsO1xuXG4gICAgICAgIGxldCBmaXJzdFJlbmRlcmVkID0gdGhpcy53dFRhYmxlLmdldEZpcnN0UmVuZGVyZWRDb2x1bW4oKTtcbiAgICAgICAgbGV0IGxhc3RSZW5kZXJlZCA9IHRoaXMud3RUYWJsZS5nZXRMYXN0UmVuZGVyZWRDb2x1bW4oKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gZmlyc3RSZW5kZXJlZDsgaSA8IGxhc3RSZW5kZXJlZDsgaSsrKSB7XG4gICAgICAgICAgbGV0IHdpZHRoID0gdGhpcy53dFRhYmxlLmdldFN0cmV0Y2hlZENvbHVtbldpZHRoKGkpO1xuICAgICAgICAgIGxldCByZW5kZXJlZEluZGV4ID0gdGhpcy5jb2x1bW5GaWx0ZXIuc291cmNlVG9SZW5kZXJlZChpKTtcblxuICAgICAgICAgIHRoaXMuQ09MR1JPVVAuY2hpbGROb2Rlc1tyZW5kZXJlZEluZGV4ICsgdGhpcy5yb3dIZWFkZXJDb3VudF0uc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy53b3QuZ2V0U2V0dGluZygnb25EcmF3JywgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByZW5kZXJlZFJvd3NDb3VudFxuICAgKi9cbiAgcmVtb3ZlUmVkdW5kYW50Um93cyhyZW5kZXJlZFJvd3NDb3VudCkge1xuICAgIHdoaWxlICh0aGlzLnd0VGFibGUudGJvZHlDaGlsZHJlbkxlbmd0aCA+IHJlbmRlcmVkUm93c0NvdW50KSB7XG4gICAgICB0aGlzLlRCT0RZLnJlbW92ZUNoaWxkKHRoaXMuVEJPRFkubGFzdENoaWxkKTtcbiAgICAgIHRoaXMud3RUYWJsZS50Ym9keUNoaWxkcmVuTGVuZ3RoLS07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0b3RhbFJvd3NcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJvd3NUb1JlbmRlclxuICAgKiBAcGFyYW0ge051bWJlcn0gY29sdW1uc1RvUmVuZGVyXG4gICAqL1xuICByZW5kZXJSb3dzKHRvdGFsUm93cywgcm93c1RvUmVuZGVyLCBjb2x1bW5zVG9SZW5kZXIpIHtcbiAgICBsZXQgbGFzdFRELCBUUjtcbiAgICBsZXQgdmlzaWJsZVJvd0luZGV4ID0gMDtcbiAgICBsZXQgc291cmNlUm93SW5kZXggPSB0aGlzLnJvd0ZpbHRlci5yZW5kZXJlZFRvU291cmNlKHZpc2libGVSb3dJbmRleCk7XG4gICAgbGV0IGlzV29ya2luZ09uQ2xvbmUgPSB0aGlzLnd0VGFibGUuaXNXb3JraW5nT25DbG9uZSgpO1xuXG4gICAgd2hpbGUgKHNvdXJjZVJvd0luZGV4IDwgdG90YWxSb3dzICYmIHNvdXJjZVJvd0luZGV4ID49IDApIHtcbiAgICAgIGlmICh2aXNpYmxlUm93SW5kZXggPiAxMDAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2VjdXJpdHkgYnJha2U6IFRvbyBtdWNoIFRScy4gUGxlYXNlIGRlZmluZSBoZWlnaHQgZm9yIHlvdXIgdGFibGUsIHdoaWNoIHdpbGwgZW5mb3JjZSBzY3JvbGxiYXJzLicpO1xuICAgICAgfVxuICAgICAgaWYgKHJvd3NUb1JlbmRlciAhPT0gdm9pZCAwICYmIHZpc2libGVSb3dJbmRleCA9PT0gcm93c1RvUmVuZGVyKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgYXMgbXVjaCByb3dzIGFzIG5lZWRlZCBmb3IgdGhpcyBjbG9uZVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIFRSID0gdGhpcy5nZXRPckNyZWF0ZVRyRm9yUm93KHZpc2libGVSb3dJbmRleCwgVFIpO1xuXG4gICAgICAvLyBSZW5kZXIgcm93IGhlYWRlcnNcbiAgICAgIHRoaXMucmVuZGVyUm93SGVhZGVycyhzb3VyY2VSb3dJbmRleCwgVFIpO1xuICAgICAgLy8gQWRkIGFuZC9vciByZW1vdmUgVERzIHRvIFRSIHRvIG1hdGNoIHRoZSBkZXNpcmVkIG51bWJlclxuICAgICAgdGhpcy5hZGp1c3RDb2x1bW5zKFRSLCBjb2x1bW5zVG9SZW5kZXIgKyB0aGlzLnJvd0hlYWRlckNvdW50KTtcblxuICAgICAgbGFzdFREID0gdGhpcy5yZW5kZXJDZWxscyhzb3VyY2VSb3dJbmRleCwgVFIsIGNvbHVtbnNUb1JlbmRlcik7XG5cbiAgICAgIGlmICghaXNXb3JraW5nT25DbG9uZSkge1xuICAgICAgICAvLyBSZXNldCB0aGUgb3ZlcnNpemVkIHJvdyBjYWNoZSBmb3IgdGhpcyByb3dcbiAgICAgICAgdGhpcy5yZXNldE92ZXJzaXplZFJvdyhzb3VyY2VSb3dJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChUUi5maXJzdENoaWxkKSB7XG4gICAgICAgIC8vIGlmIEkgaGF2ZSAyIGZpeGVkIGNvbHVtbnMgd2l0aCBvbmUtbGluZSBjb250ZW50IGFuZCB0aGUgM3JkIGNvbHVtbiBoYXMgYSBtdWx0aWxpbmUgY29udGVudCwgdGhpcyBpc1xuICAgICAgICAvLyB0aGUgd2F5IHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBvdmVybGF5IHdpbGwgaGFzIHNhbWUgcm93IGhlaWdodFxuICAgICAgICBsZXQgaGVpZ2h0ID0gdGhpcy53b3Qud3RUYWJsZS5nZXRSb3dIZWlnaHQoc291cmNlUm93SW5kZXgpO1xuXG4gICAgICAgIGlmIChoZWlnaHQpIHtcbiAgICAgICAgICAvLyBEZWNyZWFzZSBoZWlnaHQuIDEgcGl4ZWwgd2lsbCBiZSBcInJlcGxhY2VkXCIgYnkgMXB4IGJvcmRlciB0b3BcbiAgICAgICAgICBoZWlnaHQtLTtcbiAgICAgICAgICBUUi5maXJzdENoaWxkLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgVFIuZmlyc3RDaGlsZC5zdHlsZS5oZWlnaHQgPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmlzaWJsZVJvd0luZGV4Kys7XG4gICAgICBzb3VyY2VSb3dJbmRleCA9IHRoaXMucm93RmlsdGVyLnJlbmRlcmVkVG9Tb3VyY2UodmlzaWJsZVJvd0luZGV4KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgdGhlIG92ZXJzaXplZCByb3cgY2FjaGUgZm9yIHRoZSBwcm92aWRlZCBpbmRleFxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gc291cmNlUm93IFJvdyBpbmRleFxuICAgKi9cbiAgcmVzZXRPdmVyc2l6ZWRSb3coc291cmNlUm93KSB7XG4gICAgaWYgKHRoaXMud290LmdldFNldHRpbmcoJ2V4dGVybmFsUm93Q2FsY3VsYXRvcicpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLndvdC53dFZpZXdwb3J0Lm92ZXJzaXplZFJvd3MgJiYgdGhpcy53b3Qud3RWaWV3cG9ydC5vdmVyc2l6ZWRSb3dzW3NvdXJjZVJvd10pIHtcbiAgICAgIHRoaXMud290Lnd0Vmlld3BvcnQub3ZlcnNpemVkUm93c1tzb3VyY2VSb3ddID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbnkgb2YgdGhlIHJlbmRlcmVkIHJvd3MgaXMgaGlnaGVyIHRoYW4gZXhwZWN0ZWQsIGFuZCBpZiBzbywgY2FjaGUgdGhlbVxuICAgKi9cbiAgbWFya092ZXJzaXplZFJvd3MoKSB7XG4gICAgaWYgKHRoaXMud290LmdldFNldHRpbmcoJ2V4dGVybmFsUm93Q2FsY3VsYXRvcicpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCByb3dDb3VudCA9IHRoaXMuaW5zdGFuY2Uud3RUYWJsZS5UQk9EWS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICBsZXQgZXhwZWN0ZWRUYWJsZUhlaWdodCA9IHJvd0NvdW50ICogdGhpcy5pbnN0YW5jZS53dFNldHRpbmdzLnNldHRpbmdzLmRlZmF1bHRSb3dIZWlnaHQ7XG4gICAgbGV0IGFjdHVhbFRhYmxlSGVpZ2h0ID0gaW5uZXJIZWlnaHQodGhpcy5pbnN0YW5jZS53dFRhYmxlLlRCT0RZKSAtIDE7XG4gICAgbGV0IHByZXZpb3VzUm93SGVpZ2h0O1xuICAgIGxldCByb3dJbm5lckhlaWdodDtcbiAgICBsZXQgc291cmNlUm93SW5kZXg7XG4gICAgbGV0IGN1cnJlbnRUcjtcbiAgICBsZXQgcm93SGVhZGVyO1xuXG4gICAgaWYgKGV4cGVjdGVkVGFibGVIZWlnaHQgPT09IGFjdHVhbFRhYmxlSGVpZ2h0KSB7XG4gICAgICAvLyBJZiB0aGUgYWN0dWFsIHRhYmxlIGhlaWdodCBlcXVhbHMgcm93Q291bnQgKiBkZWZhdWx0IHNpbmdsZSByb3cgaGVpZ2h0LCBubyByb3cgaXMgb3ZlcnNpemVkIC0+IG5vIG5lZWQgdG8gaXRlcmF0ZSBvdmVyIHRoZW1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aGlsZSAocm93Q291bnQpIHtcbiAgICAgIHJvd0NvdW50LS07XG4gICAgICBzb3VyY2VSb3dJbmRleCA9IHRoaXMuaW5zdGFuY2Uud3RUYWJsZS5yb3dGaWx0ZXIucmVuZGVyZWRUb1NvdXJjZShyb3dDb3VudCk7XG4gICAgICBwcmV2aW91c1Jvd0hlaWdodCA9IHRoaXMuaW5zdGFuY2Uud3RUYWJsZS5nZXRSb3dIZWlnaHQoc291cmNlUm93SW5kZXgpO1xuICAgICAgY3VycmVudFRyID0gdGhpcy5pbnN0YW5jZS53dFRhYmxlLmdldFRyRm9yUm93KHNvdXJjZVJvd0luZGV4KTtcbiAgICAgIHJvd0hlYWRlciA9IGN1cnJlbnRUci5xdWVyeVNlbGVjdG9yKCd0aCcpO1xuXG4gICAgICBpZiAocm93SGVhZGVyKSB7XG4gICAgICAgIHJvd0lubmVySGVpZ2h0ID0gaW5uZXJIZWlnaHQocm93SGVhZGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvd0lubmVySGVpZ2h0ID0gaW5uZXJIZWlnaHQoY3VycmVudFRyKSAtIDE7XG4gICAgICB9XG5cbiAgICAgIGlmICgoIXByZXZpb3VzUm93SGVpZ2h0ICYmIHRoaXMuaW5zdGFuY2Uud3RTZXR0aW5ncy5zZXR0aW5ncy5kZWZhdWx0Um93SGVpZ2h0IDwgcm93SW5uZXJIZWlnaHQgfHxcbiAgICAgICAgICBwcmV2aW91c1Jvd0hlaWdodCA8IHJvd0lubmVySGVpZ2h0KSkge1xuICAgICAgICB0aGlzLmluc3RhbmNlLnd0Vmlld3BvcnQub3ZlcnNpemVkUm93c1tzb3VyY2VSb3dJbmRleF0gPSArK3Jvd0lubmVySGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbnkgb2YgdGhlIHJlbmRlcmVkIGNvbHVtbnMgaXMgd2lkZXIgdGhhbiBleHBlY3RlZCwgYW5kIGlmIHNvLCBjYWNoZSB0aGVtLlxuICAgKi9cbiAgbWFya092ZXJzaXplZENvbHVtbnMoKSB7XG4gICAgbGV0IG92ZXJsYXlOYW1lID0gdGhpcy53b3QuZ2V0T3ZlcmxheU5hbWUoKTtcblxuICAgIGlmICghdGhpcy5jb2x1bW5IZWFkZXJDb3VudCB8fCB0aGlzLndvdC53dFZpZXdwb3J0LmlzTWFya2VkT3ZlcnNpemVkQ29sdW1uW292ZXJsYXlOYW1lXSB8fCB0aGlzLnd0VGFibGUuaXNXb3JraW5nT25DbG9uZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjb2x1bW5Db3VudCA9IHRoaXMud3RUYWJsZS5nZXRSZW5kZXJlZENvbHVtbnNDb3VudCgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbHVtbkhlYWRlckNvdW50OyBpKyspIHtcbiAgICAgIGZvciAobGV0IHJlbmRlcmVkQ29sdW1uSW5kZXggPSAoLTEpICogdGhpcy5yb3dIZWFkZXJDb3VudDsgcmVuZGVyZWRDb2x1bW5JbmRleCA8IGNvbHVtbkNvdW50OyByZW5kZXJlZENvbHVtbkluZGV4KyspIHtcbiAgICAgICAgdGhpcy5tYXJrSWZPdmVyc2l6ZWRDb2x1bW5IZWFkZXIocmVuZGVyZWRDb2x1bW5JbmRleCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMud290Lnd0Vmlld3BvcnQuaXNNYXJrZWRPdmVyc2l6ZWRDb2x1bW5bb3ZlcmxheU5hbWVdID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKi9cbiAgYWRqdXN0Q29sdW1uSGVhZGVySGVpZ2h0cygpIHtcbiAgICBsZXQgY29sdW1uSGVhZGVycyA9IHRoaXMud290LmdldFNldHRpbmcoJ2NvbHVtbkhlYWRlcnMnKTtcbiAgICBsZXQgY2hpbGRzID0gdGhpcy53b3Qud3RUYWJsZS5USEVBRC5jaGlsZE5vZGVzO1xuICAgIGxldCBvdmVyc2l6ZWRDb2xzID0gdGhpcy53b3Qud3RWaWV3cG9ydC5vdmVyc2l6ZWRDb2x1bW5IZWFkZXJzO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNvbHVtbkhlYWRlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChvdmVyc2l6ZWRDb2xzW2ldKSB7XG4gICAgICAgIGlmIChjaGlsZHNbaV0uY2hpbGROb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRzW2ldLmNoaWxkTm9kZXNbMF0uc3R5bGUuaGVpZ2h0ID0gb3ZlcnNpemVkQ29sc1tpXSArICdweCc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGNvbHVtbiBoZWFkZXIgZm9yIHRoZSBzcGVjaWZpZWQgY29sdW1uIGlzIGhpZ2hlciB0aGFuIGV4cGVjdGVkLCBhbmQgaWYgc28sIGNhY2hlIGl0XG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb2wgSW5kZXggb2YgY29sdW1uXG4gICAqL1xuICBtYXJrSWZPdmVyc2l6ZWRDb2x1bW5IZWFkZXIoY29sKSB7XG4gICAgbGV0IHNvdXJjZUNvbEluZGV4ID0gdGhpcy53b3Qud3RUYWJsZS5jb2x1bW5GaWx0ZXIucmVuZGVyZWRUb1NvdXJjZShjb2wpO1xuICAgIGxldCBsZXZlbCA9IHRoaXMuY29sdW1uSGVhZGVyQ291bnQ7XG4gICAgbGV0IGRlZmF1bHRSb3dIZWlnaHQgPSB0aGlzLndvdC53dFNldHRpbmdzLnNldHRpbmdzLmRlZmF1bHRSb3dIZWlnaHQ7XG4gICAgbGV0IHByZXZpb3VzQ29sSGVhZGVySGVpZ2h0O1xuICAgIGxldCBjdXJyZW50SGVhZGVyO1xuICAgIGxldCBjdXJyZW50SGVhZGVySGVpZ2h0O1xuXG4gICAgd2hpbGUgKGxldmVsKSB7XG4gICAgICBsZXZlbC0tO1xuXG4gICAgICBwcmV2aW91c0NvbEhlYWRlckhlaWdodCA9IHRoaXMud290Lnd0VGFibGUuZ2V0Q29sdW1uSGVhZGVySGVpZ2h0KGxldmVsKTtcbiAgICAgIGN1cnJlbnRIZWFkZXIgPSB0aGlzLndvdC53dFRhYmxlLmdldENvbHVtbkhlYWRlcihzb3VyY2VDb2xJbmRleCwgbGV2ZWwpO1xuXG4gICAgICBpZiAoIWN1cnJlbnRIZWFkZXIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvL2N1cnJlbnRIZWFkZXJIZWlnaHQgPSBkZWZhdWx0Um93SGVpZ2h0O1xuICAgICAgY3VycmVudEhlYWRlckhlaWdodCA9IGlubmVySGVpZ2h0KGN1cnJlbnRIZWFkZXIpO1xuXG4gICAgICBpZiAoIXByZXZpb3VzQ29sSGVhZGVySGVpZ2h0ICYmIGRlZmF1bHRSb3dIZWlnaHQgPCBjdXJyZW50SGVhZGVySGVpZ2h0IHx8IHByZXZpb3VzQ29sSGVhZGVySGVpZ2h0IDwgY3VycmVudEhlYWRlckhlaWdodCkge1xuICAgICAgICB0aGlzLndvdC53dFZpZXdwb3J0Lm92ZXJzaXplZENvbHVtbkhlYWRlcnNbbGV2ZWxdID0gY3VycmVudEhlYWRlckhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNvdXJjZVJvd0luZGV4XG4gICAqIEBwYXJhbSB7SFRNTFRhYmxlUm93RWxlbWVudH0gVFJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbHVtbnNUb1JlbmRlclxuICAgKiBAcmV0dXJucyB7SFRNTFRhYmxlQ2VsbEVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJDZWxscyhzb3VyY2VSb3dJbmRleCwgVFIsIGNvbHVtbnNUb1JlbmRlcikge1xuICAgIGxldCBURDtcbiAgICBsZXQgc291cmNlQ29sSW5kZXg7XG5cbiAgICBmb3IgKGxldCB2aXNpYmxlQ29sSW5kZXggPSAwOyB2aXNpYmxlQ29sSW5kZXggPCBjb2x1bW5zVG9SZW5kZXI7IHZpc2libGVDb2xJbmRleCsrKSB7XG4gICAgICBzb3VyY2VDb2xJbmRleCA9IHRoaXMuY29sdW1uRmlsdGVyLnJlbmRlcmVkVG9Tb3VyY2UodmlzaWJsZUNvbEluZGV4KTtcblxuICAgICAgaWYgKHZpc2libGVDb2xJbmRleCA9PT0gMCkge1xuICAgICAgICBURCA9IFRSLmNoaWxkTm9kZXNbdGhpcy5jb2x1bW5GaWx0ZXIuc291cmNlQ29sdW1uVG9WaXNpYmxlUm93SGVhZGVkQ29sdW1uKHNvdXJjZUNvbEluZGV4KV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBURCA9IFRELm5leHRTaWJsaW5nOyAvL2h0dHA6Ly9qc3BlcmYuY29tL25leHRzaWJsaW5nLXZzLWluZGV4ZWQtY2hpbGRub2Rlc1xuICAgICAgfVxuICAgICAgLy8gSWYgdGhlIG51bWJlciBvZiBoZWFkZXJzIGhhcyBiZWVuIHJlZHVjZWQsIHdlIG5lZWQgdG8gcmVwbGFjZSBleGNlc3MgVEggd2l0aCBURFxuICAgICAgaWYgKFRELm5vZGVOYW1lID09ICdUSCcpIHtcbiAgICAgICAgVEQgPSByZXBsYWNlVGhXaXRoVGQoVEQsIFRSKTtcbiAgICAgIH1cbiAgICAgIGlmICghaGFzQ2xhc3MoVEQsICdoaWRlJykpIHtcbiAgICAgICAgVEQuY2xhc3NOYW1lID0gJyc7XG4gICAgICB9XG4gICAgICBURC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICB0aGlzLndvdC53dFNldHRpbmdzLnNldHRpbmdzLmNlbGxSZW5kZXJlcihzb3VyY2VSb3dJbmRleCwgc291cmNlQ29sSW5kZXgsIFREKTtcbiAgICB9XG5cbiAgICByZXR1cm4gVEQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbHVtbnNUb1JlbmRlclxuICAgKi9cbiAgYWRqdXN0Q29sdW1uV2lkdGhzKGNvbHVtbnNUb1JlbmRlcikge1xuICAgIGxldCBzY3JvbGxiYXJDb21wZW5zYXRpb24gPSAwO1xuICAgIGxldCBzb3VyY2VJbnN0YW5jZSA9IHRoaXMud290LmNsb25lU291cmNlID8gdGhpcy53b3QuY2xvbmVTb3VyY2UgOiB0aGlzLndvdDtcbiAgICBsZXQgbWFpbkhvbGRlciA9IHNvdXJjZUluc3RhbmNlLnd0VGFibGUuaG9sZGVyO1xuXG4gICAgaWYgKG1haW5Ib2xkZXIub2Zmc2V0SGVpZ2h0IDwgbWFpbkhvbGRlci5zY3JvbGxIZWlnaHQpIHtcbiAgICAgIHNjcm9sbGJhckNvbXBlbnNhdGlvbiA9IGdldFNjcm9sbGJhcldpZHRoKCk7XG4gICAgfVxuICAgIHRoaXMud290Lnd0Vmlld3BvcnQuY29sdW1uc1JlbmRlckNhbGN1bGF0b3IucmVmcmVzaFN0cmV0Y2hpbmcodGhpcy53b3Qud3RWaWV3cG9ydC5nZXRWaWV3cG9ydFdpZHRoKCkgLSBzY3JvbGxiYXJDb21wZW5zYXRpb24pO1xuXG4gICAgZm9yIChsZXQgcmVuZGVyZWRDb2xJbmRleCA9IDA7IHJlbmRlcmVkQ29sSW5kZXggPCBjb2x1bW5zVG9SZW5kZXI7IHJlbmRlcmVkQ29sSW5kZXgrKykge1xuICAgICAgbGV0IHdpZHRoID0gdGhpcy53dFRhYmxlLmdldFN0cmV0Y2hlZENvbHVtbldpZHRoKHRoaXMuY29sdW1uRmlsdGVyLnJlbmRlcmVkVG9Tb3VyY2UocmVuZGVyZWRDb2xJbmRleCkpO1xuICAgICAgdGhpcy5DT0xHUk9VUC5jaGlsZE5vZGVzW3JlbmRlcmVkQ29sSW5kZXggKyB0aGlzLnJvd0hlYWRlckNvdW50XS5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MVGFibGVDZWxsRWxlbWVudH0gVFJcbiAgICovXG4gIGFwcGVuZFRvVGJvZHkoVFIpIHtcbiAgICB0aGlzLlRCT0RZLmFwcGVuZENoaWxkKFRSKTtcbiAgICB0aGlzLnd0VGFibGUudGJvZHlDaGlsZHJlbkxlbmd0aCsrO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByb3dJbmRleFxuICAgKiBAcGFyYW0ge0hUTUxUYWJsZVJvd0VsZW1lbnR9IGN1cnJlbnRUclxuICAgKiBAcmV0dXJucyB7SFRNTFRhYmxlQ2VsbEVsZW1lbnR9XG4gICAqL1xuICBnZXRPckNyZWF0ZVRyRm9yUm93KHJvd0luZGV4LCBjdXJyZW50VHIpIHtcbiAgICBsZXQgVFI7XG5cbiAgICBpZiAocm93SW5kZXggPj0gdGhpcy53dFRhYmxlLnRib2R5Q2hpbGRyZW5MZW5ndGgpIHtcbiAgICAgIFRSID0gdGhpcy5jcmVhdGVSb3coKTtcbiAgICAgIHRoaXMuYXBwZW5kVG9UYm9keShUUik7XG5cbiAgICB9IGVsc2UgaWYgKHJvd0luZGV4ID09PSAwKSB7XG4gICAgICBUUiA9IHRoaXMuVEJPRFkuZmlyc3RDaGlsZDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBodHRwOi8vanNwZXJmLmNvbS9uZXh0c2libGluZy12cy1pbmRleGVkLWNoaWxkbm9kZXNcbiAgICAgIFRSID0gY3VycmVudFRyLm5leHRTaWJsaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBUUjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTFRhYmxlQ2VsbEVsZW1lbnR9XG4gICAqL1xuICBjcmVhdGVSb3coKSB7XG4gICAgbGV0IFRSID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnVFInKTtcblxuICAgIGZvciAobGV0IHZpc2libGVDb2xJbmRleCA9IDA7IHZpc2libGVDb2xJbmRleCA8IHRoaXMucm93SGVhZGVyQ291bnQ7IHZpc2libGVDb2xJbmRleCsrKSB7XG4gICAgICBUUi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdUSCcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gVFI7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJvd1xuICAgKiBAcGFyYW0ge051bWJlcn0gY29sXG4gICAqIEBwYXJhbSB7SFRNTFRhYmxlQ2VsbEVsZW1lbnR9IFRIXG4gICAqL1xuICByZW5kZXJSb3dIZWFkZXIocm93LCBjb2wsIFRIKSB7XG4gICAgVEguY2xhc3NOYW1lID0gJyc7XG4gICAgVEgucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgIHRoaXMucm93SGVhZGVyc1tjb2xdKHJvdywgVEgsIGNvbCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJvd1xuICAgKiBAcGFyYW0ge0hUTUxUYWJsZUNlbGxFbGVtZW50fSBUUlxuICAgKi9cbiAgcmVuZGVyUm93SGVhZGVycyhyb3csIFRSKSB7XG4gICAgZm9yIChsZXQgVEggPSBUUi5maXJzdENoaWxkLCB2aXNpYmxlQ29sSW5kZXggPSAwOyB2aXNpYmxlQ29sSW5kZXggPCB0aGlzLnJvd0hlYWRlckNvdW50OyB2aXNpYmxlQ29sSW5kZXgrKykge1xuICAgICAgLy8gSWYgdGhlIG51bWJlciBvZiByb3cgaGVhZGVycyBpbmNyZWFzZWQgd2UgbmVlZCB0byBjcmVhdGUgVEggb3IgcmVwbGFjZSBhbiBleGlzdGluZyBURCBub2RlIHdpdGggVEhcbiAgICAgIGlmICghVEgpIHtcbiAgICAgICAgVEggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdUSCcpO1xuICAgICAgICBUUi5hcHBlbmRDaGlsZChUSCk7XG5cbiAgICAgIH0gZWxzZSBpZiAoVEgubm9kZU5hbWUgPT0gJ1REJykge1xuICAgICAgICBUSCA9IHJlcGxhY2VUZFdpdGhUaChUSCwgVFIpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJSb3dIZWFkZXIocm93LCB2aXNpYmxlQ29sSW5kZXgsIFRIKTtcbiAgICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL25leHRzaWJsaW5nLXZzLWluZGV4ZWQtY2hpbGRub2Rlc1xuICAgICAgVEggPSBUSC5uZXh0U2libGluZztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRqdXN0IHRoZSBudW1iZXIgb2YgQ09MIGFuZCBUSCBlbGVtZW50cyB0byBtYXRjaCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgYW5kIGhlYWRlcnMgdGhhdCBuZWVkIHRvIGJlIHJlbmRlcmVkXG4gICAqL1xuICBhZGp1c3RBdmFpbGFibGVOb2RlcygpIHtcbiAgICB0aGlzLmFkanVzdENvbEdyb3VwcygpO1xuICAgIHRoaXMuYWRqdXN0VGhlYWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjb2x1bW4gaGVhZGVyc1xuICAgKi9cbiAgcmVuZGVyQ29sdW1uSGVhZGVycygpIHtcbiAgICBsZXQgb3ZlcmxheU5hbWUgPSB0aGlzLndvdC5nZXRPdmVybGF5TmFtZSgpO1xuXG4gICAgaWYgKCF0aGlzLmNvbHVtbkhlYWRlckNvdW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjb2x1bW5Db3VudCA9IHRoaXMud3RUYWJsZS5nZXRSZW5kZXJlZENvbHVtbnNDb3VudCgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbHVtbkhlYWRlckNvdW50OyBpKyspIHtcbiAgICAgIGxldCBUUiA9IHRoaXMuZ2V0VHJGb3JDb2x1bW5IZWFkZXJzKGkpO1xuXG4gICAgICBmb3IgKGxldCByZW5kZXJlZENvbHVtbkluZGV4ID0gKC0xKSAqIHRoaXMucm93SGVhZGVyQ291bnQ7IHJlbmRlcmVkQ29sdW1uSW5kZXggPCBjb2x1bW5Db3VudDsgcmVuZGVyZWRDb2x1bW5JbmRleCsrKSB7XG4gICAgICAgIGxldCBzb3VyY2VDb2wgPSB0aGlzLmNvbHVtbkZpbHRlci5yZW5kZXJlZFRvU291cmNlKHJlbmRlcmVkQ29sdW1uSW5kZXgpO1xuXG4gICAgICAgIHRoaXMucmVuZGVyQ29sdW1uSGVhZGVyKGksIHNvdXJjZUNvbCwgVFIuY2hpbGROb2Rlc1tyZW5kZXJlZENvbHVtbkluZGV4ICsgdGhpcy5yb3dIZWFkZXJDb3VudF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGp1c3RzIHRoZSBudW1iZXIgb2YgQ09MIGVsZW1lbnRzIHRvIG1hdGNoIHRoZSBudW1iZXIgb2YgY29sdW1ucyB0aGF0IG5lZWQgdG8gYmUgcmVuZGVyZWRcbiAgICovXG4gIGFkanVzdENvbEdyb3VwcygpIHtcbiAgICBsZXQgY29sdW1uQ291bnQgPSB0aGlzLnd0VGFibGUuZ2V0UmVuZGVyZWRDb2x1bW5zQ291bnQoKTtcblxuICAgIHdoaWxlICh0aGlzLnd0VGFibGUuY29sZ3JvdXBDaGlsZHJlbkxlbmd0aCA8IGNvbHVtbkNvdW50ICsgdGhpcy5yb3dIZWFkZXJDb3VudCkge1xuICAgICAgdGhpcy5DT0xHUk9VUC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdDT0wnKSk7XG4gICAgICB0aGlzLnd0VGFibGUuY29sZ3JvdXBDaGlsZHJlbkxlbmd0aCsrO1xuICAgIH1cbiAgICB3aGlsZSAodGhpcy53dFRhYmxlLmNvbGdyb3VwQ2hpbGRyZW5MZW5ndGggPiBjb2x1bW5Db3VudCArIHRoaXMucm93SGVhZGVyQ291bnQpIHtcbiAgICAgIHRoaXMuQ09MR1JPVVAucmVtb3ZlQ2hpbGQodGhpcy5DT0xHUk9VUC5sYXN0Q2hpbGQpO1xuICAgICAgdGhpcy53dFRhYmxlLmNvbGdyb3VwQ2hpbGRyZW5MZW5ndGgtLTtcbiAgICB9XG4gICAgaWYgKHRoaXMucm93SGVhZGVyQ291bnQpIHtcbiAgICAgIGFkZENsYXNzKHRoaXMuQ09MR1JPVVAuY2hpbGROb2Rlc1swXSwgJ3Jvd0hlYWRlcicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGp1c3RzIHRoZSBudW1iZXIgb2YgVEggZWxlbWVudHMgaW4gVEhFQUQgdG8gbWF0Y2ggdGhlIG51bWJlciBvZiBoZWFkZXJzIGFuZCBjb2x1bW5zIHRoYXQgbmVlZCB0byBiZSByZW5kZXJlZFxuICAgKi9cbiAgYWRqdXN0VGhlYWQoKSB7XG4gICAgbGV0IGNvbHVtbkNvdW50ID0gdGhpcy53dFRhYmxlLmdldFJlbmRlcmVkQ29sdW1uc0NvdW50KCk7XG4gICAgbGV0IFRSID0gdGhpcy5USEVBRC5maXJzdENoaWxkO1xuXG4gICAgaWYgKHRoaXMuY29sdW1uSGVhZGVycy5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLmNvbHVtbkhlYWRlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgVFIgPSB0aGlzLlRIRUFELmNoaWxkTm9kZXNbaV07XG5cbiAgICAgICAgaWYgKCFUUikge1xuICAgICAgICAgIFRSID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnVFInKTtcbiAgICAgICAgICB0aGlzLlRIRUFELmFwcGVuZENoaWxkKFRSKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRoZWFkQ2hpbGRyZW5MZW5ndGggPSBUUi5jaGlsZE5vZGVzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAodGhpcy50aGVhZENoaWxkcmVuTGVuZ3RoIDwgY29sdW1uQ291bnQgKyB0aGlzLnJvd0hlYWRlckNvdW50KSB7XG4gICAgICAgICAgVFIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnVEgnKSk7XG4gICAgICAgICAgdGhpcy50aGVhZENoaWxkcmVuTGVuZ3RoKys7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMudGhlYWRDaGlsZHJlbkxlbmd0aCA+IGNvbHVtbkNvdW50ICsgdGhpcy5yb3dIZWFkZXJDb3VudCkge1xuICAgICAgICAgIFRSLnJlbW92ZUNoaWxkKFRSLmxhc3RDaGlsZCk7XG4gICAgICAgICAgdGhpcy50aGVhZENoaWxkcmVuTGVuZ3RoLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCB0aGVhZENoaWxkcmVuTGVuZ3RoID0gdGhpcy5USEVBRC5jaGlsZE5vZGVzLmxlbmd0aDtcblxuICAgICAgaWYgKHRoZWFkQ2hpbGRyZW5MZW5ndGggPiB0aGlzLmNvbHVtbkhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmNvbHVtbkhlYWRlcnMubGVuZ3RoOyBpIDwgdGhlYWRDaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5USEVBRC5yZW1vdmVDaGlsZCh0aGlzLlRIRUFELmxhc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFRSKSB7XG4gICAgICBlbXB0eShUUik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcmV0dXJucyB7SFRNTFRhYmxlQ2VsbEVsZW1lbnR9XG4gICAqL1xuICBnZXRUckZvckNvbHVtbkhlYWRlcnMoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5USEVBRC5jaGlsZE5vZGVzW2luZGV4XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gcm93XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb2xcbiAgICogQHBhcmFtIHtIVE1MVGFibGVDZWxsRWxlbWVudH0gVEhcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICByZW5kZXJDb2x1bW5IZWFkZXIocm93LCBjb2wsIFRIKSB7XG4gICAgVEguY2xhc3NOYW1lID0gJyc7XG4gICAgVEgucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuXG4gICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyc1tyb3ddKGNvbCwgVEgsIHJvdyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGFuZC9vciByZW1vdmUgdGhlIFREcyB0byBtYXRjaCB0aGUgZGVzaXJlZCBudW1iZXJcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MVGFibGVDZWxsRWxlbWVudH0gVFIgVGFibGUgcm93IGluIHF1ZXN0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZXNpcmVkQ291bnQgVGhlIGRlc2lyZWQgbnVtYmVyIG9mIFREcyBpbiB0aGUgVFJcbiAgICovXG4gIGFkanVzdENvbHVtbnMoVFIsIGRlc2lyZWRDb3VudCkge1xuICAgIGxldCBjb3VudCA9IFRSLmNoaWxkTm9kZXMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGNvdW50IDwgZGVzaXJlZENvdW50KSB7XG4gICAgICBsZXQgVEQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdURCcpO1xuXG4gICAgICBUUi5hcHBlbmRDaGlsZChURCk7XG4gICAgICBjb3VudCsrO1xuICAgIH1cbiAgICB3aGlsZSAoY291bnQgPiBkZXNpcmVkQ291bnQpIHtcbiAgICAgIFRSLnJlbW92ZUNoaWxkKFRSLmxhc3RDaGlsZCk7XG4gICAgICBjb3VudC0tO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gY29sdW1uc1RvUmVuZGVyXG4gICAqL1xuICByZW1vdmVSZWR1bmRhbnRDb2x1bW5zKGNvbHVtbnNUb1JlbmRlcikge1xuICAgIHdoaWxlICh0aGlzLnd0VGFibGUudGJvZHlDaGlsZHJlbkxlbmd0aCA+IGNvbHVtbnNUb1JlbmRlcikge1xuICAgICAgdGhpcy5UQk9EWS5yZW1vdmVDaGlsZCh0aGlzLlRCT0RZLmxhc3RDaGlsZCk7XG4gICAgICB0aGlzLnd0VGFibGUudGJvZHlDaGlsZHJlbkxlbmd0aC0tO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlVGRXaXRoVGgoVEQsIFRSKSB7XG4gIGxldCBUSCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ1RIJyk7XG5cbiAgVFIuaW5zZXJ0QmVmb3JlKFRILCBURCk7XG4gIFRSLnJlbW92ZUNoaWxkKFREKTtcblxuICByZXR1cm4gVEg7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VUaFdpdGhUZChUSCwgVFIpIHtcbiAgbGV0IFREID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnVEQnKTtcblxuICBUUi5pbnNlcnRCZWZvcmUoVEQsIFRIKTtcbiAgVFIucmVtb3ZlQ2hpbGQoVEgpO1xuXG4gIHJldHVybiBURDtcbn1cblxuZXhwb3J0IHtXYWxrb250YWJsZVRhYmxlUmVuZGVyZXJ9O1xuXG53aW5kb3cuV2Fsa29udGFibGVUYWJsZVJlbmRlcmVyID0gV2Fsa29udGFibGVUYWJsZVJlbmRlcmVyO1xuIiwiXG5pbXBvcnQge1xuICBnZXRTY3JvbGxiYXJXaWR0aCxcbiAgZ2V0U2Nyb2xsVG9wLFxuICBnZXRTdHlsZSxcbiAgb2Zmc2V0LFxuICBvdXRlckhlaWdodCxcbiAgb3V0ZXJXaWR0aCxcbiAgICB9IGZyb20gJy4vLi4vLi4vLi4vaGVscGVycy9kb20vZWxlbWVudCc7XG5pbXBvcnQge0V2ZW50TWFuYWdlcn0gZnJvbSAnLi8uLi8uLi8uLi9ldmVudE1hbmFnZXInO1xuaW1wb3J0IHtXYWxrb250YWJsZVZpZXdwb3J0Q29sdW1uc0NhbGN1bGF0b3J9IGZyb20gJy4vY2FsY3VsYXRvci92aWV3cG9ydENvbHVtbnMnO1xuaW1wb3J0IHtXYWxrb250YWJsZVZpZXdwb3J0Um93c0NhbGN1bGF0b3J9IGZyb20gJy4vY2FsY3VsYXRvci92aWV3cG9ydFJvd3MnO1xuXG5cbi8qKlxuICogQGNsYXNzIFdhbGtvbnRhYmxlVmlld3BvcnRcbiAqL1xuY2xhc3MgV2Fsa29udGFibGVWaWV3cG9ydCB7XG4gIC8qKlxuICAgKiBAcGFyYW0gd290SW5zdGFuY2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdvdEluc3RhbmNlKSB7XG4gICAgdGhpcy53b3QgPSB3b3RJbnN0YW5jZTtcblxuICAgIC8vIGxlZ2FjeSBzdXBwb3J0XG4gICAgdGhpcy5pbnN0YW5jZSA9IHRoaXMud290O1xuXG4gICAgdGhpcy5vdmVyc2l6ZWRSb3dzID0gW107XG4gICAgdGhpcy5vdmVyc2l6ZWRDb2x1bW5IZWFkZXJzID0gW107XG4gICAgdGhpcy5pc01hcmtlZE92ZXJzaXplZENvbHVtbiA9IHt9O1xuICAgIHRoaXMuY2xpZW50SGVpZ2h0ID0gMDtcbiAgICB0aGlzLmNvbnRhaW5lcldpZHRoID0gTmFOO1xuICAgIHRoaXMucm93SGVhZGVyV2lkdGggPSBOYU47XG4gICAgdGhpcy5yb3dzVmlzaWJsZUNhbGN1bGF0b3IgPSBudWxsO1xuICAgIHRoaXMuY29sdW1uc1Zpc2libGVDYWxjdWxhdG9yID0gbnVsbDtcblxuICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gbmV3IEV2ZW50TWFuYWdlcih0aGlzLndvdCk7XG4gICAgdGhpcy5ldmVudE1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csICdyZXNpemUnLCAoKSA9PiB7XG4gICAgICB0aGlzLmNsaWVudEhlaWdodCA9IHRoaXMuZ2V0V29ya3NwYWNlSGVpZ2h0KCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGdldFdvcmtzcGFjZUhlaWdodCgpIHtcbiAgICAvLyB2YXIgc2Nyb2xsSGFuZGxlciA9IHRoaXMuaW5zdGFuY2Uud3RPdmVybGF5cy50b3BPdmVybGF5LnNjcm9sbEhhbmRsZXI7XG4gICAgbGV0IHRyaW1taW5nQ29udGFpbmVyID0gdGhpcy5pbnN0YW5jZS53dE92ZXJsYXlzLnRvcE92ZXJsYXkudHJpbW1pbmdDb250YWluZXI7XG4gICAgbGV0IGVsZW1IZWlnaHQ7XG4gICAgbGV0IGhlaWdodCA9IDA7XG5cbiAgICBpZiAodHJpbW1pbmdDb250YWluZXIgPT09IHdpbmRvdykge1xuICAgICAgaGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcblxuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtSGVpZ2h0ID0gb3V0ZXJIZWlnaHQodHJpbW1pbmdDb250YWluZXIpO1xuICAgICAgLy8gcmV0dXJucyBoZWlnaHQgd2l0aG91dCBESVYgc2Nyb2xsYmFyXG4gICAgICBoZWlnaHQgPSAoZWxlbUhlaWdodCA+IDAgJiYgdHJpbW1pbmdDb250YWluZXIuY2xpZW50SGVpZ2h0ID4gMCkgPyB0cmltbWluZ0NvbnRhaW5lci5jbGllbnRIZWlnaHQgOiBJbmZpbml0eTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGVpZ2h0O1xuICB9XG5cbiAgZ2V0V29ya3NwYWNlV2lkdGgoKSB7XG4gICAgbGV0IHdpZHRoO1xuICAgIGxldCB0b3RhbENvbHVtbnMgPSB0aGlzLmluc3RhbmNlLmdldFNldHRpbmcoXCJ0b3RhbENvbHVtbnNcIik7XG4gICAgbGV0IHRyaW1taW5nQ29udGFpbmVyID0gdGhpcy5pbnN0YW5jZS53dE92ZXJsYXlzLmxlZnRPdmVybGF5LnRyaW1taW5nQ29udGFpbmVyO1xuICAgIGxldCBvdmVyZmxvdztcbiAgICBsZXQgc3RyZXRjaFNldHRpbmcgPSB0aGlzLmluc3RhbmNlLmdldFNldHRpbmcoJ3N0cmV0Y2hIJyk7XG4gICAgbGV0IGRvY09mZnNldFdpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldFdpZHRoO1xuXG4gICAgaWYgKEhhbmRzb250YWJsZS5mcmVlemVPdmVybGF5cykge1xuICAgICAgd2lkdGggPSBNYXRoLm1pbihkb2NPZmZzZXRXaWR0aCAtIHRoaXMuZ2V0V29ya3NwYWNlT2Zmc2V0KCkubGVmdCwgZG9jT2Zmc2V0V2lkdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aCA9IE1hdGgubWluKHRoaXMuZ2V0Q29udGFpbmVyRmlsbFdpZHRoKCksIGRvY09mZnNldFdpZHRoIC0gdGhpcy5nZXRXb3Jrc3BhY2VPZmZzZXQoKS5sZWZ0LCBkb2NPZmZzZXRXaWR0aCk7XG4gICAgfVxuXG4gICAgaWYgKHRyaW1taW5nQ29udGFpbmVyID09PSB3aW5kb3cgJiYgdG90YWxDb2x1bW5zID4gMCAmJiB0aGlzLnN1bUNvbHVtbldpZHRocygwLCB0b3RhbENvbHVtbnMgLSAxKSA+IHdpZHRoKSB7XG4gICAgICAvLyBpbiBjYXNlIHN1bSBvZiBjb2x1bW4gd2lkdGhzIGlzIGhpZ2hlciB0aGFuIGF2YWlsYWJsZSBzdHlsZXNoZWV0IHdpZHRoLCBsZXQncyBhc3N1bWUgdXNpbmcgdGhlIHdob2xlIHdpbmRvd1xuICAgICAgLy8gb3RoZXJ3aXNlIGNvbnRpbnVlIGJlbG93LCB3aGljaCB3aWxsIGFsbG93IHN0cmV0Y2hpbmdcbiAgICAgIC8vIHRoaXMgaXMgdXNlZCBpbiBgc2Nyb2xsX3dpbmRvdy5odG1sYFxuICAgICAgLy8gVE9ETyB0ZXN0IG1lXG4gICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIH1cblxuICAgIGlmICh0cmltbWluZ0NvbnRhaW5lciAhPT0gd2luZG93KSB7XG4gICAgICBvdmVyZmxvdyA9IGdldFN0eWxlKHRoaXMuaW5zdGFuY2Uud3RPdmVybGF5cy5sZWZ0T3ZlcmxheS50cmltbWluZ0NvbnRhaW5lciwgJ292ZXJmbG93Jyk7XG5cbiAgICAgIGlmIChvdmVyZmxvdyA9PSBcInNjcm9sbFwiIHx8IG92ZXJmbG93ID09IFwiaGlkZGVuXCIgfHwgb3ZlcmZsb3cgPT0gXCJhdXRvXCIpIHtcbiAgICAgICAgLy8gdGhpcyBpcyB1c2VkIGluIGBzY3JvbGwuaHRtbGBcbiAgICAgICAgLy8gVE9ETyB0ZXN0IG1lXG4gICAgICAgIHJldHVybiBNYXRoLm1heCh3aWR0aCwgdHJpbW1pbmdDb250YWluZXIuY2xpZW50V2lkdGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHJldGNoU2V0dGluZyA9PT0gJ25vbmUnIHx8ICFzdHJldGNoU2V0dGluZykge1xuICAgICAgLy8gaWYgbm8gc3RyZXRjaGluZyBpcyB1c2VkLCByZXR1cm4gdGhlIG1heGltdW0gdXNlZCB3b3Jrc3BhY2Ugd2lkdGhcbiAgICAgIHJldHVybiBNYXRoLm1heCh3aWR0aCwgb3V0ZXJXaWR0aCh0aGlzLmluc3RhbmNlLnd0VGFibGUuVEFCTEUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgc3RyZXRjaGluZyBpcyB1c2VkLCByZXR1cm4gdGhlIGFjdHVhbCBjb250YWluZXIgd2lkdGgsIHNvIHRoZSBjb2x1bW5zIGNhbiBmaXQgaW5zaWRlIGl0XG4gICAgICByZXR1cm4gd2lkdGg7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB2aWV3cG9ydCBoYXMgdmVydGljYWwgc2Nyb2xsXG4gICAqXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgaGFzVmVydGljYWxTY3JvbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0V29ya3NwYWNlQWN0dWFsSGVpZ2h0KCkgPiB0aGlzLmdldFdvcmtzcGFjZUhlaWdodCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB2aWV3cG9ydCBoYXMgaG9yaXpvbnRhbCBzY3JvbGxcbiAgICpcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBoYXNIb3Jpem9udGFsU2Nyb2xsKCkge1xuICAgIHJldHVybiB0aGlzLmdldFdvcmtzcGFjZUFjdHVhbFdpZHRoKCkgPiB0aGlzLmdldFdvcmtzcGFjZVdpZHRoKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGZyb21cbiAgICogQHBhcmFtIGxlbmd0aFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgc3VtQ29sdW1uV2lkdGhzKGZyb20sIGxlbmd0aCkge1xuICAgIGxldCBzdW0gPSAwO1xuXG4gICAgd2hpbGUgKGZyb20gPCBsZW5ndGgpIHtcbiAgICAgIHN1bSArPSB0aGlzLndvdC53dFRhYmxlLmdldENvbHVtbldpZHRoKGZyb20pO1xuICAgICAgZnJvbSArKztcbiAgICB9XG5cbiAgICByZXR1cm4gc3VtO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRDb250YWluZXJGaWxsV2lkdGgoKSB7XG4gICAgaWYgKHRoaXMuY29udGFpbmVyV2lkdGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcldpZHRoO1xuICAgIH1cbiAgICBsZXQgbWFpbkNvbnRhaW5lciA9IHRoaXMuaW5zdGFuY2Uud3RUYWJsZS5ob2xkZXI7XG4gICAgbGV0IGZpbGxXaWR0aDtcbiAgICBsZXQgZHVtbXlFbGVtZW50O1xuXG4gICAgZHVtbXlFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtcbiAgICBkdW1teUVsZW1lbnQuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICBkdW1teUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gXCIxcHhcIjtcbiAgICBtYWluQ29udGFpbmVyLmFwcGVuZENoaWxkKGR1bW15RWxlbWVudCk7XG4gICAgZmlsbFdpZHRoID0gZHVtbXlFbGVtZW50Lm9mZnNldFdpZHRoO1xuXG4gICAgdGhpcy5jb250YWluZXJXaWR0aCA9IGZpbGxXaWR0aDtcbiAgICBtYWluQ29udGFpbmVyLnJlbW92ZUNoaWxkKGR1bW15RWxlbWVudCk7XG5cbiAgICByZXR1cm4gZmlsbFdpZHRoO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRXb3Jrc3BhY2VPZmZzZXQoKSB7XG4gICAgcmV0dXJuIG9mZnNldCh0aGlzLndvdC53dFRhYmxlLlRBQkxFKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0V29ya3NwYWNlQWN0dWFsSGVpZ2h0KCkge1xuICAgIHJldHVybiBvdXRlckhlaWdodCh0aGlzLndvdC53dFRhYmxlLlRBQkxFKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0V29ya3NwYWNlQWN0dWFsV2lkdGgoKSB7XG4gICAgcmV0dXJuIG91dGVyV2lkdGgodGhpcy53b3Qud3RUYWJsZS5UQUJMRSkgfHxcbiAgICAgIG91dGVyV2lkdGgodGhpcy53b3Qud3RUYWJsZS5UQk9EWSkgfHxcbiAgICAgIG91dGVyV2lkdGgodGhpcy53b3Qud3RUYWJsZS5USEVBRCk7IC8vSUU4IHJlcG9ydHMgMCBhcyA8dGFibGU+IG9mZnNldFdpZHRoO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuICBnZXRDb2x1bW5IZWFkZXJIZWlnaHQoKSB7XG4gICAgaWYgKGlzTmFOKHRoaXMuY29sdW1uSGVhZGVySGVpZ2h0KSkge1xuICAgICAgdGhpcy5jb2x1bW5IZWFkZXJIZWlnaHQgPSBvdXRlckhlaWdodCh0aGlzLndvdC53dFRhYmxlLlRIRUFEKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJIZWlnaHQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG4gIGdldFZpZXdwb3J0SGVpZ2h0KCkge1xuICAgIGxldCBjb250YWluZXJIZWlnaHQgPSB0aGlzLmdldFdvcmtzcGFjZUhlaWdodCgpO1xuICAgIGxldCBjb2x1bW5IZWFkZXJIZWlnaHQ7XG5cbiAgICBpZiAoY29udGFpbmVySGVpZ2h0ID09PSBJbmZpbml0eSkge1xuICAgICAgcmV0dXJuIGNvbnRhaW5lckhlaWdodDtcbiAgICB9XG4gICAgY29sdW1uSGVhZGVySGVpZ2h0ID0gdGhpcy5nZXRDb2x1bW5IZWFkZXJIZWlnaHQoKTtcblxuICAgIGlmIChjb2x1bW5IZWFkZXJIZWlnaHQgPiAwKSB7XG4gICAgICBjb250YWluZXJIZWlnaHQgLT0gY29sdW1uSGVhZGVySGVpZ2h0O1xuICAgIH1cblxuICAgIHJldHVybiBjb250YWluZXJIZWlnaHQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG4gIGdldFJvd0hlYWRlcldpZHRoKCkge1xuICAgIGlmICh0aGlzLndvdC5jbG9uZVNvdXJjZSkge1xuICAgICAgcmV0dXJuIHRoaXMud290LmNsb25lU291cmNlLnd0Vmlld3BvcnQuZ2V0Um93SGVhZGVyV2lkdGgoKTtcbiAgICB9XG4gICAgaWYgKGlzTmFOKHRoaXMucm93SGVhZGVyV2lkdGgpKSB7XG4gICAgICBsZXQgcm93SGVhZGVycyA9IHRoaXMuaW5zdGFuY2UuZ2V0U2V0dGluZygncm93SGVhZGVycycpO1xuXG4gICAgICBpZiAocm93SGVhZGVycy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IFRIID0gdGhpcy5pbnN0YW5jZS53dFRhYmxlLlRBQkxFLnF1ZXJ5U2VsZWN0b3IoJ1RIJyk7XG4gICAgICAgIHRoaXMucm93SGVhZGVyV2lkdGggPSAwO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSByb3dIZWFkZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKFRIKSB7XG4gICAgICAgICAgICB0aGlzLnJvd0hlYWRlcldpZHRoICs9IG91dGVyV2lkdGgoVEgpO1xuICAgICAgICAgICAgVEggPSBUSC5uZXh0U2libGluZztcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB5ZXMgdGhpcyBpcyBhIGNoZWF0IGJ1dCBpdCB3b3JrZWQgbGlrZSB0aGF0IGJlZm9yZSwganVzdCB0YWtpbmcgYXNzdW1wdGlvbiBmcm9tIENTUyBpbnN0ZWFkIG9mIG1lYXN1cmluZy5cbiAgICAgICAgICAgIC8vIFRPRE86IHByb3BlciBmaXhcbiAgICAgICAgICAgIHRoaXMucm93SGVhZGVyV2lkdGggKz0gNTA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJvd0hlYWRlcldpZHRoID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yb3dIZWFkZXJXaWR0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0Vmlld3BvcnRXaWR0aCgpIHtcbiAgICBsZXQgY29udGFpbmVyV2lkdGggPSB0aGlzLmdldFdvcmtzcGFjZVdpZHRoKCk7XG4gICAgbGV0IHJvd0hlYWRlcldpZHRoO1xuXG4gICAgaWYgKGNvbnRhaW5lcldpZHRoID09PSBJbmZpbml0eSkge1xuICAgICAgcmV0dXJuIGNvbnRhaW5lcldpZHRoO1xuICAgIH1cbiAgICByb3dIZWFkZXJXaWR0aCA9IHRoaXMuZ2V0Um93SGVhZGVyV2lkdGgoKTtcblxuICAgIGlmIChyb3dIZWFkZXJXaWR0aCA+IDApIHtcbiAgICAgIHJldHVybiBjb250YWluZXJXaWR0aCAtIHJvd0hlYWRlcldpZHRoO1xuICAgIH1cblxuICAgIHJldHVybiBjb250YWluZXJXaWR0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzOlxuICAgKiAgLSByb3dzUmVuZGVyQ2FsY3VsYXRvciAoYmVmb3JlIGRyYXcsIHRvIHF1YWxpZnkgcm93cyBmb3IgcmVuZGVyaW5nKVxuICAgKiAgLSByb3dzVmlzaWJsZUNhbGN1bGF0b3IgKGFmdGVyIGRyYXcsIHRvIG1lYXN1cmUgd2hpY2ggcm93cyBhcmUgYWN0dWFsbHkgdmlzaWJsZSlcbiAgICpcbiAgICogQHJldHVybnMge1dhbGtvbnRhYmxlVmlld3BvcnRSb3dzQ2FsY3VsYXRvcn1cbiAgICovXG4gIGNyZWF0ZVJvd3NDYWxjdWxhdG9yKHZpc2libGUgPSBmYWxzZSkge1xuICAgIGxldCBoZWlnaHQ7XG4gICAgbGV0IHBvcztcbiAgICBsZXQgZml4ZWRSb3dzVG9wO1xuICAgIGxldCBzY3JvbGxiYXJIZWlnaHQ7XG5cbiAgICB0aGlzLnJvd0hlYWRlcldpZHRoID0gTmFOO1xuXG4gICAgaWYgKHRoaXMud290Lnd0U2V0dGluZ3Muc2V0dGluZ3MucmVuZGVyQWxsUm93cykge1xuICAgICAgaGVpZ2h0ID0gSW5maW5pdHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlaWdodCA9IHRoaXMuZ2V0Vmlld3BvcnRIZWlnaHQoKTtcbiAgICB9XG4gICAgcG9zID0gZ2V0U2Nyb2xsVG9wKHRoaXMud290Lnd0T3ZlcmxheXMubWFpblRhYmxlU2Nyb2xsYWJsZUVsZW1lbnQpIC0gdGhpcy53b3Qud3RPdmVybGF5cy50b3BPdmVybGF5LmdldFRhYmxlUGFyZW50T2Zmc2V0KCk7XG5cbiAgICBpZiAocG9zIDwgMCkge1xuICAgICAgcG9zID0gMDtcbiAgICB9XG4gICAgZml4ZWRSb3dzVG9wID0gdGhpcy53b3QuZ2V0U2V0dGluZygnZml4ZWRSb3dzVG9wJyk7XG5cbiAgICBpZiAoZml4ZWRSb3dzVG9wKSB7XG4gICAgICBsZXQgZml4ZWRSb3dzSGVpZ2h0ID0gdGhpcy53b3Qud3RPdmVybGF5cy50b3BPdmVybGF5LnN1bUNlbGxTaXplcygwLCBmaXhlZFJvd3NUb3ApO1xuICAgICAgcG9zICs9IGZpeGVkUm93c0hlaWdodDtcbiAgICAgIGhlaWdodCAtPSBmaXhlZFJvd3NIZWlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMud290Lnd0VGFibGUuaG9sZGVyLmNsaWVudEhlaWdodCAhPT0gdGhpcy53b3Qud3RUYWJsZS5ob2xkZXIub2Zmc2V0SGVpZ2h0KSB7XG4gICAgICBzY3JvbGxiYXJIZWlnaHQgPSBnZXRTY3JvbGxiYXJXaWR0aCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY3JvbGxiYXJIZWlnaHQgPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgV2Fsa29udGFibGVWaWV3cG9ydFJvd3NDYWxjdWxhdG9yKFxuICAgICAgaGVpZ2h0LFxuICAgICAgcG9zLFxuICAgICAgdGhpcy53b3QuZ2V0U2V0dGluZygndG90YWxSb3dzJyksXG4gICAgICAoc291cmNlUm93KSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLndvdC53dFRhYmxlLmdldFJvd0hlaWdodChzb3VyY2VSb3cpO1xuICAgICAgfSxcbiAgICAgIHZpc2libGUgPyBudWxsIDogdGhpcy53b3Qud3RTZXR0aW5ncy5zZXR0aW5ncy52aWV3cG9ydFJvd0NhbGN1bGF0b3JPdmVycmlkZSxcbiAgICAgIHZpc2libGUsXG4gICAgICBzY3JvbGxiYXJIZWlnaHRcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXM6XG4gICAqICAtIGNvbHVtbnNSZW5kZXJDYWxjdWxhdG9yIChiZWZvcmUgZHJhdywgdG8gcXVhbGlmeSBjb2x1bW5zIGZvciByZW5kZXJpbmcpXG4gICAqICAtIGNvbHVtbnNWaXNpYmxlQ2FsY3VsYXRvciAoYWZ0ZXIgZHJhdywgdG8gbWVhc3VyZSB3aGljaCBjb2x1bW5zIGFyZSBhY3R1YWxseSB2aXNpYmxlKVxuICAgKlxuICAgKiBAcmV0dXJucyB7V2Fsa29udGFibGVWaWV3cG9ydFJvd3NDYWxjdWxhdG9yfVxuICAgKi9cbiAgY3JlYXRlQ29sdW1uc0NhbGN1bGF0b3IodmlzaWJsZSA9IGZhbHNlKSB7XG4gICAgbGV0IHdpZHRoID0gdGhpcy5nZXRWaWV3cG9ydFdpZHRoKCk7XG4gICAgbGV0IHBvcztcbiAgICBsZXQgZml4ZWRDb2x1bW5zTGVmdDtcblxuICAgIHRoaXMuY29sdW1uSGVhZGVySGVpZ2h0ID0gTmFOO1xuXG4gICAgcG9zID0gdGhpcy53b3Qud3RPdmVybGF5cy5sZWZ0T3ZlcmxheS5nZXRTY3JvbGxQb3NpdGlvbigpIC0gdGhpcy53b3Qud3RPdmVybGF5cy5sZWZ0T3ZlcmxheS5nZXRUYWJsZVBhcmVudE9mZnNldCgpO1xuXG4gICAgaWYgKHBvcyA8IDApIHtcbiAgICAgIHBvcyA9IDA7XG4gICAgfVxuICAgIGZpeGVkQ29sdW1uc0xlZnQgPSB0aGlzLndvdC5nZXRTZXR0aW5nKCdmaXhlZENvbHVtbnNMZWZ0Jyk7XG5cbiAgICBpZiAoZml4ZWRDb2x1bW5zTGVmdCkge1xuICAgICAgbGV0IGZpeGVkQ29sdW1uc1dpZHRoID0gdGhpcy53b3Qud3RPdmVybGF5cy5sZWZ0T3ZlcmxheS5zdW1DZWxsU2l6ZXMoMCwgZml4ZWRDb2x1bW5zTGVmdCk7XG4gICAgICBwb3MgKz0gZml4ZWRDb2x1bW5zV2lkdGg7XG4gICAgICB3aWR0aCAtPSBmaXhlZENvbHVtbnNXaWR0aDtcbiAgICB9XG4gICAgaWYgKHRoaXMud290Lnd0VGFibGUuaG9sZGVyLmNsaWVudFdpZHRoICE9PSB0aGlzLndvdC53dFRhYmxlLmhvbGRlci5vZmZzZXRXaWR0aCkge1xuICAgICAgd2lkdGggLT0gZ2V0U2Nyb2xsYmFyV2lkdGgoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFdhbGtvbnRhYmxlVmlld3BvcnRDb2x1bW5zQ2FsY3VsYXRvcihcbiAgICAgIHdpZHRoLFxuICAgICAgcG9zLFxuICAgICAgdGhpcy53b3QuZ2V0U2V0dGluZygndG90YWxDb2x1bW5zJyksXG4gICAgICAoc291cmNlQ29sKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLndvdC53dFRhYmxlLmdldENvbHVtbldpZHRoKHNvdXJjZUNvbCk7XG4gICAgICB9LFxuICAgICAgdmlzaWJsZSA/IG51bGwgOiB0aGlzLndvdC53dFNldHRpbmdzLnNldHRpbmdzLnZpZXdwb3J0Q29sdW1uQ2FsY3VsYXRvck92ZXJyaWRlLFxuICAgICAgdmlzaWJsZSxcbiAgICAgIHRoaXMud290LmdldFNldHRpbmcoJ3N0cmV0Y2hIJylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgcm93c1JlbmRlckNhbGN1bGF0b3IgYW5kIGNvbHVtbnNSZW5kZXJDYWxjdWxhdG9yIChiZWZvcmUgZHJhdywgdG8gZGV0ZXJtaW5lIHdoYXQgcm93cyBhbmRcbiAgICogY29scyBzaG91bGQgYmUgcmVuZGVyZWQpXG4gICAqXG4gICAqIEBwYXJhbSBmYXN0RHJhdyB7Qm9vbGVhbn0gSWYgYHRydWVgLCB3aWxsIHRyeSB0byBhdm9pZCBmdWxsIHJlZHJhdyBhbmQgb25seSB1cGRhdGUgdGhlIGJvcmRlciBwb3NpdGlvbnMuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgYGZhbHNlYCBvciBgdW5kZWZpbmVkYCwgd2lsbCBwZXJmb3JtIGEgZnVsbCByZWRyYXdcbiAgICogQHJldHVybnMgZmFzdERyYXcge0Jvb2xlYW59IFRoZSBmYXN0RHJhdyB2YWx1ZSwgcG9zc2libHkgbW9kaWZpZWRcbiAgICovXG4gIGNyZWF0ZVJlbmRlckNhbGN1bGF0b3JzKGZhc3REcmF3ID0gZmFsc2UpIHtcbiAgICBpZiAoZmFzdERyYXcpIHtcbiAgICAgIGxldCBwcm9wb3NlZFJvd3NWaXNpYmxlQ2FsY3VsYXRvciA9IHRoaXMuY3JlYXRlUm93c0NhbGN1bGF0b3IodHJ1ZSk7XG4gICAgICBsZXQgcHJvcG9zZWRDb2x1bW5zVmlzaWJsZUNhbGN1bGF0b3IgPSB0aGlzLmNyZWF0ZUNvbHVtbnNDYWxjdWxhdG9yKHRydWUpO1xuXG4gICAgICBpZiAoISh0aGlzLmFyZUFsbFByb3Bvc2VkVmlzaWJsZVJvd3NBbHJlYWR5UmVuZGVyZWQocHJvcG9zZWRSb3dzVmlzaWJsZUNhbGN1bGF0b3IpICYmXG4gICAgICAgICAgdGhpcy5hcmVBbGxQcm9wb3NlZFZpc2libGVDb2x1bW5zQWxyZWFkeVJlbmRlcmVkKHByb3Bvc2VkQ29sdW1uc1Zpc2libGVDYWxjdWxhdG9yKSkpIHtcbiAgICAgICAgZmFzdERyYXcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWZhc3REcmF3KSB7XG4gICAgICB0aGlzLnJvd3NSZW5kZXJDYWxjdWxhdG9yID0gdGhpcy5jcmVhdGVSb3dzQ2FsY3VsYXRvcigpO1xuICAgICAgdGhpcy5jb2x1bW5zUmVuZGVyQ2FsY3VsYXRvciA9IHRoaXMuY3JlYXRlQ29sdW1uc0NhbGN1bGF0b3IoKTtcbiAgICB9XG4gICAgLy8gZGVsZXRlIHRlbXBvcmFyaWx5IHRvIG1ha2Ugc3VyZSB0aGF0IHJlbmRlcmVycyBhbHdheXMgdXNlIHJvd3NSZW5kZXJDYWxjdWxhdG9yLCBub3Qgcm93c1Zpc2libGVDYWxjdWxhdG9yXG4gICAgdGhpcy5yb3dzVmlzaWJsZUNhbGN1bGF0b3IgPSBudWxsO1xuICAgIHRoaXMuY29sdW1uc1Zpc2libGVDYWxjdWxhdG9yID0gbnVsbDtcblxuICAgIHJldHVybiBmYXN0RHJhdztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHJvd3NWaXNpYmxlQ2FsY3VsYXRvciBhbmQgY29sdW1uc1Zpc2libGVDYWxjdWxhdG9yIChhZnRlciBkcmF3LCB0byBkZXRlcm1pbmUgd2hhdCBhcmVcbiAgICogdGhlIGFjdHVhbGx5IHZpc2libGUgcm93cyBhbmQgY29sdW1ucylcbiAgICovXG4gIGNyZWF0ZVZpc2libGVDYWxjdWxhdG9ycygpIHtcbiAgICB0aGlzLnJvd3NWaXNpYmxlQ2FsY3VsYXRvciA9IHRoaXMuY3JlYXRlUm93c0NhbGN1bGF0b3IodHJ1ZSk7XG4gICAgdGhpcy5jb2x1bW5zVmlzaWJsZUNhbGN1bGF0b3IgPSB0aGlzLmNyZWF0ZUNvbHVtbnNDYWxjdWxhdG9yKHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaW5mb3JtYXRpb24gd2hldGhlciBwcm9wb3NlZFJvd3NWaXNpYmxlQ2FsY3VsYXRvciB2aWV3cG9ydFxuICAgKiBpcyBjb250YWluZWQgaW5zaWRlIHJvd3MgcmVuZGVyZWQgaW4gcHJldmlvdXMgZHJhdyAoY2FjaGVkIGluIHJvd3NSZW5kZXJDYWxjdWxhdG9yKVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcG9zZWRSb3dzVmlzaWJsZUNhbGN1bGF0b3JcbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBwcm9wb3NlZCB2aXNpYmxlIHJvd3MgYXJlIGFscmVhZHkgcmVuZGVyZWQgKG1lYW5pbmc6IHJlZHJhdyBpcyBub3QgbmVlZGVkKS5cbiAgICogICAgICAgICAgICAgICAgICAgIFJldHVybnMgYGZhbHNlYCBpZiBhdCBsZWFzdCBvbmUgcHJvcG9zZWQgdmlzaWJsZSByb3cgaXMgbm90IGFscmVhZHkgcmVuZGVyZWQgKG1lYW5pbmc6IHJlZHJhdyBpcyBuZWVkZWQpXG4gICAqL1xuICBhcmVBbGxQcm9wb3NlZFZpc2libGVSb3dzQWxyZWFkeVJlbmRlcmVkKHByb3Bvc2VkUm93c1Zpc2libGVDYWxjdWxhdG9yKSB7XG4gICAgaWYgKHRoaXMucm93c1Zpc2libGVDYWxjdWxhdG9yKSB7XG4gICAgICBpZiAocHJvcG9zZWRSb3dzVmlzaWJsZUNhbGN1bGF0b3Iuc3RhcnRSb3cgPCB0aGlzLnJvd3NSZW5kZXJDYWxjdWxhdG9yLnN0YXJ0Um93IHx8XG4gICAgICAgICAgKHByb3Bvc2VkUm93c1Zpc2libGVDYWxjdWxhdG9yLnN0YXJ0Um93ID09PSB0aGlzLnJvd3NSZW5kZXJDYWxjdWxhdG9yLnN0YXJ0Um93ICYmXG4gICAgICAgICAgcHJvcG9zZWRSb3dzVmlzaWJsZUNhbGN1bGF0b3Iuc3RhcnRSb3cgPiAwKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgIH0gZWxzZSBpZiAocHJvcG9zZWRSb3dzVmlzaWJsZUNhbGN1bGF0b3IuZW5kUm93ID4gdGhpcy5yb3dzUmVuZGVyQ2FsY3VsYXRvci5lbmRSb3cgfHxcbiAgICAgICAgICAocHJvcG9zZWRSb3dzVmlzaWJsZUNhbGN1bGF0b3IuZW5kUm93ID09PSB0aGlzLnJvd3NSZW5kZXJDYWxjdWxhdG9yLmVuZFJvdyAmJlxuICAgICAgICAgIHByb3Bvc2VkUm93c1Zpc2libGVDYWxjdWxhdG9yLmVuZFJvdyA8IHRoaXMud290LmdldFNldHRpbmcoJ3RvdGFsUm93cycpIC0gMSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBpbmZvcm1hdGlvbiB3aGV0aGVyIHByb3Bvc2VkQ29sdW1uc1Zpc2libGVDYWxjdWxhdG9yIHZpZXdwb3J0XG4gICAqIGlzIGNvbnRhaW5lZCBpbnNpZGUgY29sdW1uIHJlbmRlcmVkIGluIHByZXZpb3VzIGRyYXcgKGNhY2hlZCBpbiBjb2x1bW5zUmVuZGVyQ2FsY3VsYXRvcilcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3Bvc2VkQ29sdW1uc1Zpc2libGVDYWxjdWxhdG9yXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgcHJvcG9zZWQgdmlzaWJsZSBjb2x1bW5zIGFyZSBhbHJlYWR5IHJlbmRlcmVkIChtZWFuaW5nOiByZWRyYXcgaXMgbm90IG5lZWRlZCkuXG4gICAqICAgICAgICAgICAgICAgICAgICBSZXR1cm5zIGBmYWxzZWAgaWYgYXQgbGVhc3Qgb25lIHByb3Bvc2VkIHZpc2libGUgY29sdW1uIGlzIG5vdCBhbHJlYWR5IHJlbmRlcmVkIChtZWFuaW5nOiByZWRyYXcgaXMgbmVlZGVkKVxuICAgKi9cbiAgYXJlQWxsUHJvcG9zZWRWaXNpYmxlQ29sdW1uc0FscmVhZHlSZW5kZXJlZChwcm9wb3NlZENvbHVtbnNWaXNpYmxlQ2FsY3VsYXRvcikge1xuICAgIGlmICh0aGlzLmNvbHVtbnNWaXNpYmxlQ2FsY3VsYXRvcikge1xuICAgICAgaWYgKHByb3Bvc2VkQ29sdW1uc1Zpc2libGVDYWxjdWxhdG9yLnN0YXJ0Q29sdW1uIDwgdGhpcy5jb2x1bW5zUmVuZGVyQ2FsY3VsYXRvci5zdGFydENvbHVtbiB8fFxuICAgICAgICAgIChwcm9wb3NlZENvbHVtbnNWaXNpYmxlQ2FsY3VsYXRvci5zdGFydENvbHVtbiA9PT0gdGhpcy5jb2x1bW5zUmVuZGVyQ2FsY3VsYXRvci5zdGFydENvbHVtbiAmJlxuICAgICAgICAgIHByb3Bvc2VkQ29sdW1uc1Zpc2libGVDYWxjdWxhdG9yLnN0YXJ0Q29sdW1uID4gMCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICB9IGVsc2UgaWYgKHByb3Bvc2VkQ29sdW1uc1Zpc2libGVDYWxjdWxhdG9yLmVuZENvbHVtbiA+IHRoaXMuY29sdW1uc1JlbmRlckNhbGN1bGF0b3IuZW5kQ29sdW1uIHx8XG4gICAgICAgICAgKHByb3Bvc2VkQ29sdW1uc1Zpc2libGVDYWxjdWxhdG9yLmVuZENvbHVtbiA9PT0gdGhpcy5jb2x1bW5zUmVuZGVyQ2FsY3VsYXRvci5lbmRDb2x1bW4gJiZcbiAgICAgICAgICBwcm9wb3NlZENvbHVtbnNWaXNpYmxlQ2FsY3VsYXRvci5lbmRDb2x1bW4gPCB0aGlzLndvdC5nZXRTZXR0aW5nKCd0b3RhbENvbHVtbnMnKSAtIDEpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCB7V2Fsa29udGFibGVWaWV3cG9ydH07XG5cbndpbmRvdy5XYWxrb250YWJsZVZpZXdwb3J0ID0gV2Fsa29udGFibGVWaWV3cG9ydDtcbiIsIlxubGV0IHZlcnNpb24gPSBIYW5kc29udGFibGUudmVyc2lvbjtcbmxldCBidWlsZERhdGUgPSBIYW5kc29udGFibGUuYnVpbGREYXRlO1xuXG53aW5kb3cuSGFuZHNvbnRhYmxlID0gZnVuY3Rpb24gSGFuZHNvbnRhYmxlKHJvb3RFbGVtZW50LCB1c2VyU2V0dGluZ3MpIHtcbiAgdmFyIGluc3RhbmNlID0gbmV3IEhhbmRzb250YWJsZS5Db3JlKHJvb3RFbGVtZW50LCB1c2VyU2V0dGluZ3MgfHwge30pO1xuXG4gIGluc3RhbmNlLmluaXQoKTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59O1xuXG5IYW5kc29udGFibGUudmVyc2lvbiA9IHZlcnNpb247XG5IYW5kc29udGFibGUuYnVpbGREYXRlID0gYnVpbGREYXRlO1xuXG5pbXBvcnQgJy4vc2hpbXMvY2xhc3Nlcyc7XG5pbXBvcnQgJ2VzNmNvbGxlY3Rpb25zJztcblxuSGFuZHNvbnRhYmxlLnBsdWdpbnMgPSB7fTtcblxuaW1wb3J0IHtIb29rc30gZnJvbSAnLi9wbHVnaW5Ib29rcyc7XG5cbmlmICghSGFuZHNvbnRhYmxlLmhvb2tzKSB7XG4gIEhhbmRzb250YWJsZS5ob29rcyA9IG5ldyBIb29rcygpO1xufVxuXG5pbXBvcnQgJy4vY29yZSc7XG5pbXBvcnQgJy4vcmVuZGVyZXJzL19jZWxsRGVjb3JhdG9yJztcbmltcG9ydCAnLi9jZWxsVHlwZXMnO1xuaW1wb3J0ICcuLy4uL3BsdWdpbnMvanF1ZXJ5SGFuZHNvbnRhYmxlJztcblxuLy8gZXhwb3J0IGhlbHBlcnNcbmltcG9ydCAqIGFzIGFycmF5SGVscGVycyBmcm9tICcuL2hlbHBlcnMvYXJyYXknO1xuaW1wb3J0ICogYXMgYnJvd3NlckhlbHBlcnMgZnJvbSAnLi9oZWxwZXJzL2Jyb3dzZXInO1xuaW1wb3J0ICogYXMgZGF0YUhlbHBlcnMgZnJvbSAnLi9oZWxwZXJzL2RhdGEnO1xuaW1wb3J0ICogYXMgZnVuY3Rpb25IZWxwZXJzIGZyb20gJy4vaGVscGVycy9mdW5jdGlvbic7XG5pbXBvcnQgKiBhcyBtaXhlZEhlbHBlcnMgZnJvbSAnLi9oZWxwZXJzL21peGVkJztcbmltcG9ydCAqIGFzIG51bWJlckhlbHBlcnMgZnJvbSAnLi9oZWxwZXJzL251bWJlcic7XG5pbXBvcnQgKiBhcyBvYmplY3RIZWxwZXJzIGZyb20gJy4vaGVscGVycy9vYmplY3QnO1xuaW1wb3J0ICogYXMgc2V0dGluZ0hlbHBlcnMgZnJvbSAnLi9oZWxwZXJzL3NldHRpbmcnO1xuaW1wb3J0ICogYXMgc3RyaW5nSGVscGVycyBmcm9tICcuL2hlbHBlcnMvc3RyaW5nJztcbmltcG9ydCAqIGFzIHVuaWNvZGVIZWxwZXJzIGZyb20gJy4vaGVscGVycy91bmljb2RlJztcblxuY29uc3QgaGVscGVycyA9IFthcnJheUhlbHBlcnMsIGJyb3dzZXJIZWxwZXJzLCBkYXRhSGVscGVycywgZnVuY3Rpb25IZWxwZXJzLCBtaXhlZEhlbHBlcnMsIG51bWJlckhlbHBlcnMsIG9iamVjdEhlbHBlcnMsXG4gIHNldHRpbmdIZWxwZXJzLCBzdHJpbmdIZWxwZXJzLCB1bmljb2RlSGVscGVyc107XG5cbkhhbmRzb250YWJsZS5oZWxwZXIgPSB7fTtcblxuYXJyYXlIZWxwZXJzLmFycmF5RWFjaChoZWxwZXJzLCAoaGVscGVyKSA9PiB7XG4gIGFycmF5SGVscGVycy5hcnJheUVhY2goT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVscGVyKSwgKGtleSkgPT4ge1xuICAgIGlmIChrZXkuY2hhckF0KDApICE9PSAnXycpIHtcbiAgICAgIEhhbmRzb250YWJsZS5oZWxwZXJba2V5XSA9IGhlbHBlcltrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxuLy8gZXhwb3J0IGhlbHBlcnNcbmltcG9ydCAqIGFzIGRvbUhlbHBlcnMgZnJvbSAnLi9oZWxwZXJzL2RvbS9lbGVtZW50JztcbmltcG9ydCAqIGFzIGRvbUV2ZW50SGVscGVycyBmcm9tICcuL2hlbHBlcnMvZG9tL2V2ZW50JztcblxuSGFuZHNvbnRhYmxlLmRvbSA9IHt9O1xuSGFuZHNvbnRhYmxlLkRvbSA9IEhhbmRzb250YWJsZS5kb207IC8vIGxlZ2FjeSBzdXBwb3J0XG5cbmFycmF5SGVscGVycy5hcnJheUVhY2goW2RvbUhlbHBlcnMsIGRvbUV2ZW50SGVscGVyc10sIChoZWxwZXIpID0+IHtcbiAgYXJyYXlIZWxwZXJzLmFycmF5RWFjaChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWxwZXIpLCAoa2V5KSA9PiB7XG4gICAgaWYgKGtleS5jaGFyQXQoMCkgIT09ICdfJykge1xuICAgICAgSGFuZHNvbnRhYmxlLmRvbVtrZXldID0gaGVscGVyW2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xuIiwiLyoqXG4gKiBDZWxsIHR5cGUgaXMganVzdCBhIHNob3J0Y3V0IGZvciBzZXR0aW5nIGJ1bmNoIG9mIGNlbGxQcm9wZXJ0aWVzICh1c2VkIGluIGdldENlbGxNZXRhKVxuICovXG5cbmltcG9ydCB7aXNNb2JpbGVCcm93c2VyfSBmcm9tICcuL2hlbHBlcnMvYnJvd3Nlcic7XG5pbXBvcnQge2dldEVkaXRvckNvbnN0cnVjdG9yfSBmcm9tICcuL2VkaXRvcnMnO1xuaW1wb3J0IHtnZXRSZW5kZXJlcn0gZnJvbSAnLi9yZW5kZXJlcnMnO1xuXG5pbXBvcnQge0F1dG9jb21wbGV0ZUVkaXRvcn0gZnJvbSAnLi9lZGl0b3JzL2F1dG9jb21wbGV0ZUVkaXRvcic7XG5pbXBvcnQge0NoZWNrYm94RWRpdG9yfSBmcm9tICcuL2VkaXRvcnMvY2hlY2tib3hFZGl0b3InO1xuaW1wb3J0IHtEYXRlRWRpdG9yfSBmcm9tICcuL2VkaXRvcnMvZGF0ZUVkaXRvcic7XG5pbXBvcnQge0Ryb3Bkb3duRWRpdG9yfSBmcm9tICcuL2VkaXRvcnMvZHJvcGRvd25FZGl0b3InO1xuaW1wb3J0IHtIYW5kc29udGFibGVFZGl0b3J9IGZyb20gJy4vZWRpdG9ycy9oYW5kc29udGFibGVFZGl0b3InO1xuaW1wb3J0IHtNb2JpbGVUZXh0RWRpdG9yfSBmcm9tICcuL2VkaXRvcnMvbW9iaWxlVGV4dEVkaXRvcic7XG5pbXBvcnQge051bWVyaWNFZGl0b3J9IGZyb20gJy4vZWRpdG9ycy9udW1lcmljRWRpdG9yJztcbmltcG9ydCB7UGFzc3dvcmRFZGl0b3J9IGZyb20gJy4vZWRpdG9ycy9wYXNzd29yZEVkaXRvcic7XG5pbXBvcnQge1NlbGVjdEVkaXRvcn0gZnJvbSAnLi9lZGl0b3JzL3NlbGVjdEVkaXRvcic7XG5pbXBvcnQge1RleHRFZGl0b3J9IGZyb20gJy4vZWRpdG9ycy90ZXh0RWRpdG9yJztcblxuaW1wb3J0IHtBdXRvY29tcGxldGVSZW5kZXJlcn0gZnJvbSAnLi9yZW5kZXJlcnMvYXV0b2NvbXBsZXRlUmVuZGVyZXInO1xuaW1wb3J0IHtDaGVja2JveFJlbmRlcmVyfSBmcm9tICcuL3JlbmRlcmVycy9jaGVja2JveFJlbmRlcmVyJztcbmltcG9ydCB7SHRtbFJlbmRlcmVyfSBmcm9tICcuL3JlbmRlcmVycy9odG1sUmVuZGVyZXInO1xuaW1wb3J0IHtOdW1lcmljUmVuZGVyZXJ9IGZyb20gJy4vcmVuZGVyZXJzL251bWVyaWNSZW5kZXJlcic7XG5pbXBvcnQge1Bhc3N3b3JkUmVuZGVyZXJ9IGZyb20gJy4vcmVuZGVyZXJzL3Bhc3N3b3JkUmVuZGVyZXInO1xuaW1wb3J0IHtUZXh0UmVuZGVyZXJ9IGZyb20gJy4vcmVuZGVyZXJzL3RleHRSZW5kZXJlcic7XG5cbmltcG9ydCB7QXV0b2NvbXBsZXRlVmFsaWRhdG9yfSBmcm9tICcuL3ZhbGlkYXRvcnMvYXV0b2NvbXBsZXRlVmFsaWRhdG9yJztcbmltcG9ydCB7RGF0ZVZhbGlkYXRvcn0gZnJvbSAnLi92YWxpZGF0b3JzL2RhdGVWYWxpZGF0b3InO1xuaW1wb3J0IHtOdW1lcmljVmFsaWRhdG9yfSBmcm9tICcuL3ZhbGlkYXRvcnMvbnVtZXJpY1ZhbGlkYXRvcic7XG5cblxuSGFuZHNvbnRhYmxlLm1vYmlsZUJyb3dzZXIgPSBpc01vYmlsZUJyb3dzZXIoKTtcblxuSGFuZHNvbnRhYmxlLkF1dG9jb21wbGV0ZUNlbGwgPSB7XG4gIGVkaXRvcjogZ2V0RWRpdG9yQ29uc3RydWN0b3IoJ2F1dG9jb21wbGV0ZScpLFxuICByZW5kZXJlcjogZ2V0UmVuZGVyZXIoJ2F1dG9jb21wbGV0ZScpLFxuICB2YWxpZGF0b3I6IEhhbmRzb250YWJsZS5BdXRvY29tcGxldGVWYWxpZGF0b3Jcbn07XG5cbkhhbmRzb250YWJsZS5DaGVja2JveENlbGwgPSB7XG4gIGVkaXRvcjogZ2V0RWRpdG9yQ29uc3RydWN0b3IoJ2NoZWNrYm94JyksXG4gIHJlbmRlcmVyOiBnZXRSZW5kZXJlcignY2hlY2tib3gnKVxufTtcblxuSGFuZHNvbnRhYmxlLlRleHRDZWxsID0ge1xuICBlZGl0b3I6IEhhbmRzb250YWJsZS5tb2JpbGVCcm93c2VyID8gZ2V0RWRpdG9yQ29uc3RydWN0b3IoJ21vYmlsZScpIDogZ2V0RWRpdG9yQ29uc3RydWN0b3IoJ3RleHQnKSxcbiAgcmVuZGVyZXI6IGdldFJlbmRlcmVyKCd0ZXh0Jylcbn07XG5cbkhhbmRzb250YWJsZS5OdW1lcmljQ2VsbCA9IHtcbiAgZWRpdG9yOiBnZXRFZGl0b3JDb25zdHJ1Y3RvcignbnVtZXJpYycpLFxuICByZW5kZXJlcjogZ2V0UmVuZGVyZXIoJ251bWVyaWMnKSxcbiAgdmFsaWRhdG9yOiBIYW5kc29udGFibGUuTnVtZXJpY1ZhbGlkYXRvcixcbiAgZGF0YVR5cGU6ICdudW1iZXInXG59O1xuXG5IYW5kc29udGFibGUuRGF0ZUNlbGwgPSB7XG4gIGVkaXRvcjogZ2V0RWRpdG9yQ29uc3RydWN0b3IoJ2RhdGUnKSxcbiAgdmFsaWRhdG9yOiBIYW5kc29udGFibGUuRGF0ZVZhbGlkYXRvcixcbiAgLy8gZGlzcGxheXMgc21hbGwgZ3JheSBhcnJvdyBvbiByaWdodCBzaWRlIG9mIHRoZSBjZWxsXG4gIHJlbmRlcmVyOiBnZXRSZW5kZXJlcignYXV0b2NvbXBsZXRlJylcbn07XG5cbkhhbmRzb250YWJsZS5IYW5kc29udGFibGVDZWxsID0ge1xuICBlZGl0b3I6IGdldEVkaXRvckNvbnN0cnVjdG9yKCdoYW5kc29udGFibGUnKSxcbiAgLy9kaXNwbGF5cyBzbWFsbCBncmF5IGFycm93IG9uIHJpZ2h0IHNpZGUgb2YgdGhlIGNlbGxcbiAgcmVuZGVyZXI6IGdldFJlbmRlcmVyKCdhdXRvY29tcGxldGUnKVxufTtcblxuSGFuZHNvbnRhYmxlLlBhc3N3b3JkQ2VsbCA9IHtcbiAgZWRpdG9yOiBnZXRFZGl0b3JDb25zdHJ1Y3RvcigncGFzc3dvcmQnKSxcbiAgcmVuZGVyZXI6IGdldFJlbmRlcmVyKCdwYXNzd29yZCcpLFxuICBjb3B5YWJsZTogZmFsc2Vcbn07XG5cbkhhbmRzb250YWJsZS5Ecm9wZG93bkNlbGwgPSB7XG4gIGVkaXRvcjogZ2V0RWRpdG9yQ29uc3RydWN0b3IoJ2Ryb3Bkb3duJyksXG4gIC8vZGlzcGxheXMgc21hbGwgZ3JheSBhcnJvdyBvbiByaWdodCBzaWRlIG9mIHRoZSBjZWxsXG4gIHJlbmRlcmVyOiBnZXRSZW5kZXJlcignYXV0b2NvbXBsZXRlJyksXG4gIHZhbGlkYXRvcjogSGFuZHNvbnRhYmxlLkF1dG9jb21wbGV0ZVZhbGlkYXRvclxufTtcblxuLy9oZXJlIHNldHVwIHRoZSBmcmllbmRseSBhbGlhc2VzIHRoYXQgYXJlIHVzZWQgYnkgY2VsbFByb3BlcnRpZXMudHlwZVxuSGFuZHNvbnRhYmxlLmNlbGxUeXBlcyA9IHtcbiAgdGV4dDogSGFuZHNvbnRhYmxlLlRleHRDZWxsLFxuICBkYXRlOiBIYW5kc29udGFibGUuRGF0ZUNlbGwsXG4gIG51bWVyaWM6IEhhbmRzb250YWJsZS5OdW1lcmljQ2VsbCxcbiAgY2hlY2tib3g6IEhhbmRzb250YWJsZS5DaGVja2JveENlbGwsXG4gIGF1dG9jb21wbGV0ZTogSGFuZHNvbnRhYmxlLkF1dG9jb21wbGV0ZUNlbGwsXG4gIGhhbmRzb250YWJsZTogSGFuZHNvbnRhYmxlLkhhbmRzb250YWJsZUNlbGwsXG4gIHBhc3N3b3JkOiBIYW5kc29udGFibGUuUGFzc3dvcmRDZWxsLFxuICBkcm9wZG93bjogSGFuZHNvbnRhYmxlLkRyb3Bkb3duQ2VsbFxufTtcblxuLy9oZXJlIHNldHVwIHRoZSBmcmllbmRseSBhbGlhc2VzIHRoYXQgYXJlIHVzZWQgYnkgY2VsbFByb3BlcnRpZXMucmVuZGVyZXIgYW5kIGNlbGxQcm9wZXJ0aWVzLmVkaXRvclxuSGFuZHNvbnRhYmxlLmNlbGxMb29rdXAgPSB7XG4gIHZhbGlkYXRvcjoge1xuICAgIG51bWVyaWM6IEhhbmRzb250YWJsZS5OdW1lcmljVmFsaWRhdG9yLFxuICAgIGF1dG9jb21wbGV0ZTogSGFuZHNvbnRhYmxlLkF1dG9jb21wbGV0ZVZhbGlkYXRvclxuICB9XG59O1xuIiwiXG5pbXBvcnQgbnVtZXJhbCBmcm9tICdudW1lcmFsJztcbmltcG9ydCB7YWRkQ2xhc3MsIGVtcHR5LCBpc0NoaWxkT2ZXZWJDb21wb25lbnRUYWJsZSwgcmVtb3ZlQ2xhc3N9IGZyb20gJy4vaGVscGVycy9kb20vZWxlbWVudCc7XG5pbXBvcnQge2NvbHVtbkZhY3Rvcnl9IGZyb20gJy4vaGVscGVycy9zZXR0aW5nJztcbmltcG9ydCB7RGF0YU1hcH0gZnJvbSAnLi9kYXRhTWFwJztcbmltcG9ydCB7RWRpdG9yTWFuYWdlcn0gZnJvbSAnLi9lZGl0b3JNYW5hZ2VyJztcbmltcG9ydCB7ZXZlbnRNYW5hZ2VyIGFzIGV2ZW50TWFuYWdlck9iamVjdH0gZnJvbSAnLi9ldmVudE1hbmFnZXInO1xuaW1wb3J0IHtleHRlbmQsIGR1Y2tTY2hlbWEsIGlzT2JqZWN0RXF1YWxzLCBkZWVwQ2xvbmV9IGZyb20gJy4vaGVscGVycy9vYmplY3QnO1xuaW1wb3J0IHtnZXRQbHVnaW59IGZyb20gJy4vcGx1Z2lucyc7XG5pbXBvcnQge2dldFJlbmRlcmVyfSBmcm9tICcuL3JlbmRlcmVycyc7XG5pbXBvcnQge3JhbmRvbVN0cmluZ30gZnJvbSAnLi9oZWxwZXJzL3N0cmluZyc7XG5pbXBvcnQge1RhYmxlVmlld30gZnJvbSAnLi90YWJsZVZpZXcnO1xuaW1wb3J0IHt0cmFuc2xhdGVSb3dzVG9Db2x1bW5zLCBjZWxsTWV0aG9kTG9va3VwRmFjdG9yeSwgc3ByZWFkc2hlZXRDb2x1bW5MYWJlbH0gZnJvbSAnLi9oZWxwZXJzL2RhdGEnO1xuaW1wb3J0IHtXYWxrb250YWJsZUNlbGxDb29yZHN9IGZyb20gJy4vM3JkcGFydHkvd2Fsa29udGFibGUvc3JjL2NlbGwvY29vcmRzJztcbmltcG9ydCB7V2Fsa29udGFibGVDZWxsUmFuZ2V9IGZyb20gJy4vM3JkcGFydHkvd2Fsa29udGFibGUvc3JjL2NlbGwvcmFuZ2UnO1xuaW1wb3J0IHtXYWxrb250YWJsZVNlbGVjdGlvbn0gZnJvbSAnLi8zcmRwYXJ0eS93YWxrb250YWJsZS9zcmMvc2VsZWN0aW9uJztcbmltcG9ydCB7V2Fsa29udGFibGVWaWV3cG9ydENvbHVtbnNDYWxjdWxhdG9yfSBmcm9tICcuLzNyZHBhcnR5L3dhbGtvbnRhYmxlL3NyYy9jYWxjdWxhdG9yL3ZpZXdwb3J0Q29sdW1ucyc7XG5cbkhhbmRzb250YWJsZS5hY3RpdmVHdWlkID0gbnVsbDtcblxuLyoqXG4gKiBIYW5kc29udGFibGUgY29uc3RydWN0b3JcbiAqXG4gKiBAY29yZVxuICogQGRlcGVuZGVuY2llcyBudW1lcmFsXG4gKiBAY29uc3RydWN0b3IgQ29yZVxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogQWZ0ZXIgSGFuZHNvbnRhYmxlIGlzIGNvbnN0cnVjdGVkLCB5b3UgY2FuIG1vZGlmeSB0aGUgZ3JpZCBiZWhhdmlvciB1c2luZyB0aGUgYXZhaWxhYmxlIHB1YmxpYyBtZXRob2RzLlxuICpcbiAqIC0tLVxuICogIyMgSG93IHRvIGNhbGwgbWV0aG9kc1xuICpcbiAqIFRoZXNlIGFyZSAyIGVxdWFsIHdheXMgdG8gY2FsbCBhIEhhbmRzb250YWJsZSBtZXRob2Q6XG4gKlxuICogYGBganNcbiAqIC8vIGFsbCBmb2xsb3dpbmcgZXhhbXBsZXMgYXNzdW1lIHRoYXQgeW91IGNvbnN0cnVjdGVkIEhhbmRzb250YWJsZSBsaWtlIHRoaXNcbiAqIHZhciBodCA9IG5ldyBIYW5kc29udGFibGUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2V4YW1wbGUxJyksIG9wdGlvbnMpO1xuICpcbiAqIC8vIG5vdywgdG8gdXNlIHNldERhdGFBdENlbGwgbWV0aG9kLCB5b3UgY2FuIGVpdGhlcjpcbiAqIGh0LnNldERhdGFBdENlbGwoMCwgMCwgJ25ldyB2YWx1ZScpO1xuICogYGBgXG4gKlxuICogQWx0ZXJuYXRpdmVseSwgeW91IGNhbiBjYWxsIHRoZSBtZXRob2QgdXNpbmcgalF1ZXJ5IHdyYXBwZXIgKF9fb2Jzb2xldGVfXywgcmVxdWlyZXMgaW5pdGlhbGl6YXRpb24gdXNpbmcgb3VyIGpRdWVyeSBndWlkZVxuICogYGBganNcbiAqICAgJCgnI2V4YW1wbGUxJykuaGFuZHNvbnRhYmxlKCdzZXREYXRhQXRDZWxsJywgMCwgMCwgJ25ldyB2YWx1ZScpO1xuICogYGBgXG4gKiAtLS1cbiAqL1xuSGFuZHNvbnRhYmxlLkNvcmUgPSBmdW5jdGlvbiBDb3JlKHJvb3RFbGVtZW50LCB1c2VyU2V0dGluZ3MpIHtcbiAgdmFyIHByaXZcbiAgICAsIGRhdGFtYXBcbiAgICAsIGdyaWRcbiAgICAsIHNlbGVjdGlvblxuICAgICwgZWRpdG9yTWFuYWdlclxuICAgICwgaW5zdGFuY2UgPSB0aGlzXG4gICAgLCBHcmlkU2V0dGluZ3MgPSBmdW5jdGlvbigpIHt9XG4gICAgLCBldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXJPYmplY3QoaW5zdGFuY2UpO1xuXG4gIGV4dGVuZChHcmlkU2V0dGluZ3MucHJvdG90eXBlLCBEZWZhdWx0U2V0dGluZ3MucHJvdG90eXBlKTsgLy9jcmVhdGUgZ3JpZCBzZXR0aW5ncyBhcyBhIGNvcHkgb2YgZGVmYXVsdCBzZXR0aW5nc1xuICBleHRlbmQoR3JpZFNldHRpbmdzLnByb3RvdHlwZSwgdXNlclNldHRpbmdzKTsgLy9vdmVyd3JpdGUgZGVmYXVsdHMgd2l0aCB1c2VyIHNldHRpbmdzXG4gIGV4dGVuZChHcmlkU2V0dGluZ3MucHJvdG90eXBlLCBleHBhbmRUeXBlKHVzZXJTZXR0aW5ncykpO1xuXG4gIHRoaXMucm9vdEVsZW1lbnQgPSByb290RWxlbWVudDtcbiAgdGhpcy5pc0hvdFRhYmxlRW52ID0gaXNDaGlsZE9mV2ViQ29tcG9uZW50VGFibGUodGhpcy5yb290RWxlbWVudCk7XG4gIEhhbmRzb250YWJsZS5ldmVudE1hbmFnZXIuaXNIb3RUYWJsZUVudiA9IHRoaXMuaXNIb3RUYWJsZUVudjtcblxuICB0aGlzLmNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICB0aGlzLnJlbmRlckNhbGwgPSBmYWxzZTtcblxuICByb290RWxlbWVudC5pbnNlcnRCZWZvcmUodGhpcy5jb250YWluZXIsIHJvb3RFbGVtZW50LmZpcnN0Q2hpbGQpO1xuXG4gIHRoaXMuZ3VpZCA9ICdodF8nICsgcmFuZG9tU3RyaW5nKCk7IC8vdGhpcyBpcyB0aGUgbmFtZXNwYWNlIGZvciBnbG9iYWwgZXZlbnRzXG5cbiAgaWYgKCF0aGlzLnJvb3RFbGVtZW50LmlkIHx8IHRoaXMucm9vdEVsZW1lbnQuaWQuc3Vic3RyaW5nKDAsIDMpID09PSBcImh0X1wiKSB7XG4gICAgdGhpcy5yb290RWxlbWVudC5pZCA9IHRoaXMuZ3VpZDsgLy9pZiByb290IGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBhbiBpZCwgYXNzaWduIGEgcmFuZG9tIGlkXG4gIH1cbiAgcHJpdiA9IHtcbiAgICBjZWxsU2V0dGluZ3M6IFtdLFxuICAgIGNvbHVtblNldHRpbmdzOiBbXSxcbiAgICBjb2x1bW5zU2V0dGluZ0NvbmZsaWN0czogWydkYXRhJywgJ3dpZHRoJ10sXG4gICAgc2V0dGluZ3M6IG5ldyBHcmlkU2V0dGluZ3MoKSwgLy8gY3VycmVudCBzZXR0aW5ncyBpbnN0YW5jZVxuICAgIHNlbFJhbmdlOiBudWxsLCAvL2V4cG9zZWQgYnkgcHVibGljIG1ldGhvZCBgZ2V0U2VsZWN0ZWRSYW5nZWBcbiAgICBpc1BvcHVsYXRlZDogbnVsbCxcbiAgICBzY3JvbGxhYmxlOiBudWxsLFxuICAgIGZpcnN0UnVuOiB0cnVlXG4gIH07XG5cbiAgZ3JpZCA9IHtcbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIG9yIHJlbW92ZXMgcm93cyBhbmQgY29sdW1uc1xuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENvcmUjXG4gICAgICogQGZ1bmN0aW9uIGFsdGVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uIFBvc3NpYmxlIHZhbHVlczogXCJpbnNlcnRfcm93XCIsIFwiaW5zZXJ0X2NvbFwiLCBcInJlbW92ZV9yb3dcIiwgXCJyZW1vdmVfY29sXCJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzb3VyY2VdIE9wdGlvbmFsLiBTb3VyY2Ugb2YgaG9vayBydW5uZXIuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBba2VlcEVtcHR5Um93c10gT3B0aW9uYWwuIEZsYWcgZm9yIHByZXZlbnRpbmcgZGVsZXRpb24gb2YgZW1wdHkgcm93cy5cbiAgICAgKi9cbiAgICBhbHRlcjogZnVuY3Rpb24oYWN0aW9uLCBpbmRleCwgYW1vdW50LCBzb3VyY2UsIGtlZXBFbXB0eVJvd3MpIHtcbiAgICAgIHZhciBkZWx0YTtcblxuICAgICAgYW1vdW50ID0gYW1vdW50IHx8IDE7XG5cbiAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgIGNhc2UgXCJpbnNlcnRfcm93XCI6XG5cbiAgICAgICAgICBpZiAoaW5zdGFuY2UuZ2V0U2V0dGluZ3MoKS5tYXhSb3dzID09PSBpbnN0YW5jZS5jb3VudFJvd3MoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlbHRhID0gZGF0YW1hcC5jcmVhdGVSb3coaW5kZXgsIGFtb3VudCk7XG5cbiAgICAgICAgICBpZiAoZGVsdGEpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uaXNTZWxlY3RlZCgpICYmIHByaXYuc2VsUmFuZ2UuZnJvbS5yb3cgPj0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgcHJpdi5zZWxSYW5nZS5mcm9tLnJvdyA9IHByaXYuc2VsUmFuZ2UuZnJvbS5yb3cgKyBkZWx0YTtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uLnRyYW5zZm9ybUVuZChkZWx0YSwgMCk7IC8vd2lsbCBjYWxsIHJlbmRlcigpIGludGVybmFsbHlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBzZWxlY3Rpb24ucmVmcmVzaEJvcmRlcnMoKTsgLy9pdCB3aWxsIGNhbGwgcmVuZGVyIGFuZCBwcmVwYXJlIG1ldGhvZHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcImluc2VydF9jb2xcIjpcbiAgICAgICAgICAvLyAvL2NvbHVtbiBvcmRlciBtYXkgaGF2ZSBjaGFuZ2VzLCBzbyB3ZSBuZWVkIHRvIHRyYW5zbGF0ZSB0aGUgc2VsZWN0aW9uIGNvbHVtbiBpbmRleCAtPiBzb3VyY2UgYXJyYXkgaW5kZXhcbiAgICAgICAgICAvLyBpbmRleCA9IGluc3RhbmNlLnJ1bkhvb2tzQW5kUmV0dXJuKCdtb2RpZnlDb2wnLCBpbmRleCk7XG4gICAgICAgICAgZGVsdGEgPSBkYXRhbWFwLmNyZWF0ZUNvbChpbmRleCwgYW1vdW50KTtcblxuICAgICAgICAgIGlmIChkZWx0YSkge1xuXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnN0YW5jZS5nZXRTZXR0aW5ncygpLmNvbEhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgIHZhciBzcGxpY2VBcnJheSA9IFtpbmRleCwgMF07XG4gICAgICAgICAgICAgIHNwbGljZUFycmF5Lmxlbmd0aCArPSBkZWx0YTsgLy9pbnNlcnRzIGVtcHR5ICh1bmRlZmluZWQpIGVsZW1lbnRzIGF0IHRoZSBlbmQgb2YgYW4gYXJyYXlcbiAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5hcHBseShpbnN0YW5jZS5nZXRTZXR0aW5ncygpLmNvbEhlYWRlcnMsIHNwbGljZUFycmF5KTsgLy9pbnNlcnRzIGVtcHR5ICh1bmRlZmluZWQpIGVsZW1lbnRzIGludG8gdGhlIGNvbEhlYWRlciBhcnJheVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLmlzU2VsZWN0ZWQoKSAmJiBwcml2LnNlbFJhbmdlLmZyb20uY29sID49IGluZGV4KSB7XG4gICAgICAgICAgICAgIHByaXYuc2VsUmFuZ2UuZnJvbS5jb2wgPSBwcml2LnNlbFJhbmdlLmZyb20uY29sICsgZGVsdGE7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbi50cmFuc2Zvcm1FbmQoMCwgZGVsdGEpOyAvL3dpbGwgY2FsbCByZW5kZXIoKSBpbnRlcm5hbGx5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uLnJlZnJlc2hCb3JkZXJzKCk7IC8vaXQgd2lsbCBjYWxsIHJlbmRlciBhbmQgcHJlcGFyZSBtZXRob2RzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJyZW1vdmVfcm93XCI6XG4gICAgICAgICAgLy9jb2x1bW4gb3JkZXIgbWF5IGhhdmUgY2hhbmdlcywgc28gd2UgbmVlZCB0byB0cmFuc2xhdGUgdGhlIHNlbGVjdGlvbiBjb2x1bW4gaW5kZXggLT4gc291cmNlIGFycmF5IGluZGV4XG4gICAgICAgICAgaW5kZXggPSBpbnN0YW5jZS5ydW5Ib29rcygnbW9kaWZ5Q29sJywgaW5kZXgpO1xuXG4gICAgICAgICAgZGF0YW1hcC5yZW1vdmVSb3coaW5kZXgsIGFtb3VudCk7XG4gICAgICAgICAgcHJpdi5jZWxsU2V0dGluZ3Muc3BsaWNlKGluZGV4LCBhbW91bnQpO1xuXG4gICAgICAgICAgdmFyIGZpeGVkUm93c1RvcCA9IGluc3RhbmNlLmdldFNldHRpbmdzKCkuZml4ZWRSb3dzVG9wO1xuICAgICAgICAgIGlmIChmaXhlZFJvd3NUb3AgPj0gaW5kZXggKyAxKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5nZXRTZXR0aW5ncygpLmZpeGVkUm93c1RvcCAtPSBNYXRoLm1pbihhbW91bnQsIGZpeGVkUm93c1RvcCAtIGluZGV4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBncmlkLmFkanVzdFJvd3NBbmRDb2xzKCk7XG4gICAgICAgICAgc2VsZWN0aW9uLnJlZnJlc2hCb3JkZXJzKCk7IC8vaXQgd2lsbCBjYWxsIHJlbmRlciBhbmQgcHJlcGFyZSBtZXRob2RzXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcInJlbW92ZV9jb2xcIjpcbiAgICAgICAgICBkYXRhbWFwLnJlbW92ZUNvbChpbmRleCwgYW1vdW50KTtcblxuICAgICAgICAgIGZvciAodmFyIHJvdyA9IDAsIGxlbiA9IGRhdGFtYXAuZ2V0QWxsKCkubGVuZ3RoOyByb3cgPCBsZW47IHJvdysrKSB7XG4gICAgICAgICAgICBpZiAocm93IGluIHByaXYuY2VsbFNldHRpbmdzKSB7ICAvL2lmIHJvdyBoYXNuJ3QgYmVlbiByZW5kZXJlZCBpdCB3b3VsZG4ndCBoYXZlIGNlbGxTZXR0aW5nc1xuICAgICAgICAgICAgICBwcml2LmNlbGxTZXR0aW5nc1tyb3ddLnNwbGljZShpbmRleCwgYW1vdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZml4ZWRDb2x1bW5zTGVmdCA9IGluc3RhbmNlLmdldFNldHRpbmdzKCkuZml4ZWRDb2x1bW5zTGVmdDtcbiAgICAgICAgICBpZiAoZml4ZWRDb2x1bW5zTGVmdCA+PSBpbmRleCArIDEpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLmdldFNldHRpbmdzKCkuZml4ZWRDb2x1bW5zTGVmdCAtPSBNYXRoLm1pbihhbW91bnQsIGZpeGVkQ29sdW1uc0xlZnQgLSBpbmRleCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5zdGFuY2UuZ2V0U2V0dGluZ3MoKS5jb2xIZWFkZXJzKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5zdGFuY2UuZ2V0U2V0dGluZ3MoKS5jb2xIZWFkZXJzLnNwbGljZShpbmRleCwgYW1vdW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvL3ByaXYuY29sdW1uU2V0dGluZ3Muc3BsaWNlKGluZGV4LCBhbW91bnQpO1xuXG4gICAgICAgICAgZ3JpZC5hZGp1c3RSb3dzQW5kQ29scygpO1xuICAgICAgICAgIHNlbGVjdGlvbi5yZWZyZXNoQm9yZGVycygpOyAvL2l0IHdpbGwgY2FsbCByZW5kZXIgYW5kIHByZXBhcmUgbWV0aG9kc1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIG5vIHN1Y2ggYWN0aW9uIFwiJyArIGFjdGlvbiArICdcIicpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuICAgICAgfVxuXG4gICAgICBpZiAoIWtlZXBFbXB0eVJvd3MpIHtcbiAgICAgICAgZ3JpZC5hZGp1c3RSb3dzQW5kQ29scygpOyAvL21ha2VzIHN1cmUgdGhhdCB3ZSBkaWQgbm90IGFkZCByb3dzIHRoYXQgd2lsbCBiZSByZW1vdmVkIGluIG5leHQgcmVmcmVzaFxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBzdXJlIHRoZXJlIGFyZSBlbXB0eSByb3dzIGF0IHRoZSBib3R0b20gb2YgdGhlIHRhYmxlXG4gICAgICovXG4gICAgYWRqdXN0Um93c0FuZENvbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHByaXYuc2V0dGluZ3MubWluUm93cykge1xuICAgICAgICAvLyBzaG91bGQgSSBhZGQgZW1wdHkgcm93cyB0byBkYXRhIHNvdXJjZSB0byBtZWV0IG1pblJvd3M/XG4gICAgICAgIGxldCByb3dzID0gaW5zdGFuY2UuY291bnRSb3dzKCk7XG5cbiAgICAgICAgaWYgKHJvd3MgPCBwcml2LnNldHRpbmdzLm1pblJvd3MpIHtcbiAgICAgICAgICBmb3IgKGxldCByID0gMCwgbWluUm93cyA9IHByaXYuc2V0dGluZ3MubWluUm93czsgciA8IG1pblJvd3MgLSByb3dzOyByKyspIHtcbiAgICAgICAgICAgIGRhdGFtYXAuY3JlYXRlUm93KGluc3RhbmNlLmNvdW50Um93cygpLCAxLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcml2LnNldHRpbmdzLm1pblNwYXJlUm93cykge1xuICAgICAgICBsZXQgZW1wdHlSb3dzID0gaW5zdGFuY2UuY291bnRFbXB0eVJvd3ModHJ1ZSk7XG5cbiAgICAgICAgLy8gc2hvdWxkIEkgYWRkIGVtcHR5IHJvd3MgdG8gbWVldCBtaW5TcGFyZVJvd3M/XG4gICAgICAgIGlmIChlbXB0eVJvd3MgPCBwcml2LnNldHRpbmdzLm1pblNwYXJlUm93cykge1xuICAgICAgICAgIGZvciAoOyBlbXB0eVJvd3MgPCBwcml2LnNldHRpbmdzLm1pblNwYXJlUm93cyAmJiBpbnN0YW5jZS5jb3VudFJvd3MoKSA8IHByaXYuc2V0dGluZ3MubWF4Um93czsgZW1wdHlSb3dzKyspIHtcbiAgICAgICAgICAgIGRhdGFtYXAuY3JlYXRlUm93KGluc3RhbmNlLmNvdW50Um93cygpLCAxLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHtcbiAgICAgICAgbGV0IGVtcHR5Q29scztcblxuICAgICAgICAvLyBjb3VudCBjdXJyZW50bHkgZW1wdHkgY29sc1xuICAgICAgICBpZiAocHJpdi5zZXR0aW5ncy5taW5Db2xzIHx8IHByaXYuc2V0dGluZ3MubWluU3BhcmVDb2xzKSB7XG4gICAgICAgICAgZW1wdHlDb2xzID0gaW5zdGFuY2UuY291bnRFbXB0eUNvbHModHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaG91bGQgSSBhZGQgZW1wdHkgY29scyB0byBtZWV0IG1pbkNvbHM/XG4gICAgICAgIGlmIChwcml2LnNldHRpbmdzLm1pbkNvbHMgJiYgIXByaXYuc2V0dGluZ3MuY29sdW1ucyAmJiBpbnN0YW5jZS5jb3VudENvbHMoKSA8IHByaXYuc2V0dGluZ3MubWluQ29scykge1xuICAgICAgICAgIGZvciAoOyBpbnN0YW5jZS5jb3VudENvbHMoKSA8IHByaXYuc2V0dGluZ3MubWluQ29sczsgZW1wdHlDb2xzKyspIHtcbiAgICAgICAgICAgIGRhdGFtYXAuY3JlYXRlQ29sKGluc3RhbmNlLmNvdW50Q29scygpLCAxLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2hvdWxkIEkgYWRkIGVtcHR5IGNvbHMgdG8gbWVldCBtaW5TcGFyZUNvbHM/XG4gICAgICAgIGlmIChwcml2LnNldHRpbmdzLm1pblNwYXJlQ29scyAmJiAhcHJpdi5zZXR0aW5ncy5jb2x1bW5zICYmIGluc3RhbmNlLmRhdGFUeXBlID09PSAnYXJyYXknICYmXG4gICAgICAgICAgICBlbXB0eUNvbHMgPCBwcml2LnNldHRpbmdzLm1pblNwYXJlQ29scykge1xuICAgICAgICAgIGZvciAoOyBlbXB0eUNvbHMgPCBwcml2LnNldHRpbmdzLm1pblNwYXJlQ29scyAmJiBpbnN0YW5jZS5jb3VudENvbHMoKSA8IHByaXYuc2V0dGluZ3MubWF4Q29sczsgZW1wdHlDb2xzKyspIHtcbiAgICAgICAgICAgIGRhdGFtYXAuY3JlYXRlQ29sKGluc3RhbmNlLmNvdW50Q29scygpLCAxLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCByb3dDb3VudCA9IGluc3RhbmNlLmNvdW50Um93cygpO1xuICAgICAgbGV0IGNvbENvdW50ID0gaW5zdGFuY2UuY291bnRDb2xzKCk7XG5cbiAgICAgIGlmIChyb3dDb3VudCA9PT0gMCB8fCBjb2xDb3VudCA9PT0gMCkge1xuICAgICAgICBzZWxlY3Rpb24uZGVzZWxlY3QoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdGlvbi5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICAgbGV0IHNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGZyb21Sb3cgPSBwcml2LnNlbFJhbmdlLmZyb20ucm93O1xuICAgICAgICBsZXQgZnJvbUNvbCA9IHByaXYuc2VsUmFuZ2UuZnJvbS5jb2w7XG4gICAgICAgIGxldCB0b1JvdyA9IHByaXYuc2VsUmFuZ2UudG8ucm93O1xuICAgICAgICBsZXQgdG9Db2wgPSBwcml2LnNlbFJhbmdlLnRvLmNvbDtcblxuICAgICAgICAvLyBpZiBzZWxlY3Rpb24gaXMgb3V0c2lkZSwgbW92ZSBzZWxlY3Rpb24gdG8gbGFzdCByb3dcbiAgICAgICAgaWYgKGZyb21Sb3cgPiByb3dDb3VudCAtIDEpIHtcbiAgICAgICAgICBmcm9tUm93ID0gcm93Q291bnQgLSAxO1xuICAgICAgICAgIHNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHRvUm93ID4gZnJvbVJvdykge1xuICAgICAgICAgICAgdG9Sb3cgPSBmcm9tUm93O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0b1JvdyA+IHJvd0NvdW50IC0gMSkge1xuICAgICAgICAgIHRvUm93ID0gcm93Q291bnQgLSAxO1xuICAgICAgICAgIHNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKGZyb21Sb3cgPiB0b1Jvdykge1xuICAgICAgICAgICAgZnJvbVJvdyA9IHRvUm93O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBzZWxlY3Rpb24gaXMgb3V0c2lkZSwgbW92ZSBzZWxlY3Rpb24gdG8gbGFzdCByb3dcbiAgICAgICAgaWYgKGZyb21Db2wgPiBjb2xDb3VudCAtIDEpIHtcbiAgICAgICAgICBmcm9tQ29sID0gY29sQ291bnQgLSAxO1xuICAgICAgICAgIHNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHRvQ29sID4gZnJvbUNvbCkge1xuICAgICAgICAgICAgdG9Db2wgPSBmcm9tQ29sO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0b0NvbCA+IGNvbENvdW50IC0gMSkge1xuICAgICAgICAgIHRvQ29sID0gY29sQ291bnQgLSAxO1xuICAgICAgICAgIHNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKGZyb21Db2wgPiB0b0NvbCkge1xuICAgICAgICAgICAgZnJvbUNvbCA9IHRvQ29sO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxlY3Rpb25DaGFuZ2VkKSB7XG4gICAgICAgICAgaW5zdGFuY2Uuc2VsZWN0Q2VsbChmcm9tUm93LCBmcm9tQ29sLCB0b1JvdywgdG9Db2wpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaW5zdGFuY2Uudmlldykge1xuICAgICAgICBpbnN0YW5jZS52aWV3Lnd0Lnd0T3ZlcmxheXMuYWRqdXN0RWxlbWVudHNTaXplKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBvcHVsYXRlIGNlbGxzIGF0IHBvc2l0aW9uIHdpdGggMmQgYXJyYXlcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YXJ0IFN0YXJ0IHNlbGVjdGlvbiBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGlucHV0IDJkIGFycmF5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtlbmRdIEVuZCBzZWxlY3Rpb24gcG9zaXRpb24gKG9ubHkgZm9yIGRyYWctZG93biBtb2RlKVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc291cmNlPVwicG9wdWxhdGVGcm9tQXJyYXlcIl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW21ldGhvZD1cIm92ZXJ3cml0ZVwiXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24gKGxlZnR8cmlnaHR8dXB8ZG93bilcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkZWx0YXMgYXJyYXlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fHVuZGVmaW5lZH0gZW5kaW5nIHRkIGluIHBhc3RlZCBhcmVhIChvbmx5IGlmIGFueSBjZWxsIHdhcyBjaGFuZ2VkKVxuICAgICAqL1xuICAgIHBvcHVsYXRlRnJvbUFycmF5OiBmdW5jdGlvbihzdGFydCwgaW5wdXQsIGVuZCwgc291cmNlLCBtZXRob2QsIGRpcmVjdGlvbiwgZGVsdGFzKSB7XG4gICAgICB2YXIgciwgcmxlbiwgYywgY2xlbiwgc2V0RGF0YSA9IFtdLCBjdXJyZW50ID0ge307XG4gICAgICBybGVuID0gaW5wdXQubGVuZ3RoO1xuICAgICAgaWYgKHJsZW4gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVwZWF0Q29sXG4gICAgICAgICwgcmVwZWF0Um93XG4gICAgICAgICwgY21heFxuICAgICAgICAsIHJtYXg7XG5cbiAgICAgIC8vIGluc2VydCBkYXRhIHdpdGggc3BlY2lmaWVkIHBhc3RlTW9kZSBtZXRob2RcbiAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgIGNhc2UgJ3NoaWZ0X2Rvd24nIDpcbiAgICAgICAgICByZXBlYXRDb2wgPSBlbmQgPyBlbmQuY29sIC0gc3RhcnQuY29sICsgMSA6IDA7XG4gICAgICAgICAgcmVwZWF0Um93ID0gZW5kID8gZW5kLnJvdyAtIHN0YXJ0LnJvdyArIDEgOiAwO1xuICAgICAgICAgIGlucHV0ID0gdHJhbnNsYXRlUm93c1RvQ29sdW1ucyhpbnB1dCk7XG4gICAgICAgICAgZm9yIChjID0gMCwgY2xlbiA9IGlucHV0Lmxlbmd0aCwgY21heCA9IE1hdGgubWF4KGNsZW4sIHJlcGVhdENvbCk7IGMgPCBjbWF4OyBjKyspIHtcbiAgICAgICAgICAgIGlmIChjIDwgY2xlbikge1xuICAgICAgICAgICAgICBmb3IgKHIgPSAwLCBybGVuID0gaW5wdXRbY10ubGVuZ3RoOyByIDwgcmVwZWF0Um93IC0gcmxlbjsgcisrKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRbY10ucHVzaChpbnB1dFtjXVtyICUgcmxlbl0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlucHV0W2NdLnVuc2hpZnQoc3RhcnQuY29sICsgYywgc3RhcnQucm93LCAwKTtcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc3BsaWNlQ29sLmFwcGx5KGluc3RhbmNlLCBpbnB1dFtjXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaW5wdXRbYyAlIGNsZW5dWzBdID0gc3RhcnQuY29sICsgYztcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc3BsaWNlQ29sLmFwcGx5KGluc3RhbmNlLCBpbnB1dFtjICUgY2xlbl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzaGlmdF9yaWdodCcgOlxuICAgICAgICAgIHJlcGVhdENvbCA9IGVuZCA/IGVuZC5jb2wgLSBzdGFydC5jb2wgKyAxIDogMDtcbiAgICAgICAgICByZXBlYXRSb3cgPSBlbmQgPyBlbmQucm93IC0gc3RhcnQucm93ICsgMSA6IDA7XG4gICAgICAgICAgZm9yIChyID0gMCwgcmxlbiA9IGlucHV0Lmxlbmd0aCwgcm1heCA9IE1hdGgubWF4KHJsZW4sIHJlcGVhdFJvdyk7IHIgPCBybWF4OyByKyspIHtcbiAgICAgICAgICAgIGlmIChyIDwgcmxlbikge1xuICAgICAgICAgICAgICBmb3IgKGMgPSAwLCBjbGVuID0gaW5wdXRbcl0ubGVuZ3RoOyBjIDwgcmVwZWF0Q29sIC0gY2xlbjsgYysrKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRbcl0ucHVzaChpbnB1dFtyXVtjICUgY2xlbl0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlucHV0W3JdLnVuc2hpZnQoc3RhcnQucm93ICsgciwgc3RhcnQuY29sLCAwKTtcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc3BsaWNlUm93LmFwcGx5KGluc3RhbmNlLCBpbnB1dFtyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaW5wdXRbciAlIHJsZW5dWzBdID0gc3RhcnQucm93ICsgcjtcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc3BsaWNlUm93LmFwcGx5KGluc3RhbmNlLCBpbnB1dFtyICUgcmxlbl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gICAgICAgIGNhc2UgJ292ZXJ3cml0ZSc6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cbiAgICAgICAgICAvLyBvdmVyd3JpdGUgYW5kIG90aGVyIG5vdCBzcGVjaWZpZWQgb3B0aW9uc1xuICAgICAgICAgIGN1cnJlbnQucm93ID0gc3RhcnQucm93O1xuICAgICAgICAgIGN1cnJlbnQuY29sID0gc3RhcnQuY29sO1xuXG4gICAgICAgICAgdmFyIGl0ZXJhdG9ycyA9IHtyb3c6IDAsIGNvbDogMH0sIC8vIG51bWJlciBvZiBwYWNrYWdlc1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSB7IC8vIHNlbGVjdGVkIHJhbmdlXG4gICAgICAgICAgICAgIHJvdzogKGVuZCAmJiBzdGFydCkgPyAoZW5kLnJvdyAtIHN0YXJ0LnJvdyArIDEpIDogMSxcbiAgICAgICAgICAgICAgY29sOiAoZW5kICYmIHN0YXJ0KSA/IChlbmQuY29sIC0gc3RhcnQuY29sICsgMSkgOiAxXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHVzaERhdGEgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKFsndXAnLCAnbGVmdCddLmluZGV4T2YoZGlyZWN0aW9uKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9ycyA9IHtcbiAgICAgICAgICAgICAgcm93OiBNYXRoLmNlaWwoc2VsZWN0ZWQucm93IC8gcmxlbikgfHwgMSxcbiAgICAgICAgICAgICAgY29sOiBNYXRoLmNlaWwoc2VsZWN0ZWQuY29sIC8gaW5wdXRbMF0ubGVuZ3RoKSB8fCAxXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSBpZiAoWydkb3duJywgJ3JpZ2h0J10uaW5kZXhPZihkaXJlY3Rpb24pICE9PSAtMSkge1xuICAgICAgICAgICAgaXRlcmF0b3JzID0ge1xuICAgICAgICAgICAgICByb3c6IDEsXG4gICAgICAgICAgICAgIGNvbDogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cblxuICAgICAgICAgIGZvciAociA9IDA7IHIgPCBybGVuOyByKyspIHtcbiAgICAgICAgICAgIGlmICgoZW5kICYmIGN1cnJlbnQucm93ID4gZW5kLnJvdykgfHwgKCFwcml2LnNldHRpbmdzLmFsbG93SW5zZXJ0Um93ICYmIGN1cnJlbnQucm93ID4gaW5zdGFuY2UuY291bnRSb3dzKCkgLSAxKSB8fCAoY3VycmVudC5yb3cgPj0gcHJpdi5zZXR0aW5ncy5tYXhSb3dzKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQuY29sID0gc3RhcnQuY29sO1xuICAgICAgICAgICAgY2xlbiA9IGlucHV0W3JdID8gaW5wdXRbcl0ubGVuZ3RoIDogMDtcbiAgICAgICAgICAgIGZvciAoYyA9IDA7IGMgPCBjbGVuOyBjKyspIHtcbiAgICAgICAgICAgICAgaWYgKChlbmQgJiYgY3VycmVudC5jb2wgPiBlbmQuY29sKSB8fCAoIXByaXYuc2V0dGluZ3MuYWxsb3dJbnNlcnRDb2x1bW4gJiYgY3VycmVudC5jb2wgPiBpbnN0YW5jZS5jb3VudENvbHMoKSAtIDEpIHx8IChjdXJyZW50LmNvbCA+PSBwcml2LnNldHRpbmdzLm1heENvbHMpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWluc3RhbmNlLmdldENlbGxNZXRhKGN1cnJlbnQucm93LCBjdXJyZW50LmNvbCkucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpbnB1dFtyXVtjXSxcbiAgICAgICAgICAgICAgICAgIG9yZ1ZhbHVlID0gaW5zdGFuY2UuZ2V0RGF0YUF0Q2VsbChjdXJyZW50LnJvdywgY3VycmVudC5jb2wpLFxuICAgICAgICAgICAgICAgICAgaW5kZXggPSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdzogcixcbiAgICAgICAgICAgICAgICAgICAgY29sOiBjXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgdmFsdWVTY2hlbWEsXG4gICAgICAgICAgICAgICAgICBvcmdWYWx1ZVNjaGVtYTtcblxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UgPT09ICdhdXRvZmlsbCcpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGluc3RhbmNlLnJ1bkhvb2tzKCdiZWZvcmVBdXRvZmlsbEluc2lkZVBvcHVsYXRlJywgaW5kZXgsIGRpcmVjdGlvbiwgaW5wdXQsIGRlbHRhcywgaXRlcmF0b3JzLCBzZWxlY3RlZCk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3JzID0gdHlwZW9mKHJlc3VsdC5pdGVyYXRvcnMpICE9PSAndW5kZWZpbmVkJyA/IHJlc3VsdC5pdGVyYXRvcnMgOiBpdGVyYXRvcnM7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdHlwZW9mKHJlc3VsdC52YWx1ZSkgIT09ICd1bmRlZmluZWQnID8gcmVzdWx0LnZhbHVlIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICBpZiAob3JnVmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIG9yZ1ZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBwdXNoRGF0YSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcmdWYWx1ZVNjaGVtYSA9IGR1Y2tTY2hlbWEob3JnVmFsdWVbMF0gfHwgb3JnVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVNjaGVtYSA9IGR1Y2tTY2hlbWEodmFsdWVbMF0gfHwgdmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8qIGpzaGludCAtVzA3MyAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3RFcXVhbHMob3JnVmFsdWVTY2hlbWEsIHZhbHVlU2NoZW1hKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZGVlcENsb25lKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBwdXNoRGF0YSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9yZ1ZhbHVlICE9PSBudWxsICYmIHR5cGVvZiBvcmdWYWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgIHB1c2hEYXRhID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwdXNoRGF0YSkge1xuICAgICAgICAgICAgICAgICAgc2V0RGF0YS5wdXNoKFtjdXJyZW50LnJvdywgY3VycmVudC5jb2wsIHZhbHVlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHB1c2hEYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGN1cnJlbnQuY29sKys7XG5cbiAgICAgICAgICAgICAgaWYgKGVuZCAmJiBjID09PSBjbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgIGMgPSAtMTtcblxuICAgICAgICAgICAgICAgIGlmIChbJ2Rvd24nLCAncmlnaHQnXS5pbmRleE9mKGRpcmVjdGlvbikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICBpdGVyYXRvcnMuY29sKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChbJ3VwJywgJ2xlZnQnXS5pbmRleE9mKGRpcmVjdGlvbikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaXRlcmF0b3JzLmNvbCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3JzLmNvbC0tO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnQucm93Kys7XG4gICAgICAgICAgICBpdGVyYXRvcnMuY29sID0gMTtcblxuICAgICAgICAgICAgaWYgKGVuZCAmJiByID09PSBybGVuIC0gMSkge1xuICAgICAgICAgICAgICByID0gLTE7XG5cbiAgICAgICAgICAgICAgaWYgKFsnZG93bicsICdyaWdodCddLmluZGV4T2YoZGlyZWN0aW9uKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvcnMucm93Kys7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoWyd1cCcsICdsZWZ0J10uaW5kZXhPZihkaXJlY3Rpb24pICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVyYXRvcnMucm93ID4gMSkge1xuICAgICAgICAgICAgICAgICAgaXRlcmF0b3JzLnJvdy0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGluc3RhbmNlLnNldERhdGFBdENlbGwoc2V0RGF0YSwgbnVsbCwgbnVsbCwgc291cmNlIHx8ICdwb3B1bGF0ZUZyb21BcnJheScpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbiA9IHsgLy90aGlzIHB1YmxpYyBhc3NpZ25tZW50IGlzIG9ubHkgdGVtcG9yYXJ5XG4gICAgaW5Qcm9ncmVzczogZmFsc2UsXG5cbiAgICBzZWxlY3RlZEhlYWRlcjoge1xuICAgICAgY29sczogZmFsc2UsXG4gICAgICByb3dzOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJvd3NcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbHNcbiAgICAgKi9cbiAgICBzZXRTZWxlY3RlZEhlYWRlcnM6IGZ1bmN0aW9uKHJvd3MsIGNvbHMpIHtcbiAgICAgIGluc3RhbmNlLnNlbGVjdGlvbi5zZWxlY3RlZEhlYWRlci5yb3dzID0gcm93cztcbiAgICAgIGluc3RhbmNlLnNlbGVjdGlvbi5zZWxlY3RlZEhlYWRlci5jb2xzID0gY29scztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBpblByb2dyZXNzIHRvIGB0cnVlYC4gVGhpcyBlbmFibGVzIG9uU2VsZWN0aW9uRW5kIGFuZCBvblNlbGVjdGlvbkVuZEJ5UHJvcCB0byBmdW5jdGlvbiBhcyBkZXNpcmVkLlxuICAgICAqL1xuICAgIGJlZ2luOiBmdW5jdGlvbigpIHtcbiAgICAgIGluc3RhbmNlLnNlbGVjdGlvbi5pblByb2dyZXNzID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBpblByb2dyZXNzIHRvIGBmYWxzZWAuIFRyaWdnZXJzIG9uU2VsZWN0aW9uRW5kIGFuZCBvblNlbGVjdGlvbkVuZEJ5UHJvcC5cbiAgICAgKi9cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbCA9IGluc3RhbmNlLmdldFNlbGVjdGVkKCk7XG4gICAgICBIYW5kc29udGFibGUuaG9va3MucnVuKGluc3RhbmNlLCBcImFmdGVyU2VsZWN0aW9uRW5kXCIsIHNlbFswXSwgc2VsWzFdLCBzZWxbMl0sIHNlbFszXSk7XG4gICAgICBIYW5kc29udGFibGUuaG9va3MucnVuKGluc3RhbmNlLCBcImFmdGVyU2VsZWN0aW9uRW5kQnlQcm9wXCIsIHNlbFswXSwgaW5zdGFuY2UuY29sVG9Qcm9wKHNlbFsxXSksIHNlbFsyXSwgaW5zdGFuY2UuY29sVG9Qcm9wKHNlbFszXSkpO1xuICAgICAgaW5zdGFuY2Uuc2VsZWN0aW9uLmluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNJblByb2dyZXNzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS5zZWxlY3Rpb24uaW5Qcm9ncmVzcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3RhcnRzIHNlbGVjdGlvbiByYW5nZSBvbiBnaXZlbiB0ZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dhbGtvbnRhYmxlQ2VsbENvb3Jkc30gY29vcmRzXG4gICAgICogQHBhcmFtIGtlZXBFZGl0b3JPcGVuZWRcbiAgICAgKi9cbiAgICBzZXRSYW5nZVN0YXJ0OiBmdW5jdGlvbihjb29yZHMsIGtlZXBFZGl0b3JPcGVuZWQpIHtcbiAgICAgIEhhbmRzb250YWJsZS5ob29rcy5ydW4oaW5zdGFuY2UsIFwiYmVmb3JlU2V0UmFuZ2VTdGFydFwiLCBjb29yZHMpO1xuICAgICAgcHJpdi5zZWxSYW5nZSA9IG5ldyBXYWxrb250YWJsZUNlbGxSYW5nZShjb29yZHMsIGNvb3JkcywgY29vcmRzKTtcbiAgICAgIHNlbGVjdGlvbi5zZXRSYW5nZUVuZChjb29yZHMsIG51bGwsIGtlZXBFZGl0b3JPcGVuZWQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbmRzIHNlbGVjdGlvbiByYW5nZSBvbiBnaXZlbiB0ZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dhbGtvbnRhYmxlQ2VsbENvb3Jkc30gY29vcmRzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2Nyb2xsVG9DZWxsPXRydWVdIElmIGB0cnVlYCwgdmlld3BvcnQgd2lsbCBiZSBzY3JvbGxlZCB0byByYW5nZSBlbmRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtrZWVwRWRpdG9yT3BlbmVkXSBJZiBgdHJ1ZWAsIGNlbGwgZWRpdG9yIHdpbGwgYmUgc3RpbGwgb3BlbmVkIGFmdGVyIGNoYW5naW5nIHNlbGVjdGlvbiByYW5nZVxuICAgICAqL1xuICAgIHNldFJhbmdlRW5kOiBmdW5jdGlvbihjb29yZHMsIHNjcm9sbFRvQ2VsbCwga2VlcEVkaXRvck9wZW5lZCkge1xuICAgICAgaWYgKHByaXYuc2VsUmFuZ2UgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGRpc2FibGVWaXN1YWxTZWxlY3Rpb24sXG4gICAgICAgIGlzSGVhZGVyU2VsZWN0ZWQgPSBmYWxzZSxcbiAgICAgICAgYXJlQ29vcmRzUG9zaXRpdmUgPSB0cnVlO1xuXG4gICAgICB2YXIgZmlyc3RWaXNpYmxlUm93ID0gaW5zdGFuY2Uudmlldy53dC53dFRhYmxlLmdldEZpcnN0VmlzaWJsZVJvdygpO1xuICAgICAgdmFyIGZpcnN0VmlzaWJsZUNvbHVtbiA9IGluc3RhbmNlLnZpZXcud3Qud3RUYWJsZS5nZXRGaXJzdFZpc2libGVDb2x1bW4oKTtcbiAgICAgIHZhciBuZXdSYW5nZUNvb3JkcyA9IHtcbiAgICAgICAgcm93OiBudWxsLFxuICAgICAgICBjb2w6IG51bGxcbiAgICAgIH07XG5cbiAgICAgIC8vdHJpZ2dlciBoYW5kbGVyc1xuICAgICAgSGFuZHNvbnRhYmxlLmhvb2tzLnJ1bihpbnN0YW5jZSwgXCJiZWZvcmVTZXRSYW5nZUVuZFwiLCBjb29yZHMpO1xuICAgICAgaW5zdGFuY2Uuc2VsZWN0aW9uLmJlZ2luKCk7XG5cbiAgICAgIG5ld1JhbmdlQ29vcmRzLnJvdyA9IGNvb3Jkcy5yb3cgPCAwID8gZmlyc3RWaXNpYmxlUm93IDogY29vcmRzLnJvdztcbiAgICAgIG5ld1JhbmdlQ29vcmRzLmNvbCA9IGNvb3Jkcy5jb2wgPCAwID8gZmlyc3RWaXNpYmxlQ29sdW1uIDogY29vcmRzLmNvbDtcblxuICAgICAgcHJpdi5zZWxSYW5nZS50byA9IG5ldyBXYWxrb250YWJsZUNlbGxDb29yZHMobmV3UmFuZ2VDb29yZHMucm93LCBuZXdSYW5nZUNvb3Jkcy5jb2wpO1xuXG4gICAgICBpZiAoIXByaXYuc2V0dGluZ3MubXVsdGlTZWxlY3QpIHtcbiAgICAgICAgcHJpdi5zZWxSYW5nZS5mcm9tID0gY29vcmRzO1xuICAgICAgfVxuICAgICAgLy8gc2V0IHVwIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICBpbnN0YW5jZS52aWV3Lnd0LnNlbGVjdGlvbnMuY3VycmVudC5jbGVhcigpO1xuXG4gICAgICBkaXNhYmxlVmlzdWFsU2VsZWN0aW9uID0gaW5zdGFuY2UuZ2V0Q2VsbE1ldGEocHJpdi5zZWxSYW5nZS5oaWdobGlnaHQucm93LCBwcml2LnNlbFJhbmdlLmhpZ2hsaWdodC5jb2wpLmRpc2FibGVWaXN1YWxTZWxlY3Rpb247XG5cbiAgICAgIGlmICh0eXBlb2YgZGlzYWJsZVZpc3VhbFNlbGVjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGlzYWJsZVZpc3VhbFNlbGVjdGlvbiA9IFtkaXNhYmxlVmlzdWFsU2VsZWN0aW9uXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpc2FibGVWaXN1YWxTZWxlY3Rpb24gPT09IGZhbHNlIHx8XG4gICAgICAgICAgQXJyYXkuaXNBcnJheShkaXNhYmxlVmlzdWFsU2VsZWN0aW9uKSAmJiBkaXNhYmxlVmlzdWFsU2VsZWN0aW9uLmluZGV4T2YoJ2N1cnJlbnQnKSA9PT0gLTEpIHtcbiAgICAgICAgaW5zdGFuY2Uudmlldy53dC5zZWxlY3Rpb25zLmN1cnJlbnQuYWRkKHByaXYuc2VsUmFuZ2UuaGlnaGxpZ2h0KTtcbiAgICAgIH1cbiAgICAgIC8vIHNldCB1cCBhcmVhIHNlbGVjdGlvblxuICAgICAgaW5zdGFuY2Uudmlldy53dC5zZWxlY3Rpb25zLmFyZWEuY2xlYXIoKTtcblxuICAgICAgaWYgKChkaXNhYmxlVmlzdWFsU2VsZWN0aW9uID09PSBmYWxzZSB8fFxuICAgICAgICAgIEFycmF5LmlzQXJyYXkoZGlzYWJsZVZpc3VhbFNlbGVjdGlvbikgJiYgZGlzYWJsZVZpc3VhbFNlbGVjdGlvbi5pbmRleE9mKCdhcmVhJykgPT09IC0xKSAmJlxuICAgICAgICAgIHNlbGVjdGlvbi5pc011bHRpcGxlKCkpIHtcbiAgICAgICAgaW5zdGFuY2Uudmlldy53dC5zZWxlY3Rpb25zLmFyZWEuYWRkKHByaXYuc2VsUmFuZ2UuZnJvbSk7XG4gICAgICAgIGluc3RhbmNlLnZpZXcud3Quc2VsZWN0aW9ucy5hcmVhLmFkZChwcml2LnNlbFJhbmdlLnRvKTtcbiAgICAgIH1cbiAgICAgIC8vIHNldCB1cCBoaWdobGlnaHRcbiAgICAgIGlmIChwcml2LnNldHRpbmdzLmN1cnJlbnRSb3dDbGFzc05hbWUgfHwgcHJpdi5zZXR0aW5ncy5jdXJyZW50Q29sQ2xhc3NOYW1lKSB7XG4gICAgICAgIGluc3RhbmNlLnZpZXcud3Quc2VsZWN0aW9ucy5oaWdobGlnaHQuY2xlYXIoKTtcbiAgICAgICAgaW5zdGFuY2Uudmlldy53dC5zZWxlY3Rpb25zLmhpZ2hsaWdodC5hZGQocHJpdi5zZWxSYW5nZS5mcm9tKTtcbiAgICAgICAgaW5zdGFuY2Uudmlldy53dC5zZWxlY3Rpb25zLmhpZ2hsaWdodC5hZGQocHJpdi5zZWxSYW5nZS50byk7XG4gICAgICB9XG5cbiAgICAgIC8vIHRyaWdnZXIgaGFuZGxlcnNcbiAgICAgIEhhbmRzb250YWJsZS5ob29rcy5ydW4oaW5zdGFuY2UsIFwiYWZ0ZXJTZWxlY3Rpb25cIixcbiAgICAgICAgcHJpdi5zZWxSYW5nZS5mcm9tLnJvdywgcHJpdi5zZWxSYW5nZS5mcm9tLmNvbCwgcHJpdi5zZWxSYW5nZS50by5yb3csIHByaXYuc2VsUmFuZ2UudG8uY29sKTtcbiAgICAgIEhhbmRzb250YWJsZS5ob29rcy5ydW4oaW5zdGFuY2UsIFwiYWZ0ZXJTZWxlY3Rpb25CeVByb3BcIixcbiAgICAgICAgcHJpdi5zZWxSYW5nZS5mcm9tLnJvdywgZGF0YW1hcC5jb2xUb1Byb3AocHJpdi5zZWxSYW5nZS5mcm9tLmNvbCksIHByaXYuc2VsUmFuZ2UudG8ucm93LCBkYXRhbWFwLmNvbFRvUHJvcChwcml2LnNlbFJhbmdlLnRvLmNvbCkpO1xuXG4gICAgICBpZiAoKHByaXYuc2VsUmFuZ2UuZnJvbS5yb3cgPT09IDAgJiYgcHJpdi5zZWxSYW5nZS50by5yb3cgPT09IGluc3RhbmNlLmNvdW50Um93cygpIC0gMSAmJiBpbnN0YW5jZS5jb3VudFJvd3MoKSA+IDEpIHx8XG4gICAgICAgICAgKHByaXYuc2VsUmFuZ2UuZnJvbS5jb2wgPT09IDAgJiYgcHJpdi5zZWxSYW5nZS50by5jb2wgPT09IGluc3RhbmNlLmNvdW50Q29scygpIC0gMSAmJiBpbnN0YW5jZS5jb3VudENvbHMoKSA+IDEpKSB7XG4gICAgICAgIGlzSGVhZGVyU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29vcmRzLnJvdyA8IDAgfHwgY29vcmRzLmNvbCA8IDApIHtcbiAgICAgICAgYXJlQ29vcmRzUG9zaXRpdmUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNjcm9sbFRvQ2VsbCAhPT0gZmFsc2UgJiYgIWlzSGVhZGVyU2VsZWN0ZWQgJiYgYXJlQ29vcmRzUG9zaXRpdmUpIHtcbiAgICAgICAgaWYgKHByaXYuc2VsUmFuZ2UuZnJvbSAmJiAhc2VsZWN0aW9uLmlzTXVsdGlwbGUoKSkge1xuICAgICAgICAgIGluc3RhbmNlLnZpZXcuc2Nyb2xsVmlld3BvcnQocHJpdi5zZWxSYW5nZS5mcm9tKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnN0YW5jZS52aWV3LnNjcm9sbFZpZXdwb3J0KGNvb3Jkcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNlbGVjdGlvbi5yZWZyZXNoQm9yZGVycyhudWxsLCBrZWVwRWRpdG9yT3BlbmVkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgZWRpdG9yLCByZWRyYXdzIGJvcmRlcnMgYXJvdW5kIGNlbGxzLCBwcmVwYXJlcyBlZGl0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZXZlcnRPcmlnaW5hbF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtrZWVwRWRpdG9yXVxuICAgICAqL1xuICAgIHJlZnJlc2hCb3JkZXJzOiBmdW5jdGlvbihyZXZlcnRPcmlnaW5hbCwga2VlcEVkaXRvcikge1xuICAgICAgaWYgKCFrZWVwRWRpdG9yKSB7XG4gICAgICAgIGVkaXRvck1hbmFnZXIuZGVzdHJveUVkaXRvcihyZXZlcnRPcmlnaW5hbCk7XG4gICAgICB9XG4gICAgICBpbnN0YW5jZS52aWV3LnJlbmRlcigpO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uLmlzU2VsZWN0ZWQoKSAmJiAha2VlcEVkaXRvcikge1xuICAgICAgICBlZGl0b3JNYW5hZ2VyLnByZXBhcmVFZGl0b3IoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBpZiB3ZSBoYXZlIGEgbXVsdGlzZWxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc011bHRpcGxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpc011bHRpcGxlID0gIShwcml2LnNlbFJhbmdlLnRvLmNvbCA9PT0gcHJpdi5zZWxSYW5nZS5mcm9tLmNvbCAmJiBwcml2LnNlbFJhbmdlLnRvLnJvdyA9PT0gcHJpdi5zZWxSYW5nZS5mcm9tLnJvdylcbiAgICAgICAgLCBtb2RpZmllciA9IEhhbmRzb250YWJsZS5ob29rcy5ydW4oaW5zdGFuY2UsICdhZnRlcklzTXVsdGlwbGVTZWxlY3Rpb24nLCBpc011bHRpcGxlKTtcblxuICAgICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgICAgcmV0dXJuIG1vZGlmaWVyO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIGNlbGwgcmVsYXRpdmUgdG8gY3VycmVudCBjZWxsIChpZiBwb3NzaWJsZSkuXG4gICAgICovXG4gICAgdHJhbnNmb3JtU3RhcnQ6IGZ1bmN0aW9uKHJvd0RlbHRhLCBjb2xEZWx0YSwgZm9yY2UsIGtlZXBFZGl0b3JPcGVuZWQpIHtcbiAgICAgIHZhciBkZWx0YSA9IG5ldyBXYWxrb250YWJsZUNlbGxDb29yZHMocm93RGVsdGEsIGNvbERlbHRhKSxcbiAgICAgICAgcm93VHJhbnNmb3JtRGlyID0gMCxcbiAgICAgICAgY29sVHJhbnNmb3JtRGlyID0gMCxcbiAgICAgICAgdG90YWxSb3dzLFxuICAgICAgICB0b3RhbENvbHMsXG4gICAgICAgIGNvb3JkcztcblxuICAgICAgaW5zdGFuY2UucnVuSG9va3MoJ21vZGlmeVRyYW5zZm9ybVN0YXJ0JywgZGVsdGEpO1xuICAgICAgdG90YWxSb3dzID0gaW5zdGFuY2UuY291bnRSb3dzKCk7XG4gICAgICB0b3RhbENvbHMgPSBpbnN0YW5jZS5jb3VudENvbHMoKTtcblxuICAgICAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuICAgICAgaWYgKHByaXYuc2VsUmFuZ2UuaGlnaGxpZ2h0LnJvdyArIHJvd0RlbHRhID4gdG90YWxSb3dzIC0gMSkge1xuICAgICAgICBpZiAoZm9yY2UgJiYgcHJpdi5zZXR0aW5ncy5taW5TcGFyZVJvd3MgPiAwKSB7XG4gICAgICAgICAgaW5zdGFuY2UuYWx0ZXIoXCJpbnNlcnRfcm93XCIsIHRvdGFsUm93cyk7XG4gICAgICAgICAgdG90YWxSb3dzID0gaW5zdGFuY2UuY291bnRSb3dzKCk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChwcml2LnNldHRpbmdzLmF1dG9XcmFwQ29sKSB7XG4gICAgICAgICAgZGVsdGEucm93ID0gMSAtIHRvdGFsUm93cztcbiAgICAgICAgICBkZWx0YS5jb2wgPSBwcml2LnNlbFJhbmdlLmhpZ2hsaWdodC5jb2wgKyBkZWx0YS5jb2wgPT0gdG90YWxDb2xzIC0gMSA/IDEgLSB0b3RhbENvbHMgOiAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByaXYuc2V0dGluZ3MuYXV0b1dyYXBDb2wgJiYgcHJpdi5zZWxSYW5nZS5oaWdobGlnaHQucm93ICsgZGVsdGEucm93IDwgMCAmJiBwcml2LnNlbFJhbmdlLmhpZ2hsaWdodC5jb2wgKyBkZWx0YS5jb2wgPj0gMCkge1xuICAgICAgICBkZWx0YS5yb3cgPSB0b3RhbFJvd3MgLSAxO1xuICAgICAgICBkZWx0YS5jb2wgPSBwcml2LnNlbFJhbmdlLmhpZ2hsaWdodC5jb2wgKyBkZWx0YS5jb2wgPT0gMCA/IHRvdGFsQ29scyAtIDEgOiAtMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByaXYuc2VsUmFuZ2UuaGlnaGxpZ2h0LmNvbCArIGRlbHRhLmNvbCA+IHRvdGFsQ29scyAtIDEpIHtcbiAgICAgICAgaWYgKGZvcmNlICYmIHByaXYuc2V0dGluZ3MubWluU3BhcmVDb2xzID4gMCkge1xuICAgICAgICAgIGluc3RhbmNlLmFsdGVyKFwiaW5zZXJ0X2NvbFwiLCB0b3RhbENvbHMpO1xuICAgICAgICAgIHRvdGFsQ29scyA9IGluc3RhbmNlLmNvdW50Q29scygpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAocHJpdi5zZXR0aW5ncy5hdXRvV3JhcFJvdykge1xuICAgICAgICAgIGRlbHRhLnJvdyA9IHByaXYuc2VsUmFuZ2UuaGlnaGxpZ2h0LnJvdyArIGRlbHRhLnJvdyA9PSB0b3RhbFJvd3MgLSAxID8gMSAtIHRvdGFsUm93cyA6IDE7XG4gICAgICAgICAgZGVsdGEuY29sID0gMSAtIHRvdGFsQ29scztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcml2LnNldHRpbmdzLmF1dG9XcmFwUm93ICYmIHByaXYuc2VsUmFuZ2UuaGlnaGxpZ2h0LmNvbCArIGRlbHRhLmNvbCA8IDAgJiYgcHJpdi5zZWxSYW5nZS5oaWdobGlnaHQucm93ICsgZGVsdGEucm93ID49IDApIHtcbiAgICAgICAgZGVsdGEucm93ID0gcHJpdi5zZWxSYW5nZS5oaWdobGlnaHQucm93ICsgZGVsdGEucm93ID09IDAgPyB0b3RhbFJvd3MgLSAxIDogLTE7XG4gICAgICAgIGRlbHRhLmNvbCA9IHRvdGFsQ29scyAtIDE7XG4gICAgICB9XG4gICAgICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG4gICAgICBjb29yZHMgPSBuZXcgV2Fsa29udGFibGVDZWxsQ29vcmRzKHByaXYuc2VsUmFuZ2UuaGlnaGxpZ2h0LnJvdyArIGRlbHRhLnJvdywgcHJpdi5zZWxSYW5nZS5oaWdobGlnaHQuY29sICsgZGVsdGEuY29sKTtcblxuICAgICAgaWYgKGNvb3Jkcy5yb3cgPCAwKSB7XG4gICAgICAgIHJvd1RyYW5zZm9ybURpciA9IC0xO1xuICAgICAgICBjb29yZHMucm93ID0gMDtcblxuICAgICAgfSBlbHNlIGlmIChjb29yZHMucm93ID4gMCAmJiBjb29yZHMucm93ID49IHRvdGFsUm93cykge1xuICAgICAgICByb3dUcmFuc2Zvcm1EaXIgPSAxO1xuICAgICAgICBjb29yZHMucm93ID0gdG90YWxSb3dzIC0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvb3Jkcy5jb2wgPCAwKSB7XG4gICAgICAgIGNvbFRyYW5zZm9ybURpciA9IC0xO1xuICAgICAgICBjb29yZHMuY29sID0gMDtcblxuICAgICAgfSBlbHNlIGlmIChjb29yZHMuY29sID4gMCAmJiBjb29yZHMuY29sID49IHRvdGFsQ29scykge1xuICAgICAgICBjb2xUcmFuc2Zvcm1EaXIgPSAxO1xuICAgICAgICBjb29yZHMuY29sID0gdG90YWxDb2xzIC0gMTtcbiAgICAgIH1cbiAgICAgIGluc3RhbmNlLnJ1bkhvb2tzKCdhZnRlck1vZGlmeVRyYW5zZm9ybVN0YXJ0JywgY29vcmRzLCByb3dUcmFuc2Zvcm1EaXIsIGNvbFRyYW5zZm9ybURpcik7XG4gICAgICBzZWxlY3Rpb24uc2V0UmFuZ2VTdGFydChjb29yZHMsIGtlZXBFZGl0b3JPcGVuZWQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNlbGVjdGlvbiBlbmQgY2VsbCByZWxhdGl2ZSB0byBjdXJyZW50IHNlbGVjdGlvbiBlbmQgY2VsbCAoaWYgcG9zc2libGUpLlxuICAgICAqL1xuICAgIHRyYW5zZm9ybUVuZDogZnVuY3Rpb24ocm93RGVsdGEsIGNvbERlbHRhKSB7XG4gICAgICB2YXIgZGVsdGEgPSBuZXcgV2Fsa29udGFibGVDZWxsQ29vcmRzKHJvd0RlbHRhLCBjb2xEZWx0YSksXG4gICAgICAgIHJvd1RyYW5zZm9ybURpciA9IDAsXG4gICAgICAgIGNvbFRyYW5zZm9ybURpciA9IDAsXG4gICAgICAgIHRvdGFsUm93cyxcbiAgICAgICAgdG90YWxDb2xzLFxuICAgICAgICBjb29yZHM7XG5cbiAgICAgIGluc3RhbmNlLnJ1bkhvb2tzKCdtb2RpZnlUcmFuc2Zvcm1FbmQnLCBkZWx0YSk7XG5cbiAgICAgIHRvdGFsUm93cyA9IGluc3RhbmNlLmNvdW50Um93cygpO1xuICAgICAgdG90YWxDb2xzID0gaW5zdGFuY2UuY291bnRDb2xzKCk7XG4gICAgICBjb29yZHMgPSBuZXcgV2Fsa29udGFibGVDZWxsQ29vcmRzKHByaXYuc2VsUmFuZ2UudG8ucm93ICsgZGVsdGEucm93LCBwcml2LnNlbFJhbmdlLnRvLmNvbCArIGRlbHRhLmNvbCk7XG5cbiAgICAgIGlmIChjb29yZHMucm93IDwgMCkge1xuICAgICAgICByb3dUcmFuc2Zvcm1EaXIgPSAtMTtcbiAgICAgICAgY29vcmRzLnJvdyA9IDA7XG5cbiAgICAgIH0gZWxzZSBpZiAoY29vcmRzLnJvdyA+IDAgJiYgY29vcmRzLnJvdyA+PSB0b3RhbFJvd3MpIHtcbiAgICAgICAgcm93VHJhbnNmb3JtRGlyID0gMTtcbiAgICAgICAgY29vcmRzLnJvdyA9IHRvdGFsUm93cyAtIDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb29yZHMuY29sIDwgMCkge1xuICAgICAgICBjb2xUcmFuc2Zvcm1EaXIgPSAtMTtcbiAgICAgICAgY29vcmRzLmNvbCA9IDA7XG5cbiAgICAgIH0gZWxzZSBpZiAoY29vcmRzLmNvbCA+IDAgJiYgY29vcmRzLmNvbCA+PSB0b3RhbENvbHMpIHtcbiAgICAgICAgY29sVHJhbnNmb3JtRGlyID0gMTtcbiAgICAgICAgY29vcmRzLmNvbCA9IHRvdGFsQ29scyAtIDE7XG4gICAgICB9XG4gICAgICBpbnN0YW5jZS5ydW5Ib29rcygnYWZ0ZXJNb2RpZnlUcmFuc2Zvcm1FbmQnLCBjb29yZHMsIHJvd1RyYW5zZm9ybURpciwgY29sVHJhbnNmb3JtRGlyKTtcbiAgICAgIHNlbGVjdGlvbi5zZXRSYW5nZUVuZChjb29yZHMsIHRydWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiBjdXJyZW50bHkgdGhlcmUgaXMgYSBzZWxlY3Rpb24gb24gc2NyZWVuLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChwcml2LnNlbFJhbmdlICE9PSBudWxsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgY29vcmRzIGlzIHdpdGhpbiBjdXJyZW50IHNlbGVjdGlvbiBjb29yZHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1dhbGtvbnRhYmxlQ2VsbENvb3Jkc30gY29vcmRzXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaW5JblNlbGVjdGlvbjogZnVuY3Rpb24oY29vcmRzKSB7XG4gICAgICBpZiAoIXNlbGVjdGlvbi5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByaXYuc2VsUmFuZ2UuaW5jbHVkZXMoY29vcmRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVzZWxlY3RzIGFsbCBzZWxlY3RlZCBjZWxsc1xuICAgICAqL1xuICAgIGRlc2VsZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghc2VsZWN0aW9uLmlzU2VsZWN0ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpbnN0YW5jZS5zZWxlY3Rpb24uaW5Qcm9ncmVzcyA9IGZhbHNlOyAvL25lZWRlZCBieSBIVCBpbmNlcHRpb25cbiAgICAgIHByaXYuc2VsUmFuZ2UgPSBudWxsO1xuICAgICAgaW5zdGFuY2Uudmlldy53dC5zZWxlY3Rpb25zLmN1cnJlbnQuY2xlYXIoKTtcbiAgICAgIGluc3RhbmNlLnZpZXcud3Quc2VsZWN0aW9ucy5hcmVhLmNsZWFyKCk7XG4gICAgICBpZiAocHJpdi5zZXR0aW5ncy5jdXJyZW50Um93Q2xhc3NOYW1lIHx8IHByaXYuc2V0dGluZ3MuY3VycmVudENvbENsYXNzTmFtZSkge1xuICAgICAgICBpbnN0YW5jZS52aWV3Lnd0LnNlbGVjdGlvbnMuaGlnaGxpZ2h0LmNsZWFyKCk7XG4gICAgICB9XG4gICAgICBlZGl0b3JNYW5hZ2VyLmRlc3Ryb3lFZGl0b3IoKTtcbiAgICAgIHNlbGVjdGlvbi5yZWZyZXNoQm9yZGVycygpO1xuICAgICAgSGFuZHNvbnRhYmxlLmhvb2tzLnJ1bihpbnN0YW5jZSwgJ2FmdGVyRGVzZWxlY3QnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IGFsbCBjZWxsc1xuICAgICAqL1xuICAgIHNlbGVjdEFsbDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXByaXYuc2V0dGluZ3MubXVsdGlTZWxlY3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VsZWN0aW9uLnNldFJhbmdlU3RhcnQobmV3IFdhbGtvbnRhYmxlQ2VsbENvb3JkcygwLCAwKSk7XG4gICAgICBzZWxlY3Rpb24uc2V0UmFuZ2VFbmQobmV3IFdhbGtvbnRhYmxlQ2VsbENvb3JkcyhpbnN0YW5jZS5jb3VudFJvd3MoKSAtIDEsIGluc3RhbmNlLmNvdW50Q29scygpIC0gMSksIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBkYXRhIGZyb20gc2VsZWN0ZWQgY2VsbHNcbiAgICAgKi9cbiAgICBlbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXNlbGVjdGlvbi5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHRvcExlZnQgPSBwcml2LnNlbFJhbmdlLmdldFRvcExlZnRDb3JuZXIoKTtcbiAgICAgIHZhciBib3R0b21SaWdodCA9IHByaXYuc2VsUmFuZ2UuZ2V0Qm90dG9tUmlnaHRDb3JuZXIoKTtcbiAgICAgIHZhciByLCBjLCBjaGFuZ2VzID0gW107XG4gICAgICBmb3IgKHIgPSB0b3BMZWZ0LnJvdzsgciA8PSBib3R0b21SaWdodC5yb3c7IHIrKykge1xuICAgICAgICBmb3IgKGMgPSB0b3BMZWZ0LmNvbDsgYyA8PSBib3R0b21SaWdodC5jb2w7IGMrKykge1xuICAgICAgICAgIGlmICghaW5zdGFuY2UuZ2V0Q2VsbE1ldGEociwgYykucmVhZE9ubHkpIHtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaChbciwgYywgJyddKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluc3RhbmNlLnNldERhdGFBdENlbGwoY2hhbmdlcyk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIEhhbmRzb250YWJsZS5ob29rcy5ydW4oaW5zdGFuY2UsICdiZWZvcmVJbml0Jyk7XG5cbiAgICBpZiAoSGFuZHNvbnRhYmxlLm1vYmlsZUJyb3dzZXIpIHtcbiAgICAgIGFkZENsYXNzKGluc3RhbmNlLnJvb3RFbGVtZW50LCAnbW9iaWxlJyk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVTZXR0aW5ncyhwcml2LnNldHRpbmdzLCB0cnVlKTtcblxuICAgIHRoaXMudmlldyA9IG5ldyBUYWJsZVZpZXcodGhpcyk7XG4gICAgZWRpdG9yTWFuYWdlciA9IG5ldyBFZGl0b3JNYW5hZ2VyKGluc3RhbmNlLCBwcml2LCBzZWxlY3Rpb24sIGRhdGFtYXApO1xuXG4gICAgdGhpcy5mb3JjZUZ1bGxSZW5kZXIgPSB0cnVlOyAvL3VzZWQgd2hlbiBkYXRhIHdhcyBjaGFuZ2VkXG5cbiAgICBIYW5kc29udGFibGUuaG9va3MucnVuKGluc3RhbmNlLCAnaW5pdCcpO1xuICAgIHRoaXMudmlldy5yZW5kZXIoKTtcblxuICAgIGlmICh0eXBlb2YgcHJpdi5maXJzdFJ1biA9PT0gJ29iamVjdCcpIHtcbiAgICAgIEhhbmRzb250YWJsZS5ob29rcy5ydW4oaW5zdGFuY2UsICdhZnRlckNoYW5nZScsIHByaXYuZmlyc3RSdW5bMF0sIHByaXYuZmlyc3RSdW5bMV0pO1xuICAgICAgcHJpdi5maXJzdFJ1biA9IGZhbHNlO1xuICAgIH1cbiAgICBIYW5kc29udGFibGUuaG9va3MucnVuKGluc3RhbmNlLCAnYWZ0ZXJJbml0Jyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gVmFsaWRhdG9yc1F1ZXVlKCkgeyAvL21vdmVkIHRoaXMgb25lIGxldmVsIHVwIHNvIGl0IGNhbiBiZSB1c2VkIGluIGFueSBmdW5jdGlvbiBoZXJlLiBQcm9iYWJseSB0aGlzIHNob3VsZCBiZSBtb3ZlZCB0byBhIHNlcGFyYXRlIGZpbGVcbiAgICB2YXIgcmVzb2x2ZWQgPSBmYWxzZTtcblxuICAgIHJldHVybiB7XG4gICAgICB2YWxpZGF0b3JzSW5RdWV1ZTogMCxcbiAgICAgIHZhbGlkOiB0cnVlLFxuICAgICAgYWRkVmFsaWRhdG9yVG9RdWV1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdG9yc0luUXVldWUrKztcbiAgICAgICAgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgIH0sXG4gICAgICByZW1vdmVWYWxpZGF0b3JGb3JtUXVldWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnZhbGlkYXRvcnNJblF1ZXVlID0gdGhpcy52YWxpZGF0b3JzSW5RdWV1ZSAtIDEgPCAwID8gMCA6IHRoaXMudmFsaWRhdG9yc0luUXVldWUgLSAxO1xuICAgICAgICB0aGlzLmNoZWNrSWZRdWV1ZUlzRW1wdHkoKTtcbiAgICAgIH0sXG4gICAgICBvblF1ZXVlRW1wdHk6IGZ1bmN0aW9uKHZhbGlkKSB7XG4gICAgICB9LFxuICAgICAgY2hlY2tJZlF1ZXVlSXNFbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICAgICAgaWYgKHRoaXMudmFsaWRhdG9yc0luUXVldWUgPT0gMCAmJiByZXNvbHZlZCA9PSBmYWxzZSkge1xuICAgICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLm9uUXVldWVFbXB0eSh0aGlzLnZhbGlkKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZUNoYW5nZXMoY2hhbmdlcywgc291cmNlLCBjYWxsYmFjaykge1xuICAgIHZhciB3YWl0aW5nRm9yVmFsaWRhdG9yID0gbmV3IFZhbGlkYXRvcnNRdWV1ZSgpO1xuICAgIHdhaXRpbmdGb3JWYWxpZGF0b3Iub25RdWV1ZUVtcHR5ID0gcmVzb2x2ZTtcblxuICAgIGZvciAodmFyIGkgPSBjaGFuZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoY2hhbmdlc1tpXSA9PT0gbnVsbCkge1xuICAgICAgICBjaGFuZ2VzLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgcm93ID0gY2hhbmdlc1tpXVswXTtcbiAgICAgICAgdmFyIGNvbCA9IGRhdGFtYXAucHJvcFRvQ29sKGNoYW5nZXNbaV1bMV0pO1xuICAgICAgICAvL2NvbHVtbiBvcmRlciBtYXkgaGF2ZSBjaGFuZ2VzLCBzbyB3ZSBuZWVkIHRvIHRyYW5zbGF0ZSBwaHlzaWNhbCBjb2wgaW5kZXggKHN0b3JlZCBpbiBkYXRhc291cmNlKSB0byBsb2dpY2FsIChkaXNwbGF5ZWQgdG8gdXNlcilcbiAgICAgICAgdmFyIGxvZ2ljYWxDb2wgPSBpbnN0YW5jZS5ydW5Ib29rcygnbW9kaWZ5Q29sJywgY29sKTtcbiAgICAgICAgdmFyIGNlbGxQcm9wZXJ0aWVzID0gaW5zdGFuY2UuZ2V0Q2VsbE1ldGEocm93LCBsb2dpY2FsQ29sKTtcblxuICAgICAgICBpZiAoY2VsbFByb3BlcnRpZXMudHlwZSA9PT0gJ251bWVyaWMnICYmIHR5cGVvZiBjaGFuZ2VzW2ldWzNdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChjaGFuZ2VzW2ldWzNdLmxlbmd0aCA+IDAgJiYgKC9eLT9bXFxkXFxzXSooXFwufFxcLCk/XFxkKiQvLnRlc3QoY2hhbmdlc1tpXVszXSkgfHwgY2VsbFByb3BlcnRpZXMuZm9ybWF0ICkpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBjaGFuZ2VzW2ldWzNdLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2VsbFByb3BlcnRpZXMubGFuZ3VhZ2UgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgbnVtZXJhbC5sYW5ndWFnZSgnZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vdGhpcyBpbnB1dCBpbiBmb3JtYXQgWFhYWC5YWCBpcyBsaWtlbHkgdG8gY29tZSBmcm9tIHBhc3RlLiBMZXQncyBwYXJzZSBpdCB1c2luZyBpbnRlcm5hdGlvbmFsIHJ1bGVzXG4gICAgICAgICAgICBlbHNlIGlmIChjaGFuZ2VzW2ldWzNdLmluZGV4T2YoXCIuXCIpID09PSBsZW4gLSAzICYmIGNoYW5nZXNbaV1bM10uaW5kZXhPZihcIixcIikgPT09IC0xKSB7XG4gICAgICAgICAgICAgIG51bWVyYWwubGFuZ3VhZ2UoJ2VuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgbnVtZXJhbC5sYW5ndWFnZShjZWxsUHJvcGVydGllcy5sYW5ndWFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnVtZXJhbC52YWxpZGF0ZShjaGFuZ2VzW2ldWzNdKSkge1xuICAgICAgICAgICAgICBjaGFuZ2VzW2ldWzNdID0gbnVtZXJhbCgpLnVuZm9ybWF0KGNoYW5nZXNbaV1bM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICAgICAgaWYgKGluc3RhbmNlLmdldENlbGxWYWxpZGF0b3IoY2VsbFByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgd2FpdGluZ0ZvclZhbGlkYXRvci5hZGRWYWxpZGF0b3JUb1F1ZXVlKCk7XG4gICAgICAgICAgaW5zdGFuY2UudmFsaWRhdGVDZWxsKGNoYW5nZXNbaV1bM10sIGNlbGxQcm9wZXJ0aWVzLCAoZnVuY3Rpb24oaSwgY2VsbFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkYXRpb24gZXJyb3I6IHJlc3VsdCBpcyBub3QgYm9vbGVhblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UgJiYgY2VsbFByb3BlcnRpZXMuYWxsb3dJbnZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgY2hhbmdlcy5zcGxpY2UoaSwgMSk7ICAgICAgICAgLy8gY2FuY2VsIHRoZSBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLnZhbGlkID0gdHJ1ZTsgIC8vIHdlIGNhbmNlbGxlZCB0aGUgY2hhbmdlLCBzbyBjZWxsIHZhbHVlIGlzIHN0aWxsIHZhbGlkXG4gICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdhaXRpbmdGb3JWYWxpZGF0b3IucmVtb3ZlVmFsaWRhdG9yRm9ybVF1ZXVlKCk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KShpLCBjZWxsUHJvcGVydGllcylcbiAgICAgICAgICAgICwgc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuICAgICAgfVxuICAgIH1cbiAgICB3YWl0aW5nRm9yVmFsaWRhdG9yLmNoZWNrSWZRdWV1ZUlzRW1wdHkoKTtcblxuICAgIGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgICB2YXIgYmVmb3JlQ2hhbmdlUmVzdWx0O1xuXG4gICAgICBpZiAoY2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgYmVmb3JlQ2hhbmdlUmVzdWx0ID0gSGFuZHNvbnRhYmxlLmhvb2tzLnJ1bihpbnN0YW5jZSwgXCJiZWZvcmVDaGFuZ2VcIiwgY2hhbmdlcywgc291cmNlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBiZWZvcmVDaGFuZ2VSZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJZb3VyIGJlZm9yZUNoYW5nZSBjYWxsYmFjayByZXR1cm5zIGEgZnVuY3Rpb24uIEl0J3Mgbm90IHN1cHBvcnRlZCBzaW5jZSBIYW5kc29udGFibGUgMC4xMi4xIChhbmQgdGhlIHJldHVybmVkIGZ1bmN0aW9uIHdpbGwgbm90IGJlIGV4ZWN1dGVkKS5cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoYmVmb3JlQ2hhbmdlUmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgIGNoYW5nZXMuc3BsaWNlKDAsIGNoYW5nZXMubGVuZ3RoKTsgLy9pbnZhbGlkYXRlIGFsbCBjaGFuZ2VzIChyZW1vdmUgZXZlcnl0aGluZyBmcm9tIGFycmF5KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYWxsYmFjaygpOyAvL2NhbGxlZCB3aGVuIGFzeW5jIHZhbGlkYXRvcnMgYXJlIHJlc29sdmVkIGFuZCBiZWZvcmVDaGFuZ2Ugd2FzIG5vdCBhc3luY1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBhcHBseSBjaGFuZ2VzLiBDYWxsZWQgYWZ0ZXIgdmFsaWRhdGVDaGFuZ2VzXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNoYW5nZXMgQXJyYXkgaW4gZm9ybSBvZiBbcm93LCBwcm9wLCBvbGRWYWx1ZSwgbmV3VmFsdWVdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzb3VyY2UgU3RyaW5nIHRoYXQgaWRlbnRpZmllcyBob3cgdGhpcyBjaGFuZ2Ugd2lsbCBiZSBkZXNjcmliZWQgaW4gY2hhbmdlcyBhcnJheSAodXNlZnVsIGluIG9uQ2hhbmdlIGNhbGxiYWNrKVxuICAgKiBAZmlyZXMgSG9va3MjYmVmb3JlQ2hhbmdlUmVuZGVyXG4gICAqIEBmaXJlcyBIb29rcyNhZnRlckNoYW5nZVxuICAgKi9cbiAgZnVuY3Rpb24gYXBwbHlDaGFuZ2VzKGNoYW5nZXMsIHNvdXJjZSkge1xuICAgIHZhciBpID0gY2hhbmdlcy5sZW5ndGggLSAxO1xuXG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICg7IDAgPD0gaTsgaS0tKSB7XG4gICAgICBpZiAoY2hhbmdlc1tpXSA9PT0gbnVsbCkge1xuICAgICAgICBjaGFuZ2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VzW2ldWzJdID09IG51bGwgJiYgY2hhbmdlc1tpXVszXSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJpdi5zZXR0aW5ncy5hbGxvd0luc2VydFJvdykge1xuICAgICAgICB3aGlsZSAoY2hhbmdlc1tpXVswXSA+IGluc3RhbmNlLmNvdW50Um93cygpIC0gMSkge1xuICAgICAgICAgIGRhdGFtYXAuY3JlYXRlUm93KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGluc3RhbmNlLmRhdGFUeXBlID09PSAnYXJyYXknICYmIHByaXYuc2V0dGluZ3MuYWxsb3dJbnNlcnRDb2x1bW4pIHtcbiAgICAgICAgd2hpbGUgKGRhdGFtYXAucHJvcFRvQ29sKGNoYW5nZXNbaV1bMV0pID4gaW5zdGFuY2UuY291bnRDb2xzKCkgLSAxKSB7XG4gICAgICAgICAgZGF0YW1hcC5jcmVhdGVDb2woKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkYXRhbWFwLnNldChjaGFuZ2VzW2ldWzBdLCBjaGFuZ2VzW2ldWzFdLCBjaGFuZ2VzW2ldWzNdKTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5mb3JjZUZ1bGxSZW5kZXIgPSB0cnVlOyAvL3VzZWQgd2hlbiBkYXRhIHdhcyBjaGFuZ2VkXG4gICAgZ3JpZC5hZGp1c3RSb3dzQW5kQ29scygpO1xuICAgIEhhbmRzb250YWJsZS5ob29rcy5ydW4oaW5zdGFuY2UsICdiZWZvcmVDaGFuZ2VSZW5kZXInLCBjaGFuZ2VzLCBzb3VyY2UpO1xuICAgIHNlbGVjdGlvbi5yZWZyZXNoQm9yZGVycyhudWxsLCB0cnVlKTtcbiAgICBpbnN0YW5jZS52aWV3Lnd0Lnd0T3ZlcmxheXMuYWRqdXN0RWxlbWVudHNTaXplKCk7XG4gICAgSGFuZHNvbnRhYmxlLmhvb2tzLnJ1bihpbnN0YW5jZSwgJ2FmdGVyQ2hhbmdlJywgY2hhbmdlcywgc291cmNlIHx8ICdlZGl0Jyk7XG4gIH1cblxuICB0aGlzLnZhbGlkYXRlQ2VsbCA9IGZ1bmN0aW9uKHZhbHVlLCBjZWxsUHJvcGVydGllcywgY2FsbGJhY2ssIHNvdXJjZSkge1xuICAgIHZhciB2YWxpZGF0b3IgPSBpbnN0YW5jZS5nZXRDZWxsVmFsaWRhdG9yKGNlbGxQcm9wZXJ0aWVzKTtcblxuICAgIGZ1bmN0aW9uIGRvbmUodmFsaWQpIHtcbiAgICAgIHZhciBjb2wgPSBjZWxsUHJvcGVydGllcy5jb2wsXG4gICAgICAgIHJvdyA9IGNlbGxQcm9wZXJ0aWVzLnJvdyxcbiAgICAgICAgdGQgPSBpbnN0YW5jZS5nZXRDZWxsKHJvdywgY29sLCB0cnVlKTtcblxuICAgICAgaWYgKHRkKSB7XG4gICAgICAgIGluc3RhbmNlLnZpZXcud3Qud3RTZXR0aW5ncy5zZXR0aW5ncy5jZWxsUmVuZGVyZXIocm93LCBjb2wsIHRkKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKHZhbGlkKTtcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbGlkYXRvcikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgICB2YWxpZGF0b3IgPSAoZnVuY3Rpb24odmFsaWRhdG9yKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayh2YWxpZGF0b3IudGVzdCh2YWx1ZSkpO1xuICAgICAgICB9O1xuICAgICAgfSkodmFsaWRhdG9yKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbGlkYXRvciA9PSAnZnVuY3Rpb24nKSB7XG5cbiAgICAgIHZhbHVlID0gSGFuZHNvbnRhYmxlLmhvb2tzLnJ1bihpbnN0YW5jZSwgXCJiZWZvcmVWYWxpZGF0ZVwiLCB2YWx1ZSwgY2VsbFByb3BlcnRpZXMucm93LCBjZWxsUHJvcGVydGllcy5wcm9wLCBzb3VyY2UpO1xuXG4gICAgICAvLyBUbyBwcm92aWRlIGNvbnNpc3RlbnQgYmVoYXZpb3VyLCB2YWxpZGF0aW9uIHNob3VsZCBiZSBhbHdheXMgYXN5bmNocm9ub3VzXG4gICAgICBpbnN0YW5jZS5fcmVnaXN0ZXJUaW1lb3V0KHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhbGlkYXRvci5jYWxsKGNlbGxQcm9wZXJ0aWVzLCB2YWx1ZSwgZnVuY3Rpb24odmFsaWQpIHtcbiAgICAgICAgICB2YWxpZCA9IEhhbmRzb250YWJsZS5ob29rcy5ydW4oaW5zdGFuY2UsIFwiYWZ0ZXJWYWxpZGF0ZVwiLCB2YWxpZCwgdmFsdWUsIGNlbGxQcm9wZXJ0aWVzLnJvdywgY2VsbFByb3BlcnRpZXMucHJvcCwgc291cmNlKTtcbiAgICAgICAgICBjZWxsUHJvcGVydGllcy52YWxpZCA9IHZhbGlkO1xuXG4gICAgICAgICAgZG9uZSh2YWxpZCk7XG4gICAgICAgICAgSGFuZHNvbnRhYmxlLmhvb2tzLnJ1bihpbnN0YW5jZSwgXCJwb3N0QWZ0ZXJWYWxpZGF0ZVwiLCB2YWxpZCwgdmFsdWUsIGNlbGxQcm9wZXJ0aWVzLnJvdywgY2VsbFByb3BlcnRpZXMucHJvcCwgc291cmNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCAwKSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy9yZXNvbHZlIGNhbGxiYWNrIGV2ZW4gaWYgdmFsaWRhdG9yIGZ1bmN0aW9uIHdhcyBub3QgZm91bmRcbiAgICAgIGNlbGxQcm9wZXJ0aWVzLnZhbGlkID0gdHJ1ZTtcbiAgICAgIGRvbmUoY2VsbFByb3BlcnRpZXMudmFsaWQpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBzZXREYXRhSW5wdXRUb0FycmF5KHJvdywgcHJvcE9yQ29sLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2Ygcm93ID09PSBcIm9iamVjdFwiKSB7IC8vaXMgaXQgYW4gYXJyYXkgb2YgY2hhbmdlc1xuICAgICAgcmV0dXJuIHJvdztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBbcm93LCBwcm9wT3JDb2wsIHZhbHVlXVxuICAgICAgXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFNldCBuZXcgdmFsdWUgdG8gYSBjZWxsLiBUbyBjaGFuZ2UgbWFueSBjZWxscyBhdCBvbmNlLCBwYXNzIGFuIGFycmF5IG9mIGBjaGFuZ2VzYCBpbiBmb3JtYXQgYFtbcm93LCBjb2wsIHZhbHVlXSwgLi4uXWAgYXNcbiAgICogdGhlIG9ubHkgcGFyYW1ldGVyLiBgY29sYCBpcyB0aGUgaW5kZXggb2YgX192aXNpYmxlX18gY29sdW1uIChub3RlIHRoYXQgaWYgY29sdW1ucyB3ZXJlIHJlb3JkZXJlZCxcbiAgICogdGhlIGN1cnJlbnQgb3JkZXIgd2lsbCBiZSB1c2VkKS4gYHNvdXJjZWAgaXMgYSBmbGFnIGZvciBiZWZvcmUvYWZ0ZXJDaGFuZ2UgZXZlbnRzLiBJZiB5b3UgcGFzcyBvbmx5IGFycmF5IG9mXG4gICAqIGNoYW5nZXMgdGhlbiBgc291cmNlYCBjb3VsZCBiZSBzZXQgYXMgc2Vjb25kIHBhcmFtZXRlci5cbiAgICpcbiAgICogQG1lbWJlcm9mIENvcmUjXG4gICAqIEBmdW5jdGlvbiBzZXREYXRhQXRDZWxsXG4gICAqIEBwYXJhbSB7TnVtYmVyfEFycmF5fSByb3cgb3IgYXJyYXkgb2YgY2hhbmdlcyBpbiBmb3JtYXQgYFtbcm93LCBjb2wsIHZhbHVlXSwgLi4uXWBcbiAgICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBjb2wgb3Igc291cmNlIFN0cmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtzb3VyY2VdIFN0cmluZyB0aGF0IGlkZW50aWZpZXMgaG93IHRoaXMgY2hhbmdlIHdpbGwgYmUgZGVzY3JpYmVkIGluIGNoYW5nZXMgYXJyYXkgKHVzZWZ1bCBpbiBvbkNoYW5nZSBjYWxsYmFjaylcbiAgICovXG4gIHRoaXMuc2V0RGF0YUF0Q2VsbCA9IGZ1bmN0aW9uKHJvdywgY29sLCB2YWx1ZSwgc291cmNlKSB7XG4gICAgdmFyIGlucHV0ID0gc2V0RGF0YUlucHV0VG9BcnJheShyb3csIGNvbCwgdmFsdWUpXG4gICAgICAsIGlcbiAgICAgICwgaWxlblxuICAgICAgLCBjaGFuZ2VzID0gW11cbiAgICAgICwgcHJvcDtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpbnB1dC5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXRbaV0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIGBzZXREYXRhQXRDZWxsYCBhY2NlcHRzIHJvdyBudW1iZXIgb3IgY2hhbmdlcyBhcnJheSBvZiBhcnJheXMgYXMgaXRzIGZpcnN0IHBhcmFtZXRlcicpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpbnB1dFtpXVsxXSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2QgYHNldERhdGFBdENlbGxgIGFjY2VwdHMgcm93IGFuZCBjb2x1bW4gbnVtYmVyIGFzIGl0cyBwYXJhbWV0ZXJzLiBJZiB5b3Ugd2FudCB0byB1c2Ugb2JqZWN0IHByb3BlcnR5IG5hbWUsIHVzZSBtZXRob2QgYHNldERhdGFBdFJvd1Byb3BgJyk7XG4gICAgICB9XG4gICAgICBwcm9wID0gZGF0YW1hcC5jb2xUb1Byb3AoaW5wdXRbaV1bMV0pO1xuICAgICAgY2hhbmdlcy5wdXNoKFtcbiAgICAgICAgaW5wdXRbaV1bMF0sXG4gICAgICAgIHByb3AsXG4gICAgICAgIGRhdGFtYXAuZ2V0KGlucHV0W2ldWzBdLCBwcm9wKSxcbiAgICAgICAgaW5wdXRbaV1bMl1cbiAgICAgIF0pO1xuICAgIH1cblxuICAgIGlmICghc291cmNlICYmIHR5cGVvZiByb3cgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHNvdXJjZSA9IGNvbDtcbiAgICB9XG5cbiAgICB2YWxpZGF0ZUNoYW5nZXMoY2hhbmdlcywgc291cmNlLCBmdW5jdGlvbigpIHtcbiAgICAgIGFwcGx5Q2hhbmdlcyhjaGFuZ2VzLCBzb3VyY2UpO1xuICAgIH0pO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFNhbWUgYXMgYWJvdmUsIGV4Y2VwdCBpbnN0ZWFkIG9mIGBjb2xgLCB5b3UgcHJvdmlkZSBuYW1lIG9mIHRoZSBvYmplY3QgcHJvcGVydHkgKGUuZy4gYFswLCAnZmlyc3QubmFtZScsICdKZW5uaWZlciddYCkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gc2V0RGF0YUF0Um93UHJvcFxuICAgKiBAcGFyYW0ge051bWJlcnxBcnJheX0gcm93IG9yIGFycmF5IG9mIGNoYW5nZXMgaW4gZm9ybWF0IGBbW3JvdywgcHJvcCwgdmFsdWVdLCAuLi5dYFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBvciBzb3VyY2UgU3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3NvdXJjZV0gU3RyaW5nIHRoYXQgaWRlbnRpZmllcyBob3cgdGhpcyBjaGFuZ2Ugd2lsbCBiZSBkZXNjcmliZWQgaW4gY2hhbmdlcyBhcnJheSAodXNlZnVsIGluIG9uQ2hhbmdlIGNhbGxiYWNrKVxuICAgKi9cbiAgdGhpcy5zZXREYXRhQXRSb3dQcm9wID0gZnVuY3Rpb24ocm93LCBwcm9wLCB2YWx1ZSwgc291cmNlKSB7XG4gICAgdmFyIGlucHV0ID0gc2V0RGF0YUlucHV0VG9BcnJheShyb3csIHByb3AsIHZhbHVlKVxuICAgICAgLCBpXG4gICAgICAsIGlsZW5cbiAgICAgICwgY2hhbmdlcyA9IFtdO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGlucHV0Lmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgY2hhbmdlcy5wdXNoKFtcbiAgICAgICAgaW5wdXRbaV1bMF0sXG4gICAgICAgIGlucHV0W2ldWzFdLFxuICAgICAgICBkYXRhbWFwLmdldChpbnB1dFtpXVswXSwgaW5wdXRbaV1bMV0pLFxuICAgICAgICBpbnB1dFtpXVsyXVxuICAgICAgXSk7XG4gICAgfVxuXG4gICAgaWYgKCFzb3VyY2UgJiYgdHlwZW9mIHJvdyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgc291cmNlID0gcHJvcDtcbiAgICB9XG5cbiAgICB2YWxpZGF0ZUNoYW5nZXMoY2hhbmdlcywgc291cmNlLCBmdW5jdGlvbigpIHtcbiAgICAgIGFwcGx5Q2hhbmdlcyhjaGFuZ2VzLCBzb3VyY2UpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8ga2V5Ym9hcmQgaW5wdXQgb24gZG9jdW1lbnQgYm9keS5cbiAgICpcbiAgICogQG1lbWJlcm9mIENvcmUjXG4gICAqIEBmdW5jdGlvbiBsaXN0ZW5cbiAgICogQHNpbmNlIDAuMTFcbiAgICovXG4gIHRoaXMubGlzdGVuID0gZnVuY3Rpb24oKSB7XG4gICAgSGFuZHNvbnRhYmxlLmFjdGl2ZUd1aWQgPSBpbnN0YW5jZS5ndWlkO1xuXG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7IC8vSUVcbiAgICAgIGRvY3VtZW50LmJvZHkuZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3AgbGlzdGVuaW5nIHRvIGtleWJvYXJkIGlucHV0IG9uIGRvY3VtZW50IGJvZHkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gdW5saXN0ZW5cbiAgICogQHNpbmNlIDAuMTFcbiAgICovXG4gIHRoaXMudW5saXN0ZW4gPSBmdW5jdGlvbigpIHtcbiAgICBIYW5kc29udGFibGUuYWN0aXZlR3VpZCA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYHRydWVgIGlmIGN1cnJlbnQgSGFuZHNvbnRhYmxlIGluc3RhbmNlIGlzIGxpc3RlbmluZyB0byBrZXlib2FyZCBpbnB1dCBvbiBkb2N1bWVudCBib2R5LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ29yZSNcbiAgICogQGZ1bmN0aW9uIGlzTGlzdGVuaW5nXG4gICAqIEBzaW5jZSAwLjExXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgdGhpcy5pc0xpc3RlbmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBIYW5kc29udGFibGUuYWN0aXZlR3VpZCA9PT0gaW5zdGFuY2UuZ3VpZDtcbiAgfTtcblxuICAvKipcbiAgICogRGVzdHJveXMgY3VycmVudCBlZGl0b3IsIHJlbmRlcnMgYW5kIHNlbGVjdHMgY3VycmVudCBjZWxsLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ29yZSNcbiAgICogQGZ1bmN0aW9uIGRlc3Ryb3lFZGl0b3JcbiAgICogQHBhcmFtIHtCb29sZWFufSBbcmV2ZXJ0T3JpZ2luYWxdIElmICE9IGB0cnVlYCwgZWRpdGVkIGRhdGEgaXMgc2F2ZWQuIE90aGVyd2lzZSBwcmV2aW91cyB2YWx1ZSBpcyByZXN0b3JlZFxuICAgKi9cbiAgdGhpcy5kZXN0cm95RWRpdG9yID0gZnVuY3Rpb24ocmV2ZXJ0T3JpZ2luYWwpIHtcbiAgICBzZWxlY3Rpb24ucmVmcmVzaEJvcmRlcnMocmV2ZXJ0T3JpZ2luYWwpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQb3B1bGF0ZSBjZWxscyBhdCBwb3NpdGlvbiB3aXRoIDJEIGlucHV0IGFycmF5IChlLmcuIGBbWzEsIDJdLCBbMywgNF1dYCkuXG4gICAqIFVzZSBgZW5kUm93YCwgYGVuZENvbGAgd2hlbiB5b3Ugd2FudCB0byBjdXQgaW5wdXQgd2hlbiBjZXJ0YWluIHJvdyBpcyByZWFjaGVkLlxuICAgKiBPcHRpb25hbCBgc291cmNlYCBwYXJhbWV0ZXIgKGRlZmF1bHQgdmFsdWUgXCJwb3B1bGF0ZUZyb21BcnJheVwiKSBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgY2FsbCBpbiB0aGUgcmVzdWx0aW5nIGV2ZW50cyAoYmVmb3JlQ2hhbmdlLCBhZnRlckNoYW5nZSkuXG4gICAqIE9wdGlvbmFsIGBwb3B1bGF0ZU1ldGhvZGAgcGFyYW1ldGVyIChkZWZhdWx0IHZhbHVlIFwib3ZlcndyaXRlXCIsIHBvc3NpYmxlIHZhbHVlcyBcInNoaWZ0X2Rvd25cIiBhbmQgXCJzaGlmdF9yaWdodFwiKVxuICAgKiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzIHBhc3RlTWV0aG9kIG9wdGlvbiAoc2VlIE9wdGlvbnMgcGFnZSlcbiAgICpcbiAgICogQG1lbWJlcm9mIENvcmUjXG4gICAqIEBmdW5jdGlvbiBwb3B1bGF0ZUZyb21BcnJheVxuICAgKiBAc2luY2UgMC45LjBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJvdyBTdGFydCByb3dcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbCBTdGFydCBjb2x1bW5cbiAgICogQHBhcmFtIHtBcnJheX0gaW5wdXQgMmQgYXJyYXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtlbmRSb3ddIEVuZCByb3cgKHVzZSB3aGVuIHlvdSB3YW50IHRvIGN1dCBpbnB1dCB3aGVuIGNlcnRhaW4gcm93IGlzIHJlYWNoZWQpXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kQ29sXSBFbmQgY29sdW1uICh1c2Ugd2hlbiB5b3Ugd2FudCB0byBjdXQgaW5wdXQgd2hlbiBjZXJ0YWluIGNvbHVtbiBpcyByZWFjaGVkKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3NvdXJjZT1cInBvcHVsYXRlRnJvbUFycmF5XCJdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbbWV0aG9kPVwib3ZlcndyaXRlXCJdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24gZWRpdCAobGVmdHxyaWdodHx1cHxkb3duKVxuICAgKiBAcGFyYW0ge0FycmF5fSBkZWx0YXMgYXJyYXlcbiAgICogQHJldHVybnMge09iamVjdHx1bmRlZmluZWR9IGVuZGluZyB0ZCBpbiBwYXN0ZWQgYXJlYSAob25seSBpZiBhbnkgY2VsbCB3YXMgY2hhbmdlZClcbiAgICovXG4gIHRoaXMucG9wdWxhdGVGcm9tQXJyYXkgPSBmdW5jdGlvbihyb3csIGNvbCwgaW5wdXQsIGVuZFJvdywgZW5kQ29sLCBzb3VyY2UsIG1ldGhvZCwgZGlyZWN0aW9uLCBkZWx0YXMpIHtcbiAgICB2YXIgYztcblxuICAgIGlmICghKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGlucHV0WzBdID09PSAnb2JqZWN0JykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInBvcHVsYXRlRnJvbUFycmF5IHBhcmFtZXRlciBgaW5wdXRgIG11c3QgYmUgYW4gYXJyYXkgb2YgYXJyYXlzXCIpOyAvL0FQSSBjaGFuZ2VkIGluIDAuOS1iZXRhMiwgbGV0J3MgY2hlY2sgaWYgeW91IHVzZSBpdCBjb3JyZWN0bHlcbiAgICB9XG4gICAgYyA9IHR5cGVvZiBlbmRSb3cgPT09ICdudW1iZXInID8gbmV3IFdhbGtvbnRhYmxlQ2VsbENvb3JkcyhlbmRSb3csIGVuZENvbCkgOiBudWxsO1xuXG4gICAgcmV0dXJuIGdyaWQucG9wdWxhdGVGcm9tQXJyYXkobmV3IFdhbGtvbnRhYmxlQ2VsbENvb3Jkcyhyb3csIGNvbCksIGlucHV0LCBjLCBzb3VyY2UsIG1ldGhvZCwgZGlyZWN0aW9uLCBkZWx0YXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzL3JlbW92ZXMgZGF0YSBmcm9tIHRoZSBjb2x1bW4uIFRoaXMgZnVuY3Rpb24gd29ya3MgaXMgbW9kZWxsZWQgYWZ0ZXIgQXJyYXkuc3BsaWNlLlxuICAgKiBQYXJhbWV0ZXIgYGNvbGAgaXMgdGhlIGluZGV4IG9mIGNvbHVtbiBpbiB3aGljaCBkbyB5b3Ugd2FudCB0byBkbyBzcGxpY2UuXG4gICAqIFBhcmFtZXRlciBgaW5kZXhgIGlzIHRoZSByb3cgaW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgY2hhbmdpbmcgdGhlIGFycmF5LlxuICAgKiBJZiBuZWdhdGl2ZSwgd2lsbCBiZWdpbiB0aGF0IG1hbnkgZWxlbWVudHMgZnJvbSB0aGUgZW5kLiBQYXJhbWV0ZXIgYGFtb3VudGAsIGlzIHRoZSBudW1iZXIgb2Ygb2xkIGFycmF5IGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAgICogSWYgdGhlIGFtb3VudCBpcyAwLCBubyBlbGVtZW50cyBhcmUgcmVtb3ZlZC4gRm91cnRoIGFuZCBmdXJ0aGVyIHBhcmFtZXRlcnMgYXJlIHRoZSBgZWxlbWVudHNgIHRvIGFkZCB0byB0aGUgYXJyYXkuXG4gICAqIElmIHlvdSBkb24ndCBzcGVjaWZ5IGFueSBlbGVtZW50cywgc3BsaWNlQ29sIHNpbXBseSByZW1vdmVzIGVsZW1lbnRzIGZyb20gdGhlIGFycmF5LlxuICAgKiB7QGxpbmsgRGF0YU1hcCNzcGxpY2VDb2x9XG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gc3BsaWNlQ29sXG4gICAqIEBzaW5jZSAwLjktYmV0YTJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbCBJbmRleCBvZiBjb2x1bW4gaW4gd2hpY2ggZG8geW91IHdhbnQgdG8gZG8gc3BsaWNlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgY2hhbmdpbmcgdGhlIGFycmF5LiBJZiBuZWdhdGl2ZSwgd2lsbCBiZWdpbiB0aGF0IG1hbnkgZWxlbWVudHMgZnJvbSB0aGUgZW5kXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgQW4gaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBudW1iZXIgb2Ygb2xkIGFycmF5IGVsZW1lbnRzIHRvIHJlbW92ZS4gSWYgYW1vdW50IGlzIDAsIG5vIGVsZW1lbnRzIGFyZSByZW1vdmVkXG4gICAqIEBwYXJhbSB7Kn0gW2VsZW1lbnRzXSBUaGUgZWxlbWVudHMgdG8gYWRkIHRvIHRoZSBhcnJheS4gSWYgeW91IGRvbid0IHNwZWNpZnkgYW55IGVsZW1lbnRzLCBzcGxpY2VDb2wgc2ltcGx5IHJlbW92ZXMgZWxlbWVudHMgZnJvbSB0aGUgYXJyYXlcbiAgICovXG4gIHRoaXMuc3BsaWNlQ29sID0gZnVuY3Rpb24oY29sLCBpbmRleCwgYW1vdW50LyosIGVsZW1lbnRzLi4uICovKSB7XG4gICAgcmV0dXJuIGRhdGFtYXAuc3BsaWNlQ29sLmFwcGx5KGRhdGFtYXAsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMvcmVtb3ZlcyBkYXRhIGZyb20gdGhlIHJvdy4gVGhpcyBmdW5jdGlvbiB3b3JrcyBpcyBtb2RlbGxlZCBhZnRlciBBcnJheS5zcGxpY2UuXG4gICAqIFBhcmFtZXRlciBgcm93YCBpcyB0aGUgaW5kZXggb2Ygcm93IGluIHdoaWNoIGRvIHlvdSB3YW50IHRvIGRvIHNwbGljZS5cbiAgICogUGFyYW1ldGVyIGBpbmRleGAgaXMgdGhlIGNvbHVtbiBpbmRleCBhdCB3aGljaCB0byBzdGFydCBjaGFuZ2luZyB0aGUgYXJyYXkuXG4gICAqIElmIG5lZ2F0aXZlLCB3aWxsIGJlZ2luIHRoYXQgbWFueSBlbGVtZW50cyBmcm9tIHRoZSBlbmQuIFBhcmFtZXRlciBgYW1vdW50YCwgaXMgdGhlIG51bWJlciBvZiBvbGQgYXJyYXkgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICAgKiBJZiB0aGUgYW1vdW50IGlzIDAsIG5vIGVsZW1lbnRzIGFyZSByZW1vdmVkLiBGb3VydGggYW5kIGZ1cnRoZXIgcGFyYW1ldGVycyBhcmUgdGhlIGBlbGVtZW50c2AgdG8gYWRkIHRvIHRoZSBhcnJheS5cbiAgICogSWYgeW91IGRvbid0IHNwZWNpZnkgYW55IGVsZW1lbnRzLCBzcGxpY2VDb2wgc2ltcGx5IHJlbW92ZXMgZWxlbWVudHMgZnJvbSB0aGUgYXJyYXkuXG4gICAqIHtAbGluayBEYXRhTWFwI3NwbGljZVJvd31cbiAgICpcbiAgICogQG1lbWJlcm9mIENvcmUjXG4gICAqIEBmdW5jdGlvbiBzcGxpY2VSb3dcbiAgICogQHNpbmNlIDAuMTFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJvdyBJbmRleCBvZiBjb2x1bW4gaW4gd2hpY2ggZG8geW91IHdhbnQgdG8gZG8gc3BsaWNlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgY2hhbmdpbmcgdGhlIGFycmF5LiBJZiBuZWdhdGl2ZSwgd2lsbCBiZWdpbiB0aGF0IG1hbnkgZWxlbWVudHMgZnJvbSB0aGUgZW5kXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgQW4gaW50ZWdlciBpbmRpY2F0aW5nIHRoZSBudW1iZXIgb2Ygb2xkIGFycmF5IGVsZW1lbnRzIHRvIHJlbW92ZS4gSWYgYW1vdW50IGlzIDAsIG5vIGVsZW1lbnRzIGFyZSByZW1vdmVkXG4gICAqIEBwYXJhbSB7Kn0gW2VsZW1lbnRzXSBUaGUgZWxlbWVudHMgdG8gYWRkIHRvIHRoZSBhcnJheS4gSWYgeW91IGRvbid0IHNwZWNpZnkgYW55IGVsZW1lbnRzLCBzcGxpY2VDb2wgc2ltcGx5IHJlbW92ZXMgZWxlbWVudHMgZnJvbSB0aGUgYXJyYXlcbiAgICovXG4gIHRoaXMuc3BsaWNlUm93ID0gZnVuY3Rpb24ocm93LCBpbmRleCwgYW1vdW50LyosIGVsZW1lbnRzLi4uICovKSB7XG4gICAgcmV0dXJuIGRhdGFtYXAuc3BsaWNlUm93LmFwcGx5KGRhdGFtYXAsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBpbmRleCBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGNlbGxzIGFzIGFuIGFycmF5IGBbc3RhcnRSb3csIHN0YXJ0Q29sLCBlbmRSb3csIGVuZENvbF1gLlxuICAgKlxuICAgKiBTdGFydCByb3cgYW5kIHN0YXJ0IGNvbCBhcmUgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBhY3RpdmUgY2VsbCAod2hlcmUgdGhlIHNlbGVjdGlvbiB3YXMgc3RhcnRlZCkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gZ2V0U2VsZWN0ZWRcbiAgICogQHJldHVybnMge0FycmF5fVxuICAgKi9cbiAgdGhpcy5nZXRTZWxlY3RlZCA9IGZ1bmN0aW9uKCkgeyAvL2h0dHBzOi8vZ2l0aHViLmNvbS9oYW5kc29udGFibGUvaGFuZHNvbnRhYmxlL2lzc3Vlcy80NCAgLy9jamxcbiAgICBpZiAoc2VsZWN0aW9uLmlzU2VsZWN0ZWQoKSkge1xuICAgICAgcmV0dXJuIFtwcml2LnNlbFJhbmdlLmZyb20ucm93LCBwcml2LnNlbFJhbmdlLmZyb20uY29sLCBwcml2LnNlbFJhbmdlLnRvLnJvdywgcHJpdi5zZWxSYW5nZS50by5jb2xdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBjdXJyZW50IHNlbGVjdGlvbiBhcyBhIFdhbGtvbnRhYmxlQ2VsbFJhbmdlIG9iamVjdC5cbiAgICpcbiAgICogQG1lbWJlcm9mIENvcmUjXG4gICAqIEBmdW5jdGlvbiBnZXRTZWxlY3RlZFJhbmdlXG4gICAqIEBzaW5jZSAwLjExXG4gICAqIEByZXR1cm5zIHtXYWxrb250YWJsZUNlbGxSYW5nZX0gUmV0dXJucyBgdW5kZWZpbmVkYCBpZiB0aGVyZSBpcyBubyBzZWxlY3Rpb24uXG4gICAqL1xuICB0aGlzLmdldFNlbGVjdGVkUmFuZ2UgPSBmdW5jdGlvbigpIHsgLy9odHRwczovL2dpdGh1Yi5jb20vaGFuZHNvbnRhYmxlL2hhbmRzb250YWJsZS9pc3N1ZXMvNDQgIC8vY2psXG4gICAgaWYgKHNlbGVjdGlvbi5pc1NlbGVjdGVkKCkpIHtcbiAgICAgIHJldHVybiBwcml2LnNlbFJhbmdlO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBSZXJlbmRlciB0aGUgdGFibGUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gcmVuZGVyXG4gICAqL1xuICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChpbnN0YW5jZS52aWV3KSB7XG4gICAgICBpbnN0YW5jZS5yZW5kZXJDYWxsID0gdHJ1ZTtcbiAgICAgIGluc3RhbmNlLmZvcmNlRnVsbFJlbmRlciA9IHRydWU7IC8vdXNlZCB3aGVuIGRhdGEgd2FzIGNoYW5nZWRcbiAgICAgIHNlbGVjdGlvbi5yZWZyZXNoQm9yZGVycyhudWxsLCB0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlc2V0IGFsbCBjZWxscyBpbiB0aGUgZ3JpZCB0byBjb250YWluIGRhdGEgZnJvbSB0aGUgZGF0YSBhcnJheS5cbiAgICpcbiAgICogQG1lbWJlcm9mIENvcmUjXG4gICAqIEBmdW5jdGlvbiBsb2FkRGF0YVxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhXG4gICAqIEBmaXJlcyBIb29rcyNhZnRlckxvYWREYXRhXG4gICAqIEBmaXJlcyBIb29rcyNhZnRlckNoYW5nZVxuICAgKi9cbiAgdGhpcy5sb2FkRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEgIT09IG51bGwpIHtcbiAgICAgIGlmICghKGRhdGEucHVzaCAmJiBkYXRhLnNwbGljZSkpIHsgLy9jaGVjayBpZiBkYXRhIGlzIGFycmF5LiBNdXN0IHVzZSBkdWNrLXR5cGUgY2hlY2sgc28gQmFja2JvbmUgQ29sbGVjdGlvbnMgYWxzbyBwYXNzIGl0XG4gICAgICAgIC8vd2hlbiBkYXRhIGlzIG5vdCBhbiBhcnJheSwgYXR0ZW1wdCB0byBtYWtlIGEgc2luZ2xlLXJvdyBhcnJheSBvZiBpdFxuICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICBkYXRhID0gW107XG4gICAgICB2YXIgcm93O1xuICAgICAgZm9yICh2YXIgciA9IDAsIHJsZW4gPSBwcml2LnNldHRpbmdzLnN0YXJ0Um93czsgciA8IHJsZW47IHIrKykge1xuICAgICAgICByb3cgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgYyA9IDAsIGNsZW4gPSBwcml2LnNldHRpbmdzLnN0YXJ0Q29sczsgYyA8IGNsZW47IGMrKykge1xuICAgICAgICAgIHJvdy5wdXNoKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEucHVzaChyb3cpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImxvYWREYXRhIG9ubHkgYWNjZXB0cyBhcnJheSBvZiBvYmplY3RzIG9yIGFycmF5IG9mIGFycmF5cyAoXCIgKyB0eXBlb2YgZGF0YSArIFwiIGdpdmVuKVwiKTtcbiAgICB9XG5cbiAgICBwcml2LmlzUG9wdWxhdGVkID0gZmFsc2U7XG4gICAgR3JpZFNldHRpbmdzLnByb3RvdHlwZS5kYXRhID0gZGF0YTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHByaXYuc2V0dGluZ3MuZGF0YVNjaGVtYSkgfHwgQXJyYXkuaXNBcnJheShkYXRhWzBdKSkge1xuICAgICAgaW5zdGFuY2UuZGF0YVR5cGUgPSAnYXJyYXknO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgcHJpdi5zZXR0aW5ncy5kYXRhU2NoZW1hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbnN0YW5jZS5kYXRhVHlwZSA9ICdmdW5jdGlvbic7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaW5zdGFuY2UuZGF0YVR5cGUgPSAnb2JqZWN0JztcbiAgICB9XG5cbiAgICBkYXRhbWFwID0gbmV3IERhdGFNYXAoaW5zdGFuY2UsIHByaXYsIEdyaWRTZXR0aW5ncyk7XG5cbiAgICBjbGVhckNlbGxTZXR0aW5nQ2FjaGUoKTtcblxuICAgIGdyaWQuYWRqdXN0Um93c0FuZENvbHMoKTtcbiAgICBIYW5kc29udGFibGUuaG9va3MucnVuKGluc3RhbmNlLCAnYWZ0ZXJMb2FkRGF0YScpO1xuXG4gICAgaWYgKHByaXYuZmlyc3RSdW4pIHtcbiAgICAgIHByaXYuZmlyc3RSdW4gPSBbbnVsbCwgJ2xvYWREYXRhJ107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgSGFuZHNvbnRhYmxlLmhvb2tzLnJ1bihpbnN0YW5jZSwgJ2FmdGVyQ2hhbmdlJywgbnVsbCwgJ2xvYWREYXRhJyk7XG4gICAgICBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICBwcml2LmlzUG9wdWxhdGVkID0gdHJ1ZTtcblxuXG4gICAgZnVuY3Rpb24gY2xlYXJDZWxsU2V0dGluZ0NhY2hlKCkge1xuICAgICAgcHJpdi5jZWxsU2V0dGluZ3MubGVuZ3RoID0gMDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY3VycmVudCBkYXRhIG9iamVjdCAodGhlIHNhbWUgdGhhdCB3YXMgcGFzc2VkIGJ5IGBkYXRhYCBjb25maWd1cmF0aW9uIG9wdGlvbiBvciBgbG9hZERhdGFgIG1ldGhvZCkuXG4gICAqIE9wdGlvbmFsbHkgeW91IGNhbiBwcm92aWRlIGNlbGwgcmFuZ2UgYHJvd2AsIGBjb2xgLCBgcm93MmAsIGBjb2wyYCB0byBnZXQgb25seSBhIGZyYWdtZW50IG9mIGdyaWQgZGF0YS5cbiAgICpcbiAgICogQG1lbWJlcm9mIENvcmUjXG4gICAqIEBmdW5jdGlvbiBnZXREYXRhXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcl0gRnJvbSByb3dcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjXSBGcm9tIGNvbFxuICAgKiBAcGFyYW0ge051bWJlcn0gW3IyXSBUbyByb3dcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjMl0gVG8gY29sXG4gICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9XG4gICAqL1xuICB0aGlzLmdldERhdGEgPSBmdW5jdGlvbihyLCBjLCByMiwgYzIpIHtcbiAgICBpZiAodHlwZW9mIHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZGF0YW1hcC5nZXRBbGwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRhdGFtYXAuZ2V0UmFuZ2UobmV3IFdhbGtvbnRhYmxlQ2VsbENvb3JkcyhyLCBjKSwgbmV3IFdhbGtvbnRhYmxlQ2VsbENvb3JkcyhyMiwgYzIpLCBkYXRhbWFwLkRFU1RJTkFUSU9OX1JFTkRFUkVSKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB2YWx1ZSBvZiBzZWxlY3RlZCByYW5nZS4gRWFjaCBjb2x1bW4gaXMgc2VwYXJhdGVkIGJ5IHRhYiwgZWFjaCByb3cgaXMgc2VwYXJhdGVkIGJ5IG5ldyBsaW5lIGNoYXJhY3Rlci5cbiAgICoge0BsaW5rIERhdGFNYXAjZ2V0Q29weWFibGVUZXh0fVxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ29yZSNcbiAgICogQGZ1bmN0aW9uIGdldENvcHlhYmxlRGF0YVxuICAgKiBAc2luY2UgMC4xMVxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRSb3cgRnJvbSByb3dcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0Q29sIEZyb20gY29sXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRSb3cgVG8gcm93XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRDb2wgVG8gY29sXG4gICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9XG4gICAqL1xuICB0aGlzLmdldENvcHlhYmxlRGF0YSA9IGZ1bmN0aW9uKHN0YXJ0Um93LCBzdGFydENvbCwgZW5kUm93LCBlbmRDb2wpIHtcbiAgICByZXR1cm4gZGF0YW1hcC5nZXRDb3B5YWJsZVRleHQobmV3IFdhbGtvbnRhYmxlQ2VsbENvb3JkcyhzdGFydFJvdywgc3RhcnRDb2wpLCBuZXcgV2Fsa29udGFibGVDZWxsQ29vcmRzKGVuZFJvdywgZW5kQ29sKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBzY2hlbWEgcHJvdmlkZWQgYnkgY29uc3RydWN0b3Igc2V0dGluZ3Mgb3IgaWYgaXQgZG9lc24ndCBleGlzdCByZXR1cm4gc2NoZW1hIGJhc2VkIG9uIGRhdGFcbiAgICogc3RydWN0dXJlIG9uIHRoZSBmaXJzdCByb3cuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gZ2V0U2NoZW1hXG4gICAqIEBzaW5jZSAwLjEzLjJcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIHRoaXMuZ2V0U2NoZW1hID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRhdGFtYXAuZ2V0U2NoZW1hKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVzZSBpdCBpZiB5b3UgbmVlZCB0byBjaGFuZ2UgY29uZmlndXJhdGlvbiBhZnRlciBpbml0aWFsaXphdGlvbi5cbiAgICpcbiAgICogQG1lbWJlcm9mIENvcmUjXG4gICAqIEBmdW5jdGlvbiB1cGRhdGVTZXR0aW5nc1xuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0dGluZ3MgU2V0dGluZ3MgdG8gdXBkYXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5pdFxuICAgKiBAZmlyZXMgSG9va3MjYWZ0ZXJDZWxsTWV0YVJlc2V0XG4gICAqIEBmaXJlcyBIb29rcyNhZnRlclVwZGF0ZVNldHRpbmdzXG4gICAqL1xuICB0aGlzLnVwZGF0ZVNldHRpbmdzID0gZnVuY3Rpb24oc2V0dGluZ3MsIGluaXQpIHtcbiAgICB2YXIgaSwgY2xlbjtcblxuICAgIGlmICh0eXBlb2Ygc2V0dGluZ3Mucm93cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ3Jvd3MnIHNldHRpbmcgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gZG8geW91IG1lYW4gc3RhcnRSb3dzLCBtaW5Sb3dzIG9yIG1heFJvd3M/XCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNldHRpbmdzLmNvbHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIidjb2xzJyBzZXR0aW5nIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuIGRvIHlvdSBtZWFuIHN0YXJ0Q29scywgbWluQ29scyBvciBtYXhDb2xzP1wiKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgaW4gc2V0dGluZ3MpIHtcbiAgICAgIGlmIChpID09PSAnZGF0YScpIHtcbiAgICAgICAgY29udGludWU7IC8vbG9hZERhdGEgd2lsbCBiZSB0cmlnZ2VyZWQgbGF0ZXJcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoSGFuZHNvbnRhYmxlLmhvb2tzLmdldFJlZ2lzdGVyZWQoKS5pbmRleE9mKGkpID4gLTEpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzW2ldID09PSAnZnVuY3Rpb24nIHx8IEFycmF5LmlzQXJyYXkoc2V0dGluZ3NbaV0pKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5hZGRIb29rKGksIHNldHRpbmdzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gVXBkYXRlIHNldHRpbmdzXG4gICAgICAgICAgaWYgKCFpbml0ICYmIHNldHRpbmdzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBHcmlkU2V0dGluZ3MucHJvdG90eXBlW2ldID0gc2V0dGluZ3NbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTG9hZCBkYXRhIG9yIGNyZWF0ZSBkYXRhIG1hcFxuICAgIGlmIChzZXR0aW5ncy5kYXRhID09PSB2b2lkIDAgJiYgcHJpdi5zZXR0aW5ncy5kYXRhID09PSB2b2lkIDApIHtcbiAgICAgIGluc3RhbmNlLmxvYWREYXRhKG51bGwpOyAvL2RhdGEgc291cmNlIGNyZWF0ZWQganVzdCBub3dcbiAgICB9XG4gICAgZWxzZSBpZiAoc2V0dGluZ3MuZGF0YSAhPT0gdm9pZCAwKSB7XG4gICAgICBpbnN0YW5jZS5sb2FkRGF0YShzZXR0aW5ncy5kYXRhKTsgLy9kYXRhIHNvdXJjZSBnaXZlbiBhcyBvcHRpb25cbiAgICB9XG4gICAgZWxzZSBpZiAoc2V0dGluZ3MuY29sdW1ucyAhPT0gdm9pZCAwKSB7XG4gICAgICBkYXRhbWFwLmNyZWF0ZU1hcCgpO1xuICAgIH1cblxuICAgIC8vIEluaXQgY29sdW1ucyBjb25zdHJ1Y3RvcnMgY29uZmlndXJhdGlvblxuICAgIGNsZW4gPSBpbnN0YW5jZS5jb3VudENvbHMoKTtcblxuICAgIC8vQ2xlYXIgY2VsbFNldHRpbmdzIGNhY2hlXG4gICAgcHJpdi5jZWxsU2V0dGluZ3MubGVuZ3RoID0gMDtcblxuICAgIGlmIChjbGVuID4gMCkge1xuICAgICAgdmFyIHByb3RvLCBjb2x1bW47XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjbGVuOyBpKyspIHtcbiAgICAgICAgcHJpdi5jb2x1bW5TZXR0aW5nc1tpXSA9IGNvbHVtbkZhY3RvcnkoR3JpZFNldHRpbmdzLCBwcml2LmNvbHVtbnNTZXR0aW5nQ29uZmxpY3RzKTtcblxuICAgICAgICAvLyBzaG9ydGN1dCBmb3IgcHJvdG90eXBlXG4gICAgICAgIHByb3RvID0gcHJpdi5jb2x1bW5TZXR0aW5nc1tpXS5wcm90b3R5cGU7XG5cbiAgICAgICAgLy8gVXNlIHNldHRpbmdzIHByb3ZpZGVkIGJ5IHVzZXJcbiAgICAgICAgaWYgKEdyaWRTZXR0aW5ncy5wcm90b3R5cGUuY29sdW1ucykge1xuICAgICAgICAgIGNvbHVtbiA9IEdyaWRTZXR0aW5ncy5wcm90b3R5cGUuY29sdW1uc1tpXTtcbiAgICAgICAgICBleHRlbmQocHJvdG8sIGNvbHVtbik7XG4gICAgICAgICAgZXh0ZW5kKHByb3RvLCBleHBhbmRUeXBlKGNvbHVtbikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5jZWxsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZm9yIChpIGluIHNldHRpbmdzLmNlbGwpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLmNlbGwuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICB2YXIgY2VsbCA9IHNldHRpbmdzLmNlbGxbaV07XG4gICAgICAgICAgaW5zdGFuY2Uuc2V0Q2VsbE1ldGFPYmplY3QoY2VsbC5yb3csIGNlbGwuY29sLCBjZWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIEhhbmRzb250YWJsZS5ob29rcy5ydW4oaW5zdGFuY2UsICdhZnRlckNlbGxNZXRhUmVzZXQnKTtcblxuICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MuY2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAoR3JpZFNldHRpbmdzLnByb3RvdHlwZS5jbGFzc05hbWUpIHtcbiAgICAgICAgcmVtb3ZlQ2xhc3MoaW5zdGFuY2Uucm9vdEVsZW1lbnQsIEdyaWRTZXR0aW5ncy5wcm90b3R5cGUuY2xhc3NOYW1lKTtcbi8vICAgICAgICBpbnN0YW5jZS5yb290RWxlbWVudC5yZW1vdmVDbGFzcyhHcmlkU2V0dGluZ3MucHJvdG90eXBlLmNsYXNzTmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGluZ3MuY2xhc3NOYW1lKSB7XG4gICAgICAgIGFkZENsYXNzKGluc3RhbmNlLnJvb3RFbGVtZW50LCBzZXR0aW5ncy5jbGFzc05hbWUpO1xuLy8gICAgICAgIGluc3RhbmNlLnJvb3RFbGVtZW50LmFkZENsYXNzKHNldHRpbmdzLmNsYXNzTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5oZWlnaHQgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBoZWlnaHQgPSBzZXR0aW5ncy5oZWlnaHQ7XG5cbiAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0KCk7XG4gICAgICB9XG5cbiAgICAgIGluc3RhbmNlLnJvb3RFbGVtZW50LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzZXR0aW5ncy53aWR0aCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIHdpZHRoID0gc2V0dGluZ3Mud2lkdGg7XG5cbiAgICAgIGlmICh0eXBlb2Ygd2lkdGggPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3aWR0aCA9IHdpZHRoKCk7XG4gICAgICB9XG5cbiAgICAgIGluc3RhbmNlLnJvb3RFbGVtZW50LnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgIH1cblxuICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICBpZiAoaGVpZ2h0KSB7XG4gICAgICBpbnN0YW5jZS5yb290RWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgIH1cbiAgICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG4gICAgaWYgKCFpbml0KSB7XG4gICAgICBIYW5kc29udGFibGUuaG9va3MucnVuKGluc3RhbmNlLCAnYWZ0ZXJVcGRhdGVTZXR0aW5ncycpO1xuICAgIH1cblxuICAgIGdyaWQuYWRqdXN0Um93c0FuZENvbHMoKTtcbiAgICBpZiAoaW5zdGFuY2UudmlldyAmJiAhcHJpdi5maXJzdFJ1bikge1xuICAgICAgaW5zdGFuY2UuZm9yY2VGdWxsUmVuZGVyID0gdHJ1ZTsgLy91c2VkIHdoZW4gZGF0YSB3YXMgY2hhbmdlZFxuICAgICAgc2VsZWN0aW9uLnJlZnJlc2hCb3JkZXJzKG51bGwsIHRydWUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IHZhbHVlIGZyb20gc2VsZWN0ZWQgY2VsbC5cbiAgICpcbiAgICogQG1lbWJlcm9mIENvcmUjXG4gICAqIEBmdW5jdGlvbiBnZXRWYWx1ZVxuICAgKiBAc2luY2UgMC4xMVxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB2YWx1ZSBvZiBzZWxlY3RlZCBjZWxsXG4gICAqL1xuICB0aGlzLmdldFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbCA9IGluc3RhbmNlLmdldFNlbGVjdGVkKCk7XG4gICAgaWYgKEdyaWRTZXR0aW5ncy5wcm90b3R5cGUuZ2V0VmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgR3JpZFNldHRpbmdzLnByb3RvdHlwZS5nZXRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gR3JpZFNldHRpbmdzLnByb3RvdHlwZS5nZXRWYWx1ZS5jYWxsKGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNlbCkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UuZ2V0RGF0YSgpW3NlbFswXV1bR3JpZFNldHRpbmdzLnByb3RvdHlwZS5nZXRWYWx1ZV07XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlbCkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLmdldERhdGFBdENlbGwoc2VsWzBdLCBzZWxbMV0pO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBleHBhbmRUeXBlKG9iaikge1xuICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KCd0eXBlJykpIHtcbiAgICAgIC8vaWdub3JlIG9iai5wcm90b3R5cGUudHlwZVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0eXBlLCBleHBhbmRlZFR5cGUgPSB7fTtcblxuICAgIGlmICh0eXBlb2Ygb2JqLnR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB0eXBlID0gb2JqLnR5cGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBvYmoudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHR5cGUgPSBIYW5kc29udGFibGUuY2VsbFR5cGVzW29iai50eXBlXTtcbiAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgZGVjbGFyZWQgY2VsbCB0eXBlIFwiJyArIG9iai50eXBlICtcbiAgICAgICAgICAnXCIgYXMgYSBzdHJpbmcgdGhhdCBpcyBub3QgbWFwcGVkIHRvIGEga25vd24gb2JqZWN0LiBDZWxsIHR5cGUgbXVzdCBiZSBhbiBvYmplY3Qgb3IgYSBzdHJpbmcgbWFwcGVkIHRvIGFuIG9iamVjdCBpbiBIYW5kc29udGFibGUuY2VsbFR5cGVzJyk7XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICBmb3IgKHZhciBpIGluIHR5cGUpIHtcbiAgICAgIGlmICh0eXBlLmhhc093blByb3BlcnR5KGkpICYmICFvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgZXhwYW5kZWRUeXBlW2ldID0gdHlwZVtpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXhwYW5kZWRUeXBlO1xuXG4gIH1cblxuICAvKipcbiAgICogR2V0IG9iamVjdCBzZXR0aW5ncy5cbiAgICpcbiAgICogQG1lbWJlcm9mIENvcmUjXG4gICAqIEBmdW5jdGlvbiBnZXRTZXR0aW5nc1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjdXJyZW50IGdyaWQgc2V0dGluZ3NcbiAgICovXG4gIHRoaXMuZ2V0U2V0dGluZ3MgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcHJpdi5zZXR0aW5ncztcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXJzIGdyaWQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gY2xlYXJcbiAgICogQHNpbmNlIDAuMTFcbiAgICovXG4gIHRoaXMuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKCk7XG4gICAgc2VsZWN0aW9uLmVtcHR5KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gYWx0ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbiBTZWUgZ3JpZC5hbHRlciBmb3IgcG9zc2libGUgdmFsdWVzOiBgXCJpbnNlcnRfcm93XCJgLCBgXCJpbnNlcnRfY29sXCJgLCBgXCJyZW1vdmVfcm93XCJgLCBgXCJyZW1vdmVfY29sXCJgXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbc291cmNlXSBTb3VyY2Ugb2YgaG9vayBydW5uZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBba2VlcEVtcHR5Um93c10gRmxhZyBmb3IgcHJldmVudGluZyBkZWxldGlvbiBvZiBlbXB0eSByb3dzXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBJbnNlcnQgbmV3IHJvdyhzKSBhYm92ZSB0aGUgcm93IGF0IGdpdmVuIGBpbmRleGAuIElmIGluZGV4IGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYCwgdGhlIG5ldyByb3cgd2lsbCBiZVxuICAgKiBhZGRlZCBhZnRlciB0aGUgY3VycmVudCBsYXN0IHJvdy4gRGVmYXVsdCBgYW1vdW50YCBlcXVhbHMgMS5cbiAgICogYGBganNcbiAgICogdmFyIGhvdCA9IG5ldyBIYW5kc29udGFibGUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2V4YW1wbGUnKSk7XG4gICAqIGhvdC5hbHRlcignaW5zZXJ0X3JvdycsIDEwKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEluc2VydCBuZXcgY29sdW1uKHMpIGJlZm9yZSB0aGUgY29sdW1uIGF0IGdpdmVuIGBpbmRleGAuIElmIGluZGV4IGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYCwgdGhlIG5ldyBjb2x1bW5cbiAgICogd2lsbCBiZSBhZGRlZCBhZnRlciB0aGUgY3VycmVudCBsYXN0IGNvbHVtbi4gRGVmYXVsdCBgYW1vdW50YCBlcXVhbHMgMVxuICAgKiBgYGBqc1xuICAgKiB2YXIgaG90ID0gbmV3IEhhbmRzb250YWJsZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXhhbXBsZScpKTtcbiAgICogaG90LmFsdGVyKCdpbnNlcnRfY29sJywgMTApO1xuICAgKiBgYGBcbiAgICpcbiAgICogUmVtb3ZlIHRoZSByb3cocykgYXQgZ2l2ZW4gYGluZGV4YC4gRGVmYXVsdCBgYW1vdW50YCBlcXVhbHMgMVxuICAgKiBgYGBqc1xuICAgKiB2YXIgaG90ID0gbmV3IEhhbmRzb250YWJsZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXhhbXBsZScpKTtcbiAgICogaG90LmFsdGVyKCdyZW1vdmVfcm93JywgMTApO1xuICAgKiBgYGBcbiAgICpcbiAgICogUmVtb3ZlIHRoZSBjb2x1bW4ocykgYXQgZ2l2ZW4gYGluZGV4YC4gRGVmYXVsdCBgYW1vdW50YCBlcXVhbHMgMVxuICAgKiBgYGBqc1xuICAgKiB2YXIgaG90ID0gbmV3IEhhbmRzb250YWJsZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXhhbXBsZScpKTtcbiAgICogaG90LmFsdGVyKCdyZW1vdmVfY29sJywgMTApO1xuICAgKiBgYGBcbiAgICovXG4gIHRoaXMuYWx0ZXIgPSBmdW5jdGlvbihhY3Rpb24sIGluZGV4LCBhbW91bnQsIHNvdXJjZSwga2VlcEVtcHR5Um93cykge1xuICAgIGdyaWQuYWx0ZXIoYWN0aW9uLCBpbmRleCwgYW1vdW50LCBzb3VyY2UsIGtlZXBFbXB0eVJvd3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIFREIGVsZW1lbnQgZm9yIGdpdmVuIGByb3dgLCBgY29sYCBpZiBpdCBpcyByZW5kZXJlZCBvbiBzY3JlZW4uXG4gICAqIFJldHVybnMgYG51bGxgIGlmIHRoZSBURCBpcyBub3QgcmVuZGVyZWQgb24gc2NyZWVuIChwcm9iYWJseSBiZWNhdXNlIHRoYXQgcGFydCBvZiB0YWJsZSBpcyBub3QgdmlzaWJsZSkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gZ2V0Q2VsbFxuICAgKiBAcGFyYW0ge051bWJlcn0gcm93XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb2xcbiAgICogQHBhcmFtIHtCb29sZWFufSB0b3Btb3N0XG4gICAqIEByZXR1cm5zIHtFbGVtZW50fVxuICAgKi9cbiAgdGhpcy5nZXRDZWxsID0gZnVuY3Rpb24ocm93LCBjb2wsIHRvcG1vc3QpIHtcbiAgICByZXR1cm4gaW5zdGFuY2Uudmlldy5nZXRDZWxsQXRDb29yZHMobmV3IFdhbGtvbnRhYmxlQ2VsbENvb3Jkcyhyb3csIGNvbCksIHRvcG1vc3QpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvb3JkaW5hdGVzIGZvciB0aGUgcHJvdmlkZWQgZWxlbWVudC5cbiAgICpcbiAgICogQG1lbWJlcm9mIENvcmUjXG4gICAqIEBmdW5jdGlvbiBnZXRDb29yZHNcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtXG4gICAqIEByZXR1cm5zIHtXYWxrb250YWJsZUNlbGxDb29yZHN9XG4gICAqL1xuICB0aGlzLmdldENvb3JkcyA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICByZXR1cm4gdGhpcy52aWV3Lnd0Lnd0VGFibGUuZ2V0Q29vcmRzLmNhbGwodGhpcy52aWV3Lnd0Lnd0VGFibGUsIGVsZW0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHByb3BlcnR5IG5hbWUgdGhhdCBjb3JyZXNwb25kcyB3aXRoIHRoZSBnaXZlbiBjb2x1bW4gaW5kZXguIHtAbGluayBEYXRhTWFwI2NvbFRvUHJvcH1cbiAgICpcbiAgICogQG1lbWJlcm9mIENvcmUjXG4gICAqIEBmdW5jdGlvbiBjb2xUb1Byb3BcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbCBDb2x1bW4gaW5kZXhcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIHRoaXMuY29sVG9Qcm9wID0gZnVuY3Rpb24oY29sKSB7XG4gICAgcmV0dXJuIGRhdGFtYXAuY29sVG9Qcm9wKGNvbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY29sdW1uIGluZGV4IHRoYXQgY29ycmVzcG9uZHMgd2l0aCB0aGUgZ2l2ZW4gcHJvcGVydHkuIHtAbGluayBEYXRhTWFwI3Byb3BUb0NvbH1cbiAgICpcbiAgICogQG1lbWJlcm9mIENvcmUjXG4gICAqIEBmdW5jdGlvbiBwcm9wVG9Db2xcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG4gIHRoaXMucHJvcFRvQ29sID0gZnVuY3Rpb24ocHJvcCkge1xuICAgIHJldHVybiBkYXRhbWFwLnByb3BUb0NvbChwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFJldHVybiBjZWxsIHZhbHVlIGF0IGByb3dgLCBgY29sYC4gYHJvd2AgYW5kIGBjb2xgIGFyZSB0aGUgX192aXNpYmxlX18gaW5kZXhlcyAobm90ZSB0aGF0IGlmIGNvbHVtbnMgd2VyZSByZW9yZGVyZWQgb3Igc29ydGVkLFxuICAgKiB0aGUgY3VycmVudCBvcmRlciB3aWxsIGJlIHVzZWQpLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ29yZSNcbiAgICogQGZ1bmN0aW9uIGdldERhdGFBdENlbGxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJvd1xuICAgKiBAcGFyYW0ge051bWJlcn0gY29sXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgdGhpcy5nZXREYXRhQXRDZWxsID0gZnVuY3Rpb24ocm93LCBjb2wpIHtcbiAgICByZXR1cm4gZGF0YW1hcC5nZXQocm93LCBkYXRhbWFwLmNvbFRvUHJvcChjb2wpKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHZhbHVlIGF0IGByb3dgLCBgcHJvcGAuIHtAbGluayBEYXRhTWFwI2dldH1cbiAgICpcbiAgICogQG1lbWJlcm9mIENvcmUjXG4gICAqIEBmdW5jdGlvbiBnZXREYXRhQXRSb3dQcm9wXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByb3dcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICB0aGlzLmdldERhdGFBdFJvd1Byb3AgPSBmdW5jdGlvbihyb3csIHByb3ApIHtcbiAgICByZXR1cm4gZGF0YW1hcC5nZXQocm93LCBwcm9wKTtcbiAgfTtcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFJldHVybnMgYXJyYXkgb2YgY29sdW1uIHZhbHVlcyBmcm9tIHRoZSBkYXRhIHNvdXJjZS4gYGNvbGAgaXMgdGhlIF9fdmlzaWJsZV9fIGluZGV4IG9mIHRoZSBjb2x1bW4uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gZ2V0RGF0YUF0Q29sXG4gICAqIEBzaW5jZSAwLjktYmV0YTJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbFxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuICB0aGlzLmdldERhdGFBdENvbCA9IGZ1bmN0aW9uKGNvbCkge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICByZXR1cm4gb3V0LmNvbmNhdC5hcHBseShvdXQsIGRhdGFtYXAuZ2V0UmFuZ2UoXG4gICAgICBuZXcgV2Fsa29udGFibGVDZWxsQ29vcmRzKDAsIGNvbCksIG5ldyBXYWxrb250YWJsZUNlbGxDb29yZHMocHJpdi5zZXR0aW5ncy5kYXRhLmxlbmd0aCAtIDEsIGNvbCksIGRhdGFtYXAuREVTVElOQVRJT05fUkVOREVSRVIpKTtcbiAgfTtcblxuICAvKipcbiAgICogR2l2ZW4gdGhlIG9iamVjdCBwcm9wZXJ0eSBuYW1lIChlLmcuIGAnZmlyc3QubmFtZSdgKSwgcmV0dXJucyBhcnJheSBvZiBjb2x1bW4gdmFsdWVzIGZyb20gdGhlIGRhdGEgc291cmNlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ29yZSNcbiAgICogQGZ1bmN0aW9uIGdldERhdGFBdFByb3BcbiAgICogQHNpbmNlIDAuOS1iZXRhMlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHRoaXMuZ2V0RGF0YUF0UHJvcCA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICB2YXIgb3V0ID0gW10sXG4gICAgICByYW5nZTtcblxuICAgIHJhbmdlID0gZGF0YW1hcC5nZXRSYW5nZShcbiAgICAgIG5ldyBXYWxrb250YWJsZUNlbGxDb29yZHMoMCwgZGF0YW1hcC5wcm9wVG9Db2wocHJvcCkpLFxuICAgICAgbmV3IFdhbGtvbnRhYmxlQ2VsbENvb3Jkcyhwcml2LnNldHRpbmdzLmRhdGEubGVuZ3RoIC0gMSwgZGF0YW1hcC5wcm9wVG9Db2wocHJvcCkpLFxuICAgICAgZGF0YW1hcC5ERVNUSU5BVElPTl9SRU5ERVJFUik7XG5cbiAgICByZXR1cm4gb3V0LmNvbmNhdC5hcHBseShvdXQsIHJhbmdlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhcnJheSBvZiBjb2x1bW4gdmFsdWVzIGZyb20gdGhlIGRhdGEgc291cmNlLiBgY29sYCBpcyB0aGUgaW5kZXggb2YgdGhlIHJvdyBpbiB0aGUgZGF0YSBzb3VyY2UuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gZ2V0U291cmNlRGF0YUF0Q29sXG4gICAqIEBzaW5jZSAwLjExLjAtYmV0YTNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbFxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuICB0aGlzLmdldFNvdXJjZURhdGFBdENvbCA9IGZ1bmN0aW9uKGNvbCkge1xuICAgIHZhciBvdXQgPSBbXSxcbiAgICAgIGRhdGEgPSBwcml2LnNldHRpbmdzLmRhdGE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIG91dC5wdXNoKGRhdGFbaV1bY29sXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIHNpbmdsZSByb3cgb2YgdGhlIGRhdGEgKGFycmF5IG9yIG9iamVjdCwgZGVwZW5kaW5nIG9uIHdoYXQgeW91IGhhdmUpLiBgcm93YCBpcyB0aGUgaW5kZXggb2YgdGhlIHJvdyBpbiB0aGUgZGF0YSBzb3VyY2UuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gZ2V0U291cmNlRGF0YUF0Um93XG4gICAqIEBzaW5jZSAwLjExLjAtYmV0YTNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJvd1xuICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fVxuICAgKi9cbiAgdGhpcy5nZXRTb3VyY2VEYXRhQXRSb3cgPSBmdW5jdGlvbihyb3cpIHtcbiAgICByZXR1cm4gcHJpdi5zZXR0aW5ncy5kYXRhW3Jvd107XG4gIH07XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZXR1cm5zIGEgc2luZ2xlIHJvdyBvZiB0aGUgZGF0YSAoYXJyYXkgb3Igb2JqZWN0LCBkZXBlbmRpbmcgb24gd2hhdCB5b3UgaGF2ZSkuIGByb3dgIGlzIHRoZSBfX3Zpc2libGVfXyBpbmRleCBvZiB0aGUgcm93LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ29yZSNcbiAgICogQGZ1bmN0aW9uIGdldERhdGFBdFJvd1xuICAgKiBAcGFyYW0ge051bWJlcn0gcm93XG4gICAqIEByZXR1cm5zIHsqfVxuICAgKiBAc2luY2UgMC45LWJldGEyXG4gICAqL1xuICB0aGlzLmdldERhdGFBdFJvdyA9IGZ1bmN0aW9uKHJvdykge1xuICAgIHZhciBkYXRhID0gZGF0YW1hcC5nZXRSYW5nZShuZXcgV2Fsa29udGFibGVDZWxsQ29vcmRzKHJvdywgMCksIG5ldyBXYWxrb250YWJsZUNlbGxDb29yZHMocm93LCB0aGlzLmNvdW50Q29scygpIC0gMSksIGRhdGFtYXAuREVTVElOQVRJT05fUkVOREVSRVIpO1xuXG4gICAgcmV0dXJuIGRhdGFbMF07XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBga2V5YCBwcm9wZXJ0eSBvYmplY3QgZnJvbSBjZWxsIG1ldGEgZGF0YSBjb3JyZXNwb25kaW5nIHRvIHBhcmFtcyBgcm93YCwgYGNvbGAuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gcmVtb3ZlQ2VsbE1ldGFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJvd1xuICAgKiBAcGFyYW0ge051bWJlcn0gY29sXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICovXG4gIHRoaXMucmVtb3ZlQ2VsbE1ldGEgPSBmdW5jdGlvbihyb3csIGNvbCwga2V5KSB7XG4gICAgdmFyIGNlbGxNZXRhID0gaW5zdGFuY2UuZ2V0Q2VsbE1ldGEocm93LCBjb2wpO1xuICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICBpZiAoY2VsbE1ldGFba2V5XSAhPSB1bmRlZmluZWQpIHtcbiAgICAgIGRlbGV0ZSBwcml2LmNlbGxTZXR0aW5nc1tyb3ddW2NvbF1ba2V5XTtcbiAgICB9XG4gICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cbiAgfTtcblxuICAvKipcbiAgICogU2V0IGNlbGwgbWV0YSBkYXRhIG9iamVjdCBgcHJvcGAgdG8gY29ycmVzcG9uZGluZyBwYXJhbXMgYHJvd2AsIGBjb2xgXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gc2V0Q2VsbE1ldGFPYmplY3RcbiAgICogQHNpbmNlIDAuMTFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJvd1xuICAgKiBAcGFyYW0ge051bWJlcn0gY29sXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wXG4gICAqL1xuICB0aGlzLnNldENlbGxNZXRhT2JqZWN0ID0gZnVuY3Rpb24ocm93LCBjb2wsIHByb3ApIHtcbiAgICBpZiAodHlwZW9mIHByb3AgPT09ICdvYmplY3QnKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcCkge1xuICAgICAgICBpZiAocHJvcC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gcHJvcFtrZXldO1xuICAgICAgICAgIHRoaXMuc2V0Q2VsbE1ldGEocm93LCBjb2wsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIGNlbGwgbWV0YSBkYXRhIG9iamVjdCBga2V5YCBjb3JyZXNwb25kaW5nIHRvIHBhcmFtcyBgcm93YCwgYGNvbGAuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gc2V0Q2VsbE1ldGFcbiAgICogQHNpbmNlIDAuMTFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJvd1xuICAgKiBAcGFyYW0ge051bWJlcn0gY29sXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICAgKiBAZmlyZXMgSG9va3MjYWZ0ZXJTZXRDZWxsTWV0YVxuICAgKi9cbiAgdGhpcy5zZXRDZWxsTWV0YSA9IGZ1bmN0aW9uKHJvdywgY29sLCBrZXksIHZhbCkge1xuICAgIGlmICghcHJpdi5jZWxsU2V0dGluZ3Nbcm93XSkge1xuICAgICAgcHJpdi5jZWxsU2V0dGluZ3Nbcm93XSA9IFtdO1xuICAgIH1cbiAgICBpZiAoIXByaXYuY2VsbFNldHRpbmdzW3Jvd11bY29sXSkge1xuICAgICAgcHJpdi5jZWxsU2V0dGluZ3Nbcm93XVtjb2xdID0gbmV3IHByaXYuY29sdW1uU2V0dGluZ3NbY29sXSgpO1xuICAgIH1cbiAgICBwcml2LmNlbGxTZXR0aW5nc1tyb3ddW2NvbF1ba2V5XSA9IHZhbDtcbiAgICBIYW5kc29udGFibGUuaG9va3MucnVuKGluc3RhbmNlLCAnYWZ0ZXJTZXRDZWxsTWV0YScsIHJvdywgY29sLCBrZXksIHZhbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBjZWxsIHByb3BlcnRpZXMgZm9yIGdpdmVuIGByb3dgLCBgY29sYCBjb29yZGluYXRlcy5cbiAgICpcbiAgICogQG1lbWJlcm9mIENvcmUjXG4gICAqIEBmdW5jdGlvbiBnZXRDZWxsTWV0YVxuICAgKiBAcGFyYW0ge051bWJlcn0gcm93XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb2xcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICogQGZpcmVzIEhvb2tzI2JlZm9yZUdldENlbGxNZXRhXG4gICAqIEBmaXJlcyBIb29rcyNhZnRlckdldENlbGxNZXRhXG4gICAqL1xuICB0aGlzLmdldENlbGxNZXRhID0gZnVuY3Rpb24ocm93LCBjb2wpIHtcbiAgICB2YXIgcHJvcCA9IGRhdGFtYXAuY29sVG9Qcm9wKGNvbClcbiAgICAgICwgY2VsbFByb3BlcnRpZXM7XG5cbiAgICByb3cgPSB0cmFuc2xhdGVSb3dJbmRleChyb3cpO1xuICAgIGNvbCA9IHRyYW5zbGF0ZUNvbEluZGV4KGNvbCk7XG5cbiAgICBpZiAoIXByaXYuY29sdW1uU2V0dGluZ3NbY29sXSkge1xuICAgICAgcHJpdi5jb2x1bW5TZXR0aW5nc1tjb2xdID0gY29sdW1uRmFjdG9yeShHcmlkU2V0dGluZ3MsIHByaXYuY29sdW1uc1NldHRpbmdDb25mbGljdHMpO1xuICAgIH1cblxuICAgIGlmICghcHJpdi5jZWxsU2V0dGluZ3Nbcm93XSkge1xuICAgICAgcHJpdi5jZWxsU2V0dGluZ3Nbcm93XSA9IFtdO1xuICAgIH1cbiAgICBpZiAoIXByaXYuY2VsbFNldHRpbmdzW3Jvd11bY29sXSkge1xuICAgICAgcHJpdi5jZWxsU2V0dGluZ3Nbcm93XVtjb2xdID0gbmV3IHByaXYuY29sdW1uU2V0dGluZ3NbY29sXSgpO1xuICAgIH1cblxuICAgIGNlbGxQcm9wZXJ0aWVzID0gcHJpdi5jZWxsU2V0dGluZ3Nbcm93XVtjb2xdOyAvL3JldHJpZXZlIGNlbGxQcm9wZXJ0aWVzIGZyb20gY2FjaGVcblxuICAgIGNlbGxQcm9wZXJ0aWVzLnJvdyA9IHJvdztcbiAgICBjZWxsUHJvcGVydGllcy5jb2wgPSBjb2w7XG4gICAgY2VsbFByb3BlcnRpZXMucHJvcCA9IHByb3A7XG4gICAgY2VsbFByb3BlcnRpZXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcblxuICAgIEhhbmRzb250YWJsZS5ob29rcy5ydW4oaW5zdGFuY2UsICdiZWZvcmVHZXRDZWxsTWV0YScsIHJvdywgY29sLCBjZWxsUHJvcGVydGllcyk7XG4gICAgZXh0ZW5kKGNlbGxQcm9wZXJ0aWVzLCBleHBhbmRUeXBlKGNlbGxQcm9wZXJ0aWVzKSk7IC8vZm9yIGB0eXBlYCBhZGRlZCBpbiBiZWZvcmVHZXRDZWxsTWV0YVxuXG4gICAgaWYgKGNlbGxQcm9wZXJ0aWVzLmNlbGxzKSB7XG4gICAgICB2YXIgc2V0dGluZ3MgPSBjZWxsUHJvcGVydGllcy5jZWxscy5jYWxsKGNlbGxQcm9wZXJ0aWVzLCByb3csIGNvbCwgcHJvcCk7XG5cbiAgICAgIGlmIChzZXR0aW5ncykge1xuICAgICAgICBleHRlbmQoY2VsbFByb3BlcnRpZXMsIHNldHRpbmdzKTtcbiAgICAgICAgZXh0ZW5kKGNlbGxQcm9wZXJ0aWVzLCBleHBhbmRUeXBlKHNldHRpbmdzKSk7IC8vZm9yIGB0eXBlYCBhZGRlZCBpbiBjZWxsc1xuICAgICAgfVxuICAgIH1cblxuICAgIEhhbmRzb250YWJsZS5ob29rcy5ydW4oaW5zdGFuY2UsICdhZnRlckdldENlbGxNZXRhJywgcm93LCBjb2wsIGNlbGxQcm9wZXJ0aWVzKTtcblxuICAgIHJldHVybiBjZWxsUHJvcGVydGllcztcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBkYXRhIGZvcm1hdCBhbmQgY29uZmlnIGFsbG93cyB1c2VyIHRvIG1vZGlmeSB0aGUgY29sdW1uIHN0cnVjdHVyZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmlzQ29sdW1uTW9kaWZpY2F0aW9uQWxsb3dlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhKGluc3RhbmNlLmRhdGFUeXBlID09PSAnb2JqZWN0JyB8fCBpbnN0YW5jZS5nZXRTZXR0aW5ncygpLmNvbHVtbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJZiBkaXNwbGF5ZWQgcm93cyBvcmRlciBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgb3JkZXIgb2Ygcm93cyBzdG9yZWQgaW4gbWVtb3J5IChpLmUuIHNvcnRpbmcgaXMgYXBwbGllZClcbiAgICogd2UgbmVlZCB0byB0cmFuc2xhdGUgbG9naWNhbCAoc3RvcmVkKSByb3cgaW5kZXggdG8gcGh5c2ljYWwgKGRpc3BsYXllZCkgaW5kZXguXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gdHJhbnNsYXRlUm93SW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJvdyBPcmlnaW5hbCByb3cgaW5kZXhcbiAgICogQHJldHVybnMge051bWJlcn0gVHJhbnNsYXRlZCByb3cgaW5kZXhcbiAgICogQGZpcmVzIEhvb2tzI21vZGlmeVJvd1xuICAgKi9cbiAgZnVuY3Rpb24gdHJhbnNsYXRlUm93SW5kZXgocm93KSB7XG4gICAgcmV0dXJuIEhhbmRzb250YWJsZS5ob29rcy5ydW4oaW5zdGFuY2UsICdtb2RpZnlSb3cnLCByb3cpO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIGRpc3BsYXllZCBjb2x1bW5zIG9yZGVyIGlzIGRpZmZlcmVudCB0aGFuIHRoZSBvcmRlciBvZiBjb2x1bW5zIHN0b3JlZCBpbiBtZW1vcnkgKGkuZS4gY29sdW1uIHdlcmUgbW92ZWQgdXNpbmcgbWFudWFsQ29sdW1uTW92ZSBwbHVnaW4pXG4gICAqIHdlIG5lZWQgdG8gdHJhbnNsYXRlIGxvZ2ljYWwgKHN0b3JlZCkgY29sdW1uIGluZGV4IHRvIHBoeXNpY2FsIChkaXNwbGF5ZWQpIGluZGV4LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ29yZSNcbiAgICogQGZ1bmN0aW9uIHRyYW5zbGF0ZUNvbEluZGV4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb2wgT3JpZ2luYWwgY29sdW1uIGluZGV4XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRyYW5zbGF0ZWQgY29sdW1uIGluZGV4XG4gICAqIEBmaXJlcyBIb29rcyNtb2RpZnlDb2xcbiAgICovXG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZUNvbEluZGV4KGNvbCkge1xuICAgIC8vIHdhcm5pbmc6IHRoaXMgbXVzdCBiZSBkb25lIGFmdGVyIGRhdGFtYXAuY29sVG9Qcm9wXG4gICAgcmV0dXJuIEhhbmRzb250YWJsZS5ob29rcy5ydW4oaW5zdGFuY2UsICdtb2RpZnlDb2wnLCBjb2wpO1xuICB9XG5cbiAgdmFyIHJlbmRlcmVyTG9va3VwID0gY2VsbE1ldGhvZExvb2t1cEZhY3RvcnkoJ3JlbmRlcmVyJyk7XG5cbiAgLyoqXG4gICAqIEdldCBjZWxsIHJlbmRlcmVyIHR5cGUgYnkgYHJvd2AgYW5kIGBjb2xgLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ29yZSNcbiAgICogQGZ1bmN0aW9uIGdldENlbGxSZW5kZXJlclxuICAgKiBAc2luY2UgMC4xMVxuICAgKiBAcGFyYW0ge051bWJlcn0gcm93XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb2xcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHJlZGVyZXIgdHlwZVxuICAgKi9cbiAgdGhpcy5nZXRDZWxsUmVuZGVyZXIgPSBmdW5jdGlvbihyb3csIGNvbCkge1xuICAgIHZhciByZW5kZXJlciA9IHJlbmRlcmVyTG9va3VwLmNhbGwodGhpcywgcm93LCBjb2wpO1xuXG4gICAgcmV0dXJuIGdldFJlbmRlcmVyKHJlbmRlcmVyKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGNlbGwgZWRpdG9yIGJ5IGByb3dgIGFuZCBgY29sYC5cbiAgICpcbiAgICogQG1lbWJlcm9mIENvcmUjXG4gICAqIEBmdW5jdGlvbiBnZXRDZWxsRWRpdG9yXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgdGhpcy5nZXRDZWxsRWRpdG9yID0gY2VsbE1ldGhvZExvb2t1cEZhY3RvcnkoJ2VkaXRvcicpO1xuXG4gIC8qKlxuICAgKiBHZXQgY2VsbCB2YWxpZGF0b3IgYnkgYHJvd2AgYW5kIGBjb2xgXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gZ2V0Q2VsbFZhbGlkYXRvclxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHRoaXMuZ2V0Q2VsbFZhbGlkYXRvciA9IGNlbGxNZXRob2RMb29rdXBGYWN0b3J5KCd2YWxpZGF0b3InKTtcblxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgYWxsIGNlbGxzIHVzaW5nIHRoZWlyIHZhbGlkYXRvciBmdW5jdGlvbnMgYW5kIGNhbGxzIGNhbGxiYWNrIHdoZW4gZmluaXNoZWQuIERvZXMgbm90IHJlbmRlciB0aGUgdmlldy5cbiAgICpcbiAgICogSWYgb25lIG9mIGNlbGxzIGlzIGludmFsaWQgY2FsbGJhY2sgd2lsbCBiZSBmaXJlZCB3aXRoIGAndmFsaWQnYCBhcmd1bWVudHMgYXMgYGZhbHNlYCBvdGhlcndpc2UgYHRydWVgLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ29yZSNcbiAgICogQGZ1bmN0aW9uIHZhbGlkYXRlQ2VsbHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHRoaXMudmFsaWRhdGVDZWxscyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIHdhaXRpbmdGb3JWYWxpZGF0b3IgPSBuZXcgVmFsaWRhdG9yc1F1ZXVlKCk7XG4gICAgd2FpdGluZ0ZvclZhbGlkYXRvci5vblF1ZXVlRW1wdHkgPSBjYWxsYmFjaztcblxuICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICB2YXIgaSA9IGluc3RhbmNlLmNvdW50Um93cygpIC0gMTtcbiAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICB2YXIgaiA9IGluc3RhbmNlLmNvdW50Q29scygpIC0gMTtcbiAgICAgIHdoaWxlIChqID49IDApIHtcbiAgICAgICAgd2FpdGluZ0ZvclZhbGlkYXRvci5hZGRWYWxpZGF0b3JUb1F1ZXVlKCk7XG4gICAgICAgIGluc3RhbmNlLnZhbGlkYXRlQ2VsbChpbnN0YW5jZS5nZXREYXRhQXRDZWxsKGksIGopLCBpbnN0YW5jZS5nZXRDZWxsTWV0YShpLCBqKSwgZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdGlvbiBlcnJvcjogcmVzdWx0IGlzIG5vdCBib29sZWFuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgd2FpdGluZ0ZvclZhbGlkYXRvci52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3YWl0aW5nRm9yVmFsaWRhdG9yLnJlbW92ZVZhbGlkYXRvckZvcm1RdWV1ZSgpO1xuICAgICAgICB9LCAndmFsaWRhdGVDZWxscycpO1xuICAgICAgICBqLS07XG4gICAgICB9XG4gICAgICBpLS07XG4gICAgfVxuICAgIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG4gICAgd2FpdGluZ0ZvclZhbGlkYXRvci5jaGVja0lmUXVldWVJc0VtcHR5KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYXJyYXkgb2Ygcm93IGhlYWRlcnMgKGlmIHRoZXkgYXJlIGVuYWJsZWQpLiBJZiBwYXJhbSBgcm93YCBnaXZlbiwgcmV0dXJuIGhlYWRlciBhdCBnaXZlbiByb3cgYXMgc3RyaW5nLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ29yZSNcbiAgICogQGZ1bmN0aW9uIGdldFJvd0hlYWRlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3Jvd11cbiAgICogQHJldHVybnMge0FycmF5fFN0cmluZ31cbiAgICovXG4gIHRoaXMuZ2V0Um93SGVhZGVyID0gZnVuY3Rpb24ocm93KSB7XG4gICAgaWYgKHJvdyA9PT0gdm9pZCAwKSB7XG4gICAgICB2YXIgb3V0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWxlbiA9IGluc3RhbmNlLmNvdW50Um93cygpOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICAgIG91dC5wdXNoKGluc3RhbmNlLmdldFJvd0hlYWRlcihpKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHByaXYuc2V0dGluZ3Mucm93SGVhZGVycykgJiYgcHJpdi5zZXR0aW5ncy5yb3dIZWFkZXJzW3Jvd10gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHByaXYuc2V0dGluZ3Mucm93SGVhZGVyc1tyb3ddO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgcHJpdi5zZXR0aW5ncy5yb3dIZWFkZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gcHJpdi5zZXR0aW5ncy5yb3dIZWFkZXJzKHJvdyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByaXYuc2V0dGluZ3Mucm93SGVhZGVycyAmJiB0eXBlb2YgcHJpdi5zZXR0aW5ncy5yb3dIZWFkZXJzICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcHJpdi5zZXR0aW5ncy5yb3dIZWFkZXJzICE9PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHJvdyArIDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHByaXYuc2V0dGluZ3Mucm93SGVhZGVycztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaW5mb3JtYXRpb24gb2YgdGhpcyB0YWJsZSBpcyBjb25maWd1cmVkIHRvIGRpc3BsYXkgcm93IGhlYWRlcnMuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gaGFzUm93SGVhZGVyc1xuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICogQHNpbmNlIDAuMTFcbiAgICovXG4gIHRoaXMuaGFzUm93SGVhZGVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIXByaXYuc2V0dGluZ3Mucm93SGVhZGVycztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBvZiB0aGlzIHRhYmxlIGlzIGNvbmZpZ3VyZWQgdG8gZGlzcGxheSBjb2x1bW4gaGVhZGVycy5cbiAgICpcbiAgICogQG1lbWJlcm9mIENvcmUjXG4gICAqIEBmdW5jdGlvbiBoYXNDb2xIZWFkZXJzXG4gICAqIEBzaW5jZSAwLjExXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgdGhpcy5oYXNDb2xIZWFkZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHByaXYuc2V0dGluZ3MuY29sSGVhZGVycyAhPT0gdm9pZCAwICYmIHByaXYuc2V0dGluZ3MuY29sSGVhZGVycyAhPT0gbnVsbCkgeyAvL1BvbHltZXIgaGFzIGVtcHR5IHZhbHVlID0gbnVsbFxuICAgICAgcmV0dXJuICEhcHJpdi5zZXR0aW5ncy5jb2xIZWFkZXJzO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgaWxlbiA9IGluc3RhbmNlLmNvdW50Q29scygpOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBpZiAoaW5zdGFuY2UuZ2V0Q29sSGVhZGVyKGkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBhcnJheSBvZiBjb2x1bW4gaGVhZGVycyAoaWYgdGhleSBhcmUgZW5hYmxlZCkuIElmIHBhcmFtIGBjb2xgIGdpdmVuLCByZXR1cm4gaGVhZGVyIGF0IGdpdmVuIGNvbHVtbiBhcyBzdHJpbmdcbiAgICpcbiAgICogQG1lbWJlcm9mIENvcmUjXG4gICAqIEBmdW5jdGlvbiBnZXRDb2xIZWFkZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb2xdIENvbHVtbiBpbmRleFxuICAgKiBAcmV0dXJucyB7QXJyYXl8U3RyaW5nfVxuICAgKi9cbiAgdGhpcy5nZXRDb2xIZWFkZXIgPSBmdW5jdGlvbihjb2wpIHtcbiAgICBpZiAoY29sID09PSB2b2lkIDApIHtcbiAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbGVuID0gaW5zdGFuY2UuY291bnRDb2xzKCk7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgICAgb3V0LnB1c2goaW5zdGFuY2UuZ2V0Q29sSGVhZGVyKGkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIGJhc2VDb2wgPSBjb2w7XG5cbiAgICAgIGNvbCA9IEhhbmRzb250YWJsZS5ob29rcy5ydW4oaW5zdGFuY2UsICdtb2RpZnlDb2wnLCBjb2wpO1xuXG4gICAgICBpZiAocHJpdi5zZXR0aW5ncy5jb2x1bW5zICYmIHByaXYuc2V0dGluZ3MuY29sdW1uc1tjb2xdICYmIHByaXYuc2V0dGluZ3MuY29sdW1uc1tjb2xdLnRpdGxlKSB7XG4gICAgICAgIHJldHVybiBwcml2LnNldHRpbmdzLmNvbHVtbnNbY29sXS50aXRsZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocHJpdi5zZXR0aW5ncy5jb2xIZWFkZXJzKSAmJiBwcml2LnNldHRpbmdzLmNvbEhlYWRlcnNbY29sXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiBwcml2LnNldHRpbmdzLmNvbEhlYWRlcnNbY29sXTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBwcml2LnNldHRpbmdzLmNvbEhlYWRlcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHByaXYuc2V0dGluZ3MuY29sSGVhZGVycyhjb2wpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocHJpdi5zZXR0aW5ncy5jb2xIZWFkZXJzICYmIHR5cGVvZiBwcml2LnNldHRpbmdzLmNvbEhlYWRlcnMgIT09ICdzdHJpbmcnICYmIHR5cGVvZiBwcml2LnNldHRpbmdzLmNvbEhlYWRlcnMgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBzcHJlYWRzaGVldENvbHVtbkxhYmVsKGJhc2VDb2wpOyAvL3NlZSAjMTQ1OFxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBwcml2LnNldHRpbmdzLmNvbEhlYWRlcnM7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gY29sdW1uIHdpZHRoIGZyb20gc2V0dGluZ3MgKG5vIGd1ZXNzaW5nKS4gUHJpdmF0ZSB1c2UgaW50ZW5kZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gX2dldENvbFdpZHRoRnJvbVNldHRpbmdzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb2xcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG4gIHRoaXMuX2dldENvbFdpZHRoRnJvbVNldHRpbmdzID0gZnVuY3Rpb24oY29sKSB7XG4gICAgdmFyIGNlbGxQcm9wZXJ0aWVzID0gaW5zdGFuY2UuZ2V0Q2VsbE1ldGEoMCwgY29sKTtcbiAgICB2YXIgd2lkdGggPSBjZWxsUHJvcGVydGllcy53aWR0aDtcblxuICAgIGlmICh3aWR0aCA9PT0gdm9pZCAwIHx8IHdpZHRoID09PSBwcml2LnNldHRpbmdzLndpZHRoKSB7XG4gICAgICB3aWR0aCA9IGNlbGxQcm9wZXJ0aWVzLmNvbFdpZHRocztcbiAgICB9XG4gICAgaWYgKHdpZHRoICE9PSB2b2lkIDAgJiYgd2lkdGggIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAodHlwZW9mIHdpZHRoKSB7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6IC8vIGFycmF5XG4gICAgICAgICAgd2lkdGggPSB3aWR0aFtjb2xdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICB3aWR0aCA9IHdpZHRoKGNvbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHdpZHRoID09PSAnc3RyaW5nJykge1xuICAgICAgICB3aWR0aCA9IHBhcnNlSW50KHdpZHRoLCAxMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHdpZHRoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gY29sdW1uIHdpZHRoXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gZ2V0Q29sV2lkdGhcbiAgICogQHNpbmNlIDAuMTFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZmlyZXMgSG9va3MjbW9kaWZ5Q29sV2lkdGhcbiAgICovXG4gIHRoaXMuZ2V0Q29sV2lkdGggPSBmdW5jdGlvbihjb2wpIHtcbiAgICBsZXQgd2lkdGggPSBpbnN0YW5jZS5fZ2V0Q29sV2lkdGhGcm9tU2V0dGluZ3MoY29sKTtcblxuICAgIHdpZHRoID0gSGFuZHNvbnRhYmxlLmhvb2tzLnJ1bihpbnN0YW5jZSwgJ21vZGlmeUNvbFdpZHRoJywgd2lkdGgsIGNvbCk7XG5cbiAgICBpZiAod2lkdGggPT09IHZvaWQgMCkge1xuICAgICAgd2lkdGggPSBXYWxrb250YWJsZVZpZXdwb3J0Q29sdW1uc0NhbGN1bGF0b3IuREVGQVVMVF9XSURUSDtcbiAgICB9XG5cbiAgICByZXR1cm4gd2lkdGg7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiByb3cgaGVpZ2h0IGZyb20gc2V0dGluZ3MgKG5vIGd1ZXNzaW5nKS4gUHJpdmF0ZSB1c2UgaW50ZW5kZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gX2dldFJvd0hlaWdodEZyb21TZXR0aW5nc1xuICAgKiBAcGFyYW0ge051bWJlcn0gcm93XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuICB0aGlzLl9nZXRSb3dIZWlnaHRGcm9tU2V0dGluZ3MgPSBmdW5jdGlvbihyb3cpIHtcbiAgICAvL2xldCBjZWxsUHJvcGVydGllcyA9IGluc3RhbmNlLmdldENlbGxNZXRhKHJvdywgMCk7XG4gICAgLy9sZXQgaGVpZ2h0ID0gY2VsbFByb3BlcnRpZXMuaGVpZ2h0O1xuICAgIC8vXG4gICAgLy9pZiAoaGVpZ2h0ID09PSB2b2lkIDAgfHwgaGVpZ2h0ID09PSBwcml2LnNldHRpbmdzLmhlaWdodCkge1xuICAgIC8vICBoZWlnaHQgPSBjZWxsUHJvcGVydGllcy5yb3dIZWlnaHRzO1xuICAgIC8vfVxuICAgIHZhciBoZWlnaHQgPSBwcml2LnNldHRpbmdzLnJvd0hlaWdodHM7XG5cbiAgICBpZiAoaGVpZ2h0ICE9PSB2b2lkIDAgJiYgaGVpZ2h0ICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKHR5cGVvZiBoZWlnaHQpIHtcbiAgICAgICAgY2FzZSAnb2JqZWN0JzogLy8gYXJyYXlcbiAgICAgICAgICBoZWlnaHQgPSBoZWlnaHRbcm93XTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0KHJvdyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGhlaWdodCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaGVpZ2h0ID0gcGFyc2VJbnQoaGVpZ2h0LCAxMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGhlaWdodDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHJvdyBoZWlnaHQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gZ2V0Um93SGVpZ2h0XG4gICAqIEBzaW5jZSAwLjExXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByb3dcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGZpcmVzIEhvb2tzI21vZGlmeVJvd0hlaWdodFxuICAgKi9cbiAgdGhpcy5nZXRSb3dIZWlnaHQgPSBmdW5jdGlvbihyb3cpIHtcbiAgICB2YXIgaGVpZ2h0ID0gaW5zdGFuY2UuX2dldFJvd0hlaWdodEZyb21TZXR0aW5ncyhyb3cpO1xuXG4gICAgaGVpZ2h0ID0gSGFuZHNvbnRhYmxlLmhvb2tzLnJ1bihpbnN0YW5jZSwgJ21vZGlmeVJvd0hlaWdodCcsIGhlaWdodCwgcm93KTtcblxuICAgIHJldHVybiBoZWlnaHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdG90YWwgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIGdyaWQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gY291bnRSb3dzXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRvdGFsIG51bWJlciBpbiByb3dzIHRoZSBncmlkXG4gICAqL1xuICB0aGlzLmNvdW50Um93cyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwcml2LnNldHRpbmdzLmRhdGEubGVuZ3RoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRvdGFsIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBncmlkLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ29yZSNcbiAgICogQGZ1bmN0aW9uIGNvdW50Q29sc1xuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUb3RhbCBudW1iZXIgb2YgY29sdW1uc1xuICAgKi9cbiAgdGhpcy5jb3VudENvbHMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGF0YVR5cGUgPT09ICdvYmplY3QnIHx8IGluc3RhbmNlLmRhdGFUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAocHJpdi5zZXR0aW5ncy5jb2x1bW5zICYmIHByaXYuc2V0dGluZ3MuY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHByaXYuc2V0dGluZ3MuY29sdW1ucy5sZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRhdGFtYXAuY29sVG9Qcm9wQ2FjaGUubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpbnN0YW5jZS5kYXRhVHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgaWYgKHByaXYuc2V0dGluZ3MuY29sdW1ucyAmJiBwcml2LnNldHRpbmdzLmNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBwcml2LnNldHRpbmdzLmNvbHVtbnMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocHJpdi5zZXR0aW5ncy5kYXRhICYmIHByaXYuc2V0dGluZ3MuZGF0YVswXSAmJiBwcml2LnNldHRpbmdzLmRhdGFbMF0ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBwcml2LnNldHRpbmdzLmRhdGFbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0IGluZGV4IG9mIGZpcnN0IHZpc2libGUgcm93LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ29yZSNcbiAgICogQGZ1bmN0aW9uIHJvd09mZnNldFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGluZGV4IG9mIGZpcnN0IHZpc2libGUgcm93XG4gICAqL1xuICB0aGlzLnJvd09mZnNldCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpbnN0YW5jZS52aWV3Lnd0Lnd0VGFibGUuZ2V0Rmlyc3RSZW5kZXJlZFJvdygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgaW5kZXggb2YgZmlyc3QgdmlzaWJsZSBjb2x1bW4uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gY29sT2Zmc2V0XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybiBpbmRleCBvZiBmaXJzdCB2aXNpYmxlIGNvbHVtbi5cbiAgICovXG4gIHRoaXMuY29sT2Zmc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLnZpZXcud3Qud3RUYWJsZS5nZXRGaXJzdFJlbmRlcmVkQ29sdW1uKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBudW1iZXIgb2YgcmVuZGVyZWQgcm93cyAoaW5jbHVkaW5nIHJvd3MgcGFydGlhbGx5IG9yIGZ1bGx5IHJlbmRlcmVkIG91dHNpZGUgdmlld3BvcnQpLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ29yZSNcbiAgICogQGZ1bmN0aW9uIGNvdW50UmVuZGVyZWRSb3dzXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgLTEgaWYgdGFibGUgaXMgbm90IHZpc2libGVcbiAgICovXG4gIHRoaXMuY291bnRSZW5kZXJlZFJvd3MgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaW5zdGFuY2Uudmlldy53dC5kcmF3biA/IGluc3RhbmNlLnZpZXcud3Qud3RUYWJsZS5nZXRSZW5kZXJlZFJvd3NDb3VudCgpIDogLTE7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybiBudW1iZXIgb2YgdmlzaWJsZSByb3dzIChyZW5kZXJlZCByb3dzIHRoYXQgZnVsbHkgZml0IGluc2lkZSB2aWV3cG9ydCkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gY291bnRWaXNpYmxlUm93c1xuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIC0xIGlmIHRhYmxlIGlzIG5vdCB2aXNpYmxlXG4gICAqL1xuICB0aGlzLmNvdW50VmlzaWJsZVJvd3MgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaW5zdGFuY2Uudmlldy53dC5kcmF3biA/IGluc3RhbmNlLnZpZXcud3Qud3RUYWJsZS5nZXRWaXNpYmxlUm93c0NvdW50KCkgOiAtMTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIG51bWJlciBvZiB2aXNpYmxlIGNvbHVtbnMuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gY291bnRSZW5kZXJlZENvbHNcbiAgICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyAtMSBpZiB0YWJsZSBpcyBub3QgdmlzaWJsZVxuICAgKi9cbiAgdGhpcy5jb3VudFJlbmRlcmVkQ29scyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpbnN0YW5jZS52aWV3Lnd0LmRyYXduID8gaW5zdGFuY2Uudmlldy53dC53dFRhYmxlLmdldFJlbmRlcmVkQ29sdW1uc0NvdW50KCkgOiAtMTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIG51bWJlciBvZiB2aXNpYmxlIGNvbHVtbnMuIFJldHVybnMgLTEgaWYgdGFibGUgaXMgbm90IHZpc2libGVcbiAgICpcbiAgICogQG1lbWJlcm9mIENvcmUjXG4gICAqIEBmdW5jdGlvbiBjb3VudFZpc2libGVDb2xzXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIHRoaXMuY291bnRWaXNpYmxlQ29scyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpbnN0YW5jZS52aWV3Lnd0LmRyYXduID8gaW5zdGFuY2Uudmlldy53dC53dFRhYmxlLmdldFZpc2libGVDb2x1bW5zQ291bnQoKSA6IC0xO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG51bWJlciBvZiBlbXB0eSByb3dzLiBJZiB0aGUgb3B0aW9uYWwgZW5kaW5nIHBhcmFtZXRlciBpcyBgdHJ1ZWAsIHJldHVybnNcbiAgICogbnVtYmVyIG9mIGVtcHR5IHJvd3MgYXQgdGhlIGJvdHRvbSBvZiB0aGUgdGFibGUuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gY291bnRFbXB0eVJvd3NcbiAgICogQHBhcmFtIHtCb29sZWFufSBbZW5kaW5nXSBJZiBgdHJ1ZWAsIHdpbGwgb25seSBjb3VudCBlbXB0eSByb3dzIGF0IHRoZSBlbmQgb2YgdGhlIGRhdGEgc291cmNlXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IENvdW50IGVtcHR5IHJvd3NcbiAgICogQGZpcmVzIEhvb2tzI21vZGlmeVJvd1xuICAgKi9cbiAgdGhpcy5jb3VudEVtcHR5Um93cyA9IGZ1bmN0aW9uKGVuZGluZykge1xuICAgIHZhciBpID0gaW5zdGFuY2UuY291bnRSb3dzKCkgLSAxLFxuICAgICAgZW1wdHkgPSAwLFxuICAgICAgcm93O1xuXG4gICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgcm93ID0gSGFuZHNvbnRhYmxlLmhvb2tzLnJ1bih0aGlzLCAnbW9kaWZ5Um93JywgaSk7XG5cbiAgICAgIGlmIChpbnN0YW5jZS5pc0VtcHR5Um93KHJvdykpIHtcbiAgICAgICAgZW1wdHkrKztcblxuICAgICAgfSBlbHNlIGlmIChlbmRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIGVtcHR5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG51bWJlciBvZiBlbXB0eSBjb2x1bW5zLiBJZiB0aGUgb3B0aW9uYWwgZW5kaW5nIHBhcmFtZXRlciBpcyBgdHJ1ZWAsIHJldHVybnMgbnVtYmVyIG9mIGVtcHR5XG4gICAqIGNvbHVtbnMgYXQgcmlnaHQgaGFuZCBlZGdlIG9mIHRoZSB0YWJsZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIENvcmUjXG4gICAqIEBmdW5jdGlvbiBjb3VudEVtcHR5Q29sc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtlbmRpbmddIElmIGB0cnVlYCwgd2lsbCBvbmx5IGNvdW50IGVtcHR5IGNvbHVtbnMgYXQgdGhlIGVuZCBvZiB0aGUgZGF0YSBzb3VyY2Ugcm93XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IENvdW50IGVtcHR5IGNvbHNcbiAgICovXG4gIHRoaXMuY291bnRFbXB0eUNvbHMgPSBmdW5jdGlvbihlbmRpbmcpIHtcbiAgICBpZiAoaW5zdGFuY2UuY291bnRSb3dzKCkgPCAxKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgaSA9IGluc3RhbmNlLmNvdW50Q29scygpIC0gMVxuICAgICAgLCBlbXB0eSA9IDA7XG4gICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgaWYgKGluc3RhbmNlLmlzRW1wdHlDb2woaSkpIHtcbiAgICAgICAgZW1wdHkrKztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGVuZGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGktLTtcbiAgICB9XG4gICAgcmV0dXJuIGVtcHR5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpcyBgcm93YCBpcyBlbXB0eS5cbiAgICpcbiAgICogQG1lbWJlcm9mIENvcmUjXG4gICAqIEBmdW5jdGlvbiBpc0VtcHR5Um93XG4gICAqIEBwYXJhbSB7TnVtYmVyfSByb3cgUm93IGluZGV4XG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm4gYHRydWVgIGlmIHRoZSByb3cgYXQgdGhlIGdpdmVuIGByb3dgIGlzIGVtcHR5LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICovXG4gIHRoaXMuaXNFbXB0eVJvdyA9IGZ1bmN0aW9uKHJvdykge1xuICAgIHJldHVybiBwcml2LnNldHRpbmdzLmlzRW1wdHlSb3cuY2FsbChpbnN0YW5jZSwgcm93KTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaXMgYGNvbGAgaXMgZW1wdHkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gaXNFbXB0eUNvbFxuICAgKiBAcGFyYW0ge051bWJlcn0gY29sIENvbHVtbiBpbmRleFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJuIGB0cnVlYCBpZiB0aGUgY29sdW1uIGF0IHRoZSBnaXZlbiBgY29sYCBpcyBlbXB0eSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqL1xuICB0aGlzLmlzRW1wdHlDb2wgPSBmdW5jdGlvbihjb2wpIHtcbiAgICByZXR1cm4gcHJpdi5zZXR0aW5ncy5pc0VtcHR5Q29sLmNhbGwoaW5zdGFuY2UsIGNvbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNlbGVjdCBjZWxsIGByb3dgLCBgY29sYCBvciByYW5nZSBvZiBjZWxscyBmaW5pc2hpbmcgYXQgYGVuZFJvd2AsIGBlbmRDb2xgLlxuICAgKiBCeSBkZWZhdWx0LCB2aWV3cG9ydCB3aWxsIGJlIHNjcm9sbGVkIHRvIHNlbGVjdGlvbiBhbmQgYWZ0ZXIgYHNlbGVjdENlbGxgIGNhbGwgaW5zdGFuY2Ugd2lsbCBiZSBsaXN0ZW5pbmdcbiAgICogdG8ga2V5Ym9hcmQgaW5wdXQgb24gZG9jdW1lbnQuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gc2VsZWN0Q2VsbFxuICAgKiBAcGFyYW0ge051bWJlcn0gcm93XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb2xcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtlbmRSb3ddXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kQ29sXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzY3JvbGxUb0NlbGw9dHJ1ZV0gSWYgYHRydWVgLCB2aWV3cG9ydCB3aWxsIGJlIHNjcm9sbGVkIHRvIHRoZSBzZWxlY3Rpb25cbiAgICogQHBhcmFtIHtCb29sZWFufSBbY2hhbmdlTGlzdGVuZXI9dHJ1ZV0gSWYgYGZhbHNlYCwgSGFuZHNvbnRhYmxlIHdpbGwgbm90IGNoYW5nZSBrZXlib2FyZCBldmVudHMgbGlzdGVuZXIgdG9cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGltc2VsZiAoZGVmYXVsdCBgdHJ1ZWApXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgdGhpcy5zZWxlY3RDZWxsID0gZnVuY3Rpb24ocm93LCBjb2wsIGVuZFJvdywgZW5kQ29sLCBzY3JvbGxUb0NlbGwsIGNoYW5nZUxpc3RlbmVyKSB7XG4gICAgdmFyIGNvb3JkcztcblxuICAgIGNoYW5nZUxpc3RlbmVyID0gdHlwZW9mIGNoYW5nZUxpc3RlbmVyID09PSAndW5kZWZpbmVkJyB8fCBjaGFuZ2VMaXN0ZW5lciA9PT0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2Ygcm93ICE9PSAnbnVtYmVyJyB8fCByb3cgPCAwIHx8IHJvdyA+PSBpbnN0YW5jZS5jb3VudFJvd3MoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbCAhPT0gJ251bWJlcicgfHwgY29sIDwgMCB8fCBjb2wgPj0gaW5zdGFuY2UuY291bnRDb2xzKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmRSb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAodHlwZW9mIGVuZFJvdyAhPT0gJ251bWJlcicgfHwgZW5kUm93IDwgMCB8fCBlbmRSb3cgPj0gaW5zdGFuY2UuY291bnRSb3dzKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlbmRDb2wgIT09ICdudW1iZXInIHx8IGVuZENvbCA8IDAgfHwgZW5kQ29sID49IGluc3RhbmNlLmNvdW50Q29scygpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29vcmRzID0gbmV3IFdhbGtvbnRhYmxlQ2VsbENvb3Jkcyhyb3csIGNvbCk7XG4gICAgcHJpdi5zZWxSYW5nZSA9IG5ldyBXYWxrb250YWJsZUNlbGxSYW5nZShjb29yZHMsIGNvb3JkcywgY29vcmRzKTtcblxuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJlxuICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgLy8gbmVlZGVkIG9yIG90aGVyd2lzZSBwcmVwYXJlIHdvbid0IGZvY3VzIHRoZSBjZWxsLiBzZWxlY3Rpb25TcGVjIHRlc3RzIHRoaXMgKHNob3VsZCBtb3ZlIGZvY3VzIHRvIHNlbGVjdGVkIGNlbGwpXG4gICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICB9XG4gICAgaWYgKGNoYW5nZUxpc3RlbmVyKSB7XG4gICAgICBpbnN0YW5jZS5saXN0ZW4oKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGVuZFJvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHNlbGVjdGlvbi5zZXRSYW5nZUVuZChwcml2LnNlbFJhbmdlLmZyb20sIHNjcm9sbFRvQ2VsbCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0aW9uLnNldFJhbmdlRW5kKG5ldyBXYWxrb250YWJsZUNlbGxDb29yZHMoZW5kUm93LCBlbmRDb2wpLCBzY3JvbGxUb0NlbGwpO1xuICAgIH1cbiAgICBpbnN0YW5jZS5zZWxlY3Rpb24uZmluaXNoKCk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogU2VsZWN0IGNlbGwgYHJvd2AsIGBwcm9wYCBvciByYW5nZSBmaW5pc2hpbmcgYXQgYGVuZFJvd2AsIGBlbmRQcm9wYC4gQnkgZGVmYXVsdCwgdmlld3BvcnQgd2lsbCBiZSBzY3JvbGxlZCB0byBzZWxlY3Rpb24uXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gc2VsZWN0Q2VsbEJ5UHJvcFxuICAgKiBAcGFyYW0ge051bWJlcn0gcm93XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZW5kUm93XVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2VuZFByb3BdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Njcm9sbFRvQ2VsbD10cnVlXSBJZiBgdHJ1ZWAsIHZpZXdwb3J0IHdpbGwgYmUgc2Nyb2xsZWQgdG8gdGhlIHNlbGVjdGlvblxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIHRoaXMuc2VsZWN0Q2VsbEJ5UHJvcCA9IGZ1bmN0aW9uKHJvdywgcHJvcCwgZW5kUm93LCBlbmRQcm9wLCBzY3JvbGxUb0NlbGwpIHtcbiAgICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gICAgYXJndW1lbnRzWzFdID0gZGF0YW1hcC5wcm9wVG9Db2woYXJndW1lbnRzWzFdKTtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1szXSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgYXJndW1lbnRzWzNdID0gZGF0YW1hcC5wcm9wVG9Db2woYXJndW1lbnRzWzNdKTtcbiAgICB9XG4gICAgcmV0dXJuIGluc3RhbmNlLnNlbGVjdENlbGwuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG4gICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cbiAgfTtcblxuICAvKipcbiAgICogRGVzZWxlY3RzIGN1cnJlbnQgY2VsbCBzZWxlY3Rpb24gb24gZ3JpZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIENvcmUjXG4gICAqIEBmdW5jdGlvbiBkZXNlbGVjdENlbGxcbiAgICovXG4gIHRoaXMuZGVzZWxlY3RDZWxsID0gZnVuY3Rpb24oKSB7XG4gICAgc2VsZWN0aW9uLmRlc2VsZWN0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBncmlkIGZyb20gRE9NLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ29yZSNcbiAgICogQGZ1bmN0aW9uIGRlc3Ryb3lcbiAgICogQGZpcmVzIEhvb2tzI2FmdGVyRGVzdHJveVxuICAgKi9cbiAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cbiAgICBpbnN0YW5jZS5fY2xlYXJUaW1lb3V0cygpO1xuICAgIGlmIChpbnN0YW5jZS52aWV3KSB7IC8vaW4gY2FzZSBIVCBpcyBkZXN0cm95ZWQgYmVmb3JlIGluaXRpYWxpemF0aW9uIGhhcyBmaW5pc2hlZFxuICAgICAgaW5zdGFuY2Uudmlldy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGVtcHR5KGluc3RhbmNlLnJvb3RFbGVtZW50KTtcbiAgICBldmVudE1hbmFnZXIuZGVzdHJveSgpO1xuXG4gICAgSGFuZHNvbnRhYmxlLmhvb2tzLnJ1bihpbnN0YW5jZSwgJ2FmdGVyRGVzdHJveScpO1xuICAgIEhhbmRzb250YWJsZS5ob29rcy5kZXN0cm95KGluc3RhbmNlKTtcblxuICAgIGZvciAodmFyIGkgaW4gaW5zdGFuY2UpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAvL3JlcGxhY2UgaW5zdGFuY2UgbWV0aG9kcyB3aXRoIHBvc3QgbW9ydGVtXG4gICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2VbaV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGluc3RhbmNlW2ldID0gcG9zdE1vcnRlbTtcbiAgICAgICAgfVxuICAgICAgICAvL3JlcGxhY2UgaW5zdGFuY2UgcHJvcGVydGllcyB3aXRoIG51bGwgKHJlc3RvcmVzIG1lbW9yeSlcbiAgICAgICAgLy9pdCBzaG91bGQgbm90IGJlIG5lY2Vzc2FyeSBidXQgdGhpcyBwcmV2ZW50cyBhIG1lbW9yeSBsZWFrIHNpZGUgZWZmZWN0cyB0aGF0IHNob3cgaXRzZWxmIGluIEphc21pbmUgdGVzdHNcbiAgICAgICAgZWxzZSBpZiAoaSAhPT0gXCJndWlkXCIpIHtcbiAgICAgICAgICBpbnN0YW5jZVtpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cblxuICAgIC8vcmVwbGFjZSBwcml2YXRlIHByb3BlcnRpZXMgd2l0aCBudWxsIChyZXN0b3JlcyBtZW1vcnkpXG4gICAgLy9pdCBzaG91bGQgbm90IGJlIG5lY2Vzc2FyeSBidXQgdGhpcyBwcmV2ZW50cyBhIG1lbW9yeSBsZWFrIHNpZGUgZWZmZWN0cyB0aGF0IHNob3cgaXRzZWxmIGluIEphc21pbmUgdGVzdHNcbiAgICBwcml2ID0gbnVsbDtcbiAgICBkYXRhbWFwID0gbnVsbDtcbiAgICBncmlkID0gbnVsbDtcbiAgICBzZWxlY3Rpb24gPSBudWxsO1xuICAgIGVkaXRvck1hbmFnZXIgPSBudWxsO1xuICAgIGluc3RhbmNlID0gbnVsbDtcbiAgICBHcmlkU2V0dGluZ3MgPSBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXBsYWNlbWVudCBmb3IgYWxsIG1ldGhvZHMgYWZ0ZXIgSGFuZHNvdG5hYmxlIHdhcyBkZXN0cm95ZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwb3N0TW9ydGVtKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIGNhbm5vdCBiZSBjYWxsZWQgYmVjYXVzZSB0aGlzIEhhbmRzb250YWJsZSBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWRcIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhY3RpdmUgZWRpdG9yIG9iamVjdC4ge0BsaW5rIEhhbmRzb250YWJsZS5FZGl0b3JNYW5hZ2VyI2dldEFjdGl2ZUVkaXRvcn1cbiAgICpcbiAgICogQG1lbWJlcm9mIENvcmUjXG4gICAqIEBmdW5jdGlvbiBnZXRBY3RpdmVFZGl0b3JcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIHRoaXMuZ2V0QWN0aXZlRWRpdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGVkaXRvck1hbmFnZXIuZ2V0QWN0aXZlRWRpdG9yKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgcGx1Z2luIGluc3RhbmNlIGJ5IHBsdWdpbiBuYW1lXG4gICAqXG4gICAqIEBtZW1iZXJvZiBDb3JlI1xuICAgKiBAZnVuY3Rpb24gZ2V0UGx1Z2luXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwbHVnaW5OYW1lXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKiBAc2luY2UgMC4xNS4wXG4gICAqL1xuICB0aGlzLmdldFBsdWdpbiA9IGZ1bmN0aW9uKHBsdWdpbk5hbWUpIHtcbiAgICByZXR1cm4gZ2V0UGx1Z2luKHRoaXMsIHBsdWdpbk5hbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gSGFuZHNvbnRhYmxlIGluc3RhbmNlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ29yZSNcbiAgICogQGZ1bmN0aW9uIGdldEluc3RhbmNlXG4gICAqIEByZXR1cm5zIHtIYW5kc29udGFibGV9XG4gICAqL1xuICB0aGlzLmdldEluc3RhbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIGxpc3RlbmVyIHRvIHNwZWNpZmllZCBob29rIG5hbWUgYW5kIG9ubHkgZm9yIHRoaXMgSGFuZHNvbnRhYmxlIGluc3RhbmNlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ29yZSNcbiAgICogQGZ1bmN0aW9uIGFkZEhvb2tcbiAgICogQHNlZSBIb29rcyNhZGRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBIb29rIG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbnxBcnJheX0gY2FsbGJhY2sgRnVuY3Rpb24gb3IgYXJyYXkgb2YgRnVuY3Rpb25zXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGhvdC5hZGRIb29rKCdiZWZvcmVJbml0JywgbXlDYWxsYmFjayk7XG4gICAqIGBgYFxuICAgKi9cbiAgdGhpcy5hZGRIb29rID0gZnVuY3Rpb24oa2V5LCBjYWxsYmFjaykge1xuICAgIEhhbmRzb250YWJsZS5ob29rcy5hZGQoa2V5LCBjYWxsYmFjaywgaW5zdGFuY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIGxpc3RlbmVyIHRvIHNwZWNpZmllZCBob29rIG5hbWUgYW5kIG9ubHkgZm9yIHRoaXMgSGFuZHNvbnRhYmxlIGluc3RhbmNlLiBBZnRlciBob29rIHJ1bnMgdGhpc1xuICAgKiBsaXN0ZW5lciB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAgICpcbiAgICogQG1lbWJlcm9mIENvcmUjXG4gICAqIEBmdW5jdGlvbiBhZGRIb29rT25jZVxuICAgKiBAc2VlIEhvb2tzI29uY2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBIb29rIG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbnxBcnJheX0gY2FsbGJhY2sgRnVuY3Rpb24gb3IgYXJyYXkgb2YgRnVuY3Rpb25zXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGhvdC5hZGRIb29rT25jZSgnYmVmb3JlSW5pdCcsIG15Q2FsbGJhY2spO1xuICAgKiBgYGBcbiAgICovXG4gIHRoaXMuYWRkSG9va09uY2UgPSBmdW5jdGlvbihrZXksIGNhbGxiYWNrKSB7XG4gICAgSGFuZHNvbnRhYmxlLmhvb2tzLm9uY2Uoa2V5LCBjYWxsYmFjaywgaW5zdGFuY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBob29rIGxpc3RlbmVyIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB3aXRoIHtAbGluayBDb3JlI2FkZEhvb2t9LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgQ29yZSNcbiAgICogQGZ1bmN0aW9uIHJlbW92ZUhvb2tcbiAgICogQHNlZSBIb29rcyNyZW1vdmVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBIb29rIG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgRnVuY3Rpb24gd2hpY2ggaGF2ZSBiZWVuIHJlZ2lzdGVyZWQgdmlhIHtAbGluayBDb3JlI2FkZEhvb2t9XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGhvdC5yZW1vdmVIb29rKCdiZWZvcmVJbml0JywgbXlDYWxsYmFjayk7XG4gICAqIGBgYFxuICAgKi9cbiAgdGhpcy5yZW1vdmVIb29rID0gZnVuY3Rpb24oa2V5LCBjYWxsYmFjaykge1xuICAgIEhhbmRzb250YWJsZS5ob29rcy5yZW1vdmUoa2V5LCBjYWxsYmFjaywgaW5zdGFuY2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbWVtYmVyb2YgQ29yZSNcbiAgICogQGZ1bmN0aW9uIHJ1bkhvb2tzXG4gICAqIEBzZWUgSG9va3MjcnVuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgSG9vayBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gW3AxXVxuICAgKiBAcGFyYW0geyp9IFtwMl1cbiAgICogQHBhcmFtIHsqfSBbcDNdXG4gICAqIEBwYXJhbSB7Kn0gW3A0XVxuICAgKiBAcGFyYW0geyp9IFtwNV1cbiAgICogQHBhcmFtIHsqfSBbcDZdXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBob3QucnVuSG9va3MoJ2JlZm9yZUluaXQnKTtcbiAgICogYGBgXG4gICAqL1xuICB0aGlzLnJ1bkhvb2tzID0gZnVuY3Rpb24oa2V5LCBwMSwgcDIsIHAzLCBwNCwgcDUsIHA2KSB7XG4gICAgcmV0dXJuIEhhbmRzb250YWJsZS5ob29rcy5ydW4oaW5zdGFuY2UsIGtleSwgcDEsIHAyLCBwMywgcDQsIHA1LCBwNik7XG4gIH07XG5cbiAgdGhpcy50aW1lb3V0cyA9IFtdO1xuXG4gIC8qKlxuICAgKiBTZXRzIHRpbWVvdXQuIFB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gY2xlYXIgYWxsIGtub3duIHRpbWVvdXRzIHdoZW4gYGRlc3Ryb3lgIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gaGFuZGxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLl9yZWdpc3RlclRpbWVvdXQgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICB0aGlzLnRpbWVvdXRzLnB1c2goaGFuZGxlKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXJzIGFsbCBrbm93biB0aW1lb3V0cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuX2NsZWFyVGltZW91dHMgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaWxlbiA9IHRoaXMudGltZW91dHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0c1tpXSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kc29udGFibGUgdmVyc2lvblxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgdGhpcy52ZXJzaW9uID0gSGFuZHNvbnRhYmxlLnZlcnNpb247XG5cbiAgSGFuZHNvbnRhYmxlLmhvb2tzLnJ1bihpbnN0YW5jZSwgJ2NvbnN0cnVjdCcpO1xufTtcblxuLyoqXG4gKiBAYWxpYXMgT3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKiBAZGVzY3JpcHRpb25cblxuICogIyMgQ29uc3RydWN0b3Igb3B0aW9uc1xuICpcbiAqIENvbnN0cnVjdG9yIG9wdGlvbnMgYXJlIGFwcGxpZWQgdXNpbmcgYW4gb2JqZWN0IGxpdGVyYWwgcGFzc2VkIGFzIGEgZmlyc3QgYXJndW1lbnQgdG8gdGhlIEhhbmRzb250YWJsZSBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGhvdCA9IG5ldyBIYW5kc29udGFibGUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2V4YW1wbGUxJyksIHtcbiAqICAgZGF0YTogbXlBcnJheSxcbiAqICAgd2lkdGg6IDQwMCxcbiAqICAgaGVpZ2h0OiAzMDBcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiAtLS1cbiAqICMjIENhc2NhZGluZyBjb25maWd1cmF0aW9uXG4gKlxuICogSGFuZHNvbnRhYmxlIDAuOSBhbmQgbmV3ZXIgaXMgdXNpbmcgKkNhc2NhZGluZyBDb25maWd1cmF0aW9uKiwgd2hpY2ggaXMgZmFzdCB3YXkgdG8gcHJvdmlkZSBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIGZvciB3aG9sZSB0YWJsZSwgaXRzIGNvbHVtbnMgYW5kIHBhcnRpY3VsYXIgY2VsbHMuXG4gKlxuICogQ29uc2lkZXIgdGhlIGZvbGxvd2luZyBleGFtcGxlOlxuICogYGBganNcbiAqIHZhciBob3QgPSBuZXcgSGFuZHNvbnRhYmxlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdleGFtcGxlJyksIHtcbiAqICAgcmVhZE9ubHk6IHRydWUsXG4gKiAgIGNvbHVtbnM6IFtcbiAqICAgICB7cmVhZE9ubHk6IGZhbHNlfSxcbiAqICAgICB7fSxcbiAqICAgICB7fVxuICogICBdLFxuICogICBjZWxsczogZnVuY3Rpb24gKHJvdywgY29sLCBwcm9wKSB7XG4gKiAgICAgdmFyIGNlbGxQcm9wZXJ0aWVzID0ge307XG4gKlxuICogICAgIGlmIChyb3cgPT09IDAgJiYgY29sID09PSAwKSB7XG4gKiAgICAgICBjZWxsUHJvcGVydGllcy5yZWFkT25seSA9IHRydWU7XG4gKiAgICAgfVxuICpcbiAqICAgICByZXR1cm4gY2VsbFByb3BlcnRpZXM7XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogVGhlIGFib3ZlIG5vdGF0aW9uIHdpbGwgcmVzdWx0IGluIGFsbCBURHMgYmVpbmcgKnJlYWQgb25seSosIGV4Y2VwdCBmb3IgZmlyc3QgY29sdW1uIFREcyB3aGljaCB3aWxsIGJlICplZGl0YWJsZSosIGV4Y2VwdCBmb3IgdGhlIFREIGluIHRvcCBsZWZ0IGNvcm5lciB3aGljaCB3aWxsIHN0aWxsIGJlICpyZWFkIG9ubHkqLlxuICpcbiAqICMjIyBUaGUgQ2FzY2FkaW5nIENvbmZpZ3VyYXRpb24gbW9kZWxcbiAqXG4gKiAjIyMjIyAxLiBDb25zdHJ1Y3RvclxuICpcbiAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucyB0aGF0IGFyZSBwcm92aWRlZCB1c2luZyBmaXJzdC1sZXZlbCBgaGFuZHNvbnRhYmxlKGNvbnRhaW5lciwge29wdGlvbjogXCJ2YWx1ZVwifSlgIGFuZCBgdXBkYXRlU2V0dGluZ3NgIG1ldGhvZC5cbiAqXG4gKiAjIyMjIyAyLiBDb2x1bW5zXG4gKlxuICogQ29uZmlndXJhdGlvbiBvcHRpb25zIHRoYXQgYXJlIHByb3ZpZGVkIHVzaW5nIHNlY29uZC1sZXZlbCBvYmplY3QgYGhhbmRzb250YWJsZShjb250YWluZXIsIHtjb2x1bW5zOiB7b3B0aW9uOiBcInZhbHVlXCJ9XX0pYFxuICpcbiAqICMjIyMjIDMuIENlbGxzXG4gKlxuICogQ29uZmlndXJhdGlvbiBvcHRpb25zIHRoYXQgYXJlIHByb3ZpZGVkIHVzaW5nIHNlY29uZC1sZXZlbCBmdW5jdGlvbiBgaGFuZHNvbnRhYmxlKGNvbnRhaW5lciwge2NlbGxzOiBmdW5jdGlvbjogKHJvdywgY29sLCBwcm9wKXsgfX0pYFxuICpcbiAqIC0tLVxuICogIyMgQXJjaGl0ZWN0dXJlIHBlcmZvcm1hbmNlXG4gKlxuICogVGhlIENhc2NhZGluZyBDb25maWd1cmF0aW9uIG1vZGVsIGlzIGJhc2VkIG9uIHByb3RvdHlwaWNhbCBpbmhlcml0YW5jZS4gSXQgaXMgbXVjaCBmYXN0ZXIgYW5kIG1lbW9yeSBlZmZpY2llbnQgY29tcGFyZWRcbiAqIHRvIHRoZSBwcmV2aW91cyBtb2RlbCB0aGF0IHVzZWQgalF1ZXJ5IGV4dGVuZC4gU2VlOiBbaHR0cDovL2pzcGVyZi5jb20vZXh0ZW5kaW5nLXNldHRpbmdzXShodHRwOi8vanNwZXJmLmNvbS9leHRlbmRpbmctc2V0dGluZ3MpLlxuICpcbiAqIC0tLVxuICogX19JbXBvcnRhbnQgbm90aWNlOl9fIEluIG9yZGVyIGZvciB0aGUgZGF0YSBzZXBhcmF0aW9uIHRvIHdvcmsgcHJvcGVybHksIG1ha2Ugc3VyZSB0aGF0IGVhY2ggaW5zdGFuY2Ugb2YgSGFuZHNvbnRhYmxlIGhhcyBhIHVuaXF1ZSBgaWRgLlxuICovXG52YXIgRGVmYXVsdFNldHRpbmdzID0gZnVuY3Rpb24oKSB7XG59O1xuXG5EZWZhdWx0U2V0dGluZ3MucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEluaXRpYWwgZGF0YSBzb3VyY2UgdGhhdCB3aWxsIGJlIGJvdW5kIHRvIHRoZSBkYXRhIGdyaWQgX19ieSByZWZlcmVuY2VfXyAoZWRpdGluZyBkYXRhIGdyaWQgYWx0ZXJzIHRoZSBkYXRhIHNvdXJjZSkuXG4gICAqIENhbiBiZSBBcnJheSBvZiBBcnJheSwgQXJyYXkgb2YgT2JqZWN0cyBvciBGdW5jdGlvbi5cbiAgICpcbiAgICogU2VlIFtVbmRlcnN0YW5kaW5nIGJpbmRpbmcgYXMgcmVmZXJlbmNlXShodHRwOi8vaGFuZHNvbnRhYmxlLmNvbS9kZW1vL3VuZGVyc3RhbmRpbmdfcmVmZXJlbmNlLmh0bWwpLlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXl8RnVuY3Rpb259XG4gICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKi9cbiAgZGF0YTogdm9pZCAwLFxuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogRGVmaW5lcyB0aGUgc3RydWN0dXJlIG9mIGEgbmV3IHJvdyB3aGVuIGRhdGEgc291cmNlIGlzIGFuIG9iamVjdC5cbiAgICogRGVmYXVsdCBsaWtlIHRoZSBmaXJzdCBkYXRhIHJvdyBBcnJheSBvciBPYmplY3QuXG4gICAqXG4gICAqICBTZWUgW2RlbW8vZGF0YXNvdXJjZXMuaHRtbF0oaHR0cDovL2hhbmRzb250YWJsZS5jb20vZGVtby9kYXRhc291cmNlcy5odG1sKSBmb3IgZXhhbXBsZXMuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKi9cbiAgZGF0YVNjaGVtYTogdm9pZCAwLFxuXG4gIC8qKlxuICAgKiBXaWR0aCBvZiB0aGUgZ3JpZC4gQ2FuIGJlIGEgbnVtYmVyIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgbnVtYmVyLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfEZ1bmN0aW9ufVxuICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICovXG4gIHdpZHRoOiB2b2lkIDAsXG5cbiAgLyoqXG4gICAqIEhlaWdodCBvZiB0aGUgZ3JpZC4gQ2FuIGJlIGEgbnVtYmVyIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgbnVtYmVyLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfEZ1bmN0aW9ufVxuICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICovXG4gIGhlaWdodDogdm9pZCAwLFxuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogSW5pdGlhbCBudW1iZXIgb2Ygcm93cy5cbiAgICpcbiAgICogX19Ob3RpY2U6X18gVGhpcyBvcHRpb24gb25seSBoYXMgZWZmZWN0IGluIEhhbmRzb250YWJsZSBjb25zdHJ1Y3RvciBhbmQgb25seSBpZiBgZGF0YWAgb3B0aW9uIGlzIG5vdCBwcm92aWRlZFxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCA1XG4gICAqL1xuICBzdGFydFJvd3M6IDUsXG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBJbml0aWFsIG51bWJlciBvZiBjb2x1bW5zLlxuICAgKlxuICAgKiBfX05vdGljZTpfXyBUaGlzIG9wdGlvbiBvbmx5IGhhcyBlZmZlY3QgaW4gSGFuZHNvbnRhYmxlIGNvbnN0cnVjdG9yIGFuZCBvbmx5IGlmIGBkYXRhYCBvcHRpb24gaXMgbm90IHByb3ZpZGVkXG4gICAqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0IDVcbiAgICovXG4gIHN0YXJ0Q29sczogNSxcblxuICAvKipcbiAgICogU2V0dGluZyBgdHJ1ZWAgb3IgYGZhbHNlYCB3aWxsIGVuYWJsZSBvciBkaXNhYmxlIHRoZSBkZWZhdWx0IHJvdyBoZWFkZXJzICgxLCAyLCAzKS5cbiAgICogWW91IGNhbiBhbHNvIGRlZmluZSBhbiBhcnJheSBgWydPbmUnLCAnVHdvJywgJ1RocmVlJywgLi4uXWAgb3IgYSBmdW5jdGlvbiB0byBkZWZpbmUgdGhlIGhlYWRlcnMuXG4gICAqIElmIGEgZnVuY3Rpb24gaXMgc2V0IHRoZSBpbmRleCBvZiB0aGUgcm93IGlzIHBhc3NlZCBhcyBhIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW58QXJyYXl8RnVuY3Rpb259XG4gICAqIEBkZWZhdWx0IG51bGxcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogLi4uXG4gICAqIC8vIGFzIGJvb2xlYW5cbiAgICogcm93SGVhZGVyczogdHJ1ZSxcbiAgICogLi4uXG4gICAqXG4gICAqIC4uLlxuICAgKiAvLyBhcyBhcnJheVxuICAgKiByb3dIZWFkZXJzOiBbMSwgMiwgM10sXG4gICAqIC4uLlxuICAgKlxuICAgKiAuLi5cbiAgICogLy8gYXMgZnVuY3Rpb25cbiAgICogcm93SGVhZGVyczogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICogICByZXR1cm4gaW5kZXggKyAnOiBBQic7XG4gICAqIH0sXG4gICAqIC4uLlxuICAgKiBgYGBcbiAgICovXG4gIHJvd0hlYWRlcnM6IG51bGwsXG5cbiAgLyoqXG4gICAqIFNldHRpbmcgYHRydWVgIG9yIGBmYWxzZWAgd2lsbCBlbmFibGUgb3IgZGlzYWJsZSB0aGUgZGVmYXVsdCBjb2x1bW4gaGVhZGVycyAoQSwgQiwgQykuXG4gICAqIFlvdSBjYW4gYWxzbyBkZWZpbmUgYW4gYXJyYXkgYFsnT25lJywgJ1R3bycsICdUaHJlZScsIC4uLl1gIG9yIGEgZnVuY3Rpb24gdG8gZGVmaW5lIHRoZSBoZWFkZXJzLlxuICAgKiBJZiBhIGZ1bmN0aW9uIGlzIHNldCB0aGUgaW5kZXggb2YgdGhlIGNvbHVtbiBpcyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufEFycmF5fEZ1bmN0aW9ufVxuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIC4uLlxuICAgKiAvLyBhcyBib29sZWFuXG4gICAqIGNvbEhlYWRlcnM6IHRydWUsXG4gICAqIC4uLlxuICAgKlxuICAgKiAuLi5cbiAgICogLy8gYXMgYXJyYXlcbiAgICogY29sSGVhZGVyczogWydBJywgJ0InLCAnQyddLFxuICAgKiAuLi5cbiAgICpcbiAgICogLi4uXG4gICAqIC8vIGFzIGZ1bmN0aW9uXG4gICAqIGNvbEhlYWRlcnM6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAqICAgcmV0dXJuIGluZGV4ICsgJzogQUInO1xuICAgKiB9LFxuICAgKiAuLi5cbiAgICogYGBgXG4gICAqL1xuICBjb2xIZWFkZXJzOiBudWxsLFxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGNvbHVtbiB3aWR0aHMgaW4gcGl4ZWxzLiBBY2NlcHRzIG51bWJlciwgc3RyaW5nICh0aGF0IHdpbGwgYmUgY29udmVydGVkIHRvIG51bWJlciksXG4gICAqIGFycmF5IG9mIG51bWJlcnMgKGlmIHlvdSB3YW50IHRvIGRlZmluZSBjb2x1bW4gd2lkdGggc2VwYXJhdGVseSBmb3IgZWFjaCBjb2x1bW4pIG9yIGFcbiAgICogZnVuY3Rpb24gKGlmIHlvdSB3YW50IHRvIHNldCBjb2x1bW4gd2lkdGggZHluYW1pY2FsbHkgb24gZWFjaCByZW5kZXIpLlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXl8RnVuY3Rpb258TnVtYmVyfFN0cmluZ31cbiAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqL1xuICBjb2xXaWR0aHM6IHZvaWQgMCxcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIERlZmluZXMgdGhlIGNlbGwgcHJvcGVydGllcyBhbmQgZGF0YSBiaW5kaW5nIGZvciBjZXJ0YWluIGNvbHVtbnMuXG4gICAqXG4gICAqIF9fTm90aWNlOl9fIFVzaW5nIHRoaXMgb3B0aW9uIHNldHMgYSBmaXhlZCBudW1iZXIgb2YgY29sdW1ucyAob3B0aW9ucyBgc3RhcnRDb2xzYCwgYG1pbkNvbHNgLCBgbWF4Q29sc2Agd2lsbCBiZSBpZ25vcmVkKS5cbiAgICpcbiAgICogU2VlIFtkZW1vL2RhdGFzb3VyY2VzLmh0bWxdKGh0dHA6Ly9oYW5kc29udGFibGUuY29tL2RlbW8vZGF0YXNvdXJjZXMuaHRtbCkgZm9yIGV4YW1wbGVzLlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiAuLi5cbiAgICogdmFyIGV4YW1wbGVDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXhhbXBsZScpO1xuICAgKiB2YXIgaG90ID0gbmV3IEhhbmRzb250YWJsZShleGFtcGxlQ29udGFpbmVyLCB7XG4gICAqICAgY29sdW1uczogW1xuICAgKiAgICAge1xuICAgKiAgICAgICAvLyBjb2x1bW4gb3B0aW9ucyBmb3IgdGhlIGZpcnN0IGNvbHVtblxuICAgKiAgICAgICB0eXBlOiAnbnVtZXJpYycsXG4gICAqICAgICAgIGZvcm1hdDogJzAsMC4wMCAkJ1xuICAgKiAgICAgfSxcbiAgICogICAgIHtcbiAgICogICAgICAgLy8gY29sdW1uIG9wdGlvbnMgZm9yIHRoZSBzZWNvbmQgY29sdW1uXG4gICAqICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICogICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICogICAgIH1cbiAgICogICBdXG4gICAqIH0pO1xuICAgKiAuLi5cbiAgICogYGBgXG4gICAqL1xuICBjb2x1bW5zOiB2b2lkIDAsXG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBEZWZpbmVzIHRoZSBjZWxsIHByb3BlcnRpZXMgZm9yIGdpdmVuIGByb3dgLCBgY29sYCwgYHByb3BgIGNvb3JkaW5hdGVzLlxuICAgKiBBbnkgY29uc3RydWN0b3Igb3IgY29sdW1uIG9wdGlvbiBtYXkgYmUgb3ZlcndyaXR0ZW4gZm9yIGEgcGFydGljdWxhciBjZWxsIChyb3cvY29sdW1uIGNvbWJpbmF0aW9uKSwgdXNpbmcgYGNlbGxgXG4gICAqIGFycmF5IHBhc3NlZCB0byB0aGUgSGFuZHNvbnRhYmxlIGNvbnN0cnVjdG9yLiBPciB1c2luZyBgY2VsbHNgIGZ1bmN0aW9uIHByb3BlcnR5IHRvIHRoZSBIYW5kc29udGFibGUgY29uc3RydWN0b3IuXG4gICAqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIC4uLlxuICAgKiB2YXIgaG90ID0gbmV3IEhhbmRzb250YWJsZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXhhbXBsZScpLCB7XG4gICAqICAgY2VsbHM6IGZ1bmN0aW9uIChyb3csIGNvbCwgcHJvcCkge1xuICAgKiAgICAgdmFyIGNlbGxQcm9wZXJ0aWVzID0ge307XG4gICAqXG4gICAqICAgICBpZiAocm93ID09PSAwICYmIGNvbCA9PT0gMCkge1xuICAgKiAgICAgICBjZWxsUHJvcGVydGllcy5yZWFkT25seSA9IHRydWU7XG4gICAqICAgICB9XG4gICAqXG4gICAqICAgICByZXR1cm4gY2VsbFByb3BlcnRpZXM7XG4gICAqICAgfVxuICAgKiB9KTtcbiAgICogLi4uXG4gICAqIGBgYFxuICAgKi9cbiAgY2VsbHM6IHZvaWQgMCxcblxuICAvKipcbiAgICogQW55IGNvbnN0cnVjdG9yIG9yIGNvbHVtbiBvcHRpb24gbWF5IGJlIG92ZXJ3cml0dGVuIGZvciBhIHBhcnRpY3VsYXIgY2VsbCAocm93L2NvbHVtbiBjb21iaW5hdGlvbiksIHVzaW5nIGBjZWxsYFxuICAgKiBhcnJheSBwYXNzZWQgdG8gdGhlIEhhbmRzb250YWJsZSBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogQHR5cGUge0FycmF5fVxuICAgKiBAZGVmYXVsdCBbXVxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiAuLi5cbiAgICogdmFyIGhvdCA9IG5ldyBIYW5kc29udGFibGUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2V4YW1wbGUnKSwge1xuICAgKiAgIGNlbGw6IFtcbiAgICogICAgIHtyb3c6IDAsIGNvbDogMCwgcmVhZE9ubHk6IHRydWV9XG4gICAqICAgXVxuICAgKiB9KTtcbiAgICogLi4uXG4gICAqIGBgYFxuICAgKi9cbiAgY2VsbDogW10sXG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBJZiBgdHJ1ZWAsIGVuYWJsZXMge0BsaW5rIENvbW1lbnRzfSBwbHVnaW4sIHdoaWNoIGVuYWJsZXMgYXBwbHlpbmcgY2VsbCBjb21tZW50cyB0aHJvdWdoIHRoZSBjb250ZXh0IG1lbnVcbiAgICogKGNvbmZpZ3VyYWJsZSB3aXRoIGNvbnRleHQgbWVudSBrZXlzIGNvbW1lbnRzQWRkRWRpdCwgY29tbWVudHNSZW1vdmUpLlxuICAgKlxuICAgKiBUbyBpbml0aWFsaXplIEhhbmRzb250YWJsZSB3aXRoIHByZWRlZmluZWQgY29tbWVudHMsIHByb3ZpZGUgY2VsbCBjb29yZGluYXRlcyBhbmQgY29tbWVudCB0ZXh0cyBpbiBmb3JtIG9mIGFuIGFycmF5LlxuICAgKlxuICAgKiBTZWUgW0NvbW1lbnRzXShodHRwOi8vaGFuZHNvbnRhYmxlLmNvbS9kZW1vL2NvbW1lbnRzLmh0bWwpIGRlbW8gZm9yIGV4YW1wbGVzLlxuICAgKlxuICAgKiBAc2luY2UgMC4xMS4wXG4gICAqIEB0eXBlIHtCb29sZWFufEFycmF5fVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiAuLi5cbiAgICogdmFyIGhvdCA9IG5ldyBIYW5kc29udGFibGUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2V4YW1wbGUnKSwge1xuICAgKiAgIGNvbW1lbnRzOiBbe3JvdzogMSwgY29sOiAxLCBjb21tZW50OiBcIlRlc3QgY29tbWVudFwifV1cbiAgICogfSk7XG4gICAqIC4uLlxuICAgKiBgYGBcbiAgICovXG4gIGNvbW1lbnRzOiBmYWxzZSxcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIElmIGB0cnVlYCwgZW5hYmxlcyBDdXN0b20gQm9yZGVycyBwbHVnaW4sIHdoaWNoIGVuYWJsZXMgYXBwbHlpbmcgY3VzdG9tIGJvcmRlcnMgdGhyb3VnaCB0aGUgY29udGV4dCBtZW51IChjb25maWd1cmFibGUgd2l0aCBjb250ZXh0IG1lbnUga2V5IGJvcmRlcnMpLlxuICAgKlxuICAgKiBUbyBpbml0aWFsaXplIEhhbmRzb250YWJsZSB3aXRoIHByZWRlZmluZWQgY3VzdG9tIGJvcmRlcnMsIHByb3ZpZGUgY2VsbCBjb29yZGluYXRlcyBhbmQgYm9yZGVyIHN0eWxlcyBpbiBmb3JtIG9mIGFuIGFycmF5LlxuICAgKlxuICAgKiBTZWUgW0N1c3RvbSBCb3JkZXJzXShodHRwOi8vaGFuZHNvbnRhYmxlLmNvbS9kZW1vL2N1c3RvbV9ib3JkZXJzLmh0bWwpIGRlbW8gZm9yIGV4YW1wbGVzLlxuICAgKlxuICAgKiBAc2luY2UgMC4xMS4wXG4gICAqIEB0eXBlIHtCb29sZWFufEFycmF5fVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiAuLi5cbiAgICogdmFyIGhvdCA9IG5ldyBIYW5kc29udGFibGUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2V4YW1wbGUnKSwge1xuICAgKiAgIGN1c3RvbUJvcmRlcnM6IFtcbiAgICogICAgIHtyYW5nZToge1xuICAgKiAgICAgICBmcm9tOiB7cm93OiAxLCBjb2w6IDF9LFxuICAgKiAgICAgICB0bzoge3JvdzogMywgY29sOiA0fX0sXG4gICAqICAgICAgIGxlZnQ6IHt9LFxuICAgKiAgICAgICByaWdodDoge30sXG4gICAqICAgICAgIHRvcDoge30sXG4gICAqICAgICAgIGJvdHRvbToge31cbiAgICogICAgIH1cbiAgICogICBdLFxuICAgKiB9KTtcbiAgICogLi4uXG4gICAqXG4gICAqIC8vIG9yXG4gICAqIC4uLlxuICAgKiB2YXIgaG90ID0gbmV3IEhhbmRzb250YWJsZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXhhbXBsZScpLCB7XG4gICAqICAgY3VzdG9tQm9yZGVyczogW1xuICAgKiAgICAge3JvdzogMiwgY29sOiAyLCBsZWZ0OiB7d2lkdGg6IDIsIGNvbG9yOiAncmVkJ30sXG4gICAqICAgICAgIHJpZ2h0OiB7d2lkdGg6IDEsIGNvbG9yOiAnZ3JlZW4nfSwgdG9wOiAnJywgYm90dG9tOiAnJ31cbiAgICogICBdLFxuICAgKiB9KTtcbiAgICogLi4uXG4gICAqIGBgYFxuICAgKi9cbiAgY3VzdG9tQm9yZGVyczogZmFsc2UsXG5cbiAgLyoqXG4gICAqIE1pbmltdW0gbnVtYmVyIG9mIHJvd3MuIEF0IGxlYXN0IHRoYXQgYW1vdW50IG9mIHJvd3Mgd2lsbCBiZSBjcmVhdGVkIGR1cmluZyBpbml0aWFsaXphdGlvbi5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgbWluUm93czogMCxcblxuICAvKipcbiAgICogTWluaW11bSBudW1iZXIgb2YgY29sdW1ucy4gQXQgbGVhc3QgdGhhdCBtYW55IG9mIGNvbHVtbnMgd2lsbCBiZSBjcmVhdGVkIGR1cmluZyBpbml0aWFsaXphdGlvbi5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgbWluQ29sczogMCxcblxuICAvKipcbiAgICogTWF4aW11bSBudW1iZXIgb2Ygcm93cy5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlZmF1bHQgSW5maW5pdHlcbiAgICovXG4gIG1heFJvd3M6IEluZmluaXR5LFxuXG4gIC8qKlxuICAgKiBNYXhpbXVtIG51bWJlciBvZiBjb2xzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCBJbmZpbml0eVxuICAgKi9cbiAgbWF4Q29sczogSW5maW5pdHksXG5cbiAgLyoqXG4gICAqIFdoZW4gc2V0IHRvIDEgKG9yIG1vcmUpLCBIYW5kc29udGFibGUgd2lsbCBhZGQgYSBuZXcgcm93IGF0IHRoZSBlbmQgb2YgZ3JpZCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBlbXB0eSByb3dzLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBtaW5TcGFyZVJvd3M6IDAsXG5cbiAgLyoqXG4gICAqIFdoZW4gc2V0IHRvIDEgKG9yIG1vcmUpLCBIYW5kc29udGFibGUgd2lsbCBhZGQgYSBuZXcgY29sdW1uIGF0IHRoZSBlbmQgb2YgZ3JpZCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBlbXB0eSBjb2x1bW5zLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBtaW5TcGFyZUNvbHM6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBhbGxvd0luc2VydFJvdzogdHJ1ZSxcblxuICAvKipcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGFsbG93SW5zZXJ0Q29sdW1uOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgYWxsb3dSZW1vdmVSb3c6IHRydWUsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBhbGxvd1JlbW92ZUNvbHVtbjogdHJ1ZSxcblxuICAvKipcbiAgICogSWYgdHJ1ZSwgc2VsZWN0aW9uIG9mIG11bHRpcGxlIGNlbGxzIHVzaW5nIGtleWJvYXJkIG9yIG1vdXNlIGlzIGFsbG93ZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBtdWx0aVNlbGVjdDogdHJ1ZSxcblxuICAvKipcbiAgICogRW5hYmxlcyB0aGUgZmlsbCBoYW5kbGUgKGRyYWctZG93biBhbmQgY29weS1kb3duKSBmdW5jdGlvbmFsaXR5LCB3aGljaCBzaG93cyB0aGUgc21hbGwgcmVjdGFuZ2xlIGluIGJvdHRvbVxuICAgKiByaWdodCBjb3JuZXIgb2YgdGhlIHNlbGVjdGVkIGFyZWEsIHRoYXQgbGV0J3MgeW91IGV4cGFuZCB2YWx1ZXMgdG8gdGhlIGFkamFjZW50IGNlbGxzLlxuICAgKlxuICAgKiBQb3NzaWJsZSB2YWx1ZXM6IGB0cnVlYCAodG8gZW5hYmxlIGluIGFsbCBkaXJlY3Rpb25zKSwgYFwidmVydGljYWxcImAgb3IgYFwiaG9yaXpvbnRhbFwiYCAodG8gZW5hYmxlIGluIG9uZSBkaXJlY3Rpb24pLFxuICAgKiBgZmFsc2VgICh0byBkaXNhYmxlIGNvbXBsZXRlbHkpLiBTZXR0aW5nIHRvIGB0cnVlYCBlbmFibGVzIHRoZSBmaWxsSGFuZGxlIHBsdWdpbi5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW58U3RyaW5nfVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBmaWxsSGFuZGxlOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBBbGxvd3MgdG8gc3BlY2lmeSB0aGUgbnVtYmVyIG9mIHJvd3MgZml4ZWQgKGFrYSBmcmVlemVkKSBvbiB0aGUgdG9wIG9mIHRoZSB0YWJsZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgZml4ZWRSb3dzVG9wOiAwLFxuXG4gIC8qKlxuICAgKiBBbGxvd3MgdG8gc3BlY2lmeSB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgZml4ZWQgKGFrYSBmcmVlemVkKSBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSB0YWJsZS5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgZml4ZWRDb2x1bW5zTGVmdDogMCxcblxuICAvKipcbiAgICogSWYgYHRydWVgLCBtb3VzZSBjbGljayBvdXRzaWRlIHRoZSBncmlkIHdpbGwgZGVzZWxlY3QgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgb3V0c2lkZUNsaWNrRGVzZWxlY3RzOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIDxrYmQ+RU5URVI8L2tiZD4gYmVnaW5zIGVkaXRpbmcgbW9kZSAobGlrZSBHb29nbGUgRG9jcykuIElmIGBmYWxzZWAsIDxrYmQ+RU5URVI8L2tiZD4gbW92ZXMgdG8gbmV4dFxuICAgKiByb3cgKGxpa2UgRXhjZWwpIGFuZCBhZGRzIG5ldyByb3cgaWYgbmVjZXNzYXJ5LiA8a2JkPlRBQjwva2JkPiBhZGRzIG5ldyBjb2x1bW4gaWYgbmVjZXNzYXJ5LlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgZW50ZXJCZWdpbnNFZGl0aW5nOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGN1cnNvciBtb3ZlIGFmdGVyIDxrYmQ+RU5URVI8L2tiZD4gaXMgcHJlc3NlZCAoPGtiZD5TSElGVDwva2JkPiArIDxrYmQ+RU5URVI8L2tiZD4gdXNlcyBuZWdhdGl2ZSB2ZWN0b3IpLlxuICAgKiBDYW4gYmUgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIG9iamVjdC4gVGhlIGV2ZW50IGFyZ3VtZW50IHBhc3NlZCB0byB0aGUgZnVuY3Rpb25cbiAgICogaXMgYSBET00gRXZlbnQgb2JqZWN0IHJlY2VpdmVkIGFmdGVyIGEgPGtiZD5FTlRFUjwva2JkPiBrZXkgaGFzIGJlZW4gcHJlc3NlZC4gVGhpcyBldmVudCBvYmplY3QgY2FuIGJlIHVzZWQgdG8gY2hlY2tcbiAgICogd2hldGhlciB1c2VyIHByZXNzZWQgPGtiZD5FTlRFUjwva2JkPiBvciA8a2JkPlNISUZUPC9rYmQ+ICsgPGtiZD5FTlRFUjwva2JkPi5cbiAgICpcbiAgICogQHR5cGUge09iamVjdHxGdW5jdGlvbn1cbiAgICogQGRlZmF1bHQge3JvdzogMSwgY29sOiAwfVxuICAgKi9cbiAgZW50ZXJNb3Zlczoge3JvdzogMSwgY29sOiAwfSxcblxuICAvKipcbiAgICogRGVmaW5lcyBjdXJzb3IgbW92ZSBhZnRlciA8a2JkPlRBQjwva2JkPiBpcyBwcmVzc2VkICg8a2JkPlNISUZUPC9rYmQ+ICsgPGtiZD5UQUI8L2tiZD4gdXNlcyBuZWdhdGl2ZSB2ZWN0b3IpLlxuICAgKiBDYW4gYmUgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIG9iamVjdC4gVGhlIGV2ZW50IGFyZ3VtZW50IHBhc3NlZCB0byB0aGUgZnVuY3Rpb25cbiAgICogaXMgYSBET00gRXZlbnQgb2JqZWN0IHJlY2VpdmVkIGFmdGVyIGEgPGtiZD5UQUI8L2tiZD4ga2V5IGhhcyBiZWVuIHByZXNzZWQuIFRoaXMgZXZlbnQgb2JqZWN0IGNhbiBiZSB1c2VkIHRvIGNoZWNrXG4gICAqIHdoZXRoZXIgdXNlciBwcmVzc2VkIDxrYmQ+VEFCPC9rYmQ+IG9yIDxrYmQ+U0hJRlQ8L2tiZD4gKyA8a2JkPlRBQjwva2JkPi5cbiAgICpcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlZmF1bHQge3JvdzogMCwgY29sOiAxfVxuICAgKi9cbiAgdGFiTW92ZXM6IHtyb3c6IDAsIGNvbDogMX0sXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgcHJlc3NpbmcgPGtiZD5UQUI8L2tiZD4gb3IgcmlnaHQgYXJyb3cgaW4gdGhlIGxhc3QgY29sdW1uIHdpbGwgbW92ZSB0byBmaXJzdCBjb2x1bW4gaW4gbmV4dCByb3dcbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBhdXRvV3JhcFJvdzogZmFsc2UsXG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgcHJlc3NpbmcgPGtiZD5FTlRFUjwva2JkPiBvciBkb3duIGFycm93IGluIHRoZSBsYXN0IHJvdyB3aWxsIG1vdmUgdG8gZmlyc3Qgcm93IGluIG5leHQgY29sdW1uXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgYXV0b1dyYXBDb2w6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBNYXhpbXVtIG51bWJlciBvZiByb3dzIHRoYW4gY2FuIGJlIGNvcGllZCB0byBjbGlwYm9hcmQgdXNpbmcgPGtiZD5DVFJMPC9rYmQ+ICsgPGtiZD5DPC9rYmQ+LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAxMDAwXG4gICAqL1xuICBjb3B5Um93c0xpbWl0OiAxMDAwLFxuXG4gIC8qKlxuICAgKiBNYXhpbXVtIG51bWJlciBvZiBjb2x1bW5zIHRoYW4gY2FuIGJlIGNvcGllZCB0byBjbGlwYm9hcmQgdXNpbmcgPGtiZD5DVFJMPC9rYmQ+ICsgPGtiZD5DPC9rYmQ+LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAxMDAwXG4gICAqL1xuICBjb3B5Q29sc0xpbWl0OiAxMDAwLFxuXG4gIC8qKlxuICAgKiBEZWZpbmVzIHBhc3RlICg8a2JkPkNUUkw8L2tiZD4gKyA8a2JkPlY8L2tiZD4pIGJlaGF2aW9yLiBEZWZhdWx0IHZhbHVlIGBcIm92ZXJ3cml0ZVwiYCB3aWxsIHBhc3RlIGNsaXBib2FyZCB2YWx1ZSBvdmVyIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgKiBXaGVuIHNldCB0byBgXCJzaGlmdF9kb3duXCJgLCBjbGlwYm9hcmQgZGF0YSB3aWxsIGJlIHBhc3RlZCBpbiBwbGFjZSBvZiBjdXJyZW50IHNlbGVjdGlvbiwgd2hpbGUgYWxsIHNlbGVjdGVkIGNlbGxzIGFyZSBtb3ZlZCBkb3duLlxuICAgKiBXaGVuIHNldCB0byBgXCJzaGlmdF9yaWdodFwiYCwgY2xpcGJvYXJkIGRhdGEgd2lsbCBiZSBwYXN0ZWQgaW4gcGxhY2Ugb2YgY3VycmVudCBzZWxlY3Rpb24sIHdoaWxlIGFsbCBzZWxlY3RlZCBjZWxscyBhcmUgbW92ZWQgcmlnaHQuXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0ICdvdmVyd3JpdGUnXG4gICAqL1xuICBwYXN0ZU1vZGU6ICdvdmVyd3JpdGUnLFxuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVHVybiBvbiBzYXZpbmcgdGhlIHN0YXRlIG9mIGNvbHVtbiBzb3J0aW5nLCBjb2x1bW5zIHBvc2l0aW9ucyBhbmQgY29sdW1ucyBzaXplcyBpbiBsb2NhbCBzdG9yYWdlLlxuICAgKlxuICAgKiBZb3UgY2FuIHNhdmUgYW55IHNvcnQgb2YgZGF0YSBpbiBsb2NhbCBzdG9yYWdlIGluIHRvIHByZXNlcnZlIHRhYmxlIHN0YXRlIGJldHdlZW4gcGFnZSByZWxvYWRzLlxuICAgKiBJbiBvcmRlciB0byBlbmFibGUgZGF0YSBzdG9yYWdlIG1lY2hhbmlzbSwgYHBlcnNpc3RlbnRTdGF0ZWAgb3B0aW9uIG11c3QgYmUgc2V0IHRvIGB0cnVlYCAoeW91IGNhbiBzZXQgaXRcbiAgICogZWl0aGVyIGR1cmluZyBIYW5kc29udGFibGUgaW5pdGlhbGl6YXRpb24gb3IgdXNpbmcgdGhlIGB1cGRhdGVTZXR0aW5nc2AgbWV0aG9kKS4gV2hlbiBgcGVyc2lzdGVudFN0YXRlYCBpcyBlbmFibGVkIGl0IGV4cG9zZXMgMyBob29rczpcbiAgICpcbiAgICogX19wZXJzaXN0ZW50U3RhdGVTYXZlX18gKGtleTogU3RyaW5nLCB2YWx1ZTogTWl4ZWQpXG4gICAqXG4gICAqICAgKiBTYXZlcyB2YWx1ZSB1bmRlciBnaXZlbiBrZXkgaW4gYnJvd3NlciBsb2NhbCBzdG9yYWdlLlxuICAgKlxuICAgKiBfX3BlcnNpc3RlbnRTdGF0ZUxvYWRfXyAoa2V5OiBTdHJpbmcsIHZhbHVlUGxhY2Vob2xkZXI6IE9iamVjdClcbiAgICpcbiAgICogICAqIExvYWRzIGB2YWx1ZWAsIHNhdmVkIHVuZGVyIGdpdmVuIGtleSwgZm9ybSBicm93c2VyIGxvY2FsIHN0b3JhZ2UuIFRoZSBsb2FkZWQgYHZhbHVlYCB3aWxsIGJlIHNhdmVkIGluIGB2YWx1ZVBsYWNlaG9sZGVyLnZhbHVlYFxuICAgKiAgICAgKHRoaXMgaXMgZHVlIHRvIHNwZWNpZmljIGJlaGF2aW91ciBvZiBgSG9va3MucnVuKClgIG1ldGhvZCkuIElmIG5vIHZhbHVlIGhhdmUgYmVlbiBzYXZlZCB1bmRlciBrZXkgYHZhbHVlUGxhY2Vob2xkZXIudmFsdWVgXG4gICAqICAgICB3aWxsIGJlIGB1bmRlZmluZWRgLlxuICAgKlxuICAgKiBfX3BlcnNpc3RlbnRTdGF0ZVJlc2V0X18gKGtleTogU3RyaW5nKVxuICAgKlxuICAgKiAgICogQ2xlYXJzIHRoZSB2YWx1ZSBzYXZlZCB1bmRlciBga2V5YC4gSWYgbm8gYGtleWAgaXMgZ2l2ZW4sIGFsbCB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRhYmxlIHdpbGwgYmUgY2xlYXJlZC5cbiAgICpcbiAgICogX19Ob3RlOl9fIFRoZSBtYWluIHJlYXNvbiBiZWhpbmQgdXNpbmcgYHBlcnNpc3RlbnRTdGF0ZWAgaG9va3MgcmF0aGVyIHRoYW4gcmVndWxhciBMb2NhbFN0b3JhZ2UgQVBJIGlzIHRoYXQgaXRcbiAgICogZW5zdXJlcyBzZXBhcmF0aW9uIG9mIGRhdGEgc3RvcmVkIGJ5IG11bHRpcGxlIEhhbmRzb250YWJsZSBpbnN0YW5jZXMuIEluIG90aGVyIHdvcmRzLCBpZiB5b3UgaGF2ZSB0d28gKG9yIG1vcmUpXG4gICAqIGluc3RhbmNlcyBvZiBIYW5kc29udGFibGUgb24gb25lIHBhZ2UsIGRhdGEgc2F2ZWQgYnkgb25lIGluc3RhbmNlIHdvbid0IGJlIGFjY2Vzc2libGUgYnkgdGhlIHNlY29uZCBpbnN0YW5jZS5cbiAgICogVGhvc2UgdHdvIGluc3RhbmNlcyBjYW4gc3RvcmUgZGF0YSB1bmRlciB0aGUgc2FtZSBrZXkgYW5kIG5vIGRhdGEgd291bGQgYmUgb3ZlcndyaXR0ZW4uXG4gICAqXG4gICAqIF9fSW1wb3J0YW50Ol9fIEluIG9yZGVyIGZvciB0aGUgZGF0YSBzZXBhcmF0aW9uIHRvIHdvcmsgcHJvcGVybHksIG1ha2Ugc3VyZSB0aGF0IGVhY2ggaW5zdGFuY2Ugb2YgSGFuZHNvbnRhYmxlIGhhcyBhIHVuaXF1ZSBgaWRgLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHBlcnNpc3RlbnRTdGF0ZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENsYXNzIG5hbWUgZm9yIGFsbCB2aXNpYmxlIHJvd3MgaW4gY3VycmVudCBzZWxlY3Rpb24uXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKi9cbiAgY3VycmVudFJvd0NsYXNzTmFtZTogdm9pZCAwLFxuXG4gIC8qKlxuICAgKiBDbGFzcyBuYW1lIGZvciBhbGwgdmlzaWJsZSBjb2x1bW5zIGluIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICovXG4gIGN1cnJlbnRDb2xDbGFzc05hbWU6IHZvaWQgMCxcblxuICAvKipcbiAgICogQ2xhc3MgbmFtZSBmb3IgYWxsIGhhbmRzb250YWJsZSBjb250YWluZXIgZWxlbWVudC5cbiAgICpcbiAgICogQHR5cGUge1N0cmluZ3xBcnJheX1cbiAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqL1xuICBjbGFzc05hbWU6IHZvaWQgMCxcblxuICAvKipcbiAgICogQ2xhc3MgbmFtZSBmb3IgYWxsIHRhYmxlcyBpbnNpZGUgY29udGFpbmVyIGVsZW1lbnQuXG4gICAqXG4gICAqIEBzaW5jZSAwLjE3LjBcbiAgICogQHR5cGUge1N0cmluZ3xBcnJheX1cbiAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqL1xuICB0YWJsZUNsYXNzTmFtZTogdm9pZCAwLFxuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW0NvbHVtbiBzdHJldGNoaW5nXShodHRwOi8vaGFuZHNvbnRhYmxlLmNvbS9kZW1vL3Njcm9sbC5odG1sKSBtb2RlLiBQb3NzaWJsZSB2YWx1ZXM6IGBcIm5vbmVcImAsIGBcImxhc3RcImAsIGBcImFsbFwiYC5cbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAqL1xuICBzdHJldGNoSDogJ25vbmUnLFxuXG4gIC8qKlxuICAgKiBMZXRzIHlvdSBvdmVyd3JpdGUgdGhlIGRlZmF1bHQgYGlzRW1wdHlSb3dgIG1ldGhvZC5cbiAgICpcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0ge051bWJlcn0gcm93XG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgaXNFbXB0eVJvdzogZnVuY3Rpb24ocm93KSB7XG4gICAgdmFyIGNvbCwgY29sTGVuLCB2YWx1ZSwgbWV0YTtcblxuICAgIGZvciAoY29sID0gMCwgY29sTGVuID0gdGhpcy5jb3VudENvbHMoKTsgY29sIDwgY29sTGVuOyBjb2wrKykge1xuICAgICAgdmFsdWUgPSB0aGlzLmdldERhdGFBdENlbGwocm93LCBjb2wpO1xuXG4gICAgICBpZiAodmFsdWUgIT09ICcnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBtZXRhID0gdGhpcy5nZXRDZWxsTWV0YShyb3csIGNvbCk7XG5cbiAgICAgICAgICByZXR1cm4gaXNPYmplY3RFcXVhbHModGhpcy5nZXRTY2hlbWEoKVttZXRhLnByb3BdLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBMZXRzIHlvdSBvdmVyd3JpdGUgdGhlIGRlZmF1bHQgYGlzRW1wdHlDb2xgIG1ldGhvZC5cbiAgICpcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcGFyYW0ge051bWJlcn0gY29sXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgaXNFbXB0eUNvbDogZnVuY3Rpb24oY29sKSB7XG4gICAgdmFyIHJvdywgcm93TGVuLCB2YWx1ZTtcblxuICAgIGZvciAocm93ID0gMCwgcm93TGVuID0gdGhpcy5jb3VudFJvd3MoKTsgcm93IDwgcm93TGVuOyByb3crKykge1xuICAgICAgdmFsdWUgPSB0aGlzLmdldERhdGFBdENlbGwocm93LCBjb2wpO1xuXG4gICAgICBpZiAodmFsdWUgIT09ICcnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXaGVuIHNldCB0byBgdHJ1ZWAsIHRoZSB0YWJsZSBpcyByZXJlbmRlcmVkIHdoZW4gaXQgaXMgZGV0ZWN0ZWQgdGhhdCBpdCB3YXMgbWFkZSB2aXNpYmxlIGluIERPTS5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIG9ic2VydmVET01WaXNpYmlsaXR5OiB0cnVlLFxuXG4gIC8qKlxuICAgKiBJZiBzZXQgdG8gYHRydWVgLCBjZWxscyB3aWxsIGFjY2VwdCB2YWx1ZSB0aGF0IGlzIG1hcmtlZCBhcyBpbnZhbGlkIGJ5IGNlbGwgYHZhbGlkYXRvcmAsIHdpdGggYSBiYWNrZ3JvdW5kIGNvbG9yXG4gICAqIGF1dG9tYXRpY2FsbHkgYXBwbGllZCB1c2luZyBDU1MgY2xhc3MgYGh0SW52YWxpZGAuIElmIHNldCB0byBgZmFsc2VgLCBjZWxscyB3aWxsIG5vdCBhY2NlcHQgaW52YWxpZCB2YWx1ZS5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICogQHNpbmNlIDAuOS41XG4gICAqL1xuICBhbGxvd0ludmFsaWQ6IHRydWUsXG5cbiAgLyoqXG4gICAqIENTUyBjbGFzcyBuYW1lIGZvciBjZWxscyB0aGF0IGRpZCBub3QgcGFzcyB2YWxpZGF0aW9uLlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnaHRJbnZhbGlkJ1xuICAgKi9cbiAgaW52YWxpZENlbGxDbGFzc05hbWU6ICdodEludmFsaWQnLFxuXG4gIC8qKlxuICAgKiBXaGVuIHNldCB0byBhbiBub24tZW1wdHkgc3RyaW5nLCBkaXNwbGF5ZWQgYXMgdGhlIGNlbGwgY29udGVudCBmb3IgZW1wdHkgY2VsbHMuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufFN0cmluZ31cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHBsYWNlaG9sZGVyOiBmYWxzZSxcblxuICAvKipcbiAgICogQ1NTIGNsYXNzIG5hbWUgZm9yIGNlbGxzIHRoYXQgaGF2ZSBhIHBsYWNlaG9sZGVyIGluIHVzZS5cbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgJ2h0UGxhY2Vob2xkZXInXG4gICAqL1xuICBwbGFjZWhvbGRlckNlbGxDbGFzc05hbWU6ICdodFBsYWNlaG9sZGVyJyxcblxuICAvKipcbiAgICogQ1NTIGNsYXNzIG5hbWUgZm9yIHJlYWQtb25seSBjZWxscy5cbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgJ2h0RGltbWVkJ1xuICAgKi9cbiAgcmVhZE9ubHlDZWxsQ2xhc3NOYW1lOiAnaHREaW1tZWQnLFxuXG4gIC8qKlxuICAgKiBTdHJpbmcgbWF5IGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHByZWRlZmluZWQgdmFsdWVzOiBgYXV0b2NvbXBsZXRlYCwgYGNoZWNrYm94YCwgYHRleHRgLCBgbnVtZXJpY2AuIEZ1bmN0aW9uIHdpbGxcbiAgICogcmVjZWl2ZSB0aGUgZm9sbG93aW5nIGFyZ3VtZW50czogYGZ1bmN0aW9uKGluc3RhbmNlLCBURCwgcm93LCBjb2wsIHByb3AsIHZhbHVlLCBjZWxsUHJvcGVydGllcykge31gLlxuICAgKiBZb3UgY2FuIG1hcCB5b3VyIG93biBmdW5jdGlvbiB0byBhIHN0cmluZyBsaWtlIHRoaXM6IGBIYW5kc29udGFibGUuY2VsbExvb2t1cC5yZW5kZXJlci5teVJlbmRlcmVyID0gbXlSZW5kZXJlcjtgXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd8RnVuY3Rpb259XG4gICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKi9cbiAgcmVuZGVyZXI6IHZvaWQgMCxcblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgJ2h0Q29tbWVudENlbGwnXG4gICAqL1xuICBjb21tZW50ZWRDZWxsQ2xhc3NOYW1lOiAnaHRDb21tZW50Q2VsbCcsXG5cbiAgLyoqXG4gICAqIFNldHRpbmcgdG8gYHRydWVgIGVuYWJsZXMgc2VsZWN0aW5nIGp1c3QgYSBmcmFnbWVudCBvZiB0aGUgdGV4dCB3aXRoaW4gYSBzaW5nbGUgY2VsbCBvciBiZXR3ZWVuIGFkamFjZW50IGNlbGxzLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGZyYWdtZW50U2VsZWN0aW9uOiBmYWxzZSxcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIE1ha2UgY2VsbCBbcmVhZCBvbmx5XShodHRwOi8vaGFuZHNvbnRhYmxlLmNvbS9kZW1vL3JlYWRvbmx5Lmh0bWwpLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRPbmx5OiBmYWxzZSxcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFNldHRpbmcgdG8gdHJ1ZSBlbmFibGVzIHRoZSBzZWFyY2ggcGx1Z2luIChzZWUgW2RlbW9dKGh0dHA6Ly9oYW5kc29udGFibGUuY29tL2RlbW8vc2VhcmNoLmh0bWwpKS5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBzZWFyY2g6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogU2hvcnRjdXQgdG8gZGVmaW5lIGNvbWJpbmF0aW9uIG9mIGNlbGwgcmVuZGVyZXIgYW5kIGVkaXRvciBmb3IgdGhlIGNvbHVtbi5cbiAgICpcbiAgICogUG9zc2libGUgdmFsdWVzOlxuICAgKiAgKiB0ZXh0XG4gICAqICAqIFtudW1lcmljXShodHRwOi8vaGFuZHNvbnRhYmxlLmNvbS9kZW1vL251bWVyaWMuaHRtbClcbiAgICogICogW2RhdGVdKGh0dHA6Ly9oYW5kc29udGFibGUuY29tL2RlbW8vZGF0ZS5odG1sKVxuICAgKiAgKiBbY2hlY2tib3hdKGh0dHA6Ly9oYW5kc29udGFibGUuY29tL2RlbW8vY2hlY2tib3guaHRtbClcbiAgICogICogW2F1dG9jb21wbGV0ZV0oaHR0cDovL2hhbmRzb250YWJsZS5jb20vZGVtby9hdXRvY29tcGxldGUuaHRtbClcbiAgICogICogW2hhbmRzb250YWJsZV0oaHR0cDovL2hhbmRzb250YWJsZS5jb20vZGVtby9oYW5kc29udGFibGUuaHRtbClcbiAgICpcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgJ3RleHQnXG4gICAqL1xuICB0eXBlOiAndGV4dCcsXG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBNYWtlIGNlbGwgY29weWFibGUgKHByZXNzaW5nIDxrYmQ+Q1RSTDwva2JkPiArIDxrYmQ+Qzwva2JkPiBvbiB5b3VyIGtleWJvYXJkIG1vdmVzIGl0cyB2YWx1ZSB0byBzeXN0ZW0gY2xpcGJvYXJkKS5cbiAgICpcbiAgICogX19Ob3RlOl9fIHRoaXMgc2V0dGluZyBpcyBgZmFsc2VgIGJ5IGRlZmF1bHQgZm9yIGNlbGxzIHdpdGggdHlwZSBgcGFzc3dvcmRgLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKiBAc2luY2UgMC4xMC4yXG4gICAqL1xuICBjb3B5YWJsZTogdHJ1ZSxcblxuICAvKipcbiAgICogU3RyaW5nLCByZW5kZXJpbmcgZnVuY3Rpb24gb3IgYm9vbGVhbi5cbiAgICpcbiAgICogU3RyaW5nIG1heSBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyBwcmVkZWZpbmVkIHZhbHVlczpcbiAgICogICogW2F1dG9jb21wbGV0ZV0oaHR0cDovL2hhbmRzb250YWJsZS5jb20vZGVtby9hdXRvY29tcGxldGUuaHRtbClcbiAgICogICogW2NoZWNrYm94XShodHRwOi8vaGFuZHNvbnRhYmxlLmNvbS9kZW1vL2NoZWNrYm94Lmh0bWwpXG4gICAqICAqIFtkYXRlXShodHRwOi8vaGFuZHNvbnRhYmxlLmNvbS9kZW1vL2RhdGUuaHRtbClcbiAgICogICogW2Ryb3Bkb3duXShodHRwOi8vaGFuZHNvbnRhYmxlLmNvbS9kZW1vL2Ryb3Bkb3duLmh0bWwpXG4gICAqICAqIFtoYW5kc29udGFibGVdKGh0dHA6Ly9oYW5kc29udGFibGUuY29tL2RlbW8vaGFuZHNvbnRhYmxlLmh0bWwpXG4gICAqICAqIFttb2JpbGVdKGh0dHA6Ly9kb2NzLmhhbmRzb250YWJsZS5jb20vZGVtby1tb2JpbGVzLWFuZC10YWJsZXRzLmh0bWwpXG4gICAqICAqIFtwYXNzd29yZF0oaHR0cDovL2hhbmRzb250YWJsZS5jb20vZGVtby9wYXNzd29yZC5odG1sKVxuICAgKiAgKiBbc2VsZWN0XShodHRwOi8vaGFuZHNvbnRhYmxlLmNvbS9kZW1vL3NlbGVjdEVkaXRvci5odG1sKVxuICAgKiAgKiB0ZXh0XG4gICAqXG4gICAqIE9yIHlvdSBjYW4gZGlzYWJsZSBjZWxsIGVkaXRpbmcgcGFzc2luZyBgZmFsc2VgLlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfEZ1bmN0aW9ufEJvb2xlYW59XG4gICAqIEBkZWZhdWx0ICd0ZXh0J1xuICAgKi9cbiAgZWRpdG9yOiB2b2lkIDAsXG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBdXRvY29tcGxldGUgZGVmaW5pdGlvbnMuIFNlZSBbZGVtby9hdXRvY29tcGxldGUuaHRtbF0oaHR0cDovL2hhbmRzb250YWJsZS5jb20vZGVtby9hdXRvY29tcGxldGUuaHRtbCkgZm9yIGV4YW1wbGVzIGFuZCBkZWZpbml0aW9ucy5cbiAgICpcbiAgICogQHR5cGUge0FycmF5fVxuICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICovXG4gIGF1dG9Db21wbGV0ZTogdm9pZCAwLFxuXG4gIC8qKlxuICAgKiBDb250cm9sIG51bWJlciBvZiBjaG9pY2VzIGZvciBhdXRvY29tcGxldGUgKG9yIGRyb3Bkb3duKSBjZWxscy4gQWZ0ZXIgZXhjZWVkaW5nIGl0IHNjcm9sbGJhciBmb3IgZHJvcGRvd24gbGlzdCBvZiBjaG9pY2VzIHdpbGwgYmUgdmlzaWJsZS5cbiAgICpcbiAgICogQHNpbmNlIDAuMTguMFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAxMFxuICAgKi9cbiAgdmlzaWJsZVJvd3MgOiAxMCxcblxuICAvKipcbiAgICogTWFrZXMgYXV0b2NvbXBsZXRlIG9yIGRyb3Bkb3duIHdpZHRoIHRoZSBzYW1lIGFzIHRoZSBlZGl0ZWQgY2VsbCB3aWR0aC4gSWYgYGZhbHNlYCB0aGVuIGVkaXRvciB3aWxsIGJlIHNjYWxlZFxuICAgKiBhY2NvcmRpbmcgdG8gaXRzIGNvbnRlbnQuXG4gICAqXG4gICAqIEBzaW5jZSAwLjE3LjBcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHRyaW1Ecm9wZG93biA6IHRydWUsXG5cbiAgLyoqXG4gICAqIFNldHRpbmcgdG8gdHJ1ZSBlbmFibGVzIHRoZSBkZWJ1ZyBtb2RlLCBjdXJyZW50bHkgdXNlZCB0byB0ZXN0IHRoZSBjb3JyZWN0bmVzcyBvZiB0aGUgcm93IGFuZCBjb2x1bW5cbiAgICogaGVhZGVyIGZpeGVkIHBvc2l0aW9uaW5nIG9uIGEgbGF5ZXIgYWJvdmUgdGhlIG1hc3RlciB0YWJsZS5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkZWJ1ZzogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZW4gc2V0IHRvIGB0cnVlYCwgdGhlIHRleHQgb2YgdGhlIGNlbGwgY29udGVudCBpcyB3cmFwcGVkIGlmIGl0IGRvZXMgbm90IGZpdCBpbiB0aGUgZml4ZWQgY29sdW1uIHdpZHRoLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKiBAc2luY2UgMC4xMS4wXG4gICAqL1xuICB3b3JkV3JhcDogdHJ1ZSxcblxuICAvKipcbiAgICogQ1NTIGNsYXNzIG5hbWUgYWRkZWQgdG8gY2VsbHMgd2l0aCBjZWxsIG1ldGEgYHdvcmRXcmFwOiBmYWxzZWAuXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0ICdodE5vV3JhcCdcbiAgICogQHNpbmNlIDAuMTEuMFxuICAgKi9cbiAgbm9Xb3JkV3JhcENsYXNzTmFtZTogJ2h0Tm9XcmFwJyxcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIERlZmluZXMgaWYgdGhlIHJpZ2h0LWNsaWNrIGNvbnRleHQgbWVudSBzaG91bGQgYmUgZW5hYmxlZC4gQ29udGV4dCBtZW51IGFsbG93cyB0byBjcmVhdGUgbmV3IHJvdyBvclxuICAgKiBjb2x1bW4gYXQgYW55IHBsYWNlIGluIHRoZSBncmlkLiBQb3NzaWJsZSB2YWx1ZXM6IGB0cnVlYCAodG8gZW5hYmxlIGJhc2ljIG9wdGlvbnMpLCBgZmFsc2VgICh0byBkaXNhYmxlIGNvbXBsZXRlbHkpXG4gICAqIG9yIGFycmF5IG9mIGFueSBhdmFpbGFibGUgc3RyaW5nczogYFtcInJvd19hYm92ZVwiLCBcInJvd19iZWxvd1wiLCBcImNvbF9sZWZ0XCIsIFwiY29sX3JpZ2h0XCIsXG4gICAqIFwicmVtb3ZlX3Jvd1wiLCBcInJlbW92ZV9jb2xcIiwgXCJ1bmRvXCIsIFwicmVkb1wiLCBcInNlcDFcIiwgXCJzZXAyXCIsIFwic2VwM1wiXWAuXG4gICAqXG4gICAqIFNlZSBbZGVtby9jb250ZXh0bWVudS5odG1sXShodHRwOi8vaGFuZHNvbnRhYmxlLmNvbS9kZW1vL2NvbnRleHRtZW51Lmh0bWwpIGZvciBleGFtcGxlcy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW58QXJyYXl8T2JqZWN0fVxuICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICovXG4gIGNvbnRleHRNZW51OiB2b2lkIDAsXG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBEZWZpbmVzIGlmIHRoZSBkcm9wZG93biBtZW51IGluIGhlYWRlcnMgc2hvdWxkIGJlIGVuYWJsZWQuIERyb3Bkb3duIG1lbnUgYWxsb3dzIHRvIHB1dCBjdXN0b20gb3IgcHJlZGVmaW5lZCBhY3Rpb25zXG4gICAqIHdoaWNoIGNhbiBpbnRyZWFjdCB3aXRoIHNlbGVjdGVkIGNvbHVtbi5cbiAgICogUG9zc2libGUgdmFsdWVzOiBgdHJ1ZWAgKHRvIGVuYWJsZSBiYXNpYyBvcHRpb25zKSwgYGZhbHNlYCAodG8gZGlzYWJsZSBjb21wbGV0ZWx5KVxuICAgKiBvciBhcnJheSBvZiBhbnkgYXZhaWxhYmxlIHN0cmluZ3M6IGBbXCJyb3dfYWJvdmVcIiwgXCJyb3dfYmVsb3dcIiwgXCJjb2xfbGVmdFwiLCBcImNvbF9yaWdodFwiLFxuICAgKiBcInJlbW92ZV9yb3dcIiwgXCJyZW1vdmVfY29sXCIsIFwidW5kb1wiLCBcInJlZG9cIiwgXCJjbGVhcl9jb2x1bW5cIiwgXCJzZXAxXCIsIFwic2VwMlwiLCBcInNlcDNcIl1gLlxuICAgKlxuICAgKiBTZWUgW2RlbW8vZHJvcGRvd25tZW51Lmh0bWxdKGh0dHA6Ly9oYW5kc29udGFibGUuY29tL2RlbW8vZHJvcGRvd25tZW51Lmh0bWwpIGZvciBleGFtcGxlcy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW58QXJyYXl8T2JqZWN0fVxuICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICovXG4gIGRyb3Bkb3duTWVudTogdm9pZCAwLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIHVuZG8vcmVkbyBmdW5jdGlvbmFsaXR5IGlzIGVuYWJsZWQuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICovXG4gIHVuZG86IHZvaWQgMCxcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFR1cm4gb24gW0NvbHVtbiBzb3J0aW5nXShodHRwOi8vaGFuZHNvbnRhYmxlLmNvbS9kZW1vL3NvcnRpbmcuaHRtbCkuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufE9iamVjdH1cbiAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqL1xuICBjb2x1bW5Tb3J0aW5nOiB2b2lkIDAsXG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUdXJuIG9uIFtNYW51YWwgY29sdW1uIG1vdmVdKGh0dHA6Ly9kb2NzLmhhbmRzb250YWJsZS5jb20vZGVtby1yZXNpemluZy5odG1sKSwgaWYgc2V0IHRvIGEgYm9vbGVhbiBvciBkZWZpbmUgaW5pdGlhbFxuICAgKiBjb2x1bW4gb3JkZXIsIGlmIHNldCB0byBhbiBhcnJheSBvZiBjb2x1bW4gaW5kZXhlcy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW58QXJyYXl9XG4gICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKi9cbiAgbWFudWFsQ29sdW1uTW92ZTogdm9pZCAwLFxuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVHVybiBvbiBbTWFudWFsIGNvbHVtbiByZXNpemVdKGh0dHA6Ly9kb2NzLmhhbmRzb250YWJsZS5jb20vZGVtby1yZXNpemluZy5odG1sKSwgaWYgc2V0IHRvIGEgYm9vbGVhbiBvciBkZWZpbmUgaW5pdGlhbFxuICAgKiBjb2x1bW4gcmVzaXplZCB3aWR0aHMsIGlmIHNldCB0byBhbiBhcnJheSBvZiBudW1iZXJzLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbnxBcnJheX1cbiAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqL1xuICBtYW51YWxDb2x1bW5SZXNpemU6IHZvaWQgMCxcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFR1cm4gb24gW01hbnVhbCByb3cgbW92ZV0oaHR0cDovL2RvY3MuaGFuZHNvbnRhYmxlLmNvbS9kZW1vLXJlc2l6aW5nLmh0bWwpLCBpZiBzZXQgdG8gYSBib29sZWFuIG9yIGRlZmluZSBpbml0aWFsXG4gICAqIHJvdyBvcmRlciwgaWYgc2V0IHRvIGFuIGFycmF5IG9mIHJvdyBpbmRleGVzLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbnxBcnJheX1cbiAgICogQGRlZmF1bHQgdW5kZWZpbmVkXG4gICAqIEBzaW5jZSAwLjExLjBcbiAgICovXG4gIG1hbnVhbFJvd01vdmU6IHZvaWQgMCxcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFR1cm4gb24gW01hbnVhbCByb3cgcmVzaXplXShodHRwOi8vZG9jcy5oYW5kc29udGFibGUuY29tL2RlbW8tcmVzaXppbmcuaHRtbCksIGlmIHNldCB0byBhIGJvb2xlYW4gb3IgZGVmaW5lIGluaXRpYWxcbiAgICogcm93IHJlc2l6ZWQgaGVpZ2h0cywgaWYgc2V0IHRvIGFuIGFycmF5IG9mIG51bWJlcnMuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufEFycmF5fVxuICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICogQHNpbmNlIDAuMTEuMFxuICAgKi9cbiAgbWFudWFsUm93UmVzaXplOiB2b2lkIDAsXG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBTZXR0aW5nIHRvIHRydWUgb3IgYXJyYXkgZW5hYmxlcyB0aGUgbWVyZ2VDZWxscyBwbHVnaW4sIHdoaWNoIGVuYWJsZXMgdGhlIG1lcmdpbmcgb2YgdGhlIGNlbGxzLiAoc2VlIFtkZW1vXShodHRwOi8vaGFuZHNvbnRhYmxlLmNvbS9kZW1vL21lcmdlX2NlbGxzLmh0bWwpKS5cbiAgICogWW91IGNhbiBwcm92aWRlIHRoZSBtZXJnZWQgY2VsbHMgb24gdGhlIHBhZ2Vsb2FkIGlmIHlvdSBmZWVkIHRoZSBtZXJnZUNlbGxzIG9wdGlvbiB3aXRoIGFuIGFycmF5LlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbnxBcnJheX1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIG1lcmdlQ2VsbHM6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2Ygcm93cyB0byBiZSBwcmVyZW5kZXJlZCBiZWZvcmUgYW5kIGFmdGVyIHRoZSB2aWV3cG9ydCBpcyBjaGFuZ2VkLiBEZWZhdWx0IHZhbHVlIGlzIGAnYXV0bydgIHdoaWNoIG1lYW5zXG4gICAqIHRoYXQgSGFuZHNvbnRhYmxlIHRyaWVzIHRvIGNhbGN1bGF0ZXMgb2Zmc2V0IGZvciBiZXN0IHBlcmZvcm1hbmNlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfFN0cmluZ31cbiAgICogQGRlZmF1bHQgJ2F1dG8nXG4gICAqL1xuICB2aWV3cG9ydFJvd1JlbmRlcmluZ09mZnNldDogJ2F1dG8nLFxuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgY29sdW1ucyB0byBiZSBwcmVyZW5kZXJlZCBiZWZvcmUgYW5kIGFmdGVyIHRoZSB2aWV3cG9ydCBpcyBjaGFuZ2VkLiBEZWZhdWx0IHZhbHVlIGlzIGAnYXV0bydgIHdoaWNoIG1lYW5zXG4gICAqIHRoYXQgSGFuZHNvbnRhYmxlIHRyaWVzIHRvIGNhbGN1bGF0ZXMgb2Zmc2V0IGZvciBiZXN0IHBlcmZvcm1hbmNlLlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfFN0cmluZ31cbiAgICogQGRlZmF1bHQgJ2F1dG8nXG4gICAqL1xuICB2aWV3cG9ydENvbHVtblJlbmRlcmluZ09mZnNldDogJ2F1dG8nLFxuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogSWYgYHRydWVgLCBlbmFibGVzIEdyb3VwaW5nIHBsdWdpbiwgd2hpY2ggZW5hYmxlcyBhcHBseWluZyBleHBhbmRhYmxlIHJvdyBhbmQgY29sdW1uIGdyb3Vwcy5cbiAgICogVG8gaW5pdGlhbGl6ZSBIYW5kc29udGFibGUgd2l0aCBwcmVkZWZpbmVkIGdyb3VwcywgcHJvdmlkZSByb3cgb3IgY29sdW1uIGdyb3VwIHN0YXJ0IGFuZCBlbmQgY29vcmRpbmF0ZXMgaW4gZm9ybSBvZiBhbiBhcnJheS5cbiAgICpcbiAgICogU2VlIFtHcm91cGluZ10oaHR0cDovL2hhbmRzb250YWJsZS5jb20vZGVtby9ncm91cGluZy5odG1sKSBkZW1vIGZvciBleGFtcGxlcy5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW58QXJyYXl9XG4gICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKiBAc2luY2UgMC4xMS40XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIC4uLlxuICAgKiAvLyBhcyBib29sZWFuXG4gICAqIGdyb3VwczogdHJ1ZSxcbiAgICogLi4uXG4gICAqXG4gICAqIC4uLlxuICAgKiAvLyBhcyBhcnJheVxuICAgKiBncm91cHM6IFt7Y29sczogWzAsIDJdfSwge2NvbHM6IFs1LCAxNV0sIHJvd3M6IFswLCA1XX1dLFxuICAgKiAuLi5cbiAgICogYGBgXG4gICAqL1xuICBncm91cHM6IHZvaWQgMCxcblxuICAvKipcbiAgICogQSB1c3VhbGx5IHNtYWxsIGZ1bmN0aW9uIG9yIHJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IHZhbGlkYXRlcyB0aGUgaW5wdXQuXG4gICAqIEFmdGVyIHlvdSBkZXRlcm1pbmUgaWYgdGhlIGlucHV0IGlzIHZhbGlkLCBleGVjdXRlIGBjYWxsYmFjayh0cnVlKWAgb3IgYGNhbGxiYWNrKGZhbHNlKWAgdG8gcHJvY2VlZCB3aXRoIHRoZSBleGVjdXRpb24uXG4gICAqIEluIGZ1bmN0aW9uLCBgdGhpc2AgYmluZHMgdG8gY2VsbFByb3BlcnRpZXMuXG4gICAqXG4gICAqIEB0eXBlIHtGdW5jdGlvbnxSZWdFeHB9XG4gICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgKiBAc2luY2UgMC45LjVcbiAgICovXG4gIHZhbGlkYXRvcjogdm9pZCAwLFxuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogRGlzYWJsZSB2aXN1YWwgY2VsbHMgc2VsZWN0aW9uLlxuICAgKlxuICAgKiBQb3NzaWJsZSB2YWx1ZXM6XG4gICAqICAqIGB0cnVlYCAtIERpc2FibGVzIGFueSB0eXBlIG9mIHZpc3VhbCBzZWxlY3Rpb24gKGN1cnJlbnQgYW5kIGFyZWEgc2VsZWN0aW9uKSxcbiAgICogICogYGZhbHNlYCAtIEVuYWJsZXMgYW55IHR5cGUgb2YgdmlzdWFsIHNlbGVjdGlvbi4gVGhpcyBpcyBkZWZhdWx0IHZhbHVlLlxuICAgKiAgKiBgY3VycmVudGAgLSBEaXNhYmxlcyB0byBhcHBlYXIgb25seSBjdXJyZW50IHNlbGVjdGVkIGNlbGwuXG4gICAqICAqIGBhcmVhYCAtIERpc2FibGVzIHRvIGFwcGVhciBvbmx5IG11bHRpcGxlIHNlbGVjdGVkIGNlbGxzLlxuICAgKlxuICAgKiBAdHlwZSB7Qm9vbGVhbnxTdHJpbmd8QXJyYXl9XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEBzaW5jZSAwLjEzLjJcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogLi4uXG4gICAqIC8vIGFzIGJvb2xlYW5cbiAgICogZGlzYWJsZVZpc3VhbFNlbGVjdGlvbjogdHJ1ZSxcbiAgICogLi4uXG4gICAqXG4gICAqIC4uLlxuICAgKiAvLyBhcyBzdHJpbmcgKCdjdXJyZW50JyBvciAnYXJlYScpXG4gICAqIGRpc2FibGVWaXN1YWxTZWxlY3Rpb246ICdjdXJyZW50JyxcbiAgICogLi4uXG4gICAqXG4gICAqIC4uLlxuICAgKiAvLyBhcyBhcnJheVxuICAgKiBkaXNhYmxlVmlzdWFsU2VsZWN0aW9uOiBbJ2N1cnJlbnQnLCAnYXJlYSddLFxuICAgKiAuLi5cbiAgICogYGBgXG4gICAqL1xuICBkaXNhYmxlVmlzdWFsU2VsZWN0aW9uOiBmYWxzZSxcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFNldCB3aGV0aGVyIHRvIGRpc3BsYXkgdGhlIGN1cnJlbnQgc29ydGluZyBpbmRpY2F0b3IgKGEgdHJpYW5nbGUgaWNvbiBpbiB0aGUgY29sdW1uIGhlYWRlciwgc3BlY2lmeWluZyB0aGUgc29ydGluZyBvcmRlcikuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKiBAc2luY2UgMC4xNS4wLWJldGEzXG4gICAqL1xuICBzb3J0SW5kaWNhdG9yOiBmYWxzZSxcbiAgbWFudWFsQ29sdW1uRnJlZXplOiB2b2lkIDAsXG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBEZWZpbmVzIHdoZXRoZXIgSGFuZHNvbnRhYmxlIHNob3VsZCB0cmltIHRoZSB3aGl0ZXNwYWNlIGF0IHRoZSBiZWdnaW5nIGFuZCB0aGUgZW5kIG9mIHRoZSBjZWxsIGNvbnRlbnRzXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICB0cmltV2hpdGVzcGFjZTogdHJ1ZSxcbiAgc2V0dGluZ3M6IHZvaWQgMCxcbiAgc291cmNlOiB2b2lkIDAsXG4gIHRpdGxlOiB2b2lkIDAsXG5cbiAgLyoqXG4gICAqIERhdGEgdGVtcGxhdGUgZm9yIGAnY2hlY2tib3gnYCB0eXBlIHdoZW4gY2hlY2tib3ggaXMgY2hlY2tlZC5cbiAgICpcbiAgICogT3B0aW9uIGRlc2lyZWQgZm9yIGNlbGwgd2hpY2ggYCdjaGVja2JveCdgIHR5cGUuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufFN0cmluZ31cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgY2hlY2tlZFRlbXBsYXRlOiB2b2lkIDAsXG5cbiAgLyoqXG4gICAqIERhdGEgdGVtcGxhdGUgZm9yIGAnY2hlY2tib3gnYCB0eXBlIHdoZW4gY2hlY2tib3ggaXMgdW5jaGVja2VkLlxuICAgKlxuICAgKiBPcHRpb24gZGVzaXJlZCBmb3IgY2VsbCB3aGljaCBgJ2NoZWNrYm94J2AgdHlwZS5cbiAgICpcbiAgICogQHR5cGUge0Jvb2xlYW58U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgdW5jaGVja2VkVGVtcGxhdGU6IHZvaWQgMCxcblxuICAvKipcbiAgICogRGlzcGxheSBmb3JtYXQuIFNlZSBodHRwOi8vbnVtZXJpYy5jb20uXG4gICAqXG4gICAqIE9wdGlvbiBkZXNpcmVkIGZvciBjZWxsIHdoaWNoIGAnbnVtZXJpYydgIHR5cGUuXG4gICAqL1xuICBmb3JtYXQ6IHZvaWQgMCxcblxuICAvKipcbiAgICogTGFuZ3VhZ2UgZGlzcGxheSBmb3JtYXQuIFNlZSBodHRwOi8vbnVtZXJpYy5jb20uXG4gICAqXG4gICAqIE9wdGlvbiBkZXNpcmVkIGZvciBjZWxsIHdoaWNoIGAnbnVtZXJpYydgIHR5cGUuXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0ICdlbidcbiAgICovXG4gIGxhbmd1YWdlOiB2b2lkIDAsXG5cbiAgLyoqXG4gICAqIERhdGEgc291cmNlIGZvciBjZWxsIHdpdGggYCdzZWxlY3QnYCB0eXBlLlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqL1xuICBzZWxlY3RPcHRpb25zOiB2b2lkIDAsXG5cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgYXV0b0NvbHVtblNpemUgcGx1Z2luLiBEZWZhdWx0IHZhbHVlIGlzIGB1bmRlZmluZWRgIHdoaWNoIGlzIHRoZSBzYW1lIGVmZmVjdCBhcyBgdHJ1ZWAuXG4gICAqIERpc2FibGUgdGhpcyBwbHVnaW4gY2FuIGluY3JlYXNlIHBlcmZvcm1hbmNlLlxuICAgKlxuICAgKiBDb2x1bW4gd2lkdGggY2FsY3VsYXRpb25zIGFyZSBkaXZpZGVkIGludG8gc3luYyBhbmQgYXN5bmMgcGFydC4gRWFjaCBvZiB0aGlzIHBhcnQgaGFzIG93biBhZHZhbnRhZ2VzIGFuZFxuICAgKiBkaXNhZHZhbnRhZ2VzLiBTeW5jaHJvbm91cyBjb3VudGluZyBpcyBmYXN0ZXIgYnV0IGl0IGJsb2NrcyBicm93c2VyIFVJIGFuZCBhc3luY2hyb25vdXMgaXMgc2xvd2VyIGJ1dCBpdCBkb2VzIG5vdFxuICAgKiBibG9jayBCcm93c2VyIFVJLlxuICAgKlxuICAgKiBUbyBjb25maWd1cmUgdGhpcyBzeW5jL2FzeW5jIGxpbmUgeW91IGNhbiBwYXNzIGFic29sdXRlIHZhbHVlIChjb2x1bW5zKSBvciBwZXJjZW50YWdlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiAuLi5cbiAgICogLy8gYXMgbnVtYmVyICgzMDAgY29sdW1ucyBpbiBzeW5jLCByZXN0IGFzeW5jKVxuICAgKiBhdXRvQ29sdW1uU2l6ZToge3N5bmNMaW1pdDogMzAwfSxcbiAgICogLi4uXG4gICAqXG4gICAqIC4uLlxuICAgKiAvLyBhcyBzdHJpbmcgKHBlcmNlbnQpXG4gICAqIGF1dG9Db2x1bW5TaXplOiB7c3luY0xpbWl0OiAnNDAlJ30sXG4gICAqIC4uLlxuICAgKiBgYGBcbiAgICpcbiAgICogYHN5bmNMaW1pdGAgb3B0aW9ucyBpcyBhdmFpbGFibGUgc2luY2UgMC4xNi4wLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fEJvb2xlYW59XG4gICAqIEBkZWZhdWx0IHtzeW5jTGltaXQ6IDUwfVxuICAgKi9cbiAgYXV0b0NvbHVtblNpemU6IHZvaWQgMCxcblxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBhdXRvUm93U2l6ZSBwbHVnaW4uIERlZmF1bHQgdmFsdWUgaXMgYHVuZGVmaW5lZGAgd2hpY2ggaXMgdGhlIHNhbWUgZWZmZWN0IGFzIGB0cnVlYC5cbiAgICogRGlzYWJsZSB0aGlzIHBsdWdpbiBjYW4gaW5jcmVhc2UgcGVyZm9ybWFuY2UuXG4gICAqXG4gICAqIFJvdyBoZWlnaHQgY2FsY3VsYXRpb25zIGFyZSBkaXZpZGVkIGludG8gc3luYyBhbmQgYXN5bmMgcGFydC4gRWFjaCBvZiB0aGlzIHBhcnQgaGFzIG93biBhZHZhbnRhZ2VzIGFuZFxuICAgKiBkaXNhZHZhbnRhZ2VzLiBTeW5jaHJvbm91cyBjb3VudGluZyBpcyBmYXN0ZXIgYnV0IGl0IGJsb2NrcyBicm93c2VyIFVJIGFuZCBhc3luY2hyb25vdXMgaXMgc2xvd2VyIGJ1dCBpdCBkb2VzIG5vdFxuICAgKiBibG9jayBCcm93c2VyIFVJLlxuICAgKlxuICAgKiBUbyBjb25maWd1cmUgdGhpcyBzeW5jL2FzeW5jIGxpbmUgeW91IGNhbiBwYXNzIGFic29sdXRlIHZhbHVlIChyb3dzKSBvciBwZXJjZW50YWdlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiAuLi5cbiAgICogLy8gYXMgbnVtYmVyICgzMDAgY29sdW1ucyBpbiBzeW5jLCByZXN0IGFzeW5jKVxuICAgKiBhdXRvUm93U2l6ZToge3N5bmNMaW1pdDogMzAwfSxcbiAgICogLi4uXG4gICAqXG4gICAqIC4uLlxuICAgKiAvLyBhcyBzdHJpbmcgKHBlcmNlbnQpXG4gICAqIGF1dG9Sb3dTaXplOiB7c3luY0xpbWl0OiAnNDAlJ30sXG4gICAqIC4uLlxuICAgKiBgYGBcbiAgICpcbiAgICogYHN5bmNMaW1pdGAgb3B0aW9ucyBpcyBhdmFpbGFibGUgc2luY2UgMC4xNi4wLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fEJvb2xlYW59XG4gICAqIEBkZWZhdWx0IHtzeW5jTGltaXQ6IDEwMDB9XG4gICAqL1xuICBhdXRvUm93U2l6ZTogdm9pZCAwLFxuXG4gIC8qKlxuICAgKiBEYXRlIHZhbGlkYXRpb24gZm9ybWF0LlxuICAgKlxuICAgKiBPcHRpb24gZGVzaXJlZCBmb3IgY2VsbCB3aGljaCBgJ2RhdGUnYCB0eXBlLlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCAnREQvTU0vWVlZWSdcbiAgICovXG4gIGRhdGVGb3JtYXQ6IHZvaWQgMCxcblxuICAvKipcbiAgICogSWYgYHRydWVgIHRoZW4gZGF0ZXMgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGZvcm1hdHRlZCB0byBtYXRjaCB0aGUgZGVzaXJlZCBmb3JtYXQuXG4gICAqXG4gICAqIE9wdGlvbiBkZXNpcmVkIGZvciBjZWxsIHdoaWNoIGAnZGF0ZSdgIHR5cGUuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgY29ycmVjdEZvcm1hdDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgZGVmYXVsdCB2YWx1ZSB3aGljaCB3aWxsIGZpbGwgZW1wdHkgY2VsbHMuXG4gICAqXG4gICAqIE9wdGlvbiBkZXNpcmVkIGZvciBjZWxsIHdoaWNoIGAnZGF0ZSdgIHR5cGUuXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBkZWZhdWx0RGF0ZTogdm9pZCAwLFxuXG4gIC8qKlxuICAgKiBJZiB0eXBlZCBgdHJ1ZWAgdmFsdWUgZW50ZXJlZCBpbnRvIGNlbGwgbXVzdCBtYXRjaCB0byB0aGUgYXV0b2NvbXBsZXRlIHNvdXJjZS4gT3RoZXJ3aXNlIGNlbGwgd2lsbCBiZSBpbnZhbGlkLlxuICAgKlxuICAgKiBPcHRpb24gZGVzaXJlZCBmb3IgY2VsbCB3aGljaCBgJ2F1dG9jb21wbGV0ZSdgIHR5cGUuXG4gICAqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgc3RyaWN0OiB2b2lkIDAsXG59O1xuSGFuZHNvbnRhYmxlLkRlZmF1bHRTZXR0aW5ncyA9IERlZmF1bHRTZXR0aW5ncztcbiIsIlxuaW1wb3J0IFNoZWV0Q2xpcCBmcm9tICdTaGVldENsaXAnO1xuaW1wb3J0IHtjZWxsTWV0aG9kTG9va3VwRmFjdG9yeX0gZnJvbSAnLi9oZWxwZXJzL2RhdGEnO1xuaW1wb3J0IHtjb2x1bW5GYWN0b3J5fSBmcm9tICcuL2hlbHBlcnMvc2V0dGluZyc7XG5pbXBvcnQge2R1Y2tTY2hlbWEsIGRlZXBFeHRlbmR9IGZyb20gJy4vaGVscGVycy9vYmplY3QnO1xuaW1wb3J0IHtleHRlbmRBcnJheSwgdG8yZEFycmF5fSBmcm9tICcuL2hlbHBlcnMvYXJyYXknO1xuaW1wb3J0IHtNdWx0aU1hcH0gZnJvbSAnLi9tdWx0aU1hcCc7XG5cblxuLyoqXG4gKiBVdGlsaXR5IGNsYXNzIHRoYXQgZ2V0cyBhbmQgc2F2ZXMgZGF0YSBmcm9tL3RvIHRoZSBkYXRhIHNvdXJjZSB1c2luZyBtYXBwaW5nIG9mIGNvbHVtbnMgbnVtYmVycyB0byBvYmplY3QgcHJvcGVydHkgbmFtZXNcbiAqIEB0b2RvIHJlZmFjdG9yIGFyZ3VtZW50cyBvZiBtZXRob2RzIGdldFJhbmdlLCBnZXRUZXh0IHRvIGJlIG51bWJlcnMgKG5vdCBvYmplY3RzKVxuICogQHRvZG8gcmVtb3ZlIHByaXYsIEdyaWRTZXR0aW5ncyBmcm9tIG9iamVjdCBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZSBJbnN0YW5jZSBvZiBIYW5kc29udGFibGVcbiAqIEBwYXJhbSB7Kn0gcHJpdlxuICogQHBhcmFtIHsqfSBHcmlkU2V0dGluZ3MgR3JpZCBzZXR0aW5nc1xuICogQHV0aWxcbiAqIEBjbGFzcyBEYXRhTWFwXG4gKiBAZGVwZW5kZW5jaWVzIFNoZWV0Q2xpcFxuICovXG5mdW5jdGlvbiBEYXRhTWFwKGluc3RhbmNlLCBwcml2LCBHcmlkU2V0dGluZ3MpIHtcbiAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICB0aGlzLnByaXYgPSBwcml2O1xuICB0aGlzLkdyaWRTZXR0aW5ncyA9IEdyaWRTZXR0aW5ncztcbiAgdGhpcy5kYXRhU291cmNlID0gdGhpcy5pbnN0YW5jZS5nZXRTZXR0aW5ncygpLmRhdGE7XG5cbiAgaWYgKHRoaXMuZGF0YVNvdXJjZVswXSkge1xuICAgIHRoaXMuZHVja1NjaGVtYSA9IHRoaXMucmVjdXJzaXZlRHVja1NjaGVtYSh0aGlzLmRhdGFTb3VyY2VbMF0pO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuZHVja1NjaGVtYSA9IHt9O1xuICB9XG4gIHRoaXMuY3JlYXRlTWFwKCk7XG59XG5cbkRhdGFNYXAucHJvdG90eXBlLkRFU1RJTkFUSU9OX1JFTkRFUkVSID0gMTtcbkRhdGFNYXAucHJvdG90eXBlLkRFU1RJTkFUSU9OX0NMSVBCT0FSRF9HRU5FUkFUT1IgPSAyO1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmplY3RcbiAqIEByZXR1cm5zIHtPYmplY3R8QXJyYXl9XG4gKi9cbkRhdGFNYXAucHJvdG90eXBlLnJlY3Vyc2l2ZUR1Y2tTY2hlbWEgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgcmV0dXJuIGR1Y2tTY2hlbWEob2JqZWN0KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IHNjaGVtYVxuICogQHBhcmFtIHtOdW1iZXJ9IGxhc3RDb2xcbiAqIEBwYXJhbSB7TnVtYmVyfSBwYXJlbnRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbkRhdGFNYXAucHJvdG90eXBlLnJlY3Vyc2l2ZUR1Y2tDb2x1bW5zID0gZnVuY3Rpb24gKHNjaGVtYSwgbGFzdENvbCwgcGFyZW50KSB7XG4gIHZhciBwcm9wLCBpO1xuICBpZiAodHlwZW9mIGxhc3RDb2wgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbGFzdENvbCA9IDA7XG4gICAgcGFyZW50ID0gJyc7XG4gIH1cbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgIGZvciAoaSBpbiBzY2hlbWEpIHtcbiAgICAgIGlmIChzY2hlbWEuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgaWYgKHNjaGVtYVtpXSA9PT0gbnVsbCkge1xuICAgICAgICAgIHByb3AgPSBwYXJlbnQgKyBpO1xuICAgICAgICAgIHRoaXMuY29sVG9Qcm9wQ2FjaGUucHVzaChwcm9wKTtcbiAgICAgICAgICB0aGlzLnByb3BUb0NvbENhY2hlLnNldChwcm9wLCBsYXN0Q29sKTtcblxuICAgICAgICAgIGxhc3RDb2wrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsYXN0Q29sID0gdGhpcy5yZWN1cnNpdmVEdWNrQ29sdW1ucyhzY2hlbWFbaV0sIGxhc3RDb2wsIGkgKyAnLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBsYXN0Q29sO1xufTtcblxuRGF0YU1hcC5wcm90b3R5cGUuY3JlYXRlTWFwID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaSwgaWxlbiwgc2NoZW1hID0gdGhpcy5nZXRTY2hlbWEoKTtcbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnlpbmcgdG8gY3JlYXRlIGBjb2x1bW5zYCBkZWZpbml0aW9uIGJ1dCB5b3UgZGlkbnQnIHByb3ZpZGUgYHNjaGVtYWAgbm9yIGBkYXRhYFwiKTtcbiAgfVxuICB0aGlzLmNvbFRvUHJvcENhY2hlID0gW107XG4gIHRoaXMucHJvcFRvQ29sQ2FjaGUgPSBuZXcgTXVsdGlNYXAoKTtcbiAgdmFyIGNvbHVtbnMgPSB0aGlzLmluc3RhbmNlLmdldFNldHRpbmdzKCkuY29sdW1ucztcbiAgaWYgKGNvbHVtbnMpIHtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY29sdW1ucy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcblxuICAgICAgaWYgKHR5cGVvZiBjb2x1bW5zW2ldLmRhdGEgIT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICB0aGlzLmNvbFRvUHJvcENhY2hlW2ldID0gY29sdW1uc1tpXS5kYXRhO1xuICAgICAgICB0aGlzLnByb3BUb0NvbENhY2hlLnNldChjb2x1bW5zW2ldLmRhdGEsIGkpO1xuICAgICAgfVxuXG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMucmVjdXJzaXZlRHVja0NvbHVtbnMoc2NoZW1hKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHByb3BlcnR5IG5hbWUgdGhhdCBjb3JyZXNwb25kcyB3aXRoIHRoZSBnaXZlbiBjb2x1bW4gaW5kZXguXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvbFxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuRGF0YU1hcC5wcm90b3R5cGUuY29sVG9Qcm9wID0gZnVuY3Rpb24gKGNvbCkge1xuICBjb2wgPSBIYW5kc29udGFibGUuaG9va3MucnVuKHRoaXMuaW5zdGFuY2UsICdtb2RpZnlDb2wnLCBjb2wpO1xuXG4gIGlmICh0aGlzLmNvbFRvUHJvcENhY2hlICYmIHR5cGVvZiB0aGlzLmNvbFRvUHJvcENhY2hlW2NvbF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sVG9Qcm9wQ2FjaGVbY29sXTtcbiAgfVxuXG4gIHJldHVybiBjb2w7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wXG4gKiBAZmlyZXMgSG9va3MjbW9kaWZ5Q29sXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuRGF0YU1hcC5wcm90b3R5cGUucHJvcFRvQ29sID0gZnVuY3Rpb24gKHByb3ApIHtcbiAgdmFyIGNvbDtcblxuICBpZiAodHlwZW9mIHRoaXMucHJvcFRvQ29sQ2FjaGUuZ2V0KHByb3ApICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbCA9IHRoaXMucHJvcFRvQ29sQ2FjaGUuZ2V0KHByb3ApO1xuICB9IGVsc2Uge1xuICAgIGNvbCA9IHByb3A7XG4gIH1cbiAgY29sID0gSGFuZHNvbnRhYmxlLmhvb2tzLnJ1bih0aGlzLmluc3RhbmNlLCAnbW9kaWZ5Q29sJywgY29sKTtcblxuICByZXR1cm4gY29sO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5EYXRhTWFwLnByb3RvdHlwZS5nZXRTY2hlbWEgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzY2hlbWEgPSB0aGlzLmluc3RhbmNlLmdldFNldHRpbmdzKCkuZGF0YVNjaGVtYTtcbiAgaWYgKHNjaGVtYSkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gc2NoZW1hKCk7XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWE7XG4gIH1cblxuICByZXR1cm4gdGhpcy5kdWNrU2NoZW1hO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIHJvdyBhdCB0aGUgYm90dG9tIG9mIHRoZSBkYXRhIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXhdIEluZGV4IG9mIHRoZSByb3cgYmVmb3JlIHdoaWNoIHRoZSBuZXcgcm93IHdpbGwgYmUgaW5zZXJ0ZWRcbiAqIEBmaXJlcyBIb29rcyNhZnRlckNyZWF0ZVJvd1xuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBudW1iZXIgb2YgY3JlYXRlZCByb3dzXG4gKi9cbkRhdGFNYXAucHJvdG90eXBlLmNyZWF0ZVJvdyA9IGZ1bmN0aW9uIChpbmRleCwgYW1vdW50LCBjcmVhdGVkQXV0b21hdGljYWxseSkge1xuICB2YXIgcm93LCBjb2xDb3VudCA9IHRoaXMuaW5zdGFuY2UuY291bnRDb2xzKCksXG4gICAgbnVtYmVyT2ZDcmVhdGVkUm93cyA9IDAsXG4gICAgY3VycmVudEluZGV4O1xuXG4gIGlmICghYW1vdW50KSB7XG4gICAgYW1vdW50ID0gMTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInIHx8IGluZGV4ID49IHRoaXMuaW5zdGFuY2UuY291bnRSb3dzKCkpIHtcbiAgICBpbmRleCA9IHRoaXMuaW5zdGFuY2UuY291bnRSb3dzKCk7XG4gIH1cblxuICBjdXJyZW50SW5kZXggPSBpbmRleDtcbiAgdmFyIG1heFJvd3MgPSB0aGlzLmluc3RhbmNlLmdldFNldHRpbmdzKCkubWF4Um93cztcbiAgd2hpbGUgKG51bWJlck9mQ3JlYXRlZFJvd3MgPCBhbW91bnQgJiYgdGhpcy5pbnN0YW5jZS5jb3VudFJvd3MoKSA8IG1heFJvd3MpIHtcblxuICAgIGlmICh0aGlzLmluc3RhbmNlLmRhdGFUeXBlID09PSAnYXJyYXknKSB7XG4gICAgICByb3cgPSBbXTtcbiAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY29sQ291bnQ7IGMrKykge1xuICAgICAgICByb3cucHVzaChudWxsKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAodGhpcy5pbnN0YW5jZS5kYXRhVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcm93ID0gdGhpcy5pbnN0YW5jZS5nZXRTZXR0aW5ncygpLmRhdGFTY2hlbWEoaW5kZXgpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHJvdyA9IHt9O1xuICAgICAgZGVlcEV4dGVuZChyb3csIHRoaXMuZ2V0U2NoZW1hKCkpO1xuICAgIH1cblxuICAgIGlmIChpbmRleCA9PT0gdGhpcy5pbnN0YW5jZS5jb3VudFJvd3MoKSkge1xuICAgICAgdGhpcy5kYXRhU291cmNlLnB1c2gocm93KTtcblxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRhdGFTb3VyY2Uuc3BsaWNlKGluZGV4LCAwLCByb3cpO1xuICAgIH1cblxuICAgIG51bWJlck9mQ3JlYXRlZFJvd3MrKztcbiAgICBjdXJyZW50SW5kZXgrKztcbiAgfVxuXG5cbiAgSGFuZHNvbnRhYmxlLmhvb2tzLnJ1bih0aGlzLmluc3RhbmNlLCAnYWZ0ZXJDcmVhdGVSb3cnLCBpbmRleCwgbnVtYmVyT2ZDcmVhdGVkUm93cywgY3JlYXRlZEF1dG9tYXRpY2FsbHkpO1xuICB0aGlzLmluc3RhbmNlLmZvcmNlRnVsbFJlbmRlciA9IHRydWU7IC8vdXNlZCB3aGVuIGRhdGEgd2FzIGNoYW5nZWRcblxuICByZXR1cm4gbnVtYmVyT2ZDcmVhdGVkUm93cztcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBjb2wgYXQgdGhlIHJpZ2h0IG9mIHRoZSBkYXRhIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXhdIEluZGV4IG9mIHRoZSBjb2x1bW4gYmVmb3JlIHdoaWNoIHRoZSBuZXcgY29sdW1uIHdpbGwgYmUgaW5zZXJ0ZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBbYW1vdW50XVxuICogQHBhcmFtIHtOdW1iZXJ9IFtjcmVhdGVkQXV0b21hdGljYWxseV1cbiAqIEBmaXJlcyBIb29rcyNhZnRlckNyZWF0ZUNvbFxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBudW1iZXIgb2YgY3JlYXRlZCBjb2x1bW5zXG4gKi9cbkRhdGFNYXAucHJvdG90eXBlLmNyZWF0ZUNvbCA9IGZ1bmN0aW9uIChpbmRleCwgYW1vdW50LCBjcmVhdGVkQXV0b21hdGljYWxseSkge1xuICBpZiAoIXRoaXMuaW5zdGFuY2UuaXNDb2x1bW5Nb2RpZmljYXRpb25BbGxvd2VkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY3JlYXRlIG5ldyBjb2x1bW4uIFdoZW4gZGF0YSBzb3VyY2UgaW4gYW4gb2JqZWN0LCBcIiArXG4gICAgICBcInlvdSBjYW4gb25seSBoYXZlIGFzIG11Y2ggY29sdW1ucyBhcyBkZWZpbmVkIGluIGZpcnN0IGRhdGEgcm93LCBkYXRhIHNjaGVtYSBvciBpbiB0aGUgJ2NvbHVtbnMnIHNldHRpbmcuXCIgK1xuICAgICAgXCJJZiB5b3Ugd2FudCB0byBiZSBhYmxlIHRvIGFkZCBuZXcgY29sdW1ucywgeW91IGhhdmUgdG8gdXNlIGFycmF5IGRhdGFzb3VyY2UuXCIpO1xuICB9XG4gIHZhciBybGVuID0gdGhpcy5pbnN0YW5jZS5jb3VudFJvd3MoKSxcbiAgICBkYXRhID0gdGhpcy5kYXRhU291cmNlLFxuICAgIGNvbnN0cnVjdG9yLCBudW1iZXJPZkNyZWF0ZWRDb2xzID0gMCxcbiAgICBjdXJyZW50SW5kZXg7XG5cbiAgaWYgKCFhbW91bnQpIHtcbiAgICBhbW91bnQgPSAxO1xuICB9XG5cbiAgY3VycmVudEluZGV4ID0gaW5kZXg7XG5cbiAgdmFyIG1heENvbHMgPSB0aGlzLmluc3RhbmNlLmdldFNldHRpbmdzKCkubWF4Q29scztcbiAgd2hpbGUgKG51bWJlck9mQ3JlYXRlZENvbHMgPCBhbW91bnQgJiYgdGhpcy5pbnN0YW5jZS5jb3VudENvbHMoKSA8IG1heENvbHMpIHtcbiAgICBjb25zdHJ1Y3RvciA9IGNvbHVtbkZhY3RvcnkodGhpcy5HcmlkU2V0dGluZ3MsIHRoaXMucHJpdi5jb2x1bW5zU2V0dGluZ0NvbmZsaWN0cyk7XG4gICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicgfHwgaW5kZXggPj0gdGhpcy5pbnN0YW5jZS5jb3VudENvbHMoKSkge1xuICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBybGVuOyByKyspIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW3JdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGRhdGFbcl0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhW3JdLnB1c2gobnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBBZGQgbmV3IGNvbHVtbiBjb25zdHJ1Y3RvclxuICAgICAgdGhpcy5wcml2LmNvbHVtblNldHRpbmdzLnB1c2goY29uc3RydWN0b3IpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcmxlbjsgcisrKSB7XG4gICAgICAgIGRhdGFbcl0uc3BsaWNlKGN1cnJlbnRJbmRleCwgMCwgbnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBBZGQgbmV3IGNvbHVtbiBjb25zdHJ1Y3RvciBhdCBnaXZlbiBpbmRleFxuICAgICAgdGhpcy5wcml2LmNvbHVtblNldHRpbmdzLnNwbGljZShjdXJyZW50SW5kZXgsIDAsIGNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbiAgICBudW1iZXJPZkNyZWF0ZWRDb2xzKys7XG4gICAgY3VycmVudEluZGV4Kys7XG4gIH1cblxuICBIYW5kc29udGFibGUuaG9va3MucnVuKHRoaXMuaW5zdGFuY2UsICdhZnRlckNyZWF0ZUNvbCcsIGluZGV4LCBudW1iZXJPZkNyZWF0ZWRDb2xzLCBjcmVhdGVkQXV0b21hdGljYWxseSk7XG4gIHRoaXMuaW5zdGFuY2UuZm9yY2VGdWxsUmVuZGVyID0gdHJ1ZTsgLy91c2VkIHdoZW4gZGF0YSB3YXMgY2hhbmdlZFxuXG4gIHJldHVybiBudW1iZXJPZkNyZWF0ZWRDb2xzO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIHJvdyBmcm9tIHRoZSBkYXRhIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbaW5kZXhdIEluZGV4IG9mIHRoZSByb3cgdG8gYmUgcmVtb3ZlZC4gSWYgbm90IHByb3ZpZGVkLCB0aGUgbGFzdCByb3cgd2lsbCBiZSByZW1vdmVkXG4gKiBAcGFyYW0ge051bWJlcn0gW2Ftb3VudF0gQW1vdW50IG9mIHRoZSByb3dzIHRvIGJlIHJlbW92ZWQuIElmIG5vdCBwcm92aWRlZCwgb25lIHJvdyB3aWxsIGJlIHJlbW92ZWRcbiAqIEBmaXJlcyBIb29rcyNiZWZvcmVSZW1vdmVSb3dcbiAqIEBmaXJlcyBIb29rcyNhZnRlclJlbW92ZVJvd1xuICovXG5EYXRhTWFwLnByb3RvdHlwZS5yZW1vdmVSb3cgPSBmdW5jdGlvbiAoaW5kZXgsIGFtb3VudCkge1xuICBpZiAoIWFtb3VudCkge1xuICAgIGFtb3VudCA9IDE7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICBpbmRleCA9IC1hbW91bnQ7XG4gIH1cblxuICBpbmRleCA9ICh0aGlzLmluc3RhbmNlLmNvdW50Um93cygpICsgaW5kZXgpICUgdGhpcy5pbnN0YW5jZS5jb3VudFJvd3MoKTtcblxuICAvLyBXZSBoYXZlIHRvIG1hcCB0aGUgcGh5c2ljYWwgcm93IGlkcyB0byBsb2dpY2FsIGFuZCB0aGFuIHBlcmZvcm0gcmVtb3Zpbmcgd2l0aCAocG9zc2libHkpIG5ldyByb3cgaWRcbiAgdmFyIGxvZ2ljUm93cyA9IHRoaXMucGh5c2ljYWxSb3dzVG9Mb2dpY2FsKGluZGV4LCBhbW91bnQpO1xuXG4gIHZhciBhY3Rpb25XYXNOb3RDYW5jZWxsZWQgPSBIYW5kc29udGFibGUuaG9va3MucnVuKHRoaXMuaW5zdGFuY2UsICdiZWZvcmVSZW1vdmVSb3cnLCBpbmRleCwgYW1vdW50KTtcblxuICBpZiAoYWN0aW9uV2FzTm90Q2FuY2VsbGVkID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkYXRhID0gdGhpcy5kYXRhU291cmNlO1xuICB2YXIgbmV3RGF0YSA9IGRhdGEuZmlsdGVyKGZ1bmN0aW9uKHJvdywgaW5kZXgpIHtcbiAgICByZXR1cm4gbG9naWNSb3dzLmluZGV4T2YoaW5kZXgpID09IC0xO1xuICB9KTtcblxuICBkYXRhLmxlbmd0aCA9IDA7XG4gIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGRhdGEsIG5ld0RhdGEpO1xuXG4gIEhhbmRzb250YWJsZS5ob29rcy5ydW4odGhpcy5pbnN0YW5jZSwgJ2FmdGVyUmVtb3ZlUm93JywgaW5kZXgsIGFtb3VudCk7XG5cbiAgdGhpcy5pbnN0YW5jZS5mb3JjZUZ1bGxSZW5kZXIgPSB0cnVlOyAvL3VzZWQgd2hlbiBkYXRhIHdhcyBjaGFuZ2VkXG59O1xuXG4vKipcbiAqIFJlbW92ZXMgY29sdW1uIGZyb20gdGhlIGRhdGEgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IFtpbmRleF0gSW5kZXggb2YgdGhlIGNvbHVtbiB0byBiZSByZW1vdmVkLiBJZiBub3QgcHJvdmlkZWQsIHRoZSBsYXN0IGNvbHVtbiB3aWxsIGJlIHJlbW92ZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBbYW1vdW50XSBBbW91bnQgb2YgdGhlIGNvbHVtbnMgdG8gYmUgcmVtb3ZlZC4gSWYgbm90IHByb3ZpZGVkLCBvbmUgY29sdW1uIHdpbGwgYmUgcmVtb3ZlZFxuICogQGZpcmVzIEhvb2tzI2JlZm9yZVJlbW92ZUNvbFxuICogQGZpcmVzIEhvb2tzI2FmdGVyUmVtb3ZlQ29sXG4gKi9cbkRhdGFNYXAucHJvdG90eXBlLnJlbW92ZUNvbCA9IGZ1bmN0aW9uIChpbmRleCwgYW1vdW50KSB7XG4gIGlmICh0aGlzLmluc3RhbmNlLmRhdGFUeXBlID09PSAnb2JqZWN0JyB8fCB0aGlzLmluc3RhbmNlLmdldFNldHRpbmdzKCkuY29sdW1ucykge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCByZW1vdmUgY29sdW1uIHdpdGggb2JqZWN0IGRhdGEgc291cmNlIG9yIGNvbHVtbnMgb3B0aW9uIHNwZWNpZmllZFwiKTtcbiAgfVxuICBpZiAoIWFtb3VudCkge1xuICAgIGFtb3VudCA9IDE7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHtcbiAgICBpbmRleCA9IC1hbW91bnQ7XG4gIH1cblxuICBpbmRleCA9ICh0aGlzLmluc3RhbmNlLmNvdW50Q29scygpICsgaW5kZXgpICUgdGhpcy5pbnN0YW5jZS5jb3VudENvbHMoKTtcblxuICB2YXIgYWN0aW9uV2FzTm90Q2FuY2VsbGVkID0gSGFuZHNvbnRhYmxlLmhvb2tzLnJ1bih0aGlzLmluc3RhbmNlLCAnYmVmb3JlUmVtb3ZlQ29sJywgaW5kZXgsIGFtb3VudCk7XG5cbiAgaWYgKGFjdGlvbldhc05vdENhbmNlbGxlZCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGF0YSA9IHRoaXMuZGF0YVNvdXJjZTtcbiAgZm9yICh2YXIgciA9IDAsIHJsZW4gPSB0aGlzLmluc3RhbmNlLmNvdW50Um93cygpOyByIDwgcmxlbjsgcisrKSB7XG4gICAgZGF0YVtyXS5zcGxpY2UoaW5kZXgsIGFtb3VudCk7XG4gIH1cbiAgdGhpcy5wcml2LmNvbHVtblNldHRpbmdzLnNwbGljZShpbmRleCwgYW1vdW50KTtcblxuICBIYW5kc29udGFibGUuaG9va3MucnVuKHRoaXMuaW5zdGFuY2UsICdhZnRlclJlbW92ZUNvbCcsIGluZGV4LCBhbW91bnQpO1xuICB0aGlzLmluc3RhbmNlLmZvcmNlRnVsbFJlbmRlciA9IHRydWU7IC8vdXNlZCB3aGVuIGRhdGEgd2FzIGNoYW5nZWRcbn07XG5cbi8qKlxuICogQWRkL1JlbW92ZXMgZGF0YSBmcm9tIHRoZSBjb2x1bW4uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvbCBJbmRleCBvZiBjb2x1bW4gaW4gd2hpY2ggZG8geW91IHdhbnQgdG8gZG8gc3BsaWNlXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgY2hhbmdpbmcgdGhlIGFycmF5LiBJZiBuZWdhdGl2ZSwgd2lsbCBiZWdpbiB0aGF0IG1hbnkgZWxlbWVudHMgZnJvbSB0aGUgZW5kXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IEFuIGludGVnZXIgaW5kaWNhdGluZyB0aGUgbnVtYmVyIG9mIG9sZCBhcnJheSBlbGVtZW50cyB0byByZW1vdmUuIElmIGFtb3VudCBpcyAwLCBubyBlbGVtZW50cyBhcmUgcmVtb3ZlZFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHJlbW92ZWQgcG9ydGlvbiBvZiBjb2x1bW5zXG4gKi9cbkRhdGFNYXAucHJvdG90eXBlLnNwbGljZUNvbCA9IGZ1bmN0aW9uIChjb2wsIGluZGV4LCBhbW91bnQvKiwgZWxlbWVudHMuLi4qLykge1xuICB2YXIgZWxlbWVudHMgPSA0IDw9IGFyZ3VtZW50cy5sZW5ndGggPyBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMykgOiBbXTtcblxuICB2YXIgY29sRGF0YSA9IHRoaXMuaW5zdGFuY2UuZ2V0RGF0YUF0Q29sKGNvbCk7XG4gIHZhciByZW1vdmVkID0gY29sRGF0YS5zbGljZShpbmRleCwgaW5kZXggKyBhbW91bnQpO1xuICB2YXIgYWZ0ZXIgPSBjb2xEYXRhLnNsaWNlKGluZGV4ICsgYW1vdW50KTtcblxuICBleHRlbmRBcnJheShlbGVtZW50cywgYWZ0ZXIpO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgYW1vdW50KSB7XG4gICAgZWxlbWVudHMucHVzaChudWxsKTsgLy9hZGQgbnVsbCBpbiBwbGFjZSBvZiByZW1vdmVkIGVsZW1lbnRzXG4gICAgaSsrO1xuICB9XG4gIHRvMmRBcnJheShlbGVtZW50cyk7XG4gIHRoaXMuaW5zdGFuY2UucG9wdWxhdGVGcm9tQXJyYXkoaW5kZXgsIGNvbCwgZWxlbWVudHMsIG51bGwsIG51bGwsICdzcGxpY2VDb2wnKTtcblxuICByZXR1cm4gcmVtb3ZlZDtcbn07XG5cbi8qKlxuICogQWRkL1JlbW92ZXMgZGF0YSBmcm9tIHRoZSByb3cuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHJvdyBJbmRleCBvZiByb3cgaW4gd2hpY2ggZG8geW91IHdhbnQgdG8gZG8gc3BsaWNlXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgY2hhbmdpbmcgdGhlIGFycmF5LiBJZiBuZWdhdGl2ZSwgd2lsbCBiZWdpbiB0aGF0IG1hbnkgZWxlbWVudHMgZnJvbSB0aGUgZW5kXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IEFuIGludGVnZXIgaW5kaWNhdGluZyB0aGUgbnVtYmVyIG9mIG9sZCBhcnJheSBlbGVtZW50cyB0byByZW1vdmUuIElmIGFtb3VudCBpcyAwLCBubyBlbGVtZW50cyBhcmUgcmVtb3ZlZFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHJlbW92ZWQgcG9ydGlvbiBvZiByb3dzXG4gKi9cbkRhdGFNYXAucHJvdG90eXBlLnNwbGljZVJvdyA9IGZ1bmN0aW9uIChyb3csIGluZGV4LCBhbW91bnQvKiwgZWxlbWVudHMuLi4qLykge1xuICB2YXIgZWxlbWVudHMgPSA0IDw9IGFyZ3VtZW50cy5sZW5ndGggPyBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMykgOiBbXTtcblxuICB2YXIgcm93RGF0YSA9IHRoaXMuaW5zdGFuY2UuZ2V0U291cmNlRGF0YUF0Um93KHJvdyk7XG4gIHZhciByZW1vdmVkID0gcm93RGF0YS5zbGljZShpbmRleCwgaW5kZXggKyBhbW91bnQpO1xuICB2YXIgYWZ0ZXIgPSByb3dEYXRhLnNsaWNlKGluZGV4ICsgYW1vdW50KTtcblxuICBleHRlbmRBcnJheShlbGVtZW50cywgYWZ0ZXIpO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgYW1vdW50KSB7XG4gICAgZWxlbWVudHMucHVzaChudWxsKTsgLy9hZGQgbnVsbCBpbiBwbGFjZSBvZiByZW1vdmVkIGVsZW1lbnRzXG4gICAgaSsrO1xuICB9XG4gIHRoaXMuaW5zdGFuY2UucG9wdWxhdGVGcm9tQXJyYXkocm93LCBpbmRleCwgW2VsZW1lbnRzXSwgbnVsbCwgbnVsbCwgJ3NwbGljZVJvdycpO1xuXG4gIHJldHVybiByZW1vdmVkO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHNpbmdsZSB2YWx1ZSBmcm9tIHRoZSBkYXRhIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSByb3dcbiAqIEBwYXJhbSB7TnVtYmVyfSBwcm9wXG4gKi9cbkRhdGFNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChyb3csIHByb3ApIHtcbiAgcm93ID0gSGFuZHNvbnRhYmxlLmhvb2tzLnJ1bih0aGlzLmluc3RhbmNlLCAnbW9kaWZ5Um93Jywgcm93KTtcblxuICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnICYmIHByb3AuaW5kZXhPZignLicpID4gLTEpIHtcbiAgICB2YXIgc2xpY2VkID0gcHJvcC5zcGxpdChcIi5cIik7XG4gICAgdmFyIG91dCA9IHRoaXMuZGF0YVNvdXJjZVtyb3ddO1xuICAgIGlmICghb3V0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsZW4gPSBzbGljZWQubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBvdXQgPSBvdXRbc2xpY2VkW2ldXTtcbiAgICAgIGlmICh0eXBlb2Ygb3V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8qKlxuICAgICAqICBhbGxvd3MgZm9yIGludGVyYWN0aW5nIHdpdGggY29tcGxleCBzdHJ1Y3R1cmVzLCBmb3IgZXhhbXBsZVxuICAgICAqICBkMy9qUXVlcnkgZ2V0dGVyL3NldHRlciBwcm9wZXJ0aWVzOlxuICAgICAqXG4gICAgICogICAge2NvbHVtbnM6IFt7XG4gICAgICogICAgICBkYXRhOiBmdW5jdGlvbihyb3csIHZhbHVlKXtcbiAgICAgKiAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSl7XG4gICAgICogICAgICAgICAgcmV0dXJuIHJvdy5wcm9wZXJ0eSgpO1xuICAgICAqICAgICAgICB9XG4gICAgICogICAgICAgIHJvdy5wcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICogICAgICB9XG4gICAgICogICAgfV19XG4gICAgICovXG4gICAgcmV0dXJuIHByb3AodGhpcy5kYXRhU291cmNlLnNsaWNlKFxuICAgICAgcm93LFxuICAgICAgcm93ICsgMSlbMF0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2Vbcm93XSA/IHRoaXMuZGF0YVNvdXJjZVtyb3ddW3Byb3BdIDogbnVsbDtcbiAgfVxufTtcblxudmFyIGNvcHlhYmxlTG9va3VwID0gY2VsbE1ldGhvZExvb2t1cEZhY3RvcnkoJ2NvcHlhYmxlJywgZmFsc2UpO1xuXG4vKipcbiAqIFJldHVybnMgc2luZ2xlIHZhbHVlIGZyb20gdGhlIGRhdGEgYXJyYXkgKGludGVuZGVkIGZvciBjbGlwYm9hcmQgY29weSB0byBhbiBleHRlcm5hbCBhcHBsaWNhdGlvbikuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHJvd1xuICogQHBhcmFtIHtOdW1iZXJ9IHByb3BcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkRhdGFNYXAucHJvdG90eXBlLmdldENvcHlhYmxlID0gZnVuY3Rpb24gKHJvdywgcHJvcCkge1xuICBpZiAoY29weWFibGVMb29rdXAuY2FsbCh0aGlzLmluc3RhbmNlLCByb3csIHRoaXMucHJvcFRvQ29sKHByb3ApKSkge1xuICAgIHJldHVybiB0aGlzLmdldChyb3csIHByb3ApO1xuICB9XG4gIHJldHVybiAnJztcbn07XG5cbi8qKlxuICogU2F2ZXMgc2luZ2xlIHZhbHVlIHRvIHRoZSBkYXRhIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSByb3dcbiAqIEBwYXJhbSB7TnVtYmVyfSBwcm9wXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc291cmNlXSBTb3VyY2Ugb2YgaG9vayBydW5uZXIuXG4gKi9cbkRhdGFNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChyb3csIHByb3AsIHZhbHVlLCBzb3VyY2UpIHtcbiAgcm93ID0gSGFuZHNvbnRhYmxlLmhvb2tzLnJ1bih0aGlzLmluc3RhbmNlLCAnbW9kaWZ5Um93Jywgcm93LCBzb3VyY2UgfHwgXCJkYXRhbWFwR2V0XCIpO1xuXG4gIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycgJiYgcHJvcC5pbmRleE9mKCcuJykgPiAtMSkge1xuICAgIHZhciBzbGljZWQgPSBwcm9wLnNwbGl0KFwiLlwiKTtcbiAgICB2YXIgb3V0ID0gdGhpcy5kYXRhU291cmNlW3Jvd107XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsZW4gPSBzbGljZWQubGVuZ3RoIC0gMTsgaSA8IGlsZW47IGkrKykge1xuXG4gICAgICBpZiAodHlwZW9mIG91dFtzbGljZWRbaV1dID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvdXRbc2xpY2VkW2ldXSA9IHt9O1xuICAgICAgfVxuICAgICAgb3V0ID0gb3V0W3NsaWNlZFtpXV07XG4gICAgfVxuICAgIG91dFtzbGljZWRbaV1dID0gdmFsdWU7XG5cbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8qIHNlZSB0aGUgYGZ1bmN0aW9uYCBoYW5kbGVyIGluIGBnZXRgICovXG4gICAgcHJvcCh0aGlzLmRhdGFTb3VyY2Uuc2xpY2Uocm93LCByb3cgKyAxKVswXSwgdmFsdWUpO1xuXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kYXRhU291cmNlW3Jvd11bcHJvcF0gPSB2YWx1ZTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGlzIHJpZGljdWxvdXMgcGllY2Ugb2YgY29kZSBtYXBzIHJvd3MgSWQgdGhhdCBhcmUgcHJlc2VudCBpbiB0YWJsZSBkYXRhIHRvIHRob3NlIGRpc3BsYXllZCBmb3IgdXNlci5cbiAqIFRoZSB0cmljayBpcywgdGhlIHBoeXNpY2FsIHJvdyBpZCAoc3RvcmVkIGluIHNldHRpbmdzLmRhdGEpIGlzIG5vdCBuZWNlc3NhcnkgdGhlIHNhbWVcbiAqIGFzIHRoZSBsb2dpY2FsIChkaXNwbGF5ZWQpIHJvdyBpZCAoZS5nLiB3aGVuIHNvcnRpbmcgaXMgYXBwbGllZCkuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50XG4gKiBAZmlyZXMgSG9va3MjbW9kaWZ5Um93XG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG5EYXRhTWFwLnByb3RvdHlwZS5waHlzaWNhbFJvd3NUb0xvZ2ljYWwgPSBmdW5jdGlvbiAoaW5kZXgsIGFtb3VudCkge1xuICB2YXIgdG90YWxSb3dzID0gdGhpcy5pbnN0YW5jZS5jb3VudFJvd3MoKTtcbiAgdmFyIHBoeXNpY1JvdyA9ICh0b3RhbFJvd3MgKyBpbmRleCkgJSB0b3RhbFJvd3M7XG4gIHZhciBsb2dpY1Jvd3MgPSBbXTtcbiAgdmFyIHJvd3NUb1JlbW92ZSA9IGFtb3VudDtcbiAgdmFyIHJvdztcblxuICB3aGlsZSAocGh5c2ljUm93IDwgdG90YWxSb3dzICYmIHJvd3NUb1JlbW92ZSkge1xuICAgIHJvdyA9IEhhbmRzb250YWJsZS5ob29rcy5ydW4odGhpcy5pbnN0YW5jZSwgJ21vZGlmeVJvdycsIHBoeXNpY1Jvdyk7XG4gICAgbG9naWNSb3dzLnB1c2gocm93KTtcblxuICAgIHJvd3NUb1JlbW92ZS0tO1xuICAgIHBoeXNpY1JvdysrO1xuICB9XG5cbiAgcmV0dXJuIGxvZ2ljUm93cztcbn07XG5cbi8qKlxuICogQ2xlYXJzIHRoZSBkYXRhIGFycmF5LlxuICovXG5EYXRhTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgciA9IDA7IHIgPCB0aGlzLmluc3RhbmNlLmNvdW50Um93cygpOyByKyspIHtcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IHRoaXMuaW5zdGFuY2UuY291bnRDb2xzKCk7IGMrKykge1xuICAgICAgdGhpcy5zZXQociwgdGhpcy5jb2xUb1Byb3AoYyksICcnKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGF0YSBhcnJheS5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbkRhdGFNYXAucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBkYXRhIHJhbmdlIGFzIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhcnRdIFN0YXJ0IHNlbGVjdGlvbiBwb3NpdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtlbmRdIEVuZCBzZWxlY3Rpb24gcG9zaXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBkZXN0aW5hdGlvbiBEZXN0aW5hdGlvbiBvZiBkYXRhbWFwLmdldFxuICogQHJldHVybnMge0FycmF5fVxuICovXG5EYXRhTWFwLnByb3RvdHlwZS5nZXRSYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBkZXN0aW5hdGlvbikge1xuICB2YXIgciwgcmxlbiwgYywgY2xlbiwgb3V0cHV0ID0gW10sXG4gICAgcm93O1xuXG4gIHZhciBnZXRGbiA9IGRlc3RpbmF0aW9uID09PSB0aGlzLkRFU1RJTkFUSU9OX0NMSVBCT0FSRF9HRU5FUkFUT1IgPyB0aGlzLmdldENvcHlhYmxlIDogdGhpcy5nZXQ7XG5cbiAgcmxlbiA9IE1hdGgubWF4KHN0YXJ0LnJvdywgZW5kLnJvdyk7XG4gIGNsZW4gPSBNYXRoLm1heChzdGFydC5jb2wsIGVuZC5jb2wpO1xuXG4gIGZvciAociA9IE1hdGgubWluKHN0YXJ0LnJvdywgZW5kLnJvdyk7IHIgPD0gcmxlbjsgcisrKSB7XG4gICAgcm93ID0gW107XG4gICAgZm9yIChjID0gTWF0aC5taW4oc3RhcnQuY29sLCBlbmQuY29sKTsgYyA8PSBjbGVuOyBjKyspIHtcbiAgICAgIHJvdy5wdXNoKGdldEZuLmNhbGwodGhpcywgciwgdGhpcy5jb2xUb1Byb3AoYykpKTtcbiAgICB9XG4gICAgb3V0cHV0LnB1c2gocm93KTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybiBkYXRhIGFzIHRleHQgKHRhYiBzZXBhcmF0ZWQgY29sdW1ucykuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFydF0gU3RhcnQgc2VsZWN0aW9uIHBvc2l0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW2VuZF0gRW5kIHNlbGVjdGlvbiBwb3NpdGlvblxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuRGF0YU1hcC5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHJldHVybiBTaGVldENsaXAuc3RyaW5naWZ5KHRoaXMuZ2V0UmFuZ2Uoc3RhcnQsIGVuZCwgdGhpcy5ERVNUSU5BVElPTl9SRU5ERVJFUikpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gZGF0YSBhcyBjb3B5YWJsZSB0ZXh0ICh0YWIgc2VwYXJhdGVkIGNvbHVtbnMgaW50ZW5kZWQgZm9yIGNsaXBib2FyZCBjb3B5IHRvIGFuIGV4dGVybmFsIGFwcGxpY2F0aW9uKS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YXJ0XSBTdGFydCBzZWxlY3Rpb24gcG9zaXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbZW5kXSBFbmQgc2VsZWN0aW9uIHBvc2l0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5EYXRhTWFwLnByb3RvdHlwZS5nZXRDb3B5YWJsZVRleHQgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICByZXR1cm4gU2hlZXRDbGlwLnN0cmluZ2lmeSh0aGlzLmdldFJhbmdlKHN0YXJ0LCBlbmQsIHRoaXMuREVTVElOQVRJT05fQ0xJUEJPQVJEX0dFTkVSQVRPUikpO1xufTtcblxuZXhwb3J0IHtEYXRhTWFwfTtcblxuLy8gU3VwcG9ydCBmb3Igb2xkZXIgaG90IHZlcnNpb25zXG5IYW5kc29udGFibGUuRGF0YU1hcCA9IERhdGFNYXA7XG4iLCJcbmltcG9ydCB7V2Fsa29udGFibGVDZWxsQ29vcmRzfSBmcm9tICcuLzNyZHBhcnR5L3dhbGtvbnRhYmxlL3NyYy9jZWxsL2Nvb3Jkcyc7XG5pbXBvcnQge0tFWV9DT0RFUywgaXNNZXRhS2V5LCBpc0N0cmxLZXl9IGZyb20gJy4vaGVscGVycy91bmljb2RlJztcbmltcG9ydCB7c3RvcFByb3BhZ2F0aW9uLCBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24sIGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkfSBmcm9tICcuL2hlbHBlcnMvZG9tL2V2ZW50JztcbmltcG9ydCB7Z2V0RWRpdG9yfSBmcm9tICcuL2VkaXRvcnMnO1xuaW1wb3J0IHtldmVudE1hbmFnZXIgYXMgZXZlbnRNYW5hZ2VyT2JqZWN0fSBmcm9tICcuL2V2ZW50TWFuYWdlcic7XG5cbmV4cG9ydCB7RWRpdG9yTWFuYWdlcn07XG5cbi8vIHN1cHBvcnQgZm9yIG9sZGVyIHZlcnNpb25zIG9mIEhhbmRzb250YWJsZVxuSGFuZHNvbnRhYmxlLkVkaXRvck1hbmFnZXIgPSBFZGl0b3JNYW5hZ2VyO1xuXG5mdW5jdGlvbiBFZGl0b3JNYW5hZ2VyKGluc3RhbmNlLCBwcml2LCBzZWxlY3Rpb24pe1xuICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgIGRlc3Ryb3llZCA9IGZhbHNlLFxuICAgIGV2ZW50TWFuYWdlcixcbiAgICBhY3RpdmVFZGl0b3I7XG5cbiAgZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyT2JqZWN0KGluc3RhbmNlKTtcblxuICBmdW5jdGlvbiBtb3ZlU2VsZWN0aW9uQWZ0ZXJFbnRlcihzaGlmdEtleSkge1xuICAgIHZhciBlbnRlck1vdmVzID0gdHlwZW9mIHByaXYuc2V0dGluZ3MuZW50ZXJNb3ZlcyA9PT0gJ2Z1bmN0aW9uJyA/IHByaXYuc2V0dGluZ3MuZW50ZXJNb3ZlcyhldmVudCkgOiBwcml2LnNldHRpbmdzLmVudGVyTW92ZXM7XG5cbiAgICBpZiAoc2hpZnRLZXkpIHtcbiAgICAgIC8vIG1vdmUgc2VsZWN0aW9uIHVwXG4gICAgICBzZWxlY3Rpb24udHJhbnNmb3JtU3RhcnQoLWVudGVyTW92ZXMucm93LCAtIGVudGVyTW92ZXMuY29sKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtb3ZlIHNlbGVjdGlvbiBkb3duIChhZGQgYSBuZXcgcm93IGlmIG5lZWRlZClcbiAgICAgIHNlbGVjdGlvbi50cmFuc2Zvcm1TdGFydChlbnRlck1vdmVzLnJvdywgZW50ZXJNb3Zlcy5jb2wsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdmVTZWxlY3Rpb25VcChzaGlmdEtleSkge1xuICAgIGlmIChzaGlmdEtleSkge1xuICAgICAgc2VsZWN0aW9uLnRyYW5zZm9ybUVuZCgtMSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGlvbi50cmFuc2Zvcm1TdGFydCgtMSwgMCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbW92ZVNlbGVjdGlvbkRvd24oc2hpZnRLZXkpIHtcbiAgICBpZiAoc2hpZnRLZXkpIHtcbiAgICAgIC8vIGV4cGFuZGluZyBzZWxlY3Rpb24gZG93biB3aXRoIHNoaWZ0XG4gICAgICBzZWxlY3Rpb24udHJhbnNmb3JtRW5kKDEsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtb3ZlIHNlbGVjdGlvbiBkb3duXG4gICAgICBzZWxlY3Rpb24udHJhbnNmb3JtU3RhcnQoMSwgMCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbW92ZVNlbGVjdGlvblJpZ2h0KHNoaWZ0S2V5KSB7XG4gICAgaWYgKHNoaWZ0S2V5KSB7XG4gICAgICBzZWxlY3Rpb24udHJhbnNmb3JtRW5kKDAsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3Rpb24udHJhbnNmb3JtU3RhcnQoMCwgMSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbW92ZVNlbGVjdGlvbkxlZnQoc2hpZnRLZXkpIHtcbiAgICBpZiAoc2hpZnRLZXkpIHtcbiAgICAgIHNlbGVjdGlvbi50cmFuc2Zvcm1FbmQoMCwgLSAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0aW9uLnRyYW5zZm9ybVN0YXJ0KDAsIC0gMSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50KSB7XG4gICAgdmFyIGN0cmxEb3duLCByYW5nZU1vZGlmaWVyO1xuXG4gICAgaWYgKCFpbnN0YW5jZS5pc0xpc3RlbmluZygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIEhhbmRzb250YWJsZS5ob29rcy5ydW4oaW5zdGFuY2UsICdiZWZvcmVLZXlEb3duJywgZXZlbnQpO1xuXG4gICAgaWYgKGRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHByaXYubGFzdEtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuXG4gICAgaWYgKCFzZWxlY3Rpb24uaXNTZWxlY3RlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGNhdGNoIENUUkwgYnV0IG5vdCByaWdodCBBTFQgKHdoaWNoIGluIHNvbWUgc3lzdGVtcyB0cmlnZ2VycyBBTFQrQ1RSTClcbiAgICBjdHJsRG93biA9IChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpICYmICFldmVudC5hbHRLZXk7XG5cbiAgICBpZiAoYWN0aXZlRWRpdG9yICYmICFhY3RpdmVFZGl0b3IuaXNXYWl0aW5nKCkpIHtcbiAgICAgIGlmICghaXNNZXRhS2V5KGV2ZW50LmtleUNvZGUpICYmICFpc0N0cmxLZXkoZXZlbnQua2V5Q29kZSkgJiYgIWN0cmxEb3duICYmICFfdGhpcy5pc0VkaXRvck9wZW5lZCgpKSB7XG4gICAgICAgIF90aGlzLm9wZW5FZGl0b3IoXCJcIiwgZXZlbnQpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmFuZ2VNb2RpZmllciA9IGV2ZW50LnNoaWZ0S2V5ID8gc2VsZWN0aW9uLnNldFJhbmdlRW5kIDogc2VsZWN0aW9uLnNldFJhbmdlU3RhcnQ7XG5cbiAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcblxuICAgICAgY2FzZSBLRVlfQ09ERVMuQTpcbiAgICAgICAgaWYgKCFfdGhpcy5pc0VkaXRvck9wZW5lZCgpICYmIGN0cmxEb3duKSB7XG4gICAgICAgICAgc2VsZWN0aW9uLnNlbGVjdEFsbCgpO1xuXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBzdG9wUHJvcGFnYXRpb24oZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEtFWV9DT0RFUy5BUlJPV19VUDpcbiAgICAgICAgaWYgKF90aGlzLmlzRWRpdG9yT3BlbmVkKCkgJiYgIWFjdGl2ZUVkaXRvci5pc1dhaXRpbmcoKSkge1xuICAgICAgICAgIF90aGlzLmNsb3NlRWRpdG9yQW5kU2F2ZUNoYW5nZXMoY3RybERvd24pO1xuICAgICAgICB9XG4gICAgICAgIG1vdmVTZWxlY3Rpb25VcChldmVudC5zaGlmdEtleSk7XG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgc3RvcFByb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgS0VZX0NPREVTLkFSUk9XX0RPV046XG4gICAgICAgIGlmIChfdGhpcy5pc0VkaXRvck9wZW5lZCgpICYmICFhY3RpdmVFZGl0b3IuaXNXYWl0aW5nKCkpIHtcbiAgICAgICAgICBfdGhpcy5jbG9zZUVkaXRvckFuZFNhdmVDaGFuZ2VzKGN0cmxEb3duKTtcbiAgICAgICAgfVxuICAgICAgICBtb3ZlU2VsZWN0aW9uRG93bihldmVudC5zaGlmdEtleSk7XG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgc3RvcFByb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgS0VZX0NPREVTLkFSUk9XX1JJR0hUOlxuICAgICAgICBpZiAoX3RoaXMuaXNFZGl0b3JPcGVuZWQoKSAmJiAhYWN0aXZlRWRpdG9yLmlzV2FpdGluZygpKSB7XG4gICAgICAgICAgX3RoaXMuY2xvc2VFZGl0b3JBbmRTYXZlQ2hhbmdlcyhjdHJsRG93bik7XG4gICAgICAgIH1cbiAgICAgICAgbW92ZVNlbGVjdGlvblJpZ2h0KGV2ZW50LnNoaWZ0S2V5KTtcblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzdG9wUHJvcGFnYXRpb24oZXZlbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBLRVlfQ09ERVMuQVJST1dfTEVGVDpcbiAgICAgICAgaWYgKF90aGlzLmlzRWRpdG9yT3BlbmVkKCkgJiYgIWFjdGl2ZUVkaXRvci5pc1dhaXRpbmcoKSkge1xuICAgICAgICAgIF90aGlzLmNsb3NlRWRpdG9yQW5kU2F2ZUNoYW5nZXMoY3RybERvd24pO1xuICAgICAgICB9XG4gICAgICAgIG1vdmVTZWxlY3Rpb25MZWZ0KGV2ZW50LnNoaWZ0S2V5KTtcblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzdG9wUHJvcGFnYXRpb24oZXZlbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBLRVlfQ09ERVMuVEFCOlxuICAgICAgICB2YXIgdGFiTW92ZXMgPSB0eXBlb2YgcHJpdi5zZXR0aW5ncy50YWJNb3ZlcyA9PT0gJ2Z1bmN0aW9uJyA/IHByaXYuc2V0dGluZ3MudGFiTW92ZXMoZXZlbnQpIDogcHJpdi5zZXR0aW5ncy50YWJNb3ZlcztcblxuICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAvLyBtb3ZlIHNlbGVjdGlvbiBsZWZ0XG4gICAgICAgICAgc2VsZWN0aW9uLnRyYW5zZm9ybVN0YXJ0KC10YWJNb3Zlcy5yb3csIC10YWJNb3Zlcy5jb2wpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG1vdmUgc2VsZWN0aW9uIHJpZ2h0IChhZGQgYSBuZXcgY29sdW1uIGlmIG5lZWRlZClcbiAgICAgICAgICBzZWxlY3Rpb24udHJhbnNmb3JtU3RhcnQodGFiTW92ZXMucm93LCB0YWJNb3Zlcy5jb2wsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHN0b3BQcm9wYWdhdGlvbihldmVudCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEtFWV9DT0RFUy5CQUNLU1BBQ0U6XG4gICAgICBjYXNlIEtFWV9DT0RFUy5ERUxFVEU6XG4gICAgICAgIHNlbGVjdGlvbi5lbXB0eShldmVudCk7XG4gICAgICAgIF90aGlzLnByZXBhcmVFZGl0b3IoKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgS0VZX0NPREVTLkYyOlxuICAgICAgICAvKiBGMiAqL1xuICAgICAgICBfdGhpcy5vcGVuRWRpdG9yKG51bGwsIGV2ZW50KTtcblxuICAgICAgICBpZiAoYWN0aXZlRWRpdG9yKSB7XG4gICAgICAgICAgYWN0aXZlRWRpdG9yLmVuYWJsZUZ1bGxFZGl0TW9kZSgpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vcHJldmVudCBPcGVyYSBmcm9tIG9wZW5pbmcgJ0dvIHRvIFBhZ2UgZGlhbG9nJ1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBLRVlfQ09ERVMuRU5URVI6XG4gICAgICAgIC8qIHJldHVybi9lbnRlciAqL1xuICAgICAgICBpZiAoX3RoaXMuaXNFZGl0b3JPcGVuZWQoKSkge1xuXG4gICAgICAgICAgaWYgKGFjdGl2ZUVkaXRvciAmJiBhY3RpdmVFZGl0b3Iuc3RhdGUgIT09IEhhbmRzb250YWJsZS5FZGl0b3JTdGF0ZS5XQUlUSU5HKSB7XG4gICAgICAgICAgICBfdGhpcy5jbG9zZUVkaXRvckFuZFNhdmVDaGFuZ2VzKGN0cmxEb3duKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbW92ZVNlbGVjdGlvbkFmdGVyRW50ZXIoZXZlbnQuc2hpZnRLZXkpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGluc3RhbmNlLmdldFNldHRpbmdzKCkuZW50ZXJCZWdpbnNFZGl0aW5nKSB7XG4gICAgICAgICAgICBfdGhpcy5vcGVuRWRpdG9yKG51bGwsIGV2ZW50KTtcblxuICAgICAgICAgICAgaWYgKGFjdGl2ZUVkaXRvcikge1xuICAgICAgICAgICAgICBhY3RpdmVFZGl0b3IuZW5hYmxlRnVsbEVkaXRNb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vdmVTZWxlY3Rpb25BZnRlckVudGVyKGV2ZW50LnNoaWZ0S2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy9kb24ndCBhZGQgbmV3bGluZSB0byBmaWVsZFxuICAgICAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZXZlbnQpOyAvL3JlcXVpcmVkIGJ5IEhhbmRzb250YWJsZUVkaXRvclxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBLRVlfQ09ERVMuRVNDQVBFOlxuICAgICAgICBpZiAoX3RoaXMuaXNFZGl0b3JPcGVuZWQoKSkge1xuICAgICAgICAgIF90aGlzLmNsb3NlRWRpdG9yQW5kUmVzdG9yZU9yaWdpbmFsVmFsdWUoY3RybERvd24pO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEtFWV9DT0RFUy5IT01FOlxuICAgICAgICBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSB7XG4gICAgICAgICAgcmFuZ2VNb2RpZmllcihuZXcgV2Fsa29udGFibGVDZWxsQ29vcmRzKDAsIHByaXYuc2VsUmFuZ2UuZnJvbS5jb2wpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByYW5nZU1vZGlmaWVyKG5ldyBXYWxrb250YWJsZUNlbGxDb29yZHMocHJpdi5zZWxSYW5nZS5mcm9tLnJvdywgMCkpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vZG9uJ3Qgc2Nyb2xsIHRoZSB3aW5kb3dcbiAgICAgICAgc3RvcFByb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgS0VZX0NPREVTLkVORDpcbiAgICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xuICAgICAgICAgIHJhbmdlTW9kaWZpZXIobmV3IFdhbGtvbnRhYmxlQ2VsbENvb3JkcyhpbnN0YW5jZS5jb3VudFJvd3MoKSAtIDEsIHByaXYuc2VsUmFuZ2UuZnJvbS5jb2wpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByYW5nZU1vZGlmaWVyKG5ldyBXYWxrb250YWJsZUNlbGxDb29yZHMocHJpdi5zZWxSYW5nZS5mcm9tLnJvdywgaW5zdGFuY2UuY291bnRDb2xzKCkgLSAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy9kb24ndCBzY3JvbGwgdGhlIHdpbmRvd1xuICAgICAgICBzdG9wUHJvcGFnYXRpb24oZXZlbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBLRVlfQ09ERVMuUEFHRV9VUDpcbiAgICAgICAgc2VsZWN0aW9uLnRyYW5zZm9ybVN0YXJ0KC1pbnN0YW5jZS5jb3VudFZpc2libGVSb3dzKCksIDApO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvL2Rvbid0IHBhZ2UgdXAgdGhlIHdpbmRvd1xuICAgICAgICBzdG9wUHJvcGFnYXRpb24oZXZlbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBLRVlfQ09ERVMuUEFHRV9ET1dOOlxuICAgICAgICBzZWxlY3Rpb24udHJhbnNmb3JtU3RhcnQoaW5zdGFuY2UuY291bnRWaXNpYmxlUm93cygpLCAwKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy9kb24ndCBwYWdlIGRvd24gdGhlIHdpbmRvd1xuICAgICAgICBzdG9wUHJvcGFnYXRpb24oZXZlbnQpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIGluc3RhbmNlLmFkZEhvb2soJ2FmdGVyRG9jdW1lbnRLZXlEb3duJywgb25LZXlEb3duKTtcblxuICAgIGV2ZW50TWFuYWdlci5hZGRFdmVudExpc3RlbmVyKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJ2tleWRvd24nLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgaW5zdGFuY2UucnVuSG9va3MoJ2FmdGVyRG9jdW1lbnRLZXlEb3duJywgZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gb25EYmxDbGljayhldmVudCwgY29vcmRzLCBlbGVtKSB7XG4gICAgICAvLyBtYXkgYmUgVEQgb3IgVEhcbiAgICAgIGlmIChlbGVtLm5vZGVOYW1lID09IFwiVERcIikge1xuICAgICAgICBfdGhpcy5vcGVuRWRpdG9yKCk7XG5cbiAgICAgICAgaWYgKGFjdGl2ZUVkaXRvcikge1xuICAgICAgICAgIGFjdGl2ZUVkaXRvci5lbmFibGVGdWxsRWRpdE1vZGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpbnN0YW5jZS52aWV3Lnd0LnVwZGF0ZSgnb25DZWxsRGJsQ2xpY2snLCBvbkRibENsaWNrKTtcblxuICAgIGluc3RhbmNlLmFkZEhvb2soJ2FmdGVyRGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95IGN1cnJlbnQgZWRpdG9yLCBpZiBleGlzdHMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBkZXN0cm95RWRpdG9yXG4gICAqIEBtZW1iZXJvZiEgSGFuZHNvbnRhYmxlLkVkaXRvck1hbmFnZXIjXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmV2ZXJ0T3JpZ2luYWxcbiAgICovXG4gIHRoaXMuZGVzdHJveUVkaXRvciA9IGZ1bmN0aW9uKHJldmVydE9yaWdpbmFsKSB7XG4gICAgdGhpcy5jbG9zZUVkaXRvcihyZXZlcnRPcmlnaW5hbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhY3RpdmUgZWRpdG9yLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gZ2V0QWN0aXZlRWRpdG9yXG4gICAqIEBtZW1iZXJvZiEgSGFuZHNvbnRhYmxlLkVkaXRvck1hbmFnZXIjXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgdGhpcy5nZXRBY3RpdmVFZGl0b3IgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYWN0aXZlRWRpdG9yO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcmVwYXJlIHRleHQgaW5wdXQgdG8gYmUgZGlzcGxheWVkIGF0IGdpdmVuIGdyaWQgY2VsbC5cbiAgICpcbiAgICogQGZ1bmN0aW9uIHByZXBhcmVFZGl0b3JcbiAgICogQG1lbWJlcm9mISBIYW5kc29udGFibGUuRWRpdG9yTWFuYWdlciNcbiAgICovXG4gIHRoaXMucHJlcGFyZUVkaXRvciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByb3csIGNvbCwgcHJvcCwgdGQsIG9yaWdpbmFsVmFsdWUsIGNlbGxQcm9wZXJ0aWVzLCBlZGl0b3JDbGFzcztcblxuICAgIGlmIChhY3RpdmVFZGl0b3IgJiYgYWN0aXZlRWRpdG9yLmlzV2FpdGluZygpKSB7XG4gICAgICB0aGlzLmNsb3NlRWRpdG9yKGZhbHNlLCBmYWxzZSwgZnVuY3Rpb24oZGF0YVNhdmVkKSB7XG4gICAgICAgIGlmIChkYXRhU2F2ZWQpIHtcbiAgICAgICAgICBfdGhpcy5wcmVwYXJlRWRpdG9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJvdyA9IHByaXYuc2VsUmFuZ2UuaGlnaGxpZ2h0LnJvdztcbiAgICBjb2wgPSBwcml2LnNlbFJhbmdlLmhpZ2hsaWdodC5jb2w7XG4gICAgcHJvcCA9IGluc3RhbmNlLmNvbFRvUHJvcChjb2wpO1xuICAgIHRkID0gaW5zdGFuY2UuZ2V0Q2VsbChyb3csIGNvbCk7XG4gICAgb3JpZ2luYWxWYWx1ZSA9IGluc3RhbmNlLmdldERhdGFBdENlbGwocm93LCBjb2wpO1xuICAgIGNlbGxQcm9wZXJ0aWVzID0gaW5zdGFuY2UuZ2V0Q2VsbE1ldGEocm93LCBjb2wpO1xuICAgIGVkaXRvckNsYXNzID0gaW5zdGFuY2UuZ2V0Q2VsbEVkaXRvcihjZWxsUHJvcGVydGllcyk7XG5cbiAgICBpZiAoZWRpdG9yQ2xhc3MpIHtcbiAgICAgIGFjdGl2ZUVkaXRvciA9IEhhbmRzb250YWJsZS5lZGl0b3JzLmdldEVkaXRvcihlZGl0b3JDbGFzcywgaW5zdGFuY2UpO1xuICAgICAgYWN0aXZlRWRpdG9yLnByZXBhcmUocm93LCBjb2wsIHByb3AsIHRkLCBvcmlnaW5hbFZhbHVlLCBjZWxsUHJvcGVydGllcyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgYWN0aXZlRWRpdG9yID0gdm9pZCAwO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaXMgZWRpdG9yIGlzIG9wZW5lZC9zaG93ZWQuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBpc0VkaXRvck9wZW5lZFxuICAgKiBAbWVtYmVyb2YhIEhhbmRzb250YWJsZS5FZGl0b3JNYW5hZ2VyI1xuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIHRoaXMuaXNFZGl0b3JPcGVuZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYWN0aXZlRWRpdG9yICYmIGFjdGl2ZUVkaXRvci5pc09wZW5lZCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBPcGVuIGVkaXRvciB3aXRoIGluaXRpYWwgdmFsdWUuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBvcGVuRWRpdG9yXG4gICAqIEBtZW1iZXJvZiEgSGFuZHNvbnRhYmxlLkVkaXRvck1hbmFnZXIjXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbml0aWFsVmFsdWVcbiAgICogQHBhcmFtIHtET01FdmVudH0gZXZlbnRcbiAgICovXG4gIHRoaXMub3BlbkVkaXRvciA9IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUsIGV2ZW50KSB7XG4gICAgaWYgKGFjdGl2ZUVkaXRvciAmJiAhYWN0aXZlRWRpdG9yLmNlbGxQcm9wZXJ0aWVzLnJlYWRPbmx5KSB7XG4gICAgICBhY3RpdmVFZGl0b3IuYmVnaW5FZGl0aW5nKGluaXRpYWxWYWx1ZSwgZXZlbnQpO1xuICAgIH0gZWxzZSBpZiAoYWN0aXZlRWRpdG9yICYmIGFjdGl2ZUVkaXRvci5jZWxsUHJvcGVydGllcy5yZWFkT25seSkge1xuXG4gICAgICAvLyBtb3ZlIHRoZSBzZWxlY3Rpb24gYWZ0ZXIgb3BlbmluZyB0aGUgZWRpdG9yIHdpdGggRU5URVIga2V5XG4gICAgICBpZiAoZXZlbnQgJiYgZXZlbnQua2V5Q29kZSA9PT0gS0VZX0NPREVTLkVOVEVSKSB7XG4gICAgICAgIG1vdmVTZWxlY3Rpb25BZnRlckVudGVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDbG9zZSBlZGl0b3IsIGZpbmlzaCBlZGl0aW5nIGNlbGwuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBjbG9zZUVkaXRvclxuICAgKiBAbWVtYmVyb2YhIEhhbmRzb250YWJsZS5FZGl0b3JNYW5hZ2VyI1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlc3RvcmVPcmlnaW5hbFZhbHVlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2N0cmxEb3duXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gICAqL1xuICB0aGlzLmNsb3NlRWRpdG9yID0gZnVuY3Rpb24ocmVzdG9yZU9yaWdpbmFsVmFsdWUsIGN0cmxEb3duLCBjYWxsYmFjaykge1xuICAgIGlmICghYWN0aXZlRWRpdG9yKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhY3RpdmVFZGl0b3IuZmluaXNoRWRpdGluZyhyZXN0b3JlT3JpZ2luYWxWYWx1ZSwgY3RybERvd24sIGNhbGxiYWNrKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENsb3NlIGVkaXRvciBhbmQgc2F2ZSBjaGFuZ2VzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gY2xvc2VFZGl0b3JBbmRTYXZlQ2hhbmdlc1xuICAgKiBAbWVtYmVyb2YhIEhhbmRzb250YWJsZS5FZGl0b3JNYW5hZ2VyI1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGN0cmxEb3duXG4gICAqL1xuICB0aGlzLmNsb3NlRWRpdG9yQW5kU2F2ZUNoYW5nZXMgPSBmdW5jdGlvbihjdHJsRG93bikge1xuICAgIHJldHVybiB0aGlzLmNsb3NlRWRpdG9yKGZhbHNlLCBjdHJsRG93bik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsb3NlIGVkaXRvciBhbmQgcmVzdG9yZSBvcmlnaW5hbCB2YWx1ZS5cbiAgICpcbiAgICogQGZ1bmN0aW9uIGNsb3NlRWRpdG9yQW5kUmVzdG9yZU9yaWdpbmFsVmFsdWVcbiAgICogQG1lbWJlcm9mISBIYW5kc29udGFibGUuRWRpdG9yTWFuYWdlciNcbiAgICogQHBhcmFtIHtCb29sZWFufSBjdHJsRG93blxuICAgKi9cbiAgdGhpcy5jbG9zZUVkaXRvckFuZFJlc3RvcmVPcmlnaW5hbFZhbHVlID0gZnVuY3Rpb24oY3RybERvd24pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9zZUVkaXRvcih0cnVlLCBjdHJsRG93bik7XG4gIH07XG5cbiAgaW5pdCgpO1xufVxuIiwiLyoqXG4gKiBVdGlsaXR5IHRvIHJlZ2lzdGVyIGVkaXRvcnMgYW5kIGNvbW1vbiBuYW1lc3BhY2UgZm9yIGtlZXBpbmcgcmVmZXJlbmNlIHRvIGFsbCBlZGl0b3IgY2xhc3Nlc1xuICovXG5cbmltcG9ydCB7dG9VcHBlckNhc2VGaXJzdH0gZnJvbSAnLi9oZWxwZXJzL3N0cmluZyc7XG5cbmV4cG9ydCB7cmVnaXN0ZXJFZGl0b3IsIGdldEVkaXRvciwgaGFzRWRpdG9yLCBnZXRFZGl0b3JDb25zdHJ1Y3Rvcn07XG5cbnZhclxuICByZWdpc3RlcmVkRWRpdG9yTmFtZXMgPSB7fSxcbiAgcmVnaXN0ZXJlZEVkaXRvckNsYXNzZXMgPSBuZXcgV2Vha01hcCgpO1xuXG4vLyBzdXBwb3J0IGZvciBvbGRlciB2ZXJzaW9ucyBvZiBIYW5kc29udGFibGVcbkhhbmRzb250YWJsZS5lZGl0b3JzID0gSGFuZHNvbnRhYmxlLmVkaXRvcnMgfHwge307XG5IYW5kc29udGFibGUuZWRpdG9ycy5yZWdpc3RlckVkaXRvciA9IHJlZ2lzdGVyRWRpdG9yO1xuSGFuZHNvbnRhYmxlLmVkaXRvcnMuZ2V0RWRpdG9yID0gZ2V0RWRpdG9yO1xuXG5mdW5jdGlvbiBSZWdpc3RlcmVkRWRpdG9yKGVkaXRvckNsYXNzKSB7XG4gIHZhciBDbGF6eiwgaW5zdGFuY2VzO1xuXG4gIGluc3RhbmNlcyA9IHt9O1xuICBDbGF6eiA9IGVkaXRvckNsYXNzO1xuXG4gIHRoaXMuZ2V0Q29uc3RydWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZWRpdG9yQ2xhc3M7XG4gIH07XG5cbiAgdGhpcy5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uIChob3RJbnN0YW5jZSkge1xuICAgIGlmICghKGhvdEluc3RhbmNlLmd1aWQgaW4gaW5zdGFuY2VzKSkge1xuICAgICAgaW5zdGFuY2VzW2hvdEluc3RhbmNlLmd1aWRdID0gbmV3IENsYXp6KGhvdEluc3RhbmNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2VzW2hvdEluc3RhbmNlLmd1aWRdO1xuICB9O1xufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBlZGl0b3IgdW5kZXIgZ2l2ZW4gbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IGVkaXRvck5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVkaXRvckNsYXNzXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyRWRpdG9yKGVkaXRvck5hbWUsIGVkaXRvckNsYXNzKSB7XG4gIHZhciBlZGl0b3IgPSBuZXcgUmVnaXN0ZXJlZEVkaXRvcihlZGl0b3JDbGFzcyk7XG5cbiAgaWYgKHR5cGVvZiBlZGl0b3JOYW1lID09PSAnc3RyaW5nJykge1xuICAgIHJlZ2lzdGVyZWRFZGl0b3JOYW1lc1tlZGl0b3JOYW1lXSA9IGVkaXRvcjtcbiAgICBIYW5kc29udGFibGUuZWRpdG9yc1t0b1VwcGVyQ2FzZUZpcnN0KGVkaXRvck5hbWUpICsgJ0VkaXRvciddID0gZWRpdG9yQ2xhc3M7XG4gIH1cbiAgcmVnaXN0ZXJlZEVkaXRvckNsYXNzZXMuc2V0KGVkaXRvckNsYXNzLCBlZGl0b3IpO1xufVxuXG4vKipcbiAqIFJldHVybnMgaW5zdGFuY2UgKHNpbmdsZXRvbikgb2YgZWRpdG9yIGNsYXNzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGVkaXRvck5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBob3RJbnN0YW5jZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBlZGl0b3JDbGFzc1xuICovXG5mdW5jdGlvbiBnZXRFZGl0b3IoZWRpdG9yTmFtZSwgaG90SW5zdGFuY2UpIHtcbiAgdmFyIGVkaXRvcjtcblxuICBpZiAodHlwZW9mIGVkaXRvck5hbWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmICghKHJlZ2lzdGVyZWRFZGl0b3JDbGFzc2VzLmdldChlZGl0b3JOYW1lKSkpIHtcbiAgICAgIHJlZ2lzdGVyRWRpdG9yKG51bGwsIGVkaXRvck5hbWUpO1xuICAgIH1cbiAgICBlZGl0b3IgPSByZWdpc3RlcmVkRWRpdG9yQ2xhc3Nlcy5nZXQoZWRpdG9yTmFtZSk7XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIGVkaXRvck5hbWUgPT0gJ3N0cmluZycpIHtcbiAgICBlZGl0b3IgPSByZWdpc3RlcmVkRWRpdG9yTmFtZXNbZWRpdG9yTmFtZV07XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoJ09ubHkgc3RyaW5ncyBhbmQgZnVuY3Rpb25zIGNhbiBiZSBwYXNzZWQgYXMgXCJlZGl0b3JcIiBwYXJhbWV0ZXIgJyk7XG4gIH1cblxuICBpZiAoIWVkaXRvcikge1xuICAgIHRocm93IEVycm9yKCdObyBlZGl0b3IgcmVnaXN0ZXJlZCB1bmRlciBuYW1lIFwiJyArIGVkaXRvck5hbWUgKyAnXCInKTtcbiAgfVxuXG4gIHJldHVybiBlZGl0b3IuZ2V0SW5zdGFuY2UoaG90SW5zdGFuY2UpO1xufVxuXG4vKipcbiAqIEdldCBlZGl0b3IgY29uc3RydWN0b3IgY2xhc3NcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZWRpdG9yTmFtZVxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBnZXRFZGl0b3JDb25zdHJ1Y3RvcihlZGl0b3JOYW1lKSB7XG4gIHZhciBlZGl0b3I7XG5cbiAgaWYgKHR5cGVvZiBlZGl0b3JOYW1lID09ICdzdHJpbmcnKSB7XG4gICAgZWRpdG9yID0gcmVnaXN0ZXJlZEVkaXRvck5hbWVzW2VkaXRvck5hbWVdO1xuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IEVycm9yKCdPbmx5IHN0cmluZ3MgYW5kIGZ1bmN0aW9ucyBjYW4gYmUgcGFzc2VkIGFzIFwiZWRpdG9yXCIgcGFyYW1ldGVyICcpO1xuICB9XG5cbiAgaWYgKCFlZGl0b3IpIHtcbiAgICB0aHJvdyBFcnJvcignTm8gZWRpdG9yIHJlZ2lzdGVyZWQgdW5kZXIgbmFtZSBcIicgKyBlZGl0b3JOYW1lICsgJ1wiJyk7XG4gIH1cblxuICByZXR1cm4gZWRpdG9yLmdldENvbnN0cnVjdG9yKCk7XG59XG5cbi8qKlxuICogQHBhcmFtIGVkaXRvck5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNFZGl0b3IoZWRpdG9yTmFtZSkge1xuICByZXR1cm4gcmVnaXN0ZXJlZEVkaXRvck5hbWVzW2VkaXRvck5hbWVdID8gdHJ1ZSA6IGZhbHNlO1xufVxuIiwiXG5pbXBvcnQge3N0cmluZ2lmeX0gZnJvbSAnLi8uLi9oZWxwZXJzL21peGVkJztcbmltcG9ydCB7V2Fsa29udGFibGVDZWxsQ29vcmRzfSBmcm9tICcuLy4uLzNyZHBhcnR5L3dhbGtvbnRhYmxlL3NyYy9jZWxsL2Nvb3Jkcyc7XG5cbmV4cG9ydCB7QmFzZUVkaXRvcn07XG5cbkhhbmRzb250YWJsZS5lZGl0b3JzID0gSGFuZHNvbnRhYmxlLmVkaXRvcnMgfHwge307XG5IYW5kc29udGFibGUuZWRpdG9ycy5CYXNlRWRpdG9yID0gQmFzZUVkaXRvcjtcblxuSGFuZHNvbnRhYmxlLkVkaXRvclN0YXRlID0ge1xuICBWSVJHSU46ICdTVEFURV9WSVJHSU4nLCAvL2JlZm9yZSBlZGl0aW5nXG4gIEVESVRJTkc6ICdTVEFURV9FRElUSU5HJyxcbiAgV0FJVElORzogJ1NUQVRFX1dBSVRJTkcnLCAvL3dhaXRpbmcgZm9yIGFzeW5jIHZhbGlkYXRpb25cbiAgRklOSVNIRUQ6ICdTVEFURV9GSU5JU0hFRCdcbn07XG5cbmZ1bmN0aW9uIEJhc2VFZGl0b3IoaW5zdGFuY2UpIHtcbiAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICB0aGlzLnN0YXRlID0gSGFuZHNvbnRhYmxlLkVkaXRvclN0YXRlLlZJUkdJTjtcblxuICB0aGlzLl9vcGVuZWQgPSBmYWxzZTtcbiAgdGhpcy5fZnVsbEVkaXRNb2RlID0gZmFsc2U7XG4gIHRoaXMuX2Nsb3NlQ2FsbGJhY2sgPSBudWxsO1xuXG4gIHRoaXMuaW5pdCgpO1xufVxuXG5CYXNlRWRpdG9yLnByb3RvdHlwZS5fZmlyZUNhbGxiYWNrcyA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICBpZiAodGhpcy5fY2xvc2VDYWxsYmFjaykge1xuICAgIHRoaXMuX2Nsb3NlQ2FsbGJhY2socmVzdWx0KTtcbiAgICB0aGlzLl9jbG9zZUNhbGxiYWNrID0gbnVsbDtcbiAgfVxufTtcblxuQmFzZUVkaXRvci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge307XG5cbkJhc2VFZGl0b3IucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IEVycm9yKCdFZGl0b3IgZ2V0VmFsdWUoKSBtZXRob2QgdW5pbXBsZW1lbnRlZCcpO1xufTtcblxuQmFzZUVkaXRvci5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICB0aHJvdyBFcnJvcignRWRpdG9yIHNldFZhbHVlKCkgbWV0aG9kIHVuaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VFZGl0b3IucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbigpIHtcbiAgdGhyb3cgRXJyb3IoJ0VkaXRvciBvcGVuKCkgbWV0aG9kIHVuaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VFZGl0b3IucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRocm93IEVycm9yKCdFZGl0b3IgY2xvc2UoKSBtZXRob2QgdW5pbXBsZW1lbnRlZCcpO1xufTtcblxuQmFzZUVkaXRvci5wcm90b3R5cGUucHJlcGFyZSA9IGZ1bmN0aW9uKHJvdywgY29sLCBwcm9wLCB0ZCwgb3JpZ2luYWxWYWx1ZSwgY2VsbFByb3BlcnRpZXMpIHtcbiAgdGhpcy5URCA9IHRkO1xuICB0aGlzLnJvdyA9IHJvdztcbiAgdGhpcy5jb2wgPSBjb2w7XG4gIHRoaXMucHJvcCA9IHByb3A7XG4gIHRoaXMub3JpZ2luYWxWYWx1ZSA9IG9yaWdpbmFsVmFsdWU7XG4gIHRoaXMuY2VsbFByb3BlcnRpZXMgPSBjZWxsUHJvcGVydGllcztcblxuICB0aGlzLnN0YXRlID0gSGFuZHNvbnRhYmxlLkVkaXRvclN0YXRlLlZJUkdJTjtcbn07XG5cbkJhc2VFZGl0b3IucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYmFzZUNsYXNzID0gdGhpcy5jb25zdHJ1Y3RvcjtcblxuICBmdW5jdGlvbiBFZGl0b3IoKSB7XG4gICAgYmFzZUNsYXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBpbmhlcml0KENoaWxkLCBQYXJlbnQpIHtcbiAgICBmdW5jdGlvbiBCcmlkZ2UoKSB7fVxuICAgIEJyaWRnZS5wcm90b3R5cGUgPSBQYXJlbnQucHJvdG90eXBlO1xuICAgIENoaWxkLnByb3RvdHlwZSA9IG5ldyBCcmlkZ2UoKTtcbiAgICBDaGlsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDaGlsZDtcblxuICAgIHJldHVybiBDaGlsZDtcbiAgfVxuXG4gIHJldHVybiBpbmhlcml0KEVkaXRvciwgYmFzZUNsYXNzKTtcbn07XG5cbkJhc2VFZGl0b3IucHJvdG90eXBlLnNhdmVWYWx1ZSA9IGZ1bmN0aW9uKHZhbCwgY3RybERvd24pIHtcbiAgdmFyIHNlbCwgdG1wO1xuXG4gIC8vIGlmIGN0cmwrZW50ZXIgYW5kIG11bHRpcGxlIGNlbGxzIHNlbGVjdGVkLCBiZWhhdmUgbGlrZSBFeGNlbCAoZmluaXNoIGVkaXRpbmcgYW5kIGFwcGx5IHRvIGFsbCBjZWxscylcbiAgaWYgKGN0cmxEb3duKSB7XG4gICAgc2VsID0gdGhpcy5pbnN0YW5jZS5nZXRTZWxlY3RlZCgpO1xuXG4gICAgaWYgKHNlbFswXSA+IHNlbFsyXSkge1xuICAgICAgdG1wID0gc2VsWzBdO1xuICAgICAgc2VsWzBdID0gc2VsWzJdO1xuICAgICAgc2VsWzJdID0gdG1wO1xuICAgIH1cbiAgICBpZiAoc2VsWzFdID4gc2VsWzNdKSB7XG4gICAgICB0bXAgPSBzZWxbMV07XG4gICAgICBzZWxbMV0gPSBzZWxbM107XG4gICAgICBzZWxbM10gPSB0bXA7XG4gICAgfVxuXG4gICAgdGhpcy5pbnN0YW5jZS5wb3B1bGF0ZUZyb21BcnJheShzZWxbMF0sIHNlbFsxXSwgdmFsLCBzZWxbMl0sIHNlbFszXSwgJ2VkaXQnKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmluc3RhbmNlLnBvcHVsYXRlRnJvbUFycmF5KHRoaXMucm93LCB0aGlzLmNvbCwgdmFsLCBudWxsLCBudWxsLCAnZWRpdCcpO1xuICB9XG59O1xuXG5CYXNlRWRpdG9yLnByb3RvdHlwZS5iZWdpbkVkaXRpbmcgPSBmdW5jdGlvbihpbml0aWFsVmFsdWUsIGV2ZW50KSB7XG4gIGlmICh0aGlzLnN0YXRlICE9IEhhbmRzb250YWJsZS5FZGl0b3JTdGF0ZS5WSVJHSU4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5pbnN0YW5jZS52aWV3LnNjcm9sbFZpZXdwb3J0KG5ldyBXYWxrb250YWJsZUNlbGxDb29yZHModGhpcy5yb3csIHRoaXMuY29sKSk7XG4gIHRoaXMuaW5zdGFuY2Uudmlldy5yZW5kZXIoKTtcbiAgdGhpcy5zdGF0ZSA9IEhhbmRzb250YWJsZS5FZGl0b3JTdGF0ZS5FRElUSU5HO1xuXG4gIGluaXRpYWxWYWx1ZSA9IHR5cGVvZiBpbml0aWFsVmFsdWUgPT0gJ3N0cmluZycgPyBpbml0aWFsVmFsdWUgOiB0aGlzLm9yaWdpbmFsVmFsdWU7XG4gIHRoaXMuc2V0VmFsdWUoc3RyaW5naWZ5KGluaXRpYWxWYWx1ZSkpO1xuXG4gIHRoaXMub3BlbihldmVudCk7XG4gIHRoaXMuX29wZW5lZCA9IHRydWU7XG4gIHRoaXMuZm9jdXMoKTtcblxuICAvLyBvbmx5IHJlcmVuZGVyIHRoZSBzZWxlY3Rpb25zIChGaWxsSGFuZGxlIHNob3VsZCBkaXNhcHBlYXIgd2hlbiBiZWdpbmVkaXRpbmcgaXMgdHJpZ2dlcmVkKVxuICB0aGlzLmluc3RhbmNlLnZpZXcucmVuZGVyKCk7XG59O1xuXG5CYXNlRWRpdG9yLnByb3RvdHlwZS5maW5pc2hFZGl0aW5nID0gZnVuY3Rpb24ocmVzdG9yZU9yaWdpbmFsVmFsdWUsIGN0cmxEb3duLCBjYWxsYmFjaykge1xuICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgIHZhbDtcblxuICBpZiAoY2FsbGJhY2spIHtcbiAgICB2YXIgcHJldmlvdXNDbG9zZUNhbGxiYWNrID0gdGhpcy5fY2xvc2VDYWxsYmFjaztcblxuICAgIHRoaXMuX2Nsb3NlQ2FsbGJhY2sgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIGlmIChwcmV2aW91c0Nsb3NlQ2FsbGJhY2spIHtcbiAgICAgICAgcHJldmlvdXNDbG9zZUNhbGxiYWNrKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhyZXN1bHQpO1xuICAgIH07XG4gIH1cblxuICBpZiAodGhpcy5pc1dhaXRpbmcoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLnN0YXRlID09IEhhbmRzb250YWJsZS5FZGl0b3JTdGF0ZS5WSVJHSU4pIHtcbiAgICB0aGlzLmluc3RhbmNlLl9yZWdpc3RlclRpbWVvdXQoc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIF90aGlzLl9maXJlQ2FsbGJhY2tzKHRydWUpO1xuICAgIH0sIDApKTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aGlzLnN0YXRlID09IEhhbmRzb250YWJsZS5FZGl0b3JTdGF0ZS5FRElUSU5HKSB7XG4gICAgaWYgKHJlc3RvcmVPcmlnaW5hbFZhbHVlKSB7XG4gICAgICB0aGlzLmNhbmNlbENoYW5nZXMoKTtcbiAgICAgIHRoaXMuaW5zdGFuY2Uudmlldy5yZW5kZXIoKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmluc3RhbmNlLmdldFNldHRpbmdzKCkudHJpbVdoaXRlc3BhY2UpIHtcbiAgICAgIC8vIFN0cmluZy5wcm90b3R5cGUudHJpbSBpcyBkZWZpbmVkIGluIFdhbGtvbnRhYmxlIHBvbHlmaWxsLmpzXG4gICAgICB2YWwgPSBbXG4gICAgICAgIC8vIFdlIHRyaW0gb25seSBzdHJpbmcgdmFsdWVzXG4gICAgICAgIFt0eXBlb2YgdGhpcy5nZXRWYWx1ZSgpID09PSAnc3RyaW5nJyA/IFN0cmluZy5wcm90b3R5cGUudHJpbS5jYWxsKHRoaXMuZ2V0VmFsdWUoKSB8fCAnJykgOiB0aGlzLmdldFZhbHVlKCldXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gW1xuICAgICAgICBbdGhpcy5nZXRWYWx1ZSgpXVxuICAgICAgXTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0gSGFuZHNvbnRhYmxlLkVkaXRvclN0YXRlLldBSVRJTkc7XG4gICAgdGhpcy5zYXZlVmFsdWUodmFsLCBjdHJsRG93bik7XG5cbiAgICBpZiAodGhpcy5pbnN0YW5jZS5nZXRDZWxsVmFsaWRhdG9yKHRoaXMuY2VsbFByb3BlcnRpZXMpKSB7XG4gICAgICB0aGlzLmluc3RhbmNlLmFkZEhvb2tPbmNlKCdwb3N0QWZ0ZXJWYWxpZGF0ZScsIGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IEhhbmRzb250YWJsZS5FZGl0b3JTdGF0ZS5GSU5JU0hFRDtcbiAgICAgICAgX3RoaXMuZGlzY2FyZEVkaXRvcihyZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBIYW5kc29udGFibGUuRWRpdG9yU3RhdGUuRklOSVNIRUQ7XG4gICAgICB0aGlzLmRpc2NhcmRFZGl0b3IodHJ1ZSk7XG4gICAgfVxuICB9XG59O1xuXG5CYXNlRWRpdG9yLnByb3RvdHlwZS5jYW5jZWxDaGFuZ2VzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc3RhdGUgPSBIYW5kc29udGFibGUuRWRpdG9yU3RhdGUuRklOSVNIRUQ7XG4gIHRoaXMuZGlzY2FyZEVkaXRvcigpO1xufTtcblxuQmFzZUVkaXRvci5wcm90b3R5cGUuZGlzY2FyZEVkaXRvciA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICBpZiAodGhpcy5zdGF0ZSAhPT0gSGFuZHNvbnRhYmxlLkVkaXRvclN0YXRlLkZJTklTSEVEKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHZhbGlkYXRvciB3YXMgZGVmaW5lZCBhbmQgZmFpbGVkXG4gIGlmIChyZXN1bHQgPT09IGZhbHNlICYmIHRoaXMuY2VsbFByb3BlcnRpZXMuYWxsb3dJbnZhbGlkICE9PSB0cnVlKSB7XG4gICAgdGhpcy5pbnN0YW5jZS5zZWxlY3RDZWxsKHRoaXMucm93LCB0aGlzLmNvbCk7XG4gICAgdGhpcy5mb2N1cygpO1xuICAgIHRoaXMuc3RhdGUgPSBIYW5kc29udGFibGUuRWRpdG9yU3RhdGUuRURJVElORztcbiAgICB0aGlzLl9maXJlQ2FsbGJhY2tzKGZhbHNlKTtcblxuICB9IGVsc2Uge1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgICB0aGlzLl9vcGVuZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9mdWxsRWRpdE1vZGUgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXRlID0gSGFuZHNvbnRhYmxlLkVkaXRvclN0YXRlLlZJUkdJTjtcbiAgICB0aGlzLl9maXJlQ2FsbGJhY2tzKHRydWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFN3aXRjaCBlZGl0b3IgaW50byBmdWxsIGVkaXQgbW9kZS4gSW4gdGhpcyBzdGF0ZSBuYXZpZ2F0aW9uIGtleXMgZG9uJ3QgY2xvc2UgZWRpdG9yLiBUaGlzIG1vZGUgaXMgYWN0aXZhdGVkXG4gKiBhdXRvbWF0aWNhbGx5IGFmdGVyIGhpdCBFTlRFUiBvciBGMiBrZXkgb24gdGhlIGNlbGwgb3Igd2hpbGUgZWRpdGluZyBjZWxsIHByZXNzIEYyIGtleS5cbiAqL1xuQmFzZUVkaXRvci5wcm90b3R5cGUuZW5hYmxlRnVsbEVkaXRNb2RlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2Z1bGxFZGl0TW9kZSA9IHRydWU7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBlZGl0b3IgaXMgaW4gZnVsbCBlZGl0IG1vZGUuXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbkJhc2VFZGl0b3IucHJvdG90eXBlLmlzSW5GdWxsRWRpdE1vZGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2Z1bGxFZGl0TW9kZTtcbn07XG5cbkJhc2VFZGl0b3IucHJvdG90eXBlLmlzT3BlbmVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9vcGVuZWQ7XG59O1xuXG5CYXNlRWRpdG9yLnByb3RvdHlwZS5pc1dhaXRpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IEhhbmRzb250YWJsZS5FZGl0b3JTdGF0ZS5XQUlUSU5HO1xufTtcbiIsImltcG9ydCB7S0VZX0NPREVTLCBpc1ByaW50YWJsZUNoYXJ9IGZyb20gJy4vLi4vaGVscGVycy91bmljb2RlJztcbmltcG9ydCB7c3RyaW5naWZ5fSBmcm9tICcuLy4uL2hlbHBlcnMvbWl4ZWQnO1xuaW1wb3J0IHtwaXZvdH0gZnJvbSAnLi8uLi9oZWxwZXJzL2FycmF5JztcbmltcG9ydCB7XG4gIGFkZENsYXNzLFxuICBnZXRDYXJldFBvc2l0aW9uLFxuICBnZXRTY3JvbGxiYXJXaWR0aCxcbiAgZ2V0U2VsZWN0aW9uRW5kUG9zaXRpb24sXG4gIG91dGVyV2lkdGgsXG4gIHNldENhcmV0UG9zaXRpb24sXG59IGZyb20gJy4vLi4vaGVscGVycy9kb20vZWxlbWVudCc7XG5pbXBvcnQge2dldEVkaXRvckNvbnN0cnVjdG9yLCByZWdpc3RlckVkaXRvcn0gZnJvbSAnLi8uLi9lZGl0b3JzJztcbmltcG9ydCB7SGFuZHNvbnRhYmxlRWRpdG9yfSBmcm9tICcuL2hhbmRzb250YWJsZUVkaXRvcic7XG5cbnZhciBBdXRvY29tcGxldGVFZGl0b3IgPSBIYW5kc29udGFibGVFZGl0b3IucHJvdG90eXBlLmV4dGVuZCgpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAZWRpdG9yIEF1dG9jb21wbGV0ZUVkaXRvclxuICogQGNsYXNzIEF1dG9jb21wbGV0ZUVkaXRvclxuICogQGRlcGVuZGVuY2llcyBIYW5kc29udGFibGVFZGl0b3JcbiAqL1xuQXV0b2NvbXBsZXRlRWRpdG9yLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIEhhbmRzb250YWJsZUVkaXRvci5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLmNob2ljZXMgPSBbXTtcbn07XG5cbkF1dG9jb21wbGV0ZUVkaXRvci5wcm90b3R5cGUuY3JlYXRlRWxlbWVudHMgPSBmdW5jdGlvbigpIHtcbiAgSGFuZHNvbnRhYmxlRWRpdG9yLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGFkZENsYXNzKHRoaXMuaHRDb250YWluZXIsICdhdXRvY29tcGxldGVFZGl0b3InKTtcbiAgYWRkQ2xhc3ModGhpcy5odENvbnRhaW5lciwgd2luZG93Lm5hdmlnYXRvci5wbGF0Zm9ybS5pbmRleE9mKCdNYWMnKSAhPT0gLTEgPyAnaHRNYWNTY3JvbGwnIDogJycpO1xufTtcblxudmFyIHNraXBPbmUgPSBmYWxzZTtcbmZ1bmN0aW9uIG9uQmVmb3JlS2V5RG93bihldmVudCkge1xuICBza2lwT25lID0gZmFsc2U7XG4gIHZhciBlZGl0b3IgPSB0aGlzLmdldEFjdGl2ZUVkaXRvcigpO1xuXG4gIGlmIChpc1ByaW50YWJsZUNoYXIoZXZlbnQua2V5Q29kZSkgfHwgZXZlbnQua2V5Q29kZSA9PT0gS0VZX0NPREVTLkJBQ0tTUEFDRSB8fFxuICAgIGV2ZW50LmtleUNvZGUgPT09IEtFWV9DT0RFUy5ERUxFVEUgfHwgZXZlbnQua2V5Q29kZSA9PT0gS0VZX0NPREVTLklOU0VSVCkge1xuICAgIHZhciB0aW1lT2Zmc2V0ID0gMDtcblxuICAgIC8vIG9uIGN0bCtjIC8gY21kK2MgZG9uJ3QgdXBkYXRlIHN1Z2dlc3Rpb24gbGlzdFxuICAgIGlmIChldmVudC5rZXlDb2RlID09PSBLRVlfQ09ERVMuQyAmJiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWVkaXRvci5pc09wZW5lZCgpKSB7XG4gICAgICB0aW1lT2Zmc2V0ICs9IDEwO1xuICAgIH1cblxuICAgIGlmIChlZGl0b3IuaHRFZGl0b3IpIHtcbiAgICAgIGVkaXRvci5pbnN0YW5jZS5fcmVnaXN0ZXJUaW1lb3V0KHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGVkaXRvci5xdWVyeUNob2ljZXMoZWRpdG9yLlRFWFRBUkVBLnZhbHVlKTtcbiAgICAgICAgc2tpcE9uZSA9IHRydWU7XG4gICAgICB9LCB0aW1lT2Zmc2V0KSk7XG4gICAgfVxuICB9XG59XG5cbkF1dG9jb21wbGV0ZUVkaXRvci5wcm90b3R5cGUucHJlcGFyZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmluc3RhbmNlLmFkZEhvb2soJ2JlZm9yZUtleURvd24nLCBvbkJlZm9yZUtleURvd24pO1xuICBIYW5kc29udGFibGVFZGl0b3IucHJvdG90eXBlLnByZXBhcmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbkF1dG9jb21wbGV0ZUVkaXRvci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKCkge1xuICAvLyBVZ2x5IGZpeCBmb3IgaGFuZHNvbnRhYmxlIHdoaWNoIGdyYWIgd2luZG93IG9iamVjdCBmb3IgYXV0b2NvbXBsZXRlIHNjcm9sbCBsaXN0ZW5lciBpbnN0ZWFkIHRhYmxlIGVsZW1lbnQuXG4gIHRoaXMuVEVYVEFSRUFfUEFSRU5ULnN0eWxlLm92ZXJmbG93ID0gJ2F1dG8nO1xuICBIYW5kc29udGFibGVFZGl0b3IucHJvdG90eXBlLm9wZW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdGhpcy5URVhUQVJFQV9QQVJFTlQuc3R5bGUub3ZlcmZsb3cgPSAnJztcblxuICB2YXIgY2hvaWNlc0xpc3RIb3QgPSB0aGlzLmh0RWRpdG9yLmdldEluc3RhbmNlKCk7XG4gIHZhciB0aGF0ID0gdGhpcztcbiAgdmFyIHRyaW1Ecm9wZG93biA9IHRoaXMuY2VsbFByb3BlcnRpZXMudHJpbURyb3Bkb3duID09PSB2b2lkIDAgPyB0cnVlIDogdGhpcy5jZWxsUHJvcGVydGllcy50cmltRHJvcGRvd247XG5cbiAgdGhpcy5URVhUQVJFQS5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICB0aGlzLmZvY3VzKCk7XG5cbiAgY2hvaWNlc0xpc3RIb3QudXBkYXRlU2V0dGluZ3Moe1xuICAgIGNvbFdpZHRoczogdHJpbURyb3Bkb3duID8gW291dGVyV2lkdGgodGhpcy5URVhUQVJFQSkgLSAyXSA6IHZvaWQgMCxcbiAgICB3aWR0aDogdHJpbURyb3Bkb3duID8gb3V0ZXJXaWR0aCh0aGlzLlRFWFRBUkVBKSArIGdldFNjcm9sbGJhcldpZHRoKCkgKyAyIDogdm9pZCAwLFxuICAgIGFmdGVyUmVuZGVyZXI6IGZ1bmN0aW9uKFRELCByb3csIGNvbCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIHZhciBjYXNlU2Vuc2l0aXZlID0gdGhpcy5nZXRDZWxsTWV0YShyb3csIGNvbCkuZmlsdGVyaW5nQ2FzZVNlbnNpdGl2ZSA9PT0gdHJ1ZSxcbiAgICAgICAgaW5kZXhPZk1hdGNoLFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgdmFsdWUgPSBzdHJpbmdpZnkodmFsdWUpO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgaW5kZXhPZk1hdGNoID0gY2FzZVNlbnNpdGl2ZSA/IHZhbHVlLmluZGV4T2YodGhpcy5xdWVyeSkgOiB2YWx1ZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YodGhhdC5xdWVyeS50b0xvd2VyQ2FzZSgpKTtcblxuICAgICAgICBpZiAoaW5kZXhPZk1hdGNoICE9IC0xKSB7XG4gICAgICAgICAgbWF0Y2ggPSB2YWx1ZS5zdWJzdHIoaW5kZXhPZk1hdGNoLCB0aGF0LnF1ZXJ5Lmxlbmd0aCk7XG4gICAgICAgICAgVEQuaW5uZXJIVE1MID0gdmFsdWUucmVwbGFjZShtYXRjaCwgJzxzdHJvbmc+JyArIG1hdGNoICsgJzwvc3Ryb25nPicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhdXRvQ29sdW1uU2l6ZTogdHJ1ZSxcbiAgICBtb2RpZnlDb2xXaWR0aDogZnVuY3Rpb24od2lkdGgsIGNvbCkge1xuICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgPHN0cm9uZz4gdGV4dCBvdmVybGFwcGluZyB0aGUgZHJvcGRvd24sIG5vdCByZWFsbHkgYWNjdXJhdGVcbiAgICAgIGxldCBhdXRvV2lkdGhzID0gdGhpcy5nZXRQbHVnaW4oJ2F1dG9Db2x1bW5TaXplJykud2lkdGhzO1xuXG4gICAgICBpZiAoYXV0b1dpZHRoc1tjb2xdKSB7XG4gICAgICAgIHdpZHRoID0gYXV0b1dpZHRoc1tjb2xdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJpbURyb3Bkb3duID8gd2lkdGggOiB3aWR0aCArIDE1O1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gQWRkIGFkZGl0aW9uYWwgc3BhY2UgZm9yIGF1dG9jb21wbGV0ZSBob2xkZXJcbiAgdGhpcy5odEVkaXRvci52aWV3Lnd0Lnd0VGFibGUuaG9sZGVyLnBhcmVudE5vZGUuc3R5bGVbJ3BhZGRpbmctcmlnaHQnXSA9IGdldFNjcm9sbGJhcldpZHRoKCkgKyAyICsgJ3B4JztcblxuICBpZiAoc2tpcE9uZSkge1xuICAgIHNraXBPbmUgPSBmYWxzZTtcbiAgfVxuXG4gIHRoYXQuaW5zdGFuY2UuX3JlZ2lzdGVyVGltZW91dChzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHRoYXQucXVlcnlDaG9pY2VzKHRoYXQuVEVYVEFSRUEudmFsdWUpO1xuICB9LCAwKSk7XG59O1xuXG5BdXRvY29tcGxldGVFZGl0b3IucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIEhhbmRzb250YWJsZUVkaXRvci5wcm90b3R5cGUuY2xvc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5BdXRvY29tcGxldGVFZGl0b3IucHJvdG90eXBlLnF1ZXJ5Q2hvaWNlcyA9IGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gIHRoaXMucXVlcnkgPSBxdWVyeTtcblxuICBpZiAodHlwZW9mIHRoaXMuY2VsbFByb3BlcnRpZXMuc291cmNlID09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICB0aGlzLmNlbGxQcm9wZXJ0aWVzLnNvdXJjZShxdWVyeSwgZnVuY3Rpb24oY2hvaWNlcykge1xuICAgICAgdGhhdC51cGRhdGVDaG9pY2VzTGlzdChjaG9pY2VzKTtcbiAgICB9KTtcblxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5jZWxsUHJvcGVydGllcy5zb3VyY2UpKSB7XG5cbiAgICB2YXIgY2hvaWNlcztcblxuICAgIGlmICghcXVlcnkgfHwgdGhpcy5jZWxsUHJvcGVydGllcy5maWx0ZXIgPT09IGZhbHNlKSB7XG4gICAgICBjaG9pY2VzID0gdGhpcy5jZWxsUHJvcGVydGllcy5zb3VyY2U7XG4gICAgfSBlbHNlIHtcblxuICAgICAgdmFyIGZpbHRlcmluZ0Nhc2VTZW5zaXRpdmUgPSB0aGlzLmNlbGxQcm9wZXJ0aWVzLmZpbHRlcmluZ0Nhc2VTZW5zaXRpdmUgPT09IHRydWU7XG4gICAgICB2YXIgbG93ZXJDYXNlUXVlcnkgPSBxdWVyeS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBjaG9pY2VzID0gdGhpcy5jZWxsUHJvcGVydGllcy5zb3VyY2UuZmlsdGVyKGZ1bmN0aW9uKGNob2ljZSkge1xuXG4gICAgICAgIGlmIChmaWx0ZXJpbmdDYXNlU2Vuc2l0aXZlKSB7XG4gICAgICAgICAgcmV0dXJuIGNob2ljZS5pbmRleE9mKHF1ZXJ5KSAhPSAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY2hvaWNlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihsb3dlckNhc2VRdWVyeSkgIT0gLTE7XG4gICAgICAgIH1cblxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVDaG9pY2VzTGlzdChjaG9pY2VzKTtcblxuICB9IGVsc2Uge1xuICAgIHRoaXMudXBkYXRlQ2hvaWNlc0xpc3QoW10pO1xuICB9XG5cbn07XG5cbkF1dG9jb21wbGV0ZUVkaXRvci5wcm90b3R5cGUudXBkYXRlQ2hvaWNlc0xpc3QgPSBmdW5jdGlvbihjaG9pY2VzKSB7XG4gIHZhciBwb3MgPSBnZXRDYXJldFBvc2l0aW9uKHRoaXMuVEVYVEFSRUEpLFxuICAgIGVuZFBvcyA9IGdldFNlbGVjdGlvbkVuZFBvc2l0aW9uKHRoaXMuVEVYVEFSRUEpO1xuXG4gIHZhciBvcmRlckJ5UmVsZXZhbmNlID0gQXV0b2NvbXBsZXRlRWRpdG9yLnNvcnRCeVJlbGV2YW5jZSh0aGlzLmdldFZhbHVlKCksIGNob2ljZXMsIHRoaXMuY2VsbFByb3BlcnRpZXMuZmlsdGVyaW5nQ2FzZVNlbnNpdGl2ZSk7XG4gIHZhciBoaWdobGlnaHRJbmRleDtcblxuICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gIGlmICh0aGlzLmNlbGxQcm9wZXJ0aWVzLmZpbHRlciAhPSBmYWxzZSkge1xuICAgIHZhciBzb3J0ZWQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgY2hvaWNlc0NvdW50ID0gb3JkZXJCeVJlbGV2YW5jZS5sZW5ndGg7IGkgPCBjaG9pY2VzQ291bnQ7IGkrKykge1xuICAgICAgc29ydGVkLnB1c2goY2hvaWNlc1tvcmRlckJ5UmVsZXZhbmNlW2ldXSk7XG4gICAgfVxuICAgIGhpZ2hsaWdodEluZGV4ID0gMDtcbiAgICBjaG9pY2VzID0gc29ydGVkO1xuICB9IGVsc2Uge1xuICAgIGhpZ2hsaWdodEluZGV4ID0gb3JkZXJCeVJlbGV2YW5jZVswXTtcbiAgfVxuICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG4gIHRoaXMuY2hvaWNlcyA9IGNob2ljZXM7XG4gIHRoaXMuaHRFZGl0b3IubG9hZERhdGEocGl2b3QoW2Nob2ljZXNdKSk7XG5cbiAgdGhpcy51cGRhdGVEcm9wZG93bkhlaWdodCgpO1xuXG4gIGlmICh0aGlzLmNlbGxQcm9wZXJ0aWVzLnN0cmljdCA9PT0gdHJ1ZSkge1xuICAgIHRoaXMuaGlnaGxpZ2h0QmVzdE1hdGNoaW5nQ2hvaWNlKGhpZ2hsaWdodEluZGV4KTtcbiAgfVxuXG4gIHRoaXMuaW5zdGFuY2UubGlzdGVuKCk7XG4gIHRoaXMuVEVYVEFSRUEuZm9jdXMoKTtcbiAgc2V0Q2FyZXRQb3NpdGlvbih0aGlzLlRFWFRBUkVBLCBwb3MsIChwb3MgIT0gZW5kUG9zID8gZW5kUG9zIDogdm9pZCAwKSk7XG59O1xuXG5BdXRvY29tcGxldGVFZGl0b3IucHJvdG90eXBlLnVwZGF0ZURyb3Bkb3duSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjdXJyZW50RHJvcGRvd25XaWR0aCA9IHRoaXMuaHRFZGl0b3IuZ2V0Q29sV2lkdGgoMCkgKyBnZXRTY3JvbGxiYXJXaWR0aCgpICsgMjtcbiAgdmFyIHRyaW1Ecm9wZG93biA9IHRoaXMuY2VsbFByb3BlcnRpZXMudHJpbURyb3Bkb3duID09PSB2b2lkIDAgPyB0cnVlIDogdGhpcy5jZWxsUHJvcGVydGllcy50cmltRHJvcGRvd247XG5cbiAgdGhpcy5odEVkaXRvci51cGRhdGVTZXR0aW5ncyh7XG4gICAgaGVpZ2h0OiB0aGlzLmdldERyb3Bkb3duSGVpZ2h0KCksXG4gICAgd2lkdGg6IHRyaW1Ecm9wZG93biA/IHZvaWQgMCA6IGN1cnJlbnREcm9wZG93bldpZHRoXG4gIH0pO1xuXG4gIHRoaXMuaHRFZGl0b3Iudmlldy53dC53dFRhYmxlLmFsaWduT3ZlcmxheXNXaXRoVHJpbW1pbmdDb250YWluZXIoKTtcbn07XG5cbkF1dG9jb21wbGV0ZUVkaXRvci5wcm90b3R5cGUuZmluaXNoRWRpdGluZyA9IGZ1bmN0aW9uKHJlc3RvcmVPcmlnaW5hbFZhbHVlKSB7XG4gIGlmICghcmVzdG9yZU9yaWdpbmFsVmFsdWUpIHtcbiAgICB0aGlzLmluc3RhbmNlLnJlbW92ZUhvb2soJ2JlZm9yZUtleURvd24nLCBvbkJlZm9yZUtleURvd24pO1xuICB9XG4gIEhhbmRzb250YWJsZUVkaXRvci5wcm90b3R5cGUuZmluaXNoRWRpdGluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuQXV0b2NvbXBsZXRlRWRpdG9yLnByb3RvdHlwZS5oaWdobGlnaHRCZXN0TWF0Y2hpbmdDaG9pY2UgPSBmdW5jdGlvbihpbmRleCkge1xuICBpZiAodHlwZW9mIGluZGV4ID09PSBcIm51bWJlclwiKSB7XG4gICAgdGhpcy5odEVkaXRvci5zZWxlY3RDZWxsKGluZGV4LCAwKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmh0RWRpdG9yLmRlc2VsZWN0Q2VsbCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEZpbHRlcnMgYW5kIHNvcnRzIGJ5IHJlbGV2YW5jZVxuICogQHBhcmFtIHZhbHVlXG4gKiBAcGFyYW0gY2hvaWNlc1xuICogQHBhcmFtIGNhc2VTZW5zaXRpdmVcbiAqIEByZXR1cm5zIHtBcnJheX0gYXJyYXkgb2YgaW5kZXhlcyBpbiBvcmlnaW5hbCBjaG9pY2VzIGFycmF5XG4gKi9cbkF1dG9jb21wbGV0ZUVkaXRvci5zb3J0QnlSZWxldmFuY2UgPSBmdW5jdGlvbih2YWx1ZSwgY2hvaWNlcywgY2FzZVNlbnNpdGl2ZSkge1xuXG4gIHZhciBjaG9pY2VzUmVsZXZhbmNlID0gW10sXG4gICAgY3VycmVudEl0ZW0sIHZhbHVlTGVuZ3RoID0gdmFsdWUubGVuZ3RoLFxuICAgIHZhbHVlSW5kZXgsIGNoYXJzTGVmdCwgcmVzdWx0ID0gW10sXG4gICAgaSwgY2hvaWNlc0NvdW50O1xuXG4gIGlmICh2YWx1ZUxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoaSA9IDAsIGNob2ljZXNDb3VudCA9IGNob2ljZXMubGVuZ3RoOyBpIDwgY2hvaWNlc0NvdW50OyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZm9yIChpID0gMCwgY2hvaWNlc0NvdW50ID0gY2hvaWNlcy5sZW5ndGg7IGkgPCBjaG9pY2VzQ291bnQ7IGkrKykge1xuICAgIGN1cnJlbnRJdGVtID0gc3RyaW5naWZ5KGNob2ljZXNbaV0pO1xuXG4gICAgaWYgKGNhc2VTZW5zaXRpdmUpIHtcbiAgICAgIHZhbHVlSW5kZXggPSBjdXJyZW50SXRlbS5pbmRleE9mKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVJbmRleCA9IGN1cnJlbnRJdGVtLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih2YWx1ZS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG5cblxuICAgIGlmICh2YWx1ZUluZGV4ID09IC0xKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY2hhcnNMZWZ0ID0gY3VycmVudEl0ZW0ubGVuZ3RoIC0gdmFsdWVJbmRleCAtIHZhbHVlTGVuZ3RoO1xuXG4gICAgY2hvaWNlc1JlbGV2YW5jZS5wdXNoKHtcbiAgICAgIGJhc2VJbmRleDogaSxcbiAgICAgIGluZGV4OiB2YWx1ZUluZGV4LFxuICAgICAgY2hhcnNMZWZ0OiBjaGFyc0xlZnQsXG4gICAgICB2YWx1ZTogY3VycmVudEl0ZW1cbiAgICB9KTtcbiAgfVxuXG4gIGNob2ljZXNSZWxldmFuY2Uuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cbiAgICBpZiAoYi5pbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKGEuaW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoYS5pbmRleCA8IGIuaW5kZXgpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKGIuaW5kZXggPCBhLmluZGV4KSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGEuaW5kZXggPT09IGIuaW5kZXgpIHtcbiAgICAgIGlmIChhLmNoYXJzTGVmdCA8IGIuY2hhcnNMZWZ0KSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gZWxzZSBpZiAoYS5jaGFyc0xlZnQgPiBiLmNoYXJzTGVmdCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgZm9yIChpID0gMCwgY2hvaWNlc0NvdW50ID0gY2hvaWNlc1JlbGV2YW5jZS5sZW5ndGg7IGkgPCBjaG9pY2VzQ291bnQ7IGkrKykge1xuICAgIHJlc3VsdC5wdXNoKGNob2ljZXNSZWxldmFuY2VbaV0uYmFzZUluZGV4KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5BdXRvY29tcGxldGVFZGl0b3IucHJvdG90eXBlLmdldERyb3Bkb3duSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBmaXJzdFJvd0hlaWdodCA9IHRoaXMuaHRFZGl0b3IuZ2V0SW5zdGFuY2UoKS5nZXRSb3dIZWlnaHQoMCkgfHwgMjM7XG4gIHZhciBfdmlzaWJsZVJvd3MgPSB0aGlzLmNlbGxQcm9wZXJ0aWVzLnZpc2libGVSb3dzO1xuXG4gIHJldHVybiB0aGlzLmNob2ljZXMubGVuZ3RoID49IF92aXNpYmxlUm93cyA/IF92aXNpYmxlUm93cyAqIGZpcnN0Um93SGVpZ2h0IDogdGhpcy5jaG9pY2VzLmxlbmd0aCAqIGZpcnN0Um93SGVpZ2h0ICsgODtcbn07XG5cbkF1dG9jb21wbGV0ZUVkaXRvci5wcm90b3R5cGUuYWxsb3dLZXlFdmVudFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oa2V5Q29kZSkge1xuICBsZXQgc2VsZWN0ZWQgPSB7cm93OiB0aGlzLmh0RWRpdG9yLmdldFNlbGVjdGVkUmFuZ2UoKSA/IHRoaXMuaHRFZGl0b3IuZ2V0U2VsZWN0ZWRSYW5nZSgpLmZyb20ucm93IDogLTF9O1xuICBsZXQgYWxsb3dlZCA9IGZhbHNlO1xuXG4gIGlmIChrZXlDb2RlID09PSBLRVlfQ09ERVMuQVJST1dfRE9XTiAmJiBzZWxlY3RlZC5yb3cgPCB0aGlzLmh0RWRpdG9yLmNvdW50Um93cygpIC0gMSkge1xuICAgIGFsbG93ZWQgPSB0cnVlO1xuICB9XG4gIGlmIChrZXlDb2RlID09PSBLRVlfQ09ERVMuQVJST1dfVVAgJiYgc2VsZWN0ZWQucm93ID4gLTEpIHtcbiAgICBhbGxvd2VkID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBhbGxvd2VkO1xufTtcblxuZXhwb3J0IHtBdXRvY29tcGxldGVFZGl0b3J9O1xuXG5yZWdpc3RlckVkaXRvcignYXV0b2NvbXBsZXRlJywgQXV0b2NvbXBsZXRlRWRpdG9yKTtcbiIsIlxuaW1wb3J0IHtyZWdpc3RlckVkaXRvcn0gZnJvbSAnLi8uLi9lZGl0b3JzJztcbmltcG9ydCB7QmFzZUVkaXRvcn0gZnJvbSAnLi9fYmFzZUVkaXRvcic7XG5pbXBvcnQge2hhc0NsYXNzfSBmcm9tICcuLy4uL2hlbHBlcnMvZG9tL2VsZW1lbnQnO1xuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBlZGl0b3IgQ2hlY2tib3hFZGl0b3JcbiAqIEBjbGFzcyBDaGVja2JveEVkaXRvclxuICovXG5jbGFzcyBDaGVja2JveEVkaXRvciBleHRlbmRzIEJhc2VFZGl0b3Ige1xuICBiZWdpbkVkaXRpbmcoKSB7XG4gICAgbGV0IGNoZWNrYm94ID0gdGhpcy5URC5xdWVyeVNlbGVjdG9yKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKTtcblxuICAgIGlmICghaGFzQ2xhc3MoY2hlY2tib3gsICdodEJhZFZhbHVlJykpIHtcbiAgICAgIGNoZWNrYm94LmNsaWNrKCk7XG4gICAgfVxuICB9XG5cbiAgZmluaXNoRWRpdGluZygpIHt9XG4gIGluaXQoKSB7fVxuICBvcGVuKCkge31cbiAgY2xvc2UoKSB7fVxuICBnZXRWYWx1ZSgpIHt9XG4gIHNldFZhbHVlKCkge31cbiAgZm9jdXMoKSB7fVxufVxuXG5leHBvcnQge0NoZWNrYm94RWRpdG9yfTtcblxucmVnaXN0ZXJFZGl0b3IoJ2NoZWNrYm94JywgQ2hlY2tib3hFZGl0b3IpO1xuIiwiXG5pbXBvcnQge2FkZENsYXNzLCBvdXRlckhlaWdodH0gZnJvbSAnLi8uLi9oZWxwZXJzL2RvbS9lbGVtZW50JztcbmltcG9ydCB7ZGVlcEV4dGVuZH0gZnJvbSAnLi8uLi9oZWxwZXJzL29iamVjdCc7XG5pbXBvcnQge0V2ZW50TWFuYWdlcn0gZnJvbSAnLi8uLi9ldmVudE1hbmFnZXInO1xuaW1wb3J0IHtnZXRFZGl0b3IsIHJlZ2lzdGVyRWRpdG9yfSBmcm9tICcuLy4uL2VkaXRvcnMnO1xuaW1wb3J0IHtpc01ldGFLZXl9IGZyb20gJy4vLi4vaGVscGVycy91bmljb2RlJztcbmltcG9ydCB7c3RvcFByb3BhZ2F0aW9ufSBmcm9tICcuLy4uL2hlbHBlcnMvZG9tL2V2ZW50JztcbmltcG9ydCB7VGV4dEVkaXRvcn0gZnJvbSAnLi90ZXh0RWRpdG9yJztcbmltcG9ydCBtb21lbnQgZnJvbSAnbW9tZW50JztcbmltcG9ydCBQaWthZGF5IGZyb20gJ3Bpa2FkYXknO1xuXG5cbkhhbmRzb250YWJsZS5lZGl0b3JzID0gSGFuZHNvbnRhYmxlLmVkaXRvcnMgfHwge307XG5IYW5kc29udGFibGUuZWRpdG9ycy5EYXRlRWRpdG9yID0gRGF0ZUVkaXRvcjtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGVkaXRvciBEYXRlRWRpdG9yXG4gKiBAY2xhc3MgRGF0ZUVkaXRvclxuICogQGRlcGVuZGVuY2llcyBUZXh0RWRpdG9yIG1vbWVudCBwaWthZGF5XG4gKi9cbmNsYXNzIERhdGVFZGl0b3IgZXh0ZW5kcyBUZXh0RWRpdG9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29yZX0gaG90SW5zdGFuY2UgSGFuZHNvbnRhYmxlIGluc3RhbmNlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihob3RJbnN0YW5jZSkge1xuICAgIHN1cGVyKGhvdEluc3RhbmNlKTtcblxuICAgIHRoaXMuJGRhdGVQaWNrZXIgPSBudWxsO1xuICAgIHRoaXMuZGF0ZVBpY2tlciA9IG51bGw7XG4gICAgdGhpcy5kYXRlUGlja2VyU3R5bGUgPSBudWxsO1xuICAgIHRoaXMuZGVmYXVsdERhdGVGb3JtYXQgPSAnREQvTU0vWVlZWSc7XG4gICAgdGhpcy5pc0NlbGxFZGl0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBhcmVudERlc3Ryb3llZCA9IGZhbHNlO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBpZiAodHlwZW9mIG1vbWVudCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG5lZWQgdG8gaW5jbHVkZSBtb21lbnQuanMgdG8geW91ciBwcm9qZWN0LlwiKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIFBpa2FkYXkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBuZWVkIHRvIGluY2x1ZGUgUGlrYWRheSB0byB5b3VyIHByb2plY3QuXCIpO1xuICAgIH1cbiAgICBzdXBlci5pbml0KCk7XG4gICAgdGhpcy5pbnN0YW5jZS5hZGRIb29rKCdhZnRlckRlc3Ryb3knLCAoKSA9PiB7XG4gICAgICB0aGlzLnBhcmVudERlc3Ryb3llZCA9IHRydWU7XG4gICAgICB0aGlzLmRlc3Ryb3lFbGVtZW50cygpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBkYXRhIHBpY2tlciBpbnN0YW5jZVxuICAgKi9cbiAgY3JlYXRlRWxlbWVudHMoKSB7XG4gICAgc3VwZXIuY3JlYXRlRWxlbWVudHMoKTtcblxuICAgIHRoaXMuZGF0ZVBpY2tlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICAgIHRoaXMuZGF0ZVBpY2tlclN0eWxlID0gdGhpcy5kYXRlUGlja2VyLnN0eWxlO1xuICAgIHRoaXMuZGF0ZVBpY2tlclN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICB0aGlzLmRhdGVQaWNrZXJTdHlsZS50b3AgPSAwO1xuICAgIHRoaXMuZGF0ZVBpY2tlclN0eWxlLmxlZnQgPSAwO1xuICAgIHRoaXMuZGF0ZVBpY2tlclN0eWxlLnpJbmRleCA9IDk5OTk7XG5cbiAgICBhZGRDbGFzcyh0aGlzLmRhdGVQaWNrZXIsICdodERhdGVwaWNrZXJIb2xkZXInKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuZGF0ZVBpY2tlcik7XG5cbiAgICB0aGlzLiRkYXRlUGlja2VyID0gbmV3IFBpa2FkYXkodGhpcy5nZXREYXRlUGlja2VyQ29uZmlnKCkpO1xuICAgIGNvbnN0IGV2ZW50TWFuYWdlciA9IG5ldyBFdmVudE1hbmFnZXIodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBQcmV2ZW50IHJlY29nbml6aW5nIGNsaWNraW5nIG9uIGRhdGVwaWNrZXIgYXMgY2xpY2tpbmcgb3V0c2lkZSBvZiB0YWJsZVxuICAgICAqL1xuICAgIGV2ZW50TWFuYWdlci5hZGRFdmVudExpc3RlbmVyKHRoaXMuZGF0ZVBpY2tlciwgJ21vdXNlZG93bicsIChldmVudCkgPT4gc3RvcFByb3BhZ2F0aW9uKGV2ZW50KSk7XG4gICAgdGhpcy5oaWRlRGF0ZXBpY2tlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgZGF0YSBwaWNrZXIgaW5zdGFuY2VcbiAgICovXG4gIGRlc3Ryb3lFbGVtZW50cygpIHtcbiAgICB0aGlzLiRkYXRlUGlja2VyLmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwYXJlIGVkaXRvciB0byBhcHBlYXJcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJvdyBSb3cgaW5kZXhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbCBDb2x1bW4gaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZSAocGFzc2VkIHdoZW4gZGF0YXNvdXJjZSBpcyBhbiBhcnJheSBvZiBvYmplY3RzKVxuICAgKiBAcGFyYW0ge0hUTUxUYWJsZUNlbGxFbGVtZW50fSB0ZCBUYWJsZSBjZWxsIGVsZW1lbnRcbiAgICogQHBhcmFtIHsqfSBvcmlnaW5hbFZhbHVlIE9yaWdpbmFsIHZhbHVlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjZWxsUHJvcGVydGllcyBPYmplY3Qgd2l0aCBjZWxsIHByb3BlcnRpZXMgKHtAc2VlIENvcmUjZ2V0Q2VsbE1ldGF9KVxuICAgKi9cbiAgcHJlcGFyZShyb3csIGNvbCwgcHJvcCwgdGQsIG9yaWdpbmFsVmFsdWUsIGNlbGxQcm9wZXJ0aWVzKSB7XG4gICAgdGhpcy5fb3BlbmVkID0gZmFsc2U7XG4gICAgc3VwZXIucHJlcGFyZShyb3csIGNvbCwgcHJvcCwgdGQsIG9yaWdpbmFsVmFsdWUsIGNlbGxQcm9wZXJ0aWVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPcGVuIGVkaXRvclxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50fSBbZXZlbnQ9bnVsbF1cbiAgICovXG4gIG9wZW4oZXZlbnQgPSBudWxsKSB7XG4gICAgc3VwZXIub3BlbigpO1xuICAgIHRoaXMuc2hvd0RhdGVwaWNrZXIoZXZlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlIGVkaXRvclxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5fb3BlbmVkID0gZmFsc2U7XG4gICAgdGhpcy5pbnN0YW5jZS5fcmVnaXN0ZXJUaW1lb3V0KHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5pbnN0YW5jZS5zZWxlY3Rpb24ucmVmcmVzaEJvcmRlcnMoKTtcbiAgICB9LCAwKSk7XG5cbiAgICBzdXBlci5jbG9zZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzQ2FuY2VsbGVkPWZhbHNlXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjdHJsRG93bj1mYWxzZV1cbiAgICovXG4gIGZpbmlzaEVkaXRpbmcoaXNDYW5jZWxsZWQgPSBmYWxzZSwgY3RybERvd24gPSBmYWxzZSkge1xuICAgIGlmIChpc0NhbmNlbGxlZCkgeyAvLyBwcmVzc2VkIEVTQywgcmVzdG9yZSBvcmlnaW5hbCB2YWx1ZVxuICAgICAgLy8gdmFyIHZhbHVlID0gdGhpcy5pbnN0YW5jZS5nZXREYXRhQXRDZWxsKHRoaXMucm93LCB0aGlzLmNvbCk7XG4gICAgICBsZXQgdmFsdWUgPSB0aGlzLm9yaWdpbmFsVmFsdWU7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmhpZGVEYXRlcGlja2VyKCk7XG4gICAgc3VwZXIuZmluaXNoRWRpdGluZyhpc0NhbmNlbGxlZCwgY3RybERvd24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNob3cgZGF0YSBwaWNrZXJcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICovXG4gIHNob3dEYXRlcGlja2VyKGV2ZW50KSB7XG4gICAgdGhpcy4kZGF0ZVBpY2tlci5jb25maWcodGhpcy5nZXREYXRlUGlja2VyQ29uZmlnKCkpO1xuXG4gICAgbGV0IG9mZnNldCA9IHRoaXMuVEQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IGRhdGVGb3JtYXQgPSB0aGlzLmNlbGxQcm9wZXJ0aWVzLmRhdGVGb3JtYXQgfHwgdGhpcy5kZWZhdWx0RGF0ZUZvcm1hdDtcbiAgICBsZXQgZGF0ZVBpY2tlckNvbmZpZyA9IHRoaXMuJGRhdGVQaWNrZXIuY29uZmlnKCk7XG4gICAgbGV0IGRhdGVTdHI7XG4gICAgbGV0IGlzTW91c2VEb3duID0gdGhpcy5pbnN0YW5jZS52aWV3LmlzTW91c2VEb3duKCk7XG4gICAgbGV0IGlzTWV0YSA9IGV2ZW50ID8gaXNNZXRhS2V5KGV2ZW50LmtleUNvZGUpIDogZmFsc2U7XG5cbiAgICB0aGlzLmRhdGVQaWNrZXJTdHlsZS50b3AgPSAod2luZG93LnBhZ2VZT2Zmc2V0ICsgb2Zmc2V0LnRvcCArIG91dGVySGVpZ2h0KHRoaXMuVEQpKSArICdweCc7XG4gICAgdGhpcy5kYXRlUGlja2VyU3R5bGUubGVmdCA9ICh3aW5kb3cucGFnZVhPZmZzZXQgKyBvZmZzZXQubGVmdCkgKyAncHgnO1xuXG4gICAgdGhpcy4kZGF0ZVBpY2tlci5fb25JbnB1dEZvY3VzID0gZnVuY3Rpb24oKSB7fTtcbiAgICBkYXRlUGlja2VyQ29uZmlnLmZvcm1hdCA9IGRhdGVGb3JtYXQ7XG5cbiAgICBpZiAodGhpcy5vcmlnaW5hbFZhbHVlKSB7XG4gICAgICBkYXRlU3RyID0gdGhpcy5vcmlnaW5hbFZhbHVlO1xuXG4gICAgICBpZiAobW9tZW50KGRhdGVTdHIsIGRhdGVGb3JtYXQsIHRydWUpLmlzVmFsaWQoKSkge1xuICAgICAgICB0aGlzLiRkYXRlUGlja2VyLnNldE1vbWVudChtb21lbnQoZGF0ZVN0ciwgZGF0ZUZvcm1hdCksIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc01ldGEgJiYgIWlzTW91c2VEb3duKSB7XG4gICAgICAgIHRoaXMuc2V0VmFsdWUoJycpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmNlbGxQcm9wZXJ0aWVzLmRlZmF1bHREYXRlKSB7XG4gICAgICAgIGRhdGVTdHIgPSB0aGlzLmNlbGxQcm9wZXJ0aWVzLmRlZmF1bHREYXRlO1xuXG4gICAgICAgIGRhdGVQaWNrZXJDb25maWcuZGVmYXVsdERhdGUgPSBkYXRlU3RyO1xuXG4gICAgICAgIGlmIChtb21lbnQoZGF0ZVN0ciwgZGF0ZUZvcm1hdCwgdHJ1ZSkuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgdGhpcy4kZGF0ZVBpY2tlci5zZXRNb21lbnQobW9tZW50KGRhdGVTdHIsIGRhdGVGb3JtYXQpLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNNZXRhICYmICFpc01vdXNlRG93bikge1xuICAgICAgICAgIHRoaXMuc2V0VmFsdWUoJycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBhIGRlZmF1bHQgZGF0ZSBpcyBub3QgZGVmaW5lZCwgc2V0IGEgc29mdC1kZWZhdWx0LWRhdGU6IGRpc3BsYXkgdGhlIGN1cnJlbnQgZGF5IGFuZCBtb250aCBpbiB0aGVcbiAgICAgICAgLy8gZGF0ZXBpY2tlciwgYnV0IGRvbid0IGZpbGwgdGhlIGVkaXRvciBpbnB1dFxuICAgICAgICB0aGlzLiRkYXRlUGlja2VyLmdvdG9Ub2RheSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZGF0ZVBpY2tlclN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIHRoaXMuJGRhdGVQaWNrZXIuc2hvdygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhpZGUgZGF0YSBwaWNrZXJcbiAgICovXG4gIGhpZGVEYXRlcGlja2VyKCkge1xuICAgIHRoaXMuZGF0ZVBpY2tlclN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgdGhpcy4kZGF0ZVBpY2tlci5oaWRlKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGRhdGUgcGlja2VyIG9wdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBnZXREYXRlUGlja2VyQ29uZmlnKCkge1xuICAgIGxldCBodElucHV0ID0gdGhpcy5URVhUQVJFQTtcbiAgICBsZXQgb3B0aW9ucyA9IHt9O1xuXG4gICAgaWYgKHRoaXMuY2VsbFByb3BlcnRpZXMgJiYgdGhpcy5jZWxsUHJvcGVydGllcy5kYXRlUGlja2VyQ29uZmlnKSB7XG4gICAgICBkZWVwRXh0ZW5kKG9wdGlvbnMsIHRoaXMuY2VsbFByb3BlcnRpZXMuZGF0ZVBpY2tlckNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IG9yaWdPblNlbGVjdCA9IG9wdGlvbnMub25TZWxlY3Q7XG4gICAgY29uc3Qgb3JpZ09uQ2xvc2UgPSBvcHRpb25zLm9uQ2xvc2U7XG5cbiAgICBvcHRpb25zLmZpZWxkID0gaHRJbnB1dDtcbiAgICBvcHRpb25zLnRyaWdnZXIgPSBodElucHV0O1xuICAgIG9wdGlvbnMuY29udGFpbmVyID0gdGhpcy5kYXRlUGlja2VyO1xuICAgIG9wdGlvbnMuYm91bmQgPSBmYWxzZTtcbiAgICBvcHRpb25zLmZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0IHx8IHRoaXMuZGVmYXVsdERhdGVGb3JtYXQ7XG4gICAgb3B0aW9ucy5yZXBvc2l0aW9uID0gb3B0aW9ucy5yZXBvc2l0aW9uIHx8IGZhbHNlO1xuICAgIG9wdGlvbnMub25TZWxlY3QgPSAoZGF0ZVN0cikgPT4ge1xuICAgICAgaWYgKCFpc05hTihkYXRlU3RyLmdldFRpbWUoKSkpIHtcbiAgICAgICAgZGF0ZVN0ciA9IG1vbWVudChkYXRlU3RyKS5mb3JtYXQodGhpcy5jZWxsUHJvcGVydGllcy5kYXRlRm9ybWF0IHx8IHRoaXMuZGVmYXVsdERhdGVGb3JtYXQpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRWYWx1ZShkYXRlU3RyKTtcbiAgICAgIHRoaXMuaGlkZURhdGVwaWNrZXIoKTtcblxuICAgICAgaWYgKG9yaWdPblNlbGVjdCkge1xuICAgICAgICBvcmlnT25TZWxlY3QoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG9wdGlvbnMub25DbG9zZSA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5wYXJlbnREZXN0cm95ZWQpIHtcbiAgICAgICAgdGhpcy5maW5pc2hFZGl0aW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcmlnT25DbG9zZSkge1xuICAgICAgICBvcmlnT25DbG9zZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxufVxuXG5leHBvcnQge0RhdGVFZGl0b3J9O1xuXG5yZWdpc3RlckVkaXRvcignZGF0ZScsIERhdGVFZGl0b3IpO1xuIiwiaW1wb3J0IHtnZXRFZGl0b3IsIHJlZ2lzdGVyRWRpdG9yfSBmcm9tICcuLy4uL2VkaXRvcnMnO1xuaW1wb3J0IHtBdXRvY29tcGxldGVFZGl0b3J9IGZyb20gJy4vYXV0b2NvbXBsZXRlRWRpdG9yJztcblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAZWRpdG9yIERyb3Bkb3duRWRpdG9yXG4gKiBAY2xhc3MgRHJvcGRvd25FZGl0b3JcbiAqIEBkZXBlbmRlbmNpZXMgQXV0b2NvbXBsZXRlRWRpdG9yXG4gKi9cbmNsYXNzIERyb3Bkb3duRWRpdG9yIGV4dGVuZHMgQXV0b2NvbXBsZXRlRWRpdG9yIHtcbiAgcHJlcGFyZShyb3csIGNvbCwgcHJvcCwgdGQsIG9yaWdpbmFsVmFsdWUsIGNlbGxQcm9wZXJ0aWVzKSB7XG4gICAgc3VwZXIucHJlcGFyZShyb3csIGNvbCwgcHJvcCwgdGQsIG9yaWdpbmFsVmFsdWUsIGNlbGxQcm9wZXJ0aWVzKTtcbiAgICB0aGlzLmNlbGxQcm9wZXJ0aWVzLmZpbHRlciA9IGZhbHNlO1xuICAgIHRoaXMuY2VsbFByb3BlcnRpZXMuc3RyaWN0ID0gdHJ1ZTtcbiAgfVxufVxuXG5IYW5kc29udGFibGUuaG9va3MuYWRkKCdiZWZvcmVWYWxpZGF0ZScsIGZ1bmN0aW9uKHZhbHVlLCByb3csIGNvbCwgc291cmNlKSB7XG4gIGxldCBjZWxsTWV0YSA9IHRoaXMuZ2V0Q2VsbE1ldGEocm93LCBjb2wpO1xuXG4gIGlmIChjZWxsTWV0YS5lZGl0b3IgPT09IEhhbmRzb250YWJsZS5lZGl0b3JzLkRyb3Bkb3duRWRpdG9yKSB7XG4gICAgaWYgKGNlbGxNZXRhLnN0cmljdCA9PT0gdm9pZCAwKSB7XG4gICAgICBjZWxsTWV0YS5maWx0ZXIgPSBmYWxzZTtcbiAgICAgIGNlbGxNZXRhLnN0cmljdCA9IHRydWU7XG4gICAgfVxuICB9XG59KTtcblxuZXhwb3J0IHtEcm9wZG93bkVkaXRvcn07XG5cbnJlZ2lzdGVyRWRpdG9yKCdkcm9wZG93bicsIERyb3Bkb3duRWRpdG9yKTtcbiIsIlxuaW1wb3J0IHtLRVlfQ09ERVN9IGZyb20gJy4vLi4vaGVscGVycy91bmljb2RlJztcbmltcG9ydCB7ZXh0ZW5kfSBmcm9tICcuLy4uL2hlbHBlcnMvb2JqZWN0JztcbmltcG9ydCB7c2V0Q2FyZXRQb3NpdGlvbn0gZnJvbSAnLi8uLi9oZWxwZXJzL2RvbS9lbGVtZW50JztcbmltcG9ydCB7c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uLCBpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZH0gZnJvbSAnLi8uLi9oZWxwZXJzL2RvbS9ldmVudCc7XG5pbXBvcnQge2dldEVkaXRvciwgcmVnaXN0ZXJFZGl0b3J9IGZyb20gJy4vLi4vZWRpdG9ycyc7XG5pbXBvcnQge1RleHRFZGl0b3J9IGZyb20gJy4vdGV4dEVkaXRvcic7XG5cbnZhciBIYW5kc29udGFibGVFZGl0b3IgPSBUZXh0RWRpdG9yLnByb3RvdHlwZS5leHRlbmQoKTtcblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAZWRpdG9yIEhhbmRzb250YWJsZUVkaXRvclxuICogQGNsYXNzIEhhbmRzb250YWJsZUVkaXRvclxuICogQGRlcGVuZGVuY2llcyBUZXh0RWRpdG9yXG4gKi9cbkhhbmRzb250YWJsZUVkaXRvci5wcm90b3R5cGUuY3JlYXRlRWxlbWVudHMgPSBmdW5jdGlvbigpIHtcbiAgVGV4dEVkaXRvci5wcm90b3R5cGUuY3JlYXRlRWxlbWVudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICB2YXIgRElWID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gIERJVi5jbGFzc05hbWUgPSAnaGFuZHNvbnRhYmxlRWRpdG9yJztcbiAgdGhpcy5URVhUQVJFQV9QQVJFTlQuYXBwZW5kQ2hpbGQoRElWKTtcblxuICB0aGlzLmh0Q29udGFpbmVyID0gRElWO1xuICB0aGlzLmFzc2lnbkhvb2tzKCk7XG59O1xuXG5IYW5kc29udGFibGVFZGl0b3IucHJvdG90eXBlLnByZXBhcmUgPSBmdW5jdGlvbih0ZCwgcm93LCBjb2wsIHByb3AsIHZhbHVlLCBjZWxsUHJvcGVydGllcykge1xuXG4gIFRleHRFZGl0b3IucHJvdG90eXBlLnByZXBhcmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICB2YXIgcGFyZW50ID0gdGhpcztcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgc3RhcnRSb3dzOiAwLFxuICAgIHN0YXJ0Q29sczogMCxcbiAgICBtaW5Sb3dzOiAwLFxuICAgIG1pbkNvbHM6IDAsXG4gICAgY2xhc3NOYW1lOiAnbGlzdGJveCcsXG4gICAgY29weVBhc3RlOiBmYWxzZSxcbiAgICBhdXRvQ29sdW1uU2l6ZTogZmFsc2UsXG4gICAgYXV0b1Jvd1NpemU6IGZhbHNlLFxuICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgIGZpbGxIYW5kbGU6IGZhbHNlLFxuICAgIGFmdGVyT25DZWxsTW91c2VEb3duOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblxuICAgICAgLy8gaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCB0aGVuIGl0IG1lYW5zIHdlIGRvbid0IHdhbnQgdG8gc2V0IHRoZSB2YWx1ZVxuICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgcGFyZW50LnNldFZhbHVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudC5pbnN0YW5jZS5kZXN0cm95RWRpdG9yKCk7XG4gICAgfVxuICB9O1xuXG4gIGlmICh0aGlzLmNlbGxQcm9wZXJ0aWVzLmhhbmRzb250YWJsZSkge1xuICAgIGV4dGVuZChvcHRpb25zLCBjZWxsUHJvcGVydGllcy5oYW5kc29udGFibGUpO1xuICB9XG4gIHRoaXMuaHRPcHRpb25zID0gb3B0aW9ucztcbn07XG5cbnZhciBvbkJlZm9yZUtleURvd24gPSBmdW5jdGlvbihldmVudCkge1xuICBpZiAoaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoZXZlbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBlZGl0b3IgPSB0aGlzLmdldEFjdGl2ZUVkaXRvcigpO1xuXG4gIHZhciBpbm5lckhPVCA9IGVkaXRvci5odEVkaXRvci5nZXRJbnN0YW5jZSgpOyAvL0hhbmRzb250YWJsZS50bXBIYW5kc29udGFibGUoZWRpdG9yLmh0Q29udGFpbmVyLCAnZ2V0SW5zdGFuY2UnKTtcblxuICB2YXIgcm93VG9TZWxlY3Q7XG5cbiAgaWYgKGV2ZW50LmtleUNvZGUgPT0gS0VZX0NPREVTLkFSUk9XX0RPV04pIHtcbiAgICBpZiAoIWlubmVySE9ULmdldFNlbGVjdGVkKCkpIHtcbiAgICAgIHJvd1RvU2VsZWN0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNlbGVjdGVkUm93ID0gaW5uZXJIT1QuZ2V0U2VsZWN0ZWQoKVswXTtcbiAgICAgIHZhciBsYXN0Um93ID0gaW5uZXJIT1QuY291bnRSb3dzKCkgLSAxO1xuICAgICAgcm93VG9TZWxlY3QgPSBNYXRoLm1pbihsYXN0Um93LCBzZWxlY3RlZFJvdyArIDEpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IEtFWV9DT0RFUy5BUlJPV19VUCkge1xuICAgIGlmIChpbm5lckhPVC5nZXRTZWxlY3RlZCgpKSB7XG4gICAgICB2YXIgc2VsZWN0ZWRSb3cgPSBpbm5lckhPVC5nZXRTZWxlY3RlZCgpWzBdO1xuICAgICAgcm93VG9TZWxlY3QgPSBzZWxlY3RlZFJvdyAtIDE7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJvd1RvU2VsZWN0ICE9PSB2b2lkIDApIHtcbiAgICBpZiAocm93VG9TZWxlY3QgPCAwKSB7XG4gICAgICBpbm5lckhPVC5kZXNlbGVjdENlbGwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5uZXJIT1Quc2VsZWN0Q2VsbChyb3dUb1NlbGVjdCwgMCk7XG4gICAgfVxuICAgIGlmIChpbm5lckhPVC5nZXREYXRhKCkubGVuZ3RoKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGV2ZW50KTtcblxuICAgICAgZWRpdG9yLmluc3RhbmNlLmxpc3RlbigpO1xuICAgICAgZWRpdG9yLlRFWFRBUkVBLmZvY3VzKCk7XG4gICAgfVxuICB9XG59O1xuXG5IYW5kc29udGFibGVFZGl0b3IucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbigpIHtcblxuICB0aGlzLmluc3RhbmNlLmFkZEhvb2soJ2JlZm9yZUtleURvd24nLCBvbkJlZm9yZUtleURvd24pO1xuXG4gIFRleHRFZGl0b3IucHJvdG90eXBlLm9wZW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBpZiAodGhpcy5odEVkaXRvcikge1xuICAgIHRoaXMuaHRFZGl0b3IuZGVzdHJveSgpO1xuICB9XG4gIHRoaXMuaHRFZGl0b3IgPSBuZXcgSGFuZHNvbnRhYmxlKHRoaXMuaHRDb250YWluZXIsIHRoaXMuaHRPcHRpb25zKTtcblxuICBpZiAodGhpcy5jZWxsUHJvcGVydGllcy5zdHJpY3QpIHtcbiAgICB0aGlzLmh0RWRpdG9yLnNlbGVjdENlbGwoMCwgMCk7XG4gICAgdGhpcy5URVhUQVJFQS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5odEVkaXRvci5kZXNlbGVjdENlbGwoKTtcbiAgICB0aGlzLlRFWFRBUkVBLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gIH1cblxuICBzZXRDYXJldFBvc2l0aW9uKHRoaXMuVEVYVEFSRUEsIDAsIHRoaXMuVEVYVEFSRUEudmFsdWUubGVuZ3RoKTtcbn07XG5cbkhhbmRzb250YWJsZUVkaXRvci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pbnN0YW5jZS5yZW1vdmVIb29rKCdiZWZvcmVLZXlEb3duJywgb25CZWZvcmVLZXlEb3duKTtcbiAgdGhpcy5pbnN0YW5jZS5saXN0ZW4oKTtcblxuICBUZXh0RWRpdG9yLnByb3RvdHlwZS5jbG9zZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuSGFuZHNvbnRhYmxlRWRpdG9yLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmluc3RhbmNlLmxpc3RlbigpO1xuICBUZXh0RWRpdG9yLnByb3RvdHlwZS5mb2N1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuSGFuZHNvbnRhYmxlRWRpdG9yLnByb3RvdHlwZS5iZWdpbkVkaXRpbmcgPSBmdW5jdGlvbihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIG9uQmVnaW5FZGl0aW5nID0gdGhpcy5pbnN0YW5jZS5nZXRTZXR0aW5ncygpLm9uQmVnaW5FZGl0aW5nO1xuXG4gIGlmIChvbkJlZ2luRWRpdGluZyAmJiBvbkJlZ2luRWRpdGluZygpID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBUZXh0RWRpdG9yLnByb3RvdHlwZS5iZWdpbkVkaXRpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbkhhbmRzb250YWJsZUVkaXRvci5wcm90b3R5cGUuZmluaXNoRWRpdGluZyA9IGZ1bmN0aW9uKGlzQ2FuY2VsbGVkLCBjdHJsRG93bikge1xuICBpZiAodGhpcy5odEVkaXRvciAmJiB0aGlzLmh0RWRpdG9yLmlzTGlzdGVuaW5nKCkpIHsgLy9pZiBmb2N1cyBpcyBzdGlsbCBpbiB0aGUgSE9UIGVkaXRvclxuXG4gICAgLy9pZiAoSGFuZHNvbnRhYmxlLnRtcEhhbmRzb250YWJsZSh0aGlzLmh0Q29udGFpbmVyLCdpc0xpc3RlbmluZycpKSB7IC8vaWYgZm9jdXMgaXMgc3RpbGwgaW4gdGhlIEhPVCBlZGl0b3JcbiAgICAvL2lmICh0aGlzLiRodENvbnRhaW5lci5oYW5kc29udGFibGUoJ2lzTGlzdGVuaW5nJykpIHsgLy9pZiBmb2N1cyBpcyBzdGlsbCBpbiB0aGUgSE9UIGVkaXRvclxuICAgIHRoaXMuaW5zdGFuY2UubGlzdGVuKCk7IC8vcmV0dXJuIHRoZSBmb2N1cyB0byB0aGUgcGFyZW50IEhPVCBpbnN0YW5jZVxuICB9XG5cbiAgaWYgKHRoaXMuaHRFZGl0b3IgJiYgdGhpcy5odEVkaXRvci5nZXRTZWxlY3RlZCgpKSB7XG4gICAgLy9pZiAoSGFuZHNvbnRhYmxlLnRtcEhhbmRzb250YWJsZSh0aGlzLmh0Q29udGFpbmVyLCdnZXRTZWxlY3RlZCcpKSB7XG4gICAgLy9pZiAodGhpcy4kaHRDb250YWluZXIuaGFuZHNvbnRhYmxlKCdnZXRTZWxlY3RlZCcpKSB7XG4gICAgLy8gIHZhciB2YWx1ZSA9IHRoaXMuJGh0Q29udGFpbmVyLmhhbmRzb250YWJsZSgnZ2V0SW5zdGFuY2UnKS5nZXRWYWx1ZSgpO1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuaHRFZGl0b3IuZ2V0SW5zdGFuY2UoKS5nZXRWYWx1ZSgpO1xuICAgIC8vdmFyIHZhbHVlID0gSGFuZHNvbnRhYmxlLnRtcEhhbmRzb250YWJsZSh0aGlzLmh0Q29udGFpbmVyLCdnZXRJbnN0YW5jZScpLmdldFZhbHVlKCk7XG4gICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHsgLy9pZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkIHRoZW4gaXQgbWVhbnMgd2UgZG9uJ3Qgd2FudCB0byBzZXQgdGhlIHZhbHVlXG4gICAgICB0aGlzLnNldFZhbHVlKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gVGV4dEVkaXRvci5wcm90b3R5cGUuZmluaXNoRWRpdGluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxuSGFuZHNvbnRhYmxlRWRpdG9yLnByb3RvdHlwZS5hc3NpZ25Ib29rcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMuaW5zdGFuY2UuYWRkSG9vaygnYWZ0ZXJEZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKF90aGlzLmh0RWRpdG9yKSB7XG4gICAgICBfdGhpcy5odEVkaXRvci5kZXN0cm95KCk7XG4gICAgfVxuICB9KTtcbn07XG5cbmV4cG9ydCB7SGFuZHNvbnRhYmxlRWRpdG9yfTtcblxucmVnaXN0ZXJFZGl0b3IoJ2hhbmRzb250YWJsZScsIEhhbmRzb250YWJsZUVkaXRvcik7XG4iLCJcbmltcG9ydCB7S0VZX0NPREVTfSBmcm9tICcuLy4uL2hlbHBlcnMvdW5pY29kZSc7XG5pbXBvcnQge3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiwgaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWR9IGZyb20gJy4vLi4vaGVscGVycy9kb20vZXZlbnQnO1xuaW1wb3J0IHtcbiAgYWRkQ2xhc3MsXG4gIGdldFNjcm9sbExlZnQsXG4gIGdldFNjcm9sbFRvcCxcbiAgaGFzQ2xhc3MsXG4gIGlzQ2hpbGRPZixcbiAgb2Zmc2V0LFxuICBvdXRlckhlaWdodCxcbiAgb3V0ZXJXaWR0aCxcbiAgcmVtb3ZlQ2xhc3MsXG4gIHNldENhcmV0UG9zaXRpb24sXG4gICAgfSBmcm9tICcuLy4uL2hlbHBlcnMvZG9tL2VsZW1lbnQnO1xuaW1wb3J0IHtnZXRFZGl0b3IsIHJlZ2lzdGVyRWRpdG9yfSBmcm9tICcuLy4uL2VkaXRvcnMnO1xuaW1wb3J0IHtCYXNlRWRpdG9yfSBmcm9tICcuL19iYXNlRWRpdG9yJztcbmltcG9ydCB7ZXZlbnRNYW5hZ2VyIGFzIGV2ZW50TWFuYWdlck9iamVjdH0gZnJvbSAnLi8uLi9ldmVudE1hbmFnZXInO1xuXG52YXJcbiAgTW9iaWxlVGV4dEVkaXRvciA9IEJhc2VFZGl0b3IucHJvdG90eXBlLmV4dGVuZCgpLFxuICBkb21EaW1lbnNpb25zQ2FjaGUgPSB7fTtcblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAZWRpdG9yIE1vYmlsZVRleHRFZGl0b3JcbiAqIEBjbGFzcyBNb2JpbGVUZXh0RWRpdG9yXG4gKi9cbnZhciBjcmVhdGVDb250cm9scyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jb250cm9scyA9IHt9O1xuXG4gIHRoaXMuY29udHJvbHMubGVmdEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICB0aGlzLmNvbnRyb2xzLmxlZnRCdXR0b24uY2xhc3NOYW1lID0gJ2xlZnRCdXR0b24nO1xuICB0aGlzLmNvbnRyb2xzLnJpZ2h0QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gIHRoaXMuY29udHJvbHMucmlnaHRCdXR0b24uY2xhc3NOYW1lID0gJ3JpZ2h0QnV0dG9uJztcbiAgdGhpcy5jb250cm9scy51cEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICB0aGlzLmNvbnRyb2xzLnVwQnV0dG9uLmNsYXNzTmFtZSA9ICd1cEJ1dHRvbic7XG4gIHRoaXMuY29udHJvbHMuZG93bkJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICB0aGlzLmNvbnRyb2xzLmRvd25CdXR0b24uY2xhc3NOYW1lID0gJ2Rvd25CdXR0b24nO1xuXG4gIGZvciAodmFyIGJ1dHRvbiBpbiB0aGlzLmNvbnRyb2xzKSB7XG4gICAgaWYgKHRoaXMuY29udHJvbHMuaGFzT3duUHJvcGVydHkoYnV0dG9uKSkge1xuICAgICAgdGhpcy5wb3NpdGlvbkNvbnRyb2xzLmFwcGVuZENoaWxkKHRoaXMuY29udHJvbHNbYnV0dG9uXSk7XG4gICAgfVxuICB9XG59O1xuXG5Nb2JpbGVUZXh0RWRpdG9yLnByb3RvdHlwZS52YWx1ZUNoYW5nZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuaW5pdFZhbHVlICE9IHRoaXMuZ2V0VmFsdWUoKTtcbn07XG5cbk1vYmlsZVRleHRFZGl0b3IucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuICB0aGlzLmV2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlck9iamVjdCh0aGlzLmluc3RhbmNlKTtcblxuICB0aGlzLmNyZWF0ZUVsZW1lbnRzKCk7XG4gIHRoaXMuYmluZEV2ZW50cygpO1xuXG4gIHRoaXMuaW5zdGFuY2UuYWRkSG9vaygnYWZ0ZXJEZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgdGhhdC5kZXN0cm95KCk7XG4gIH0pO1xuXG59O1xuXG5Nb2JpbGVUZXh0RWRpdG9yLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5URVhUQVJFQS52YWx1ZTtcbn07XG5cbk1vYmlsZVRleHRFZGl0b3IucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgdGhpcy5pbml0VmFsdWUgPSBuZXdWYWx1ZTtcblxuICB0aGlzLlRFWFRBUkVBLnZhbHVlID0gbmV3VmFsdWU7XG59O1xuXG5Nb2JpbGVUZXh0RWRpdG9yLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50cyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVkaXRvckNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICB0aGlzLmVkaXRvckNvbnRhaW5lci5jbGFzc05hbWUgPSBcImh0TW9iaWxlRWRpdG9yQ29udGFpbmVyXCI7XG5cbiAgdGhpcy5jZWxsUG9pbnRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICB0aGlzLmNlbGxQb2ludGVyLmNsYXNzTmFtZSA9IFwiY2VsbFBvaW50ZXJcIjtcblxuICB0aGlzLm1vdmVIYW5kbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdESVYnKTtcbiAgdGhpcy5tb3ZlSGFuZGxlLmNsYXNzTmFtZSA9IFwibW92ZUhhbmRsZVwiO1xuXG4gIHRoaXMuaW5wdXRQYW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gIHRoaXMuaW5wdXRQYW5lLmNsYXNzTmFtZSA9IFwiaW5wdXRzXCI7XG5cbiAgdGhpcy5wb3NpdGlvbkNvbnRyb2xzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gIHRoaXMucG9zaXRpb25Db250cm9scy5jbGFzc05hbWUgPSBcInBvc2l0aW9uQ29udHJvbHNcIjtcblxuICB0aGlzLlRFWFRBUkVBID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnVEVYVEFSRUEnKTtcbiAgYWRkQ2xhc3ModGhpcy5URVhUQVJFQSwgJ2hhbmRzb250YWJsZUlucHV0Jyk7XG5cbiAgdGhpcy5pbnB1dFBhbmUuYXBwZW5kQ2hpbGQodGhpcy5URVhUQVJFQSk7XG5cbiAgdGhpcy5lZGl0b3JDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5jZWxsUG9pbnRlcik7XG4gIHRoaXMuZWRpdG9yQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMubW92ZUhhbmRsZSk7XG4gIHRoaXMuZWRpdG9yQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuaW5wdXRQYW5lKTtcbiAgdGhpcy5lZGl0b3JDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5wb3NpdGlvbkNvbnRyb2xzKTtcblxuICBjcmVhdGVDb250cm9scy5jYWxsKHRoaXMpO1xuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5lZGl0b3JDb250YWluZXIpO1xufTtcblxuTW9iaWxlVGV4dEVkaXRvci5wcm90b3R5cGUub25CZWZvcmVLZXlEb3duID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgdmFyIGluc3RhbmNlID0gdGhpcztcbiAgdmFyIHRoYXQgPSBpbnN0YW5jZS5nZXRBY3RpdmVFZGl0b3IoKTtcblxuICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGF0LlRFWFRBUkVBIHx8IGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKGV2ZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuICAgIGNhc2UgS0VZX0NPREVTLkVOVEVSOlxuICAgICAgdGhhdC5jbG9zZSgpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy9kb24ndCBhZGQgbmV3bGluZSB0byBmaWVsZFxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBLRVlfQ09ERVMuQkFDS1NQQUNFOlxuICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGV2ZW50KTsgLy9iYWNrc3BhY2UsIGRlbGV0ZSwgaG9tZSwgZW5kIHNob3VsZCBvbmx5IHdvcmsgbG9jYWxseSB3aGVuIGNlbGwgaXMgZWRpdGVkIChub3QgaW4gdGFibGUgY29udGV4dClcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG5Nb2JpbGVUZXh0RWRpdG9yLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaW5zdGFuY2UuYWRkSG9vaygnYmVmb3JlS2V5RG93bicsIHRoaXMub25CZWZvcmVLZXlEb3duKTtcblxuICBhZGRDbGFzcyh0aGlzLmVkaXRvckNvbnRhaW5lciwgJ2FjdGl2ZScpO1xuICByZW1vdmVDbGFzcyh0aGlzLmNlbGxQb2ludGVyLCAnaGlkZGVuJyk7XG5cbiAgdGhpcy51cGRhdGVFZGl0b3JQb3NpdGlvbigpO1xufTtcblxuTW9iaWxlVGV4dEVkaXRvci5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5URVhUQVJFQS5mb2N1cygpO1xuICBzZXRDYXJldFBvc2l0aW9uKHRoaXMuVEVYVEFSRUEsIHRoaXMuVEVYVEFSRUEudmFsdWUubGVuZ3RoKTtcbn07XG5cbk1vYmlsZVRleHRFZGl0b3IucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuVEVYVEFSRUEuYmx1cigpO1xuICB0aGlzLmluc3RhbmNlLnJlbW92ZUhvb2soJ2JlZm9yZUtleURvd24nLCB0aGlzLm9uQmVmb3JlS2V5RG93bik7XG5cbiAgcmVtb3ZlQ2xhc3ModGhpcy5lZGl0b3JDb250YWluZXIsICdhY3RpdmUnKTtcbn07XG5cbk1vYmlsZVRleHRFZGl0b3IucHJvdG90eXBlLnNjcm9sbFRvVmlldyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29vcmRzID0gdGhpcy5pbnN0YW5jZS5nZXRTZWxlY3RlZFJhbmdlKCkuaGlnaGxpZ2h0O1xuICB0aGlzLmluc3RhbmNlLnZpZXcuc2Nyb2xsVmlld3BvcnQoY29vcmRzKTtcbn07XG5cbk1vYmlsZVRleHRFZGl0b3IucHJvdG90eXBlLmhpZGVDZWxsUG9pbnRlciA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIWhhc0NsYXNzKHRoaXMuY2VsbFBvaW50ZXIsICdoaWRkZW4nKSkge1xuICAgIGFkZENsYXNzKHRoaXMuY2VsbFBvaW50ZXIsICdoaWRkZW4nKTtcbiAgfVxufTtcblxuTW9iaWxlVGV4dEVkaXRvci5wcm90b3R5cGUudXBkYXRlRWRpdG9yUG9zaXRpb24gPSBmdW5jdGlvbih4LCB5KSB7XG4gIGlmICh4ICYmIHkpIHtcbiAgICB4ID0gcGFyc2VJbnQoeCwgMTApO1xuICAgIHkgPSBwYXJzZUludCh5LCAxMCk7XG5cbiAgICB0aGlzLmVkaXRvckNvbnRhaW5lci5zdHlsZS50b3AgPSB5ICsgXCJweFwiO1xuICAgIHRoaXMuZWRpdG9yQ29udGFpbmVyLnN0eWxlLmxlZnQgPSB4ICsgXCJweFwiO1xuXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuaW5zdGFuY2UuZ2V0U2VsZWN0ZWQoKSxcbiAgICAgIHNlbGVjdGVkQ2VsbCA9IHRoaXMuaW5zdGFuY2UuZ2V0Q2VsbChzZWxlY3Rpb25bMF0sIHNlbGVjdGlvblsxXSk7XG5cbiAgICAvL2NhY2hlIHNpemVzXG4gICAgaWYgKCFkb21EaW1lbnNpb25zQ2FjaGUuY2VsbFBvaW50ZXIpIHtcbiAgICAgIGRvbURpbWVuc2lvbnNDYWNoZS5jZWxsUG9pbnRlciA9IHtcbiAgICAgICAgaGVpZ2h0OiBvdXRlckhlaWdodCh0aGlzLmNlbGxQb2ludGVyKSxcbiAgICAgICAgd2lkdGg6IG91dGVyV2lkdGgodGhpcy5jZWxsUG9pbnRlcilcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghZG9tRGltZW5zaW9uc0NhY2hlLmVkaXRvckNvbnRhaW5lcikge1xuICAgICAgZG9tRGltZW5zaW9uc0NhY2hlLmVkaXRvckNvbnRhaW5lciA9IHtcbiAgICAgICAgd2lkdGg6IG91dGVyV2lkdGgodGhpcy5lZGl0b3JDb250YWluZXIpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChzZWxlY3RlZENlbGwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIHNjcm9sbExlZnQgPSB0aGlzLmluc3RhbmNlLnZpZXcud3Qud3RPdmVybGF5cy5sZWZ0T3ZlcmxheVxuICAgICAgICAgIC50cmltbWluZ0NvbnRhaW5lciA9PSB3aW5kb3cgPyAwIDogZ2V0U2Nyb2xsTGVmdCh0aGlzLmluc3RhbmNlLnZpZXcud3Qud3RPdmVybGF5cy5sZWZ0T3ZlcmxheS5ob2xkZXIpO1xuICAgICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMuaW5zdGFuY2Uudmlldy53dC53dE92ZXJsYXlzLnRvcE92ZXJsYXlcbiAgICAgICAgICAudHJpbW1pbmdDb250YWluZXIgPT0gd2luZG93ID8gMCA6IGdldFNjcm9sbFRvcCh0aGlzLmluc3RhbmNlLnZpZXcud3Qud3RPdmVybGF5cy50b3BPdmVybGF5LmhvbGRlcik7XG5cbiAgICAgIHZhciBzZWxlY3RlZENlbGxPZmZzZXQgPSBvZmZzZXQoc2VsZWN0ZWRDZWxsKSxcbiAgICAgICAgc2VsZWN0ZWRDZWxsV2lkdGggPSBvdXRlcldpZHRoKHNlbGVjdGVkQ2VsbCksXG4gICAgICAgIGN1cnJlbnRTY3JvbGxQb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiBzY3JvbGxMZWZ0LFxuICAgICAgICAgIHk6IHNjcm9sbFRvcFxuICAgICAgICB9O1xuXG4gICAgICB0aGlzLmVkaXRvckNvbnRhaW5lci5zdHlsZS50b3AgPSBwYXJzZUludChzZWxlY3RlZENlbGxPZmZzZXQudG9wICsgb3V0ZXJIZWlnaHQoc2VsZWN0ZWRDZWxsKSAtXG4gICAgICAgICAgY3VycmVudFNjcm9sbFBvc2l0aW9uLnkgKyBkb21EaW1lbnNpb25zQ2FjaGUuY2VsbFBvaW50ZXIuaGVpZ2h0LCAxMCkgKyBcInB4XCI7XG4gICAgICB0aGlzLmVkaXRvckNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gcGFyc2VJbnQoKHdpbmRvdy5pbm5lcldpZHRoIC8gMikgLSAoZG9tRGltZW5zaW9uc0NhY2hlLmVkaXRvckNvbnRhaW5lci53aWR0aCAvIDIpLCAxMCkgKyBcInB4XCI7XG5cbiAgICAgIGlmIChzZWxlY3RlZENlbGxPZmZzZXQubGVmdCArIHNlbGVjdGVkQ2VsbFdpZHRoIC8gMiA+IHBhcnNlSW50KHRoaXMuZWRpdG9yQ29udGFpbmVyLnN0eWxlLmxlZnQsIDEwKSArXG4gICAgICAgICAgZG9tRGltZW5zaW9uc0NhY2hlLmVkaXRvckNvbnRhaW5lci53aWR0aCkge1xuICAgICAgICB0aGlzLmVkaXRvckNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gd2luZG93LmlubmVyV2lkdGggLSBkb21EaW1lbnNpb25zQ2FjaGUuZWRpdG9yQ29udGFpbmVyLndpZHRoICsgXCJweFwiO1xuXG4gICAgICB9IGVsc2UgaWYgKHNlbGVjdGVkQ2VsbE9mZnNldC5sZWZ0ICsgc2VsZWN0ZWRDZWxsV2lkdGggLyAyIDwgcGFyc2VJbnQodGhpcy5lZGl0b3JDb250YWluZXIuc3R5bGUubGVmdCwgMTApICsgMjApIHtcbiAgICAgICAgdGhpcy5lZGl0b3JDb250YWluZXIuc3R5bGUubGVmdCA9IDAgKyBcInB4XCI7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2VsbFBvaW50ZXIuc3R5bGUubGVmdCA9IHBhcnNlSW50KHNlbGVjdGVkQ2VsbE9mZnNldC5sZWZ0IC0gKGRvbURpbWVuc2lvbnNDYWNoZS5jZWxsUG9pbnRlci53aWR0aCAvIDIpIC1cbiAgICAgICAgb2Zmc2V0KHRoaXMuZWRpdG9yQ29udGFpbmVyKS5sZWZ0ICsgKHNlbGVjdGVkQ2VsbFdpZHRoIC8gMikgLSBjdXJyZW50U2Nyb2xsUG9zaXRpb24ueCwgMTApICsgXCJweFwiO1xuICAgIH1cbiAgfVxufTtcblxuXG4vLyBGb3IgdGhlIG9wdGlvbmFsIGRvbnQtYWZmZWN0LWVkaXRvci1ieS16b29taW5nIGZlYXR1cmU6XG5cbi8vTW9iaWxlVGV4dEVkaXRvci5wcm90b3R5cGUudXBkYXRlRWRpdG9yRGltZW5zaW9ucyA9IGZ1bmN0aW9uICgpIHtcbi8vICBpZighdGhpcy5iZWdpbm5pbmdXaW5kb3dXaWR0aCkge1xuLy8gICAgdGhpcy5iZWdpbm5pbmdXaW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuLy8gICAgdGhpcy5iZWdpbm5pbmdFZGl0b3JXaWR0aCA9IEhhbmRzb250YWJsZS5vdXRlcldpZHRoKHRoaXMuZWRpdG9yQ29udGFpbmVyKTtcbi8vICAgIHRoaXMuc2NhbGVSYXRpbyA9IHRoaXMuYmVnaW5uaW5nRWRpdG9yV2lkdGggLyB0aGlzLmJlZ2lubmluZ1dpbmRvd1dpZHRoO1xuLy9cbi8vICAgIHRoaXMuZWRpdG9yQ29udGFpbmVyLnN0eWxlLndpZHRoID0gdGhpcy5iZWdpbm5pbmdFZGl0b3JXaWR0aCArIFwicHhcIjtcbi8vICAgIHJldHVybjtcbi8vICB9XG4vL1xuLy8gIHZhciBjdXJyZW50U2NhbGVSYXRpbyA9IHRoaXMuYmVnaW5uaW5nRWRpdG9yV2lkdGggLyB3aW5kb3cuaW5uZXJXaWR0aDtcbi8vICAvL2lmKGN1cnJlbnRTY2FsZVJhdGlvID4gdGhpcy5zY2FsZVJhdGlvICsgMC4yIHx8IGN1cnJlbnRTY2FsZVJhdGlvIDwgdGhpcy5zY2FsZVJhdGlvIC0gMC4yKSB7XG4vLyAgaWYoY3VycmVudFNjYWxlUmF0aW8gIT0gdGhpcy5zY2FsZVJhdGlvKSB7XG4vLyAgICB0aGlzLmVkaXRvckNvbnRhaW5lci5zdHlsZVtcInpvb21cIl0gPSAoMSAtICgoY3VycmVudFNjYWxlUmF0aW8gKiB0aGlzLnNjYWxlUmF0aW8pIC0gdGhpcy5zY2FsZVJhdGlvKSkgKiAxMDAgKyBcIiVcIjtcbi8vICB9XG4vL1xuLy99O1xuXG5Nb2JpbGVUZXh0RWRpdG9yLnByb3RvdHlwZS51cGRhdGVFZGl0b3JEYXRhID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxlY3RlZCA9IHRoaXMuaW5zdGFuY2UuZ2V0U2VsZWN0ZWQoKSxcbiAgICBzZWxlY3RlZFZhbHVlID0gdGhpcy5pbnN0YW5jZS5nZXREYXRhQXRDZWxsKHNlbGVjdGVkWzBdLCBzZWxlY3RlZFsxXSk7XG5cbiAgdGhpcy5yb3cgPSBzZWxlY3RlZFswXTtcbiAgdGhpcy5jb2wgPSBzZWxlY3RlZFsxXTtcbiAgdGhpcy5zZXRWYWx1ZShzZWxlY3RlZFZhbHVlKTtcbiAgdGhpcy51cGRhdGVFZGl0b3JQb3NpdGlvbigpO1xufTtcblxuTW9iaWxlVGV4dEVkaXRvci5wcm90b3R5cGUucHJlcGFyZUFuZFNhdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbDtcblxuICBpZiAoIXRoaXMudmFsdWVDaGFuZ2VkKCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0aGlzLmluc3RhbmNlLmdldFNldHRpbmdzKCkudHJpbVdoaXRlc3BhY2UpIHtcbiAgICB2YWwgPSBbXG4gICAgICBbU3RyaW5nLnByb3RvdHlwZS50cmltLmNhbGwodGhpcy5nZXRWYWx1ZSgpKV1cbiAgICBdO1xuICB9IGVsc2Uge1xuICAgIHZhbCA9IFtcbiAgICAgIFt0aGlzLmdldFZhbHVlKCldXG4gICAgXTtcbiAgfVxuXG5cbiAgdGhpcy5zYXZlVmFsdWUodmFsKTtcbn07XG5cbk1vYmlsZVRleHRFZGl0b3IucHJvdG90eXBlLmJpbmRFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gIHRoaXMuZXZlbnRNYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5jb250cm9scy5sZWZ0QnV0dG9uLCBcInRvdWNoZW5kXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdGhhdC5wcmVwYXJlQW5kU2F2ZSgpO1xuICAgIHRoYXQuaW5zdGFuY2Uuc2VsZWN0aW9uLnRyYW5zZm9ybVN0YXJ0KDAsIC0gMSwgbnVsbCwgdHJ1ZSk7XG4gICAgdGhhdC51cGRhdGVFZGl0b3JEYXRhKCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG4gIHRoaXMuZXZlbnRNYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5jb250cm9scy5yaWdodEJ1dHRvbiwgXCJ0b3VjaGVuZFwiLCBmdW5jdGlvbihldmVudCkge1xuICAgIHRoYXQucHJlcGFyZUFuZFNhdmUoKTtcbiAgICB0aGF0Lmluc3RhbmNlLnNlbGVjdGlvbi50cmFuc2Zvcm1TdGFydCgwLCAxLCBudWxsLCB0cnVlKTtcbiAgICB0aGF0LnVwZGF0ZUVkaXRvckRhdGEoKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcbiAgdGhpcy5ldmVudE1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmNvbnRyb2xzLnVwQnV0dG9uLCBcInRvdWNoZW5kXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdGhhdC5wcmVwYXJlQW5kU2F2ZSgpO1xuICAgIHRoYXQuaW5zdGFuY2Uuc2VsZWN0aW9uLnRyYW5zZm9ybVN0YXJ0KC0xLCAwLCBudWxsLCB0cnVlKTtcbiAgICB0aGF0LnVwZGF0ZUVkaXRvckRhdGEoKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcbiAgdGhpcy5ldmVudE1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmNvbnRyb2xzLmRvd25CdXR0b24sIFwidG91Y2hlbmRcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB0aGF0LnByZXBhcmVBbmRTYXZlKCk7XG4gICAgdGhhdC5pbnN0YW5jZS5zZWxlY3Rpb24udHJhbnNmb3JtU3RhcnQoMSwgMCwgbnVsbCwgdHJ1ZSk7XG4gICAgdGhhdC51cGRhdGVFZGl0b3JEYXRhKCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG5cbiAgdGhpcy5ldmVudE1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLm1vdmVIYW5kbGUsIFwidG91Y2hzdGFydFwiLCBmdW5jdGlvbihldmVudCkge1xuICAgIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICB2YXIgdG91Y2ggPSBldmVudC50b3VjaGVzWzBdLFxuICAgICAgICBvblRvdWNoUG9zaXRpb24gPSB7XG4gICAgICAgICAgeDogdGhhdC5lZGl0b3JDb250YWluZXIub2Zmc2V0TGVmdCxcbiAgICAgICAgICB5OiB0aGF0LmVkaXRvckNvbnRhaW5lci5vZmZzZXRUb3BcbiAgICAgICAgfSwgb25Ub3VjaE9mZnNldCA9IHtcbiAgICAgICAgICB4OiB0b3VjaC5wYWdlWCAtIG9uVG91Y2hQb3NpdGlvbi54LFxuICAgICAgICAgIHk6IHRvdWNoLnBhZ2VZIC0gb25Ub3VjaFBvc2l0aW9uLnlcbiAgICAgICAgfTtcblxuICAgICAgdGhhdC5ldmVudE1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLCBcInRvdWNobW92ZVwiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgdG91Y2ggPSBldmVudC50b3VjaGVzWzBdO1xuICAgICAgICB0aGF0LnVwZGF0ZUVkaXRvclBvc2l0aW9uKHRvdWNoLnBhZ2VYIC0gb25Ub3VjaE9mZnNldC54LCB0b3VjaC5wYWdlWSAtIG9uVG91Y2hPZmZzZXQueSk7XG4gICAgICAgIHRoYXQuaGlkZUNlbGxQb2ludGVyKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9KTtcblxuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy5ldmVudE1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcihkb2N1bWVudC5ib2R5LCBcInRvdWNoZW5kXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKCFpc0NoaWxkT2YoZXZlbnQudGFyZ2V0LCB0aGF0LmVkaXRvckNvbnRhaW5lcikgJiYgIWlzQ2hpbGRPZihldmVudC50YXJnZXQsIHRoYXQuaW5zdGFuY2Uucm9vdEVsZW1lbnQpKSB7XG4gICAgICB0aGF0LmNsb3NlKCk7XG4gICAgfVxuICB9KTtcblxuICB0aGlzLmV2ZW50TWFuYWdlci5hZGRFdmVudExpc3RlbmVyKHRoaXMuaW5zdGFuY2Uudmlldy53dC53dE92ZXJsYXlzLmxlZnRPdmVybGF5LmhvbGRlciwgXCJzY3JvbGxcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAodGhhdC5pbnN0YW5jZS52aWV3Lnd0Lnd0T3ZlcmxheXMubGVmdE92ZXJsYXkudHJpbW1pbmdDb250YWluZXIgIT0gd2luZG93KSB7XG4gICAgICB0aGF0LmhpZGVDZWxsUG9pbnRlcigpO1xuICAgIH1cbiAgfSk7XG5cbiAgdGhpcy5ldmVudE1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmluc3RhbmNlLnZpZXcud3Qud3RPdmVybGF5cy50b3BPdmVybGF5LmhvbGRlciwgXCJzY3JvbGxcIiwgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAodGhhdC5pbnN0YW5jZS52aWV3Lnd0Lnd0T3ZlcmxheXMudG9wT3ZlcmxheS50cmltbWluZ0NvbnRhaW5lciAhPSB3aW5kb3cpIHtcbiAgICAgIHRoYXQuaGlkZUNlbGxQb2ludGVyKCk7XG4gICAgfVxuICB9KTtcblxufTtcblxuTW9iaWxlVGV4dEVkaXRvci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmV2ZW50TWFuYWdlci5jbGVhcigpO1xuXG4gIHRoaXMuZWRpdG9yQ29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lZGl0b3JDb250YWluZXIpO1xufTtcblxuZXhwb3J0IHtNb2JpbGVUZXh0RWRpdG9yfTtcblxucmVnaXN0ZXJFZGl0b3IoJ21vYmlsZScsIE1vYmlsZVRleHRFZGl0b3IpO1xuIiwiXG5pbXBvcnQgbnVtZXJhbCBmcm9tICdudW1lcmFsJztcbmltcG9ydCB7Z2V0RWRpdG9yLCByZWdpc3RlckVkaXRvcn0gZnJvbSAnLi8uLi9lZGl0b3JzJztcbmltcG9ydCB7VGV4dEVkaXRvcn0gZnJvbSAnLi90ZXh0RWRpdG9yJztcblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAZWRpdG9yIE51bWVyaWNFZGl0b3JcbiAqIEBjbGFzcyBOdW1lcmljRWRpdG9yXG4gKiBAZGVwZW5kZW5jaWVzIFRleHRFZGl0b3IgbnVtZXJhbFxuICovXG5jbGFzcyBOdW1lcmljRWRpdG9yIGV4dGVuZHMgVGV4dEVkaXRvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IGluaXRpYWxWYWx1ZVxuICAgKi9cbiAgYmVnaW5FZGl0aW5nKGluaXRpYWxWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YoaW5pdGlhbFZhbHVlKSA9PT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5vcmlnaW5hbFZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuY2VsbFByb3BlcnRpZXMubGFuZ3VhZ2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG51bWVyYWwubGFuZ3VhZ2UodGhpcy5jZWxsUHJvcGVydGllcy5sYW5ndWFnZSk7XG4gICAgICB9XG4gICAgICBsZXQgZGVjaW1hbERlbGltaXRlciA9IG51bWVyYWwubGFuZ3VhZ2VEYXRhKCkuZGVsaW1pdGVycy5kZWNpbWFsO1xuICAgICAgaW5pdGlhbFZhbHVlID0gKCcnICsgdGhpcy5vcmlnaW5hbFZhbHVlKS5yZXBsYWNlKCcuJywgZGVjaW1hbERlbGltaXRlcik7XG4gICAgfVxuICAgIHN1cGVyLmJlZ2luRWRpdGluZyhpbml0aWFsVmFsdWUpO1xuICB9XG59XG5cbmV4cG9ydCB7TnVtZXJpY0VkaXRvcn07XG5cbnJlZ2lzdGVyRWRpdG9yKCdudW1lcmljJywgTnVtZXJpY0VkaXRvcik7XG4iLCJcbmltcG9ydCB7ZW1wdHl9IGZyb20gJy4vLi4vaGVscGVycy9kb20vZWxlbWVudCc7XG5pbXBvcnQge2dldEVkaXRvciwgcmVnaXN0ZXJFZGl0b3J9IGZyb20gJy4vLi4vZWRpdG9ycyc7XG5pbXBvcnQge1RleHRFZGl0b3J9IGZyb20gJy4vdGV4dEVkaXRvcic7XG5cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGVkaXRvciBQYXNzd29yZEVkaXRvclxuICogQGNsYXNzIFBhc3N3b3JkRWRpdG9yXG4gKiBAZGVwZW5kZW5jaWVzIFRleHRFZGl0b3JcbiAqL1xuY2xhc3MgUGFzc3dvcmRFZGl0b3IgZXh0ZW5kcyBUZXh0RWRpdG9yIHtcbiAgY3JlYXRlRWxlbWVudHMoKSB7XG4gICAgc3VwZXIuY3JlYXRlRWxlbWVudHMoKTtcblxuICAgIHRoaXMuVEVYVEFSRUEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIHRoaXMuVEVYVEFSRUEuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3Bhc3N3b3JkJyk7XG4gICAgdGhpcy5URVhUQVJFQS5jbGFzc05hbWUgPSAnaGFuZHNvbnRhYmxlSW5wdXQnO1xuICAgIHRoaXMudGV4dGFyZWFTdHlsZSA9IHRoaXMuVEVYVEFSRUEuc3R5bGU7XG4gICAgdGhpcy50ZXh0YXJlYVN0eWxlLndpZHRoID0gMDtcbiAgICB0aGlzLnRleHRhcmVhU3R5bGUuaGVpZ2h0ID0gMDtcblxuICAgIGVtcHR5KHRoaXMuVEVYVEFSRUFfUEFSRU5UKTtcbiAgICB0aGlzLlRFWFRBUkVBX1BBUkVOVC5hcHBlbmRDaGlsZCh0aGlzLlRFWFRBUkVBKTtcbiAgfVxufVxuXG5leHBvcnQge1Bhc3N3b3JkRWRpdG9yfTtcblxucmVnaXN0ZXJFZGl0b3IoJ3Bhc3N3b3JkJywgUGFzc3dvcmRFZGl0b3IpO1xuIiwiXG5pbXBvcnQge1xuICBhZGRDbGFzcyxcbiAgZW1wdHksXG4gIGZhc3RJbm5lckhUTUwsXG4gIGdldENvbXB1dGVkU3R5bGUsXG4gIGdldENzc1RyYW5zZm9ybSxcbiAgZ2V0U2Nyb2xsYWJsZUVsZW1lbnQsXG4gIG9mZnNldCxcbiAgb3V0ZXJIZWlnaHQsXG4gIG91dGVyV2lkdGgsXG4gIHJlc2V0Q3NzVHJhbnNmb3JtLFxuICAgIH0gZnJvbSAnLi8uLi9oZWxwZXJzL2RvbS9lbGVtZW50JztcbmltcG9ydCB7c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9ufSBmcm9tICcuLy4uL2hlbHBlcnMvZG9tL2V2ZW50JztcbmltcG9ydCB7S0VZX0NPREVTfSBmcm9tICcuLy4uL2hlbHBlcnMvdW5pY29kZSc7XG5pbXBvcnQge2dldEVkaXRvciwgcmVnaXN0ZXJFZGl0b3J9IGZyb20gJy4vLi4vZWRpdG9ycyc7XG5pbXBvcnQge0Jhc2VFZGl0b3J9IGZyb20gJy4vX2Jhc2VFZGl0b3InO1xuXG52YXIgU2VsZWN0RWRpdG9yID0gQmFzZUVkaXRvci5wcm90b3R5cGUuZXh0ZW5kKCk7XG5cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQGVkaXRvciBTZWxlY3RFZGl0b3JcbiAqIEBjbGFzcyBTZWxlY3RFZGl0b3JcbiAqL1xuU2VsZWN0RWRpdG9yLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnU0VMRUNUJyk7XG4gIGFkZENsYXNzKHRoaXMuc2VsZWN0LCAnaHRTZWxlY3RFZGl0b3InKTtcbiAgdGhpcy5zZWxlY3Quc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgdGhpcy5pbnN0YW5jZS5yb290RWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNlbGVjdCk7XG4gIHRoaXMucmVnaXN0ZXJIb29rcygpO1xufTtcblxuU2VsZWN0RWRpdG9yLnByb3RvdHlwZS5yZWdpc3Rlckhvb2tzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaW5zdGFuY2UuYWRkSG9vaygnYWZ0ZXJTY3JvbGxWZXJ0aWNhbGx5JywgKCkgPT4gdGhpcy5yZWZyZXNoRGltZW5zaW9ucygpKTtcbiAgdGhpcy5pbnN0YW5jZS5hZGRIb29rKCdhZnRlckNvbHVtblJlc2l6ZScsICgpID0+IHRoaXMucmVmcmVzaERpbWVuc2lvbnMoKSk7XG4gIHRoaXMuaW5zdGFuY2UuYWRkSG9vaygnYWZ0ZXJSb3dSZXNpemUnLCAoKSA9PiB0aGlzLnJlZnJlc2hEaW1lbnNpb25zKCkpO1xufTtcblxuU2VsZWN0RWRpdG9yLnByb3RvdHlwZS5wcmVwYXJlID0gZnVuY3Rpb24oKSB7XG4gIEJhc2VFZGl0b3IucHJvdG90eXBlLnByZXBhcmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICB2YXIgc2VsZWN0T3B0aW9ucyA9IHRoaXMuY2VsbFByb3BlcnRpZXMuc2VsZWN0T3B0aW9ucztcbiAgdmFyIG9wdGlvbnM7XG5cbiAgaWYgKHR5cGVvZiBzZWxlY3RPcHRpb25zID09ICdmdW5jdGlvbicpIHtcbiAgICBvcHRpb25zID0gdGhpcy5wcmVwYXJlT3B0aW9ucyhzZWxlY3RPcHRpb25zKHRoaXMucm93LCB0aGlzLmNvbCwgdGhpcy5wcm9wKSk7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9ucyA9IHRoaXMucHJlcGFyZU9wdGlvbnMoc2VsZWN0T3B0aW9ucyk7XG4gIH1cblxuICBlbXB0eSh0aGlzLnNlbGVjdCk7XG5cbiAgZm9yICh2YXIgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKSB7XG4gICAgICB2YXIgb3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ09QVElPTicpO1xuICAgICAgb3B0aW9uRWxlbWVudC52YWx1ZSA9IG9wdGlvbjtcbiAgICAgIGZhc3RJbm5lckhUTUwob3B0aW9uRWxlbWVudCwgb3B0aW9uc1tvcHRpb25dKTtcbiAgICAgIHRoaXMuc2VsZWN0LmFwcGVuZENoaWxkKG9wdGlvbkVsZW1lbnQpO1xuICAgIH1cbiAgfVxufTtcblxuU2VsZWN0RWRpdG9yLnByb3RvdHlwZS5wcmVwYXJlT3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnNUb1ByZXBhcmUpIHtcbiAgdmFyIHByZXBhcmVkT3B0aW9ucyA9IHt9O1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnNUb1ByZXBhcmUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9wdGlvbnNUb1ByZXBhcmUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHByZXBhcmVkT3B0aW9uc1tvcHRpb25zVG9QcmVwYXJlW2ldXSA9IG9wdGlvbnNUb1ByZXBhcmVbaV07XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zVG9QcmVwYXJlID09ICdvYmplY3QnKSB7XG4gICAgcHJlcGFyZWRPcHRpb25zID0gb3B0aW9uc1RvUHJlcGFyZTtcbiAgfVxuXG4gIHJldHVybiBwcmVwYXJlZE9wdGlvbnM7XG5cbn07XG5cblNlbGVjdEVkaXRvci5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0LnZhbHVlO1xufTtcblxuU2VsZWN0RWRpdG9yLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHRoaXMuc2VsZWN0LnZhbHVlID0gdmFsdWU7XG59O1xuXG52YXIgb25CZWZvcmVLZXlEb3duID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgdmFyIGluc3RhbmNlID0gdGhpcztcbiAgdmFyIGVkaXRvciA9IGluc3RhbmNlLmdldEFjdGl2ZUVkaXRvcigpO1xuXG4gIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuICAgIGNhc2UgS0VZX0NPREVTLkFSUk9XX1VQOlxuICAgICAgdmFyIHByZXZpb3VzT3B0aW9uSW5kZXggPSBlZGl0b3Iuc2VsZWN0LnNlbGVjdGVkSW5kZXggLSAxO1xuICAgICAgaWYgKHByZXZpb3VzT3B0aW9uSW5kZXggPj0gMCkge1xuICAgICAgICBlZGl0b3Iuc2VsZWN0W3ByZXZpb3VzT3B0aW9uSW5kZXhdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgS0VZX0NPREVTLkFSUk9XX0RPV046XG4gICAgICB2YXIgbmV4dE9wdGlvbkluZGV4ID0gZWRpdG9yLnNlbGVjdC5zZWxlY3RlZEluZGV4ICsgMTtcbiAgICAgIGlmIChuZXh0T3B0aW9uSW5kZXggPD0gZWRpdG9yLnNlbGVjdC5sZW5ndGggLSAxKSB7XG4gICAgICAgIGVkaXRvci5zZWxlY3RbbmV4dE9wdGlvbkluZGV4XS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihldmVudCk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8vIFRPRE86IFJlZmFjdG9yIHRoaXMgd2l0aCB0aGUgdXNlIG9mIG5ldyBnZXRDZWxsKCkgYWZ0ZXIgMC4xMi4xXG5TZWxlY3RFZGl0b3IucHJvdG90eXBlLmNoZWNrRWRpdG9yU2VjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5yb3cgPCB0aGlzLmluc3RhbmNlLmdldFNldHRpbmdzKCkuZml4ZWRSb3dzVG9wKSB7XG4gICAgaWYgKHRoaXMuY29sIDwgdGhpcy5pbnN0YW5jZS5nZXRTZXR0aW5ncygpLmZpeGVkQ29sdW1uc0xlZnQpIHtcbiAgICAgIHJldHVybiAnY29ybmVyJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICd0b3AnO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5jb2wgPCB0aGlzLmluc3RhbmNlLmdldFNldHRpbmdzKCkuZml4ZWRDb2x1bW5zTGVmdCkge1xuICAgICAgcmV0dXJuICdsZWZ0JztcbiAgICB9XG4gIH1cbn07XG5cblNlbGVjdEVkaXRvci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9vcGVuZWQgPSB0cnVlO1xuICB0aGlzLnJlZnJlc2hEaW1lbnNpb25zKCk7XG4gIHRoaXMuc2VsZWN0LnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgdGhpcy5pbnN0YW5jZS5hZGRIb29rKCdiZWZvcmVLZXlEb3duJywgb25CZWZvcmVLZXlEb3duKTtcbn07XG5cblNlbGVjdEVkaXRvci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fb3BlbmVkID0gZmFsc2U7XG4gIHRoaXMuc2VsZWN0LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHRoaXMuaW5zdGFuY2UucmVtb3ZlSG9vaygnYmVmb3JlS2V5RG93bicsIG9uQmVmb3JlS2V5RG93bik7XG59O1xuXG5TZWxlY3RFZGl0b3IucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2VsZWN0LmZvY3VzKCk7XG59O1xuXG5TZWxlY3RFZGl0b3IucHJvdG90eXBlLnJlZnJlc2hEaW1lbnNpb25zID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnN0YXRlICE9PSBIYW5kc29udGFibGUuRWRpdG9yU3RhdGUuRURJVElORykge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLlREID0gdGhpcy5nZXRFZGl0ZWRDZWxsKCk7XG5cbiAgLy8gVEQgaXMgb3V0c2lkZSBvZiB0aGUgdmlld3BvcnQuXG4gIGlmICghdGhpcy5URCkge1xuICAgIHRoaXMuY2xvc2UoKTtcblxuICAgIHJldHVybjtcbiAgfVxuICB2YXJcbiAgICB3aWR0aCA9IG91dGVyV2lkdGgodGhpcy5URCkgKyAxLFxuICAgIGhlaWdodCA9IG91dGVySGVpZ2h0KHRoaXMuVEQpICsgMSxcbiAgICBjdXJyZW50T2Zmc2V0ID0gb2Zmc2V0KHRoaXMuVEQpLFxuICAgIGNvbnRhaW5lck9mZnNldCA9IG9mZnNldCh0aGlzLmluc3RhbmNlLnJvb3RFbGVtZW50KSxcbiAgICBzY3JvbGxhYmxlQ29udGFpbmVyID0gZ2V0U2Nyb2xsYWJsZUVsZW1lbnQodGhpcy5URCksXG4gICAgZWRpdFRvcCA9IGN1cnJlbnRPZmZzZXQudG9wIC0gY29udGFpbmVyT2Zmc2V0LnRvcCAtIDEgLSAoc2Nyb2xsYWJsZUNvbnRhaW5lci5zY3JvbGxUb3AgfHwgMCksXG4gICAgZWRpdExlZnQgPSBjdXJyZW50T2Zmc2V0LmxlZnQgLSBjb250YWluZXJPZmZzZXQubGVmdCAtIDEgLSAoc2Nyb2xsYWJsZUNvbnRhaW5lci5zY3JvbGxMZWZ0IHx8IDApLFxuICAgIGVkaXRvclNlY3Rpb24gPSB0aGlzLmNoZWNrRWRpdG9yU2VjdGlvbigpLFxuICAgIGNzc1RyYW5zZm9ybU9mZnNldDtcblxuICBjb25zdCBzZXR0aW5ncyA9IHRoaXMuaW5zdGFuY2UuZ2V0U2V0dGluZ3MoKTtcbiAgbGV0IHJvd0hlYWRlcnNDb3VudCA9IHNldHRpbmdzLnJvd0hlYWRlcnMgPyAxIDogMDtcbiAgbGV0IGNvbEhlYWRlcnNDb3VudCA9IHNldHRpbmdzLmNvbEhlYWRlcnMgPyAxIDogMDtcblxuICBzd2l0Y2ggKGVkaXRvclNlY3Rpb24pIHtcbiAgICBjYXNlICd0b3AnOlxuICAgICAgY3NzVHJhbnNmb3JtT2Zmc2V0ID0gZ2V0Q3NzVHJhbnNmb3JtKHRoaXMuaW5zdGFuY2Uudmlldy53dC53dE92ZXJsYXlzLnRvcE92ZXJsYXkuY2xvbmUud3RUYWJsZS5ob2xkZXIucGFyZW50Tm9kZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIGNzc1RyYW5zZm9ybU9mZnNldCA9IGdldENzc1RyYW5zZm9ybSh0aGlzLmluc3RhbmNlLnZpZXcud3Qud3RPdmVybGF5cy5sZWZ0T3ZlcmxheS5jbG9uZS53dFRhYmxlLmhvbGRlci5wYXJlbnROb2RlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Nvcm5lcic6XG4gICAgICBjc3NUcmFuc2Zvcm1PZmZzZXQgPSBnZXRDc3NUcmFuc2Zvcm0odGhpcy5pbnN0YW5jZS52aWV3Lnd0Lnd0T3ZlcmxheXMudG9wTGVmdENvcm5lck92ZXJsYXkuY2xvbmUud3RUYWJsZS5ob2xkZXIucGFyZW50Tm9kZSk7XG4gICAgICBicmVhaztcbiAgfVxuICBpZiAodGhpcy5pbnN0YW5jZS5nZXRTZWxlY3RlZCgpWzBdID09PSAwKSB7XG4gICAgZWRpdFRvcCArPSAxO1xuICB9XG5cbiAgaWYgKHRoaXMuaW5zdGFuY2UuZ2V0U2VsZWN0ZWQoKVsxXSA9PT0gMCkge1xuICAgIGVkaXRMZWZ0ICs9IDE7XG4gIH1cblxuICB2YXIgc2VsZWN0U3R5bGUgPSB0aGlzLnNlbGVjdC5zdHlsZTtcblxuICBpZiAoY3NzVHJhbnNmb3JtT2Zmc2V0ICYmIGNzc1RyYW5zZm9ybU9mZnNldCAhPSAtMSkge1xuICAgIHNlbGVjdFN0eWxlW2Nzc1RyYW5zZm9ybU9mZnNldFswXV0gPSBjc3NUcmFuc2Zvcm1PZmZzZXRbMV07XG4gIH0gZWxzZSB7XG4gICAgcmVzZXRDc3NUcmFuc2Zvcm0odGhpcy5zZWxlY3QpO1xuICB9XG4gIGNvbnN0IGNlbGxDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLlREKTtcblxuICBpZiAocGFyc2VJbnQoY2VsbENvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGgsIDEwKSA+IDApIHtcbiAgICBoZWlnaHQgLT0gMTtcbiAgfVxuICBpZiAocGFyc2VJbnQoY2VsbENvbXB1dGVkU3R5bGUuYm9yZGVyTGVmdFdpZHRoLCAxMCkgPiAwKSB7XG4gICAgd2lkdGggLT0gMTtcbiAgfVxuXG4gIHNlbGVjdFN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gIHNlbGVjdFN0eWxlLm1pbldpZHRoID0gd2lkdGggKyAncHgnO1xuICBzZWxlY3RTdHlsZS50b3AgPSBlZGl0VG9wICsgJ3B4JztcbiAgc2VsZWN0U3R5bGUubGVmdCA9IGVkaXRMZWZ0ICsgJ3B4JztcbiAgc2VsZWN0U3R5bGUubWFyZ2luID0gJzBweCc7XG59O1xuXG5TZWxlY3RFZGl0b3IucHJvdG90eXBlLmdldEVkaXRlZENlbGwgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGVkaXRvclNlY3Rpb24gPSB0aGlzLmNoZWNrRWRpdG9yU2VjdGlvbigpLFxuICAgIGVkaXRlZENlbGw7XG5cbiAgc3dpdGNoIChlZGl0b3JTZWN0aW9uKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICAgIGVkaXRlZENlbGwgPSB0aGlzLmluc3RhbmNlLnZpZXcud3Qud3RPdmVybGF5cy50b3BPdmVybGF5LmNsb25lLnd0VGFibGUuZ2V0Q2VsbCh7XG4gICAgICAgIHJvdzogdGhpcy5yb3csXG4gICAgICAgIGNvbDogdGhpcy5jb2xcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWxlY3Quc3R5bGUuekluZGV4ID0gMTAxO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY29ybmVyJzpcbiAgICAgIGVkaXRlZENlbGwgPSB0aGlzLmluc3RhbmNlLnZpZXcud3Qud3RPdmVybGF5cy50b3BMZWZ0Q29ybmVyT3ZlcmxheS5jbG9uZS53dFRhYmxlLmdldENlbGwoe1xuICAgICAgICByb3c6IHRoaXMucm93LFxuICAgICAgICBjb2w6IHRoaXMuY29sXG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2VsZWN0LnN0eWxlLnpJbmRleCA9IDEwMztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgZWRpdGVkQ2VsbCA9IHRoaXMuaW5zdGFuY2Uudmlldy53dC53dE92ZXJsYXlzLmxlZnRPdmVybGF5LmNsb25lLnd0VGFibGUuZ2V0Q2VsbCh7XG4gICAgICAgIHJvdzogdGhpcy5yb3csXG4gICAgICAgIGNvbDogdGhpcy5jb2xcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWxlY3Quc3R5bGUuekluZGV4ID0gMTAyO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGVkaXRlZENlbGwgPSB0aGlzLmluc3RhbmNlLmdldENlbGwodGhpcy5yb3csIHRoaXMuY29sKTtcbiAgICAgIHRoaXMuc2VsZWN0LnN0eWxlLnpJbmRleCA9ICcnO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gZWRpdGVkQ2VsbCAhPSAtMSAmJiBlZGl0ZWRDZWxsICE9IC0yID8gZWRpdGVkQ2VsbCA6IHZvaWQgMDtcbn07XG5cbmV4cG9ydCB7U2VsZWN0RWRpdG9yfTtcblxucmVnaXN0ZXJFZGl0b3IoJ3NlbGVjdCcsIFNlbGVjdEVkaXRvcik7XG5cbiIsIlxuaW1wb3J0IHtcbiAgYWRkQ2xhc3MsXG4gIGdldENhcmV0UG9zaXRpb24sXG4gIGdldENvbXB1dGVkU3R5bGUsXG4gIGdldENzc1RyYW5zZm9ybSxcbiAgZ2V0U2Nyb2xsYWJsZUVsZW1lbnQsXG4gIGlubmVyV2lkdGgsXG4gIG9mZnNldCxcbiAgcmVzZXRDc3NUcmFuc2Zvcm0sXG4gIHNldENhcmV0UG9zaXRpb24sXG4gICAgfSBmcm9tICcuLy4uL2hlbHBlcnMvZG9tL2VsZW1lbnQnO1xuaW1wb3J0IGF1dG9SZXNpemUgZnJvbSAnYXV0b1Jlc2l6ZSc7XG5pbXBvcnQge0Jhc2VFZGl0b3J9IGZyb20gJy4vX2Jhc2VFZGl0b3InO1xuaW1wb3J0IHtldmVudE1hbmFnZXIgYXMgZXZlbnRNYW5hZ2VyT2JqZWN0fSBmcm9tICcuLy4uL2V2ZW50TWFuYWdlcic7XG5pbXBvcnQge2dldEVkaXRvciwgcmVnaXN0ZXJFZGl0b3J9IGZyb20gJy4vLi4vZWRpdG9ycyc7XG5pbXBvcnQge0tFWV9DT0RFU30gZnJvbSAnLi8uLi9oZWxwZXJzL3VuaWNvZGUnO1xuaW1wb3J0IHtzdG9wUHJvcGFnYXRpb24sIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiwgaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWR9IGZyb20gJy4vLi4vaGVscGVycy9kb20vZXZlbnQnO1xuXG52YXIgVGV4dEVkaXRvciA9IEJhc2VFZGl0b3IucHJvdG90eXBlLmV4dGVuZCgpO1xuXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBlZGl0b3IgVGV4dEVkaXRvclxuICogQGNsYXNzIFRleHRFZGl0b3JcbiAqIEBkZXBlbmRlbmNpZXMgYXV0b1Jlc2l6ZVxuICovXG5UZXh0RWRpdG9yLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0aGF0ID0gdGhpcztcbiAgdGhpcy5jcmVhdGVFbGVtZW50cygpO1xuICB0aGlzLmV2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlck9iamVjdCh0aGlzKTtcbiAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gIHRoaXMuYXV0b1Jlc2l6ZSA9IGF1dG9SZXNpemUoKTtcblxuICB0aGlzLmluc3RhbmNlLmFkZEhvb2soJ2FmdGVyRGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgIHRoYXQuZGVzdHJveSgpO1xuICB9KTtcbn07XG5cblRleHRFZGl0b3IucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLlRFWFRBUkVBLnZhbHVlO1xufTtcblxuVGV4dEVkaXRvci5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICB0aGlzLlRFWFRBUkVBLnZhbHVlID0gbmV3VmFsdWU7XG59O1xuXG52YXIgb25CZWZvcmVLZXlEb3duID0gZnVuY3Rpb24gb25CZWZvcmVLZXlEb3duKGV2ZW50KSB7XG4gIHZhciBpbnN0YW5jZSA9IHRoaXMsXG4gICAgdGhhdCA9IGluc3RhbmNlLmdldEFjdGl2ZUVkaXRvcigpLFxuICAgIGN0cmxEb3duO1xuXG4gIC8vIGNhdGNoIENUUkwgYnV0IG5vdCByaWdodCBBTFQgKHdoaWNoIGluIHNvbWUgc3lzdGVtcyB0cmlnZ2VycyBBTFQrQ1RSTClcbiAgY3RybERvd24gPSAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSAmJiAhZXZlbnQuYWx0S2V5O1xuXG4gIC8vIFByb2Nlc3Mgb25seSBldmVudHMgdGhhdCBoYXZlIGJlZW4gZmlyZWQgaW4gdGhlIGVkaXRvclxuICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGF0LlRFWFRBUkVBIHx8IGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKGV2ZW50KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChldmVudC5rZXlDb2RlID09PSAxNyB8fCBldmVudC5rZXlDb2RlID09PSAyMjQgfHwgZXZlbnQua2V5Q29kZSA9PT0gOTEgfHwgZXZlbnQua2V5Q29kZSA9PT0gOTMpIHtcbiAgICAvLyB3aGVuIENUUkwgb3IgaXRzIGVxdWl2YWxlbnQgaXMgcHJlc3NlZCBhbmQgY2VsbCBpcyBlZGl0ZWQsIGRvbid0IHByZXBhcmUgc2VsZWN0YWJsZSB0ZXh0IGluIHRleHRhcmVhXG4gICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICBjYXNlIEtFWV9DT0RFUy5BUlJPV19SSUdIVDpcbiAgICAgIGlmICh0aGF0LmlzSW5GdWxsRWRpdE1vZGUoKSkge1xuICAgICAgICBpZiAoKCF0aGF0LmlzV2FpdGluZygpICYmICF0aGF0LmFsbG93S2V5RXZlbnRQcm9wYWdhdGlvbikgfHxcbiAgICAgICAgICAgICghdGhhdC5pc1dhaXRpbmcoKSAmJiB0aGF0LmFsbG93S2V5RXZlbnRQcm9wYWdhdGlvbiAmJiAhdGhhdC5hbGxvd0tleUV2ZW50UHJvcGFnYXRpb24oZXZlbnQua2V5Q29kZSkpKSB7XG4gICAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBLRVlfQ09ERVMuQVJST1dfTEVGVDpcbiAgICAgIGlmICh0aGF0LmlzSW5GdWxsRWRpdE1vZGUoKSkge1xuICAgICAgICBpZiAoKCF0aGF0LmlzV2FpdGluZygpICYmICF0aGF0LmFsbG93S2V5RXZlbnRQcm9wYWdhdGlvbikgfHxcbiAgICAgICAgICAgICghdGhhdC5pc1dhaXRpbmcoKSAmJiB0aGF0LmFsbG93S2V5RXZlbnRQcm9wYWdhdGlvbiAmJiAhdGhhdC5hbGxvd0tleUV2ZW50UHJvcGFnYXRpb24oZXZlbnQua2V5Q29kZSkpKSB7XG4gICAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBLRVlfQ09ERVMuQVJST1dfVVA6XG4gICAgY2FzZSBLRVlfQ09ERVMuQVJST1dfRE9XTjpcbiAgICAgIGlmICh0aGF0LmlzSW5GdWxsRWRpdE1vZGUoKSkge1xuICAgICAgICBpZiAoKCF0aGF0LmlzV2FpdGluZygpICYmICF0aGF0LmFsbG93S2V5RXZlbnRQcm9wYWdhdGlvbikgfHxcbiAgICAgICAgICAgICghdGhhdC5pc1dhaXRpbmcoKSAmJiB0aGF0LmFsbG93S2V5RXZlbnRQcm9wYWdhdGlvbiAmJiAhdGhhdC5hbGxvd0tleUV2ZW50UHJvcGFnYXRpb24oZXZlbnQua2V5Q29kZSkpKSB7XG4gICAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEtFWV9DT0RFUy5FTlRFUjpcbiAgICAgIHZhciBzZWxlY3RlZCA9IHRoYXQuaW5zdGFuY2UuZ2V0U2VsZWN0ZWQoKTtcbiAgICAgIHZhciBpc011bHRpcGxlU2VsZWN0aW9uID0gIShzZWxlY3RlZFswXSA9PT0gc2VsZWN0ZWRbMl0gJiYgc2VsZWN0ZWRbMV0gPT09IHNlbGVjdGVkWzNdKTtcbiAgICAgIGlmICgoY3RybERvd24gJiYgIWlzTXVsdGlwbGVTZWxlY3Rpb24pIHx8IGV2ZW50LmFsdEtleSkgeyAvL2lmIGN0cmwrZW50ZXIgb3IgYWx0K2VudGVyLCBhZGQgbmV3IGxpbmVcbiAgICAgICAgaWYgKHRoYXQuaXNPcGVuZWQoKSkge1xuICAgICAgICAgIHZhciBjYXJldFBvc2l0aW9uID0gZ2V0Q2FyZXRQb3NpdGlvbih0aGF0LlRFWFRBUkVBKSxcbiAgICAgICAgICAgIHZhbHVlID0gdGhhdC5nZXRWYWx1ZSgpO1xuXG4gICAgICAgICAgdmFyIG5ld1ZhbHVlID0gdmFsdWUuc2xpY2UoMCwgY2FyZXRQb3NpdGlvbikgKyAnXFxuJyArIHZhbHVlLnNsaWNlKGNhcmV0UG9zaXRpb24pO1xuXG4gICAgICAgICAgdGhhdC5zZXRWYWx1ZShuZXdWYWx1ZSk7XG5cbiAgICAgICAgICBzZXRDYXJldFBvc2l0aW9uKHRoYXQuVEVYVEFSRUEsIGNhcmV0UG9zaXRpb24gKyAxKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoYXQuYmVnaW5FZGl0aW5nKHRoYXQub3JpZ2luYWxWYWx1ZSArICdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oZXZlbnQpO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy9kb24ndCBhZGQgbmV3bGluZSB0byBmaWVsZFxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEtFWV9DT0RFUy5BOlxuICAgIGNhc2UgS0VZX0NPREVTLlg6XG4gICAgY2FzZSBLRVlfQ09ERVMuQzpcbiAgICBjYXNlIEtFWV9DT0RFUy5WOlxuICAgICAgaWYgKGN0cmxEb3duKSB7XG4gICAgICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihldmVudCk7IC8vQ1RSTCtBLCBDVFJMK0MsIENUUkwrViwgQ1RSTCtYIHNob3VsZCBvbmx5IHdvcmsgbG9jYWxseSB3aGVuIGNlbGwgaXMgZWRpdGVkIChub3QgaW4gdGFibGUgY29udGV4dClcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBLRVlfQ09ERVMuQkFDS1NQQUNFOlxuICAgIGNhc2UgS0VZX0NPREVTLkRFTEVURTpcbiAgICBjYXNlIEtFWV9DT0RFUy5IT01FOlxuICAgIGNhc2UgS0VZX0NPREVTLkVORDpcbiAgICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihldmVudCk7IC8vYmFja3NwYWNlLCBkZWxldGUsIGhvbWUsIGVuZCBzaG91bGQgb25seSB3b3JrIGxvY2FsbHkgd2hlbiBjZWxsIGlzIGVkaXRlZCAobm90IGluIHRhYmxlIGNvbnRleHQpXG4gICAgICBicmVhaztcbiAgfVxuXG4gIGlmIChbS0VZX0NPREVTLkFSUk9XX1VQLCBLRVlfQ09ERVMuQVJST1dfUklHSFQsIEtFWV9DT0RFUy5BUlJPV19ET1dOLCBLRVlfQ09ERVMuQVJST1dfTEVGVF0uaW5kZXhPZihldmVudC5rZXlDb2RlKSA9PT0gLTEpIHtcbiAgICB0aGF0LmF1dG9SZXNpemUucmVzaXplKFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQua2V5Q29kZSkpO1xuICB9XG59O1xuXG5cblxuVGV4dEVkaXRvci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlZnJlc2hEaW1lbnNpb25zKCk7IC8vbmVlZCBpdCBpbnN0YW50bHksIHRvIHByZXZlbnQgaHR0cHM6Ly9naXRodWIuY29tL2hhbmRzb250YWJsZS9oYW5kc29udGFibGUvaXNzdWVzLzM0OFxuXG4gIHRoaXMuaW5zdGFuY2UuYWRkSG9vaygnYmVmb3JlS2V5RG93bicsIG9uQmVmb3JlS2V5RG93bik7XG59O1xuXG5UZXh0RWRpdG9yLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnRleHRhcmVhUGFyZW50U3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICB0aGlzLmF1dG9SZXNpemUudW5PYnNlcnZlKCk7XG5cbiAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuVEVYVEFSRUEpIHtcbiAgICB0aGlzLmluc3RhbmNlLmxpc3RlbigpOyAvL2Rvbid0IHJlZm9jdXMgdGhlIHRhYmxlIGlmIHVzZXIgZm9jdXNlZCBzb21lIGNlbGwgb3V0c2lkZSBvZiBIVCBvbiBwdXJwb3NlXG4gIH1cbiAgdGhpcy5pbnN0YW5jZS5yZW1vdmVIb29rKCdiZWZvcmVLZXlEb3duJywgb25CZWZvcmVLZXlEb3duKTtcbn07XG5cblRleHRFZGl0b3IucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuVEVYVEFSRUEuZm9jdXMoKTtcbiAgc2V0Q2FyZXRQb3NpdGlvbih0aGlzLlRFWFRBUkVBLCB0aGlzLlRFWFRBUkVBLnZhbHVlLmxlbmd0aCk7XG59O1xuXG5UZXh0RWRpdG9yLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50cyA9IGZ1bmN0aW9uKCkge1xuICAvLyAgICB0aGlzLiRib2R5ID0gJChkb2N1bWVudC5ib2R5KTtcblxuICB0aGlzLlRFWFRBUkVBID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnVEVYVEFSRUEnKTtcblxuICBhZGRDbGFzcyh0aGlzLlRFWFRBUkVBLCAnaGFuZHNvbnRhYmxlSW5wdXQnKTtcblxuICB0aGlzLnRleHRhcmVhU3R5bGUgPSB0aGlzLlRFWFRBUkVBLnN0eWxlO1xuICB0aGlzLnRleHRhcmVhU3R5bGUud2lkdGggPSAwO1xuICB0aGlzLnRleHRhcmVhU3R5bGUuaGVpZ2h0ID0gMDtcblxuICB0aGlzLlRFWFRBUkVBX1BBUkVOVCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0RJVicpO1xuICBhZGRDbGFzcyh0aGlzLlRFWFRBUkVBX1BBUkVOVCwgJ2hhbmRzb250YWJsZUlucHV0SG9sZGVyJyk7XG5cbiAgdGhpcy50ZXh0YXJlYVBhcmVudFN0eWxlID0gdGhpcy5URVhUQVJFQV9QQVJFTlQuc3R5bGU7XG4gIHRoaXMudGV4dGFyZWFQYXJlbnRTdHlsZS50b3AgPSAwO1xuICB0aGlzLnRleHRhcmVhUGFyZW50U3R5bGUubGVmdCA9IDA7XG4gIHRoaXMudGV4dGFyZWFQYXJlbnRTdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gIHRoaXMuVEVYVEFSRUFfUEFSRU5ULmFwcGVuZENoaWxkKHRoaXMuVEVYVEFSRUEpO1xuXG4gIHRoaXMuaW5zdGFuY2Uucm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5URVhUQVJFQV9QQVJFTlQpO1xuXG4gIHZhciB0aGF0ID0gdGhpcztcbiAgdGhpcy5pbnN0YW5jZS5fcmVnaXN0ZXJUaW1lb3V0KHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgdGhhdC5yZWZyZXNoRGltZW5zaW9ucygpO1xuICB9LCAwKSk7XG59O1xuXG5UZXh0RWRpdG9yLnByb3RvdHlwZS5jaGVja0VkaXRvclNlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucm93IDwgdGhpcy5pbnN0YW5jZS5nZXRTZXR0aW5ncygpLmZpeGVkUm93c1RvcCkge1xuICAgIGlmICh0aGlzLmNvbCA8IHRoaXMuaW5zdGFuY2UuZ2V0U2V0dGluZ3MoKS5maXhlZENvbHVtbnNMZWZ0KSB7XG4gICAgICByZXR1cm4gJ2Nvcm5lcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAndG9wJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuY29sIDwgdGhpcy5pbnN0YW5jZS5nZXRTZXR0aW5ncygpLmZpeGVkQ29sdW1uc0xlZnQpIHtcbiAgICAgIHJldHVybiAnbGVmdCc7XG4gICAgfVxuICB9XG59O1xuXG5UZXh0RWRpdG9yLnByb3RvdHlwZS5nZXRFZGl0ZWRDZWxsID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlZGl0b3JTZWN0aW9uID0gdGhpcy5jaGVja0VkaXRvclNlY3Rpb24oKSxcbiAgICBlZGl0ZWRDZWxsO1xuXG4gIHN3aXRjaCAoZWRpdG9yU2VjdGlvbikge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICBlZGl0ZWRDZWxsID0gdGhpcy5pbnN0YW5jZS52aWV3Lnd0Lnd0T3ZlcmxheXMudG9wT3ZlcmxheS5jbG9uZS53dFRhYmxlLmdldENlbGwoe1xuICAgICAgICByb3c6IHRoaXMucm93LFxuICAgICAgICBjb2w6IHRoaXMuY29sXG4gICAgICB9KTtcbiAgICAgIHRoaXMudGV4dGFyZWFQYXJlbnRTdHlsZS56SW5kZXggPSAxMDE7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjb3JuZXInOlxuICAgICAgZWRpdGVkQ2VsbCA9IHRoaXMuaW5zdGFuY2Uudmlldy53dC53dE92ZXJsYXlzLnRvcExlZnRDb3JuZXJPdmVybGF5LmNsb25lLnd0VGFibGUuZ2V0Q2VsbCh7XG4gICAgICAgIHJvdzogdGhpcy5yb3csXG4gICAgICAgIGNvbDogdGhpcy5jb2xcbiAgICAgIH0pO1xuICAgICAgdGhpcy50ZXh0YXJlYVBhcmVudFN0eWxlLnpJbmRleCA9IDEwMztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgZWRpdGVkQ2VsbCA9IHRoaXMuaW5zdGFuY2Uudmlldy53dC53dE92ZXJsYXlzLmxlZnRPdmVybGF5LmNsb25lLnd0VGFibGUuZ2V0Q2VsbCh7XG4gICAgICAgIHJvdzogdGhpcy5yb3csXG4gICAgICAgIGNvbDogdGhpcy5jb2xcbiAgICAgIH0pO1xuICAgICAgdGhpcy50ZXh0YXJlYVBhcmVudFN0eWxlLnpJbmRleCA9IDEwMjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBlZGl0ZWRDZWxsID0gdGhpcy5pbnN0YW5jZS5nZXRDZWxsKHRoaXMucm93LCB0aGlzLmNvbCk7XG4gICAgICB0aGlzLnRleHRhcmVhUGFyZW50U3R5bGUuekluZGV4ID0gXCJcIjtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGVkaXRlZENlbGwgIT0gLTEgJiYgZWRpdGVkQ2VsbCAhPSAtMiA/IGVkaXRlZENlbGwgOiB2b2lkIDA7XG59O1xuXG5cblRleHRFZGl0b3IucHJvdG90eXBlLnJlZnJlc2hEaW1lbnNpb25zID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnN0YXRlICE9PSBIYW5kc29udGFibGUuRWRpdG9yU3RhdGUuRURJVElORykge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLlREID0gdGhpcy5nZXRFZGl0ZWRDZWxsKCk7XG5cbiAgLy8gVEQgaXMgb3V0c2lkZSBvZiB0aGUgdmlld3BvcnQuXG4gIGlmICghdGhpcy5URCkge1xuICAgIHRoaXMuY2xvc2UoKTtcblxuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY3VycmVudE9mZnNldCA9IG9mZnNldCh0aGlzLlREKSxcbiAgICBjb250YWluZXJPZmZzZXQgPSBvZmZzZXQodGhpcy5pbnN0YW5jZS5yb290RWxlbWVudCksXG4gICAgc2Nyb2xsYWJsZUNvbnRhaW5lciA9IGdldFNjcm9sbGFibGVFbGVtZW50KHRoaXMuVEQpLFxuICAgIGVkaXRUb3AgPSBjdXJyZW50T2Zmc2V0LnRvcCAtIGNvbnRhaW5lck9mZnNldC50b3AgLSAxIC0gKHNjcm9sbGFibGVDb250YWluZXIuc2Nyb2xsVG9wIHx8IDApLFxuICAgIGVkaXRMZWZ0ID0gY3VycmVudE9mZnNldC5sZWZ0IC0gY29udGFpbmVyT2Zmc2V0LmxlZnQgLSAxIC0gKHNjcm9sbGFibGVDb250YWluZXIuc2Nyb2xsTGVmdCB8fCAwKSxcblxuICAgIHNldHRpbmdzID0gdGhpcy5pbnN0YW5jZS5nZXRTZXR0aW5ncygpLFxuICAgIHJvd0hlYWRlcnNDb3VudCA9IHNldHRpbmdzLnJvd0hlYWRlcnMgPyAxIDogMCxcbiAgICBjb2xIZWFkZXJzQ291bnQgPSBzZXR0aW5ncy5jb2xIZWFkZXJzID8gMSA6IDAsXG4gICAgZWRpdG9yU2VjdGlvbiA9IHRoaXMuY2hlY2tFZGl0b3JTZWN0aW9uKCksXG4gICAgYmFja2dyb3VuZENvbG9yID0gdGhpcy5URC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgY3NzVHJhbnNmb3JtT2Zmc2V0O1xuXG4gIC8vIFRPRE86IFJlZmFjdG9yIHRoaXMgdG8gdGhlIG5ldyBpbnN0YW5jZS5nZXRDZWxsIG1ldGhvZCAoZnJvbSAjcGx5LTU5KSwgYWZ0ZXIgMC4xMi4xIGlzIHJlbGVhc2VkXG4gIHN3aXRjaCAoZWRpdG9yU2VjdGlvbikge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICBjc3NUcmFuc2Zvcm1PZmZzZXQgPSBnZXRDc3NUcmFuc2Zvcm0odGhpcy5pbnN0YW5jZS52aWV3Lnd0Lnd0T3ZlcmxheXMudG9wT3ZlcmxheS5jbG9uZS53dFRhYmxlLmhvbGRlci5wYXJlbnROb2RlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgY3NzVHJhbnNmb3JtT2Zmc2V0ID0gZ2V0Q3NzVHJhbnNmb3JtKHRoaXMuaW5zdGFuY2Uudmlldy53dC53dE92ZXJsYXlzLmxlZnRPdmVybGF5LmNsb25lLnd0VGFibGUuaG9sZGVyLnBhcmVudE5vZGUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY29ybmVyJzpcbiAgICAgIGNzc1RyYW5zZm9ybU9mZnNldCA9IGdldENzc1RyYW5zZm9ybSh0aGlzLmluc3RhbmNlLnZpZXcud3Qud3RPdmVybGF5cy50b3BMZWZ0Q29ybmVyT3ZlcmxheS5jbG9uZS53dFRhYmxlLmhvbGRlci5wYXJlbnROb2RlKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgaWYgKHRoaXMuaW5zdGFuY2UuZ2V0U2VsZWN0ZWQoKVswXSA9PT0gMCkge1xuICAgIGVkaXRUb3AgKz0gMTtcbiAgfVxuXG4gIGlmICh0aGlzLmluc3RhbmNlLmdldFNlbGVjdGVkKClbMV0gPT09IDApIHtcbiAgICBlZGl0TGVmdCArPSAxO1xuICB9XG5cbiAgaWYgKGNzc1RyYW5zZm9ybU9mZnNldCAmJiBjc3NUcmFuc2Zvcm1PZmZzZXQgIT0gLTEpIHtcbiAgICB0aGlzLnRleHRhcmVhUGFyZW50U3R5bGVbY3NzVHJhbnNmb3JtT2Zmc2V0WzBdXSA9IGNzc1RyYW5zZm9ybU9mZnNldFsxXTtcbiAgfSBlbHNlIHtcbiAgICByZXNldENzc1RyYW5zZm9ybSh0aGlzLnRleHRhcmVhUGFyZW50U3R5bGUpO1xuICB9XG5cbiAgdGhpcy50ZXh0YXJlYVBhcmVudFN0eWxlLnRvcCA9IGVkaXRUb3AgKyAncHgnO1xuICB0aGlzLnRleHRhcmVhUGFyZW50U3R5bGUubGVmdCA9IGVkaXRMZWZ0ICsgJ3B4JztcbiAgLy8vZW5kIHByZXBhcmUgdGV4dGFyZWEgcG9zaXRpb25cblxuICB2YXIgY2VsbFRvcE9mZnNldCA9IHRoaXMuVEQub2Zmc2V0VG9wIC0gdGhpcy5pbnN0YW5jZS52aWV3Lnd0Lnd0T3ZlcmxheXMudG9wT3ZlcmxheS5nZXRTY3JvbGxQb3NpdGlvbigpLFxuICAgIGNlbGxMZWZ0T2Zmc2V0ID0gdGhpcy5URC5vZmZzZXRMZWZ0IC0gdGhpcy5pbnN0YW5jZS52aWV3Lnd0Lnd0T3ZlcmxheXMubGVmdE92ZXJsYXkuZ2V0U2Nyb2xsUG9zaXRpb24oKTtcblxuICBsZXQgd2lkdGggPSBpbm5lcldpZHRoKHRoaXMuVEQpIC0gODtcbiAgLy8gMTAgaXMgVEVYVEFSRUFzIHBhZGRpbmdcbiAgbGV0IG1heFdpZHRoID0gdGhpcy5pbnN0YW5jZS52aWV3Lm1heGltdW1WaXNpYmxlRWxlbWVudFdpZHRoKGNlbGxMZWZ0T2Zmc2V0KSAtIDk7XG4gIGxldCBoZWlnaHQgPSB0aGlzLlRELnNjcm9sbEhlaWdodCArIDE7XG4gIC8vIDEwIGlzIFRFWFRBUkVBcyBib3JkZXIgYW5kIHBhZGRpbmdcbiAgbGV0IG1heEhlaWdodCA9IE1hdGgubWF4KHRoaXMuaW5zdGFuY2Uudmlldy5tYXhpbXVtVmlzaWJsZUVsZW1lbnRIZWlnaHQoY2VsbFRvcE9mZnNldCkgLSAyLCAyMyk7XG5cbiAgY29uc3QgY2VsbENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuVEQpO1xuXG4gIHRoaXMuVEVYVEFSRUEuc3R5bGUuZm9udFNpemUgPSBjZWxsQ29tcHV0ZWRTdHlsZS5mb250U2l6ZTtcbiAgdGhpcy5URVhUQVJFQS5zdHlsZS5mb250RmFtaWx5ID0gY2VsbENvbXB1dGVkU3R5bGUuZm9udEZhbWlseTtcblxuICB0aGlzLlRFWFRBUkVBLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcnOyAvL1JFU0VUIFNUWUxFXG5cbiAgdGhpcy5URVhUQVJFQS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBiYWNrZ3JvdW5kQ29sb3IgPyBiYWNrZ3JvdW5kQ29sb3IgOiBnZXRDb21wdXRlZFN0eWxlKHRoaXMuVEVYVEFSRUEpLmJhY2tncm91bmRDb2xvcjtcblxuICB0aGlzLmF1dG9SZXNpemUuaW5pdCh0aGlzLlRFWFRBUkVBLCB7XG4gICAgbWluSGVpZ2h0OiBNYXRoLm1pbihoZWlnaHQsIG1heEhlaWdodCksXG4gICAgbWF4SGVpZ2h0OiBtYXhIZWlnaHQsIC8vVEVYVEFSRUEgc2hvdWxkIG5ldmVyIGJlIHdpZGVyIHRoYW4gdmlzaWJsZSBwYXJ0IG9mIHRoZSB2aWV3cG9ydCAoc2hvdWxkIG5vdCBjb3ZlciB0aGUgc2Nyb2xsYmFyKVxuICAgIG1pbldpZHRoOiBNYXRoLm1pbih3aWR0aCwgbWF4V2lkdGgpLFxuICAgIG1heFdpZHRoOiBtYXhXaWR0aCAvL1RFWFRBUkVBIHNob3VsZCBuZXZlciBiZSB3aWRlciB0aGFuIHZpc2libGUgcGFydCBvZiB0aGUgdmlld3BvcnQgKHNob3VsZCBub3QgY292ZXIgdGhlIHNjcm9sbGJhcilcbiAgfSwgdHJ1ZSk7XG5cbiAgdGhpcy50ZXh0YXJlYVBhcmVudFN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xufTtcblxuVGV4dEVkaXRvci5wcm90b3R5cGUuYmluZEV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZWRpdG9yID0gdGhpcztcblxuICB0aGlzLmV2ZW50TWFuYWdlci5hZGRFdmVudExpc3RlbmVyKHRoaXMuVEVYVEFSRUEsICdjdXQnLCBmdW5jdGlvbihldmVudCkge1xuICAgIHN0b3BQcm9wYWdhdGlvbihldmVudCk7XG4gIH0pO1xuXG4gIHRoaXMuZXZlbnRNYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5URVhUQVJFQSwgJ3Bhc3RlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBzdG9wUHJvcGFnYXRpb24oZXZlbnQpO1xuICB9KTtcblxuICB0aGlzLmluc3RhbmNlLmFkZEhvb2soJ2FmdGVyU2Nyb2xsVmVydGljYWxseScsIGZ1bmN0aW9uKCkge1xuICAgIGVkaXRvci5yZWZyZXNoRGltZW5zaW9ucygpO1xuICB9KTtcblxuICB0aGlzLmluc3RhbmNlLmFkZEhvb2soJ2FmdGVyQ29sdW1uUmVzaXplJywgZnVuY3Rpb24oKSB7XG4gICAgZWRpdG9yLnJlZnJlc2hEaW1lbnNpb25zKCk7XG4gICAgZWRpdG9yLmZvY3VzKCk7XG4gIH0pO1xuXG4gIHRoaXMuaW5zdGFuY2UuYWRkSG9vaygnYWZ0ZXJSb3dSZXNpemUnLCBmdW5jdGlvbigpIHtcbiAgICBlZGl0b3IucmVmcmVzaERpbWVuc2lvbnMoKTtcbiAgICBlZGl0b3IuZm9jdXMoKTtcbiAgfSk7XG5cbiAgdGhpcy5pbnN0YW5jZS5hZGRIb29rKCdhZnRlckRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICBlZGl0b3IuZXZlbnRNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgfSk7XG59O1xuXG5UZXh0RWRpdG9yLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZXZlbnRNYW5hZ2VyLmRlc3Ryb3koKTtcbn07XG5cbmV4cG9ydCB7VGV4dEVkaXRvcn07XG5cbnJlZ2lzdGVyRWRpdG9yKCd0ZXh0JywgVGV4dEVkaXRvcik7XG4iLCJcbmltcG9ydCB7cG9seW1lcldyYXAsIGNsb3Nlc3R9IGZyb20gJy4vaGVscGVycy9kb20vZWxlbWVudCc7XG5pbXBvcnQge2lzV2ViQ29tcG9uZW50U3VwcG9ydGVkTmF0aXZlbHl9IGZyb20gJy4vaGVscGVycy9icm93c2VyJztcblxuXG4vKipcbiAqIEV2ZW50IERPTSBtYW5hZ2VyIGZvciBpbnRlcm5hbCB1c2UgaW4gSGFuZHNvbnRhYmxlLlxuICpcbiAqIEBjbGFzcyBFdmVudE1hbmFnZXJcbiAqIEBwcml2YXRlXG4gKiBAdXRpbFxuICovXG5jbGFzcyBFdmVudE1hbmFnZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0PW51bGxdXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb250ZXh0ID0gbnVsbCkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcztcblxuICAgIGlmICghdGhpcy5jb250ZXh0LmV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLmNvbnRleHQuZXZlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBmdW5jdGlvbiB3aGljaCB5b3UgY2FuIGVhc2lseSBjYWxsIHRvIHJlbW92ZSB0aGF0IGV2ZW50XG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICBsZXQgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgIGZ1bmN0aW9uIGNhbGxiYWNrUHJveHkoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC50YXJnZXQgPT0gdm9pZCAwICYmIGV2ZW50LnNyY0VsZW1lbnQgIT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChldmVudC5kZWZpbmVQb3BlcnR5KSB7XG4gICAgICAgICAgZXZlbnQuZGVmaW5lUG9wZXJ0eSgndGFyZ2V0Jywge1xuICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnNyY0VsZW1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBldmVudC50YXJnZXQgPSBldmVudC5zcmNFbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQgPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChldmVudC5kZWZpbmVQb3BlcnR5KSB7XG4gICAgICAgICAgZXZlbnQuZGVmaW5lUG9wZXJ0eSgncHJldmVudERlZmF1bHQnLCB7XG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHRoaXMucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBldmVudCA9IGV4dGVuZEV2ZW50KGNvbnRleHQsIGV2ZW50KTtcblxuICAgICAgLyoganNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gICAgdGhpcy5jb250ZXh0LmV2ZW50TGlzdGVuZXJzLnB1c2goe1xuICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgIGV2ZW50OiBldmVudE5hbWUsXG4gICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICBjYWxsYmFja1Byb3h5OiBjYWxsYmFja1Byb3h5XG4gICAgfSk7XG5cbiAgICBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrUHJveHksIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnROYW1lLCBjYWxsYmFja1Byb3h5KTtcbiAgICB9XG4gICAgSGFuZHNvbnRhYmxlLmNvdW50RXZlbnRNYW5hZ2VyTGlzdGVuZXJzICsrO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBldmVudFxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgbGV0IGxlbiA9IHRoaXMuY29udGV4dC5ldmVudExpc3RlbmVycy5sZW5ndGg7XG4gICAgbGV0IHRtcEV2ZW50O1xuXG4gICAgd2hpbGUgKGxlbi0tKSB7XG4gICAgICB0bXBFdmVudCA9IHRoaXMuY29udGV4dC5ldmVudExpc3RlbmVyc1tsZW5dO1xuXG4gICAgICBpZiAodG1wRXZlbnQuZXZlbnQgPT0gZXZlbnROYW1lICYmIHRtcEV2ZW50LmVsZW1lbnQgPT0gZWxlbWVudCkge1xuICAgICAgICBpZiAoY2FsbGJhY2sgJiYgY2FsbGJhY2sgIT0gdG1wRXZlbnQuY2FsbGJhY2spIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRleHQuZXZlbnRMaXN0ZW5lcnMuc3BsaWNlKGxlbiwgMSk7XG5cbiAgICAgICAgaWYgKHRtcEV2ZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgIHRtcEV2ZW50LmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0bXBFdmVudC5ldmVudCwgdG1wRXZlbnQuY2FsbGJhY2tQcm94eSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRtcEV2ZW50LmVsZW1lbnQuZGV0YWNoRXZlbnQoJ29uJyArIHRtcEV2ZW50LmV2ZW50LCB0bXBFdmVudC5jYWxsYmFja1Byb3h5KTtcbiAgICAgICAgfVxuICAgICAgICBIYW5kc29udGFibGUuY291bnRFdmVudE1hbmFnZXJMaXN0ZW5lcnMgLS07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBldmVudHNcbiAgICpcbiAgICogQHNpbmNlIDAuMTUuMC1iZXRhM1xuICAgKi9cbiAgY2xlYXJFdmVudHMoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGxlbiA9IHRoaXMuY29udGV4dC5ldmVudExpc3RlbmVycy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGxldCBldmVudCA9IHRoaXMuY29udGV4dC5ldmVudExpc3RlbmVyc1tsZW5dO1xuXG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LmVsZW1lbnQsIGV2ZW50LmV2ZW50LCBldmVudC5jYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBldmVudHNcbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuY2xlYXJFdmVudHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95IGluc3RhbmNlXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY2xlYXJFdmVudHMoKTtcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgZXZlbnRcbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWVcbiAgICovXG4gIGZpcmVFdmVudChlbGVtZW50LCBldmVudE5hbWUpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiAoZXZlbnROYW1lICE9PSAnbW91c2Vtb3ZlJyksXG4gICAgICB2aWV3OiB3aW5kb3csXG4gICAgICBkZXRhaWw6IDAsXG4gICAgICBzY3JlZW5YOiAwLFxuICAgICAgc2NyZWVuWTogMCxcbiAgICAgIGNsaWVudFg6IDEsXG4gICAgICBjbGllbnRZOiAxLFxuICAgICAgY3RybEtleTogZmFsc2UsXG4gICAgICBhbHRLZXk6IGZhbHNlLFxuICAgICAgc2hpZnRLZXk6IGZhbHNlLFxuICAgICAgbWV0YUtleTogZmFsc2UsXG4gICAgICBidXR0b246IDAsXG4gICAgICByZWxhdGVkVGFyZ2V0OiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHZhciBldmVudDtcblxuICAgIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudCkge1xuICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcbiAgICAgIGV2ZW50LmluaXRNb3VzZUV2ZW50KGV2ZW50TmFtZSwgb3B0aW9ucy5idWJibGVzLCBvcHRpb25zLmNhbmNlbGFibGUsXG4gICAgICAgIG9wdGlvbnMudmlldywgb3B0aW9ucy5kZXRhaWwsXG4gICAgICAgIG9wdGlvbnMuc2NyZWVuWCwgb3B0aW9ucy5zY3JlZW5ZLCBvcHRpb25zLmNsaWVudFgsIG9wdGlvbnMuY2xpZW50WSxcbiAgICAgICAgb3B0aW9ucy5jdHJsS2V5LCBvcHRpb25zLmFsdEtleSwgb3B0aW9ucy5zaGlmdEtleSwgb3B0aW9ucy5tZXRhS2V5LFxuICAgICAgICBvcHRpb25zLmJ1dHRvbiwgb3B0aW9ucy5yZWxhdGVkVGFyZ2V0IHx8IGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCgpO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LmRpc3BhdGNoRXZlbnQpIHtcbiAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuZmlyZUV2ZW50KCdvbicgKyBldmVudE5hbWUsIGV2ZW50KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kRXZlbnQoY29udGV4dCwgZXZlbnQpIHtcbiAgbGV0IGNvbXBvbmVudE5hbWUgPSAnSE9ULVRBQkxFJztcbiAgbGV0IGlzSG90VGFibGVTcG90dGVkO1xuICBsZXQgZnJvbUVsZW1lbnQ7XG4gIGxldCByZWFsVGFyZ2V0O1xuICBsZXQgdGFyZ2V0O1xuICBsZXQgbGVuO1xuXG4gIGV2ZW50LmlzVGFyZ2V0V2ViQ29tcG9uZW50ID0gZmFsc2U7XG4gIGV2ZW50LnJlYWxUYXJnZXQgPSBldmVudC50YXJnZXQ7XG5cbiAgaWYgKCFIYW5kc29udGFibGUuZXZlbnRNYW5hZ2VyLmlzSG90VGFibGVFbnYpIHtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgZXZlbnQgPSBwb2x5bWVyV3JhcChldmVudCk7XG4gIGxlbiA9IGV2ZW50LnBhdGggPyBldmVudC5wYXRoLmxlbmd0aCA6IDA7XG5cbiAgd2hpbGUgKGxlbiAtLSkge1xuICAgIGlmIChldmVudC5wYXRoW2xlbl0ubm9kZU5hbWUgPT09IGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIGlzSG90VGFibGVTcG90dGVkID0gdHJ1ZTtcblxuICAgIH0gZWxzZSBpZiAoaXNIb3RUYWJsZVNwb3R0ZWQgJiYgZXZlbnQucGF0aFtsZW5dLnNoYWRvd1Jvb3QpIHtcbiAgICAgIHRhcmdldCA9IGV2ZW50LnBhdGhbbGVuXTtcblxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChsZW4gPT09IDAgJiYgIXRhcmdldCkge1xuICAgICAgdGFyZ2V0ID0gZXZlbnQucGF0aFtsZW5dO1xuICAgIH1cbiAgfVxuICBpZiAoIXRhcmdldCkge1xuICAgIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgfVxuICBldmVudC5pc1RhcmdldFdlYkNvbXBvbmVudCA9IHRydWU7XG5cbiAgaWYgKGlzV2ViQ29tcG9uZW50U3VwcG9ydGVkTmF0aXZlbHkoKSkge1xuICAgIGV2ZW50LnJlYWxUYXJnZXQgPSBldmVudC5zcmNFbGVtZW50IHx8IGV2ZW50LnRvRWxlbWVudDtcblxuICB9IGVsc2UgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBIYW5kc29udGFibGUuQ29yZSB8fCBjb250ZXh0IGluc3RhbmNlb2YgV2Fsa29udGFibGUpIHtcbiAgICAvLyBQb2x5bWVyIGRvZXNuJ3Qgc3VwcG9ydCBgZXZlbnQudGFyZ2V0YCBwcm9wZXJ0eSBwcm9wZXJseSB3ZSBtdXN0IGVtdWxhdGUgaXQgb3Vyc2VsdmVzXG4gICAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBIYW5kc29udGFibGUuQ29yZSkge1xuICAgICAgZnJvbUVsZW1lbnQgPSBjb250ZXh0LnZpZXcgPyBjb250ZXh0LnZpZXcud3Qud3RUYWJsZS5UQUJMRSA6IG51bGw7XG5cbiAgICB9IGVsc2UgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBXYWxrb250YWJsZSkge1xuICAgICAgLy8gLnd0SGlkZXJcbiAgICAgIGZyb21FbGVtZW50ID0gY29udGV4dC53dFRhYmxlLlRBQkxFLnBhcmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmVhbFRhcmdldCA9IGNsb3Nlc3QoZXZlbnQudGFyZ2V0LCBbY29tcG9uZW50TmFtZV0sIGZyb21FbGVtZW50KTtcblxuICAgIGlmIChyZWFsVGFyZ2V0KSB7XG4gICAgICBldmVudC5yZWFsVGFyZ2V0ID0gZnJvbUVsZW1lbnQucXVlcnlTZWxlY3Rvcihjb21wb25lbnROYW1lKSB8fCBldmVudC50YXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LnJlYWxUYXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV2ZW50LCAndGFyZ2V0Jywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcG9seW1lcldyYXAodGFyZ2V0KTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuXG4gIHJldHVybiBldmVudDtcbn1cblxuZXhwb3J0IHtFdmVudE1hbmFnZXIsIGV2ZW50TWFuYWdlcn07XG5cbndpbmRvdy5IYW5kc29udGFibGUgPSB3aW5kb3cuSGFuZHNvbnRhYmxlIHx8IHt9O1xuLy8gdXNlZCB0byBkZWJ1ZyBtZW1vcnkgbGVha3NcbkhhbmRzb250YWJsZS5jb3VudEV2ZW50TWFuYWdlckxpc3RlbmVycyA9IDA7XG4vLyBzdXBwb3J0IGZvciBvbGRlciB2ZXJzaW9ucyBvZiBIYW5kc29udGFibGUsIGRlcHJlY2F0ZWRcbkhhbmRzb250YWJsZS5ldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXI7XG5cbmZ1bmN0aW9uIGV2ZW50TWFuYWdlcihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgRXZlbnRNYW5hZ2VyKGNvbnRleHQpO1xufVxuIiwiXG5leHBvcnQgZnVuY3Rpb24gdG8yZEFycmF5KGFycikge1xuICB2YXIgaSA9IDBcbiAgICAsIGlsZW4gPSBhcnIubGVuZ3RoO1xuICB3aGlsZSAoaSA8IGlsZW4pIHtcbiAgICBhcnJbaV0gPSBbYXJyW2ldXTtcbiAgICBpKys7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZEFycmF5KGFyciwgZXh0ZW5zaW9uKSB7XG4gIHZhciBpID0gMFxuICAgICwgaWxlbiA9IGV4dGVuc2lvbi5sZW5ndGg7XG4gIHdoaWxlIChpIDwgaWxlbikge1xuICAgIGFyci5wdXNoKGV4dGVuc2lvbltpXSk7XG4gICAgaSsrO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwaXZvdChhcnIpIHtcbiAgdmFyIHBpdm90ZWRBcnIgPSBbXTtcblxuICBpZighYXJyIHx8IGFyci5sZW5ndGggPT09IDAgfHwgIWFyclswXSB8fCBhcnJbMF0ubGVuZ3RoID09PSAwKXtcbiAgICByZXR1cm4gcGl2b3RlZEFycjtcbiAgfVxuXG4gIHZhciByb3dDb3VudCA9IGFyci5sZW5ndGg7XG4gIHZhciBjb2xDb3VudCA9IGFyclswXS5sZW5ndGg7XG5cbiAgZm9yKHZhciBpID0gMDsgaSA8IHJvd0NvdW50OyBpKyspe1xuICAgIGZvcih2YXIgaiA9IDA7IGogPCBjb2xDb3VudDsgaisrKXtcbiAgICAgIGlmKCFwaXZvdGVkQXJyW2pdKXtcbiAgICAgICAgcGl2b3RlZEFycltqXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBwaXZvdGVkQXJyW2pdW2ldID0gYXJyW2ldW2pdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwaXZvdGVkQXJyO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAqXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi9tYXN0ZXIvbG9kYXNoLmpzfVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtCb29sZWFufSBbaW5pdEZyb21BcnJheV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0RnJvbUFycmF5KSB7XG4gIGxldCBpbmRleCA9IC0xLFxuICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoaW5pdEZyb21BcnJheSAmJiBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG5cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAqXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi9tYXN0ZXIvbG9kYXNoLmpzfVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICBsZXQgaW5kZXggPSAtMSxcbiAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgcmVzSW5kZXggPSAtMSxcbiAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGxldCB2YWx1ZSA9IGFycmF5W2luZGV4XTtcblxuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFsrK3Jlc0luZGV4XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGAuZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGNhbGxiYWNrXG4gKiBzaG9ydGhhbmRzIGFuZCBgdGhpc2AgYmluZGluZy5cbiAqXG4gKiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi9tYXN0ZXIvbG9kYXNoLmpzfVxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIGxldCBpbmRleCA9IC0xLFxuICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHN1bSB2YWx1ZSBmb3IgZWFjaCBpdGVtIG9mIHRoZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgY2FsY3VsYXRlZCBzdW0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcnJheVN1bShhcnJheSkge1xuICByZXR1cm4gYXJyYXlSZWR1Y2UoYXJyYXksIChhLCBiKSA9PiAoYSArIGIpLCAwKTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgYXZlcmFnZSB2YWx1ZSBmb3IgZWFjaCBpdGVtIG9mIHRoZSBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgY2FsY3VsYXRlZCBhdmVyYWdlIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlBdmcoYXJyYXkpIHtcbiAgaWYgKCFhcnJheS5sZW5ndGgpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBhcnJheVN1bShhcnJheSkgLyBhcnJheS5sZW5ndGg7XG59XG4iLCJcbnZhciBfaXNJRTggPSAhKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCd0ZXN0JykudGV4dENvbnRlbnQpO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNJRTgoKSB7XG4gIHJldHVybiBfaXNJRTg7XG59XG5cbnZhciBfaXNJRTkgPSAhIShkb2N1bWVudC5kb2N1bWVudE1vZGUpO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNJRTkoKSB7XG4gIHJldHVybiBfaXNJRTk7XG59XG5cbnZhciBfaXNTYWZhcmkgPSAoL1NhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAvQXBwbGUgQ29tcHV0ZXIvLnRlc3QobmF2aWdhdG9yLnZlbmRvcikpO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNTYWZhcmkoKSB7XG4gIHJldHVybiBfaXNTYWZhcmk7XG59XG5cbnZhciBfaXNDaHJvbWUgPSAoL0Nocm9tZS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAvR29vZ2xlLy50ZXN0KG5hdmlnYXRvci52ZW5kb3IpKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzQ2hyb21lKCkge1xuICByZXR1cm4gX2lzQ2hyb21lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNNb2JpbGVCcm93c2VyKHVzZXJBZ2VudCkge1xuICBpZiAoIXVzZXJBZ2VudCkge1xuICAgIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIH1cblxuICByZXR1cm4gKC9BbmRyb2lkfHdlYk9TfGlQaG9uZXxpUGFkfGlQb2R8QmxhY2tCZXJyeXxJRU1vYmlsZXxPcGVyYSBNaW5pL2kudGVzdCh1c2VyQWdlbnQpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVG91Y2hTdXBwb3J0ZWQoKSB7XG4gIHJldHVybiAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYnJvd3NlciBpcyBzdXBwb3J0IHdlYiBjb21wb25lbnRzIG5hdGl2ZWx5XG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1dlYkNvbXBvbmVudFN1cHBvcnRlZE5hdGl2ZWx5KCkge1xuICB2YXIgdGVzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gIHJldHVybiB0ZXN0LmNyZWF0ZVNoYWRvd1Jvb3QgJiYgdGVzdC5jcmVhdGVTaGFkb3dSb290LnRvU3RyaW5nKCkubWF0Y2goL1xcW25hdGl2ZSBjb2RlXFxdLykgPyB0cnVlIDogZmFsc2U7XG59XG5cbnZhciBfaGFzQ2FwdGlvblByb2JsZW07XG5cbmZ1bmN0aW9uIGRldGVjdENhcHRpb25Qcm9ibGVtKCkge1xuICB2YXIgVEFCTEUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdUQUJMRScpO1xuICBUQUJMRS5zdHlsZS5ib3JkZXJTcGFjaW5nID0gMDtcbiAgVEFCTEUuc3R5bGUuYm9yZGVyV2lkdGggPSAwO1xuICBUQUJMRS5zdHlsZS5wYWRkaW5nID0gMDtcbiAgdmFyIFRCT0RZID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnVEJPRFknKTtcbiAgVEFCTEUuYXBwZW5kQ2hpbGQoVEJPRFkpO1xuICBUQk9EWS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdUUicpKTtcbiAgVEJPRFkuZmlyc3RDaGlsZC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdURCcpKTtcbiAgVEJPRFkuZmlyc3RDaGlsZC5maXJzdENoaWxkLmlubmVySFRNTCA9ICc8dHI+PHRkPnQ8YnI+dDwvdGQ+PC90cj4nO1xuXG4gIHZhciBDQVBUSU9OID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnQ0FQVElPTicpO1xuICBDQVBUSU9OLmlubmVySFRNTCA9ICdjPGJyPmM8YnI+Yzxicj5jJztcbiAgQ0FQVElPTi5zdHlsZS5wYWRkaW5nID0gMDtcbiAgQ0FQVElPTi5zdHlsZS5tYXJnaW4gPSAwO1xuICBUQUJMRS5pbnNlcnRCZWZvcmUoQ0FQVElPTiwgVEJPRFkpO1xuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoVEFCTEUpO1xuICBfaGFzQ2FwdGlvblByb2JsZW0gPSAoVEFCTEUub2Zmc2V0SGVpZ2h0IDwgMiAqIFRBQkxFLmxhc3RDaGlsZC5vZmZzZXRIZWlnaHQpOyAvL2Jvb2xlYW5cbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChUQUJMRSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNDYXB0aW9uUHJvYmxlbSgpIHtcbiAgaWYgKF9oYXNDYXB0aW9uUHJvYmxlbSA9PT0gdm9pZCAwKSB7XG4gICAgZGV0ZWN0Q2FwdGlvblByb2JsZW0oKTtcbiAgfVxuXG4gIHJldHVybiBfaGFzQ2FwdGlvblByb2JsZW07XG59XG4iLCJcbmltcG9ydCB7Z2V0UHJvdG90eXBlT2Z9IGZyb20gJy4vb2JqZWN0JztcblxuLyoqXG4gKiBHZW5lcmF0ZXMgc3ByZWFkc2hlZXQtbGlrZSBjb2x1bW4gbmFtZXM6IEEsIEIsIEMsIC4uLiwgWiwgQUEsIEFCLCBldGNcbiAqIEBwYXJhbSBpbmRleFxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwcmVhZHNoZWV0Q29sdW1uTGFiZWwoaW5kZXgpIHtcbiAgdmFyIGRpdmlkZW5kID0gaW5kZXggKyAxO1xuICB2YXIgY29sdW1uTGFiZWwgPSAnJztcbiAgdmFyIG1vZHVsbztcbiAgd2hpbGUgKGRpdmlkZW5kID4gMCkge1xuICAgIG1vZHVsbyA9IChkaXZpZGVuZCAtIDEpICUgMjY7XG4gICAgY29sdW1uTGFiZWwgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1ICsgbW9kdWxvKSArIGNvbHVtbkxhYmVsO1xuICAgIGRpdmlkZW5kID0gcGFyc2VJbnQoKGRpdmlkZW5kIC0gbW9kdWxvKSAvIDI2LCAxMCk7XG4gIH1cbiAgcmV0dXJuIGNvbHVtbkxhYmVsO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgMkQgYXJyYXkgb2YgRXhjZWwtbGlrZSB2YWx1ZXMgXCJBMVwiLCBcIkEyXCIsIC4uLlxuICogQHBhcmFtIHJvd0NvdW50XG4gKiBAcGFyYW0gY29sQ291bnRcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNwcmVhZHNoZWV0RGF0YShyb3dDb3VudCwgY29sQ291bnQpIHtcbiAgcm93Q291bnQgPSB0eXBlb2Ygcm93Q291bnQgPT09ICdudW1iZXInID8gcm93Q291bnQgOiAxMDA7XG4gIGNvbENvdW50ID0gdHlwZW9mIGNvbENvdW50ID09PSAnbnVtYmVyJyA/IGNvbENvdW50IDogNDtcblxuICB2YXIgcm93cyA9IFtdXG4gICAgLCBpXG4gICAgLCBqO1xuXG4gIGZvciAoaSA9IDA7IGkgPCByb3dDb3VudDsgaSsrKSB7XG4gICAgdmFyIHJvdyA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBjb2xDb3VudDsgaisrKSB7XG4gICAgICByb3cucHVzaChzcHJlYWRzaGVldENvbHVtbkxhYmVsKGopICsgKGkgKyAxKSk7XG4gICAgfVxuICAgIHJvd3MucHVzaChyb3cpO1xuICB9XG4gIHJldHVybiByb3dzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3ByZWFkc2hlZXRPYmplY3REYXRhKHJvd0NvdW50LCBjb2xDb3VudCkge1xuICByb3dDb3VudCA9IHR5cGVvZiByb3dDb3VudCA9PT0gJ251bWJlcicgPyByb3dDb3VudCA6IDEwMDtcbiAgY29sQ291bnQgPSB0eXBlb2YgY29sQ291bnQgPT09ICdudW1iZXInID8gY29sQ291bnQgOiA0O1xuXG4gIHZhciByb3dzID0gW11cbiAgICAsIGlcbiAgICAsIGo7XG5cbiAgZm9yIChpID0gMDsgaSA8IHJvd0NvdW50OyBpKyspIHtcbiAgICB2YXIgcm93ID0ge307XG4gICAgZm9yIChqID0gMDsgaiA8IGNvbENvdW50OyBqKyspIHtcbiAgICAgIHJvd1sncHJvcCcgKyBqXSA9IHNwcmVhZHNoZWV0Q29sdW1uTGFiZWwoaikgKyAoaSArIDEpO1xuICAgIH1cbiAgICByb3dzLnB1c2gocm93KTtcbiAgfVxuICByZXR1cm4gcm93cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZVJvd3NUb0NvbHVtbnMoaW5wdXQpIHtcbiAgdmFyIGlcbiAgICAsIGlsZW5cbiAgICAsIGpcbiAgICAsIGpsZW5cbiAgICAsIG91dHB1dCA9IFtdXG4gICAgLCBvbGVuID0gMDtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gaW5wdXQubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgZm9yIChqID0gMCwgamxlbiA9IGlucHV0W2ldLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgaWYgKGogPT0gb2xlbikge1xuICAgICAgICBvdXRwdXQucHVzaChbXSk7XG4gICAgICAgIG9sZW4rKztcbiAgICAgIH1cbiAgICAgIG91dHB1dFtqXS5wdXNoKGlucHV0W2ldW2pdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IHRoYXQgcHJvZHVjZXMgYSBmdW5jdGlvbiBmb3Igc2VhcmNoaW5nIG1ldGhvZHMgKG9yIGFueSBwcm9wZXJ0aWVzKSB3aGljaCBjb3VsZCBiZSBkZWZpbmVkIGRpcmVjdGx5IGluXG4gKiB0YWJsZSBjb25maWd1cmF0aW9uIG9yIGltcGxpY2l0bHksIHdpdGhpbiBjZWxsIHR5cGUgZGVmaW5pdGlvbi5cbiAqXG4gKiBGb3IgZXhhbXBsZTogcmVuZGVyZXIgY2FuIGJlIGRlZmluZWQgZXhwbGljaXRseSB1c2luZyBcInJlbmRlcmVyXCIgcHJvcGVydHkgaW4gY29sdW1uIGNvbmZpZ3VyYXRpb24gb3IgaXQgY2FuIGJlXG4gKiBkZWZpbmVkIGltcGxpY2l0bHkgdXNpbmcgXCJ0eXBlXCIgcHJvcGVydHkuXG4gKlxuICogTWV0aG9kcy9wcm9wZXJ0aWVzIGRlZmluZWQgZXhwbGljaXRseSBhbHdheXMgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRob3NlIGRlZmluZWQgdGhyb3VnaCBcInR5cGVcIi5cbiAqXG4gKiBJZiB0aGUgbWV0aG9kL3Byb3BlcnR5IGlzIG5vdCBmb3VuZCBpbiBhbiBvYmplY3QsIHNlYXJjaGluZyBpcyBjb250aW51ZWQgcmVjdXJzaXZlbHkgdGhyb3VnaCBwcm90b3R5cGUgY2hhaW4sIHVudGlsXG4gKiBpdCByZWFjaGVzIHRoZSBPYmplY3QucHJvdG90eXBlLlxuICpcbiAqXG4gKiBAcGFyYW0gbWV0aG9kTmFtZSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBtZXRob2QvcHJvcGVydHkgdG8gc2VhcmNoIChpLmUuICdyZW5kZXJlcicsICd2YWxpZGF0b3InLCAnY29weWFibGUnKVxuICogQHBhcmFtIGFsbG93VW5kZWZpbmVkIHtCb29sZWFufSBbb3B0aW9uYWxdIGlmIGZhbHNlLCB0aGUgc2VhcmNoIGlzIGNvbnRpbnVlZCBpZiBtZXRob2ROYW1lIGhhcyBub3QgYmVlbiBmb3VuZCBpbiBjZWxsIFwidHlwZVwiXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjZWxsTWV0aG9kTG9va3VwRmFjdG9yeShtZXRob2ROYW1lLCBhbGxvd1VuZGVmaW5lZCkge1xuXG4gIGFsbG93VW5kZWZpbmVkID0gdHlwZW9mIGFsbG93VW5kZWZpbmVkID09ICd1bmRlZmluZWQnID8gdHJ1ZSA6IGFsbG93VW5kZWZpbmVkO1xuXG4gIHJldHVybiBmdW5jdGlvbiBjZWxsTWV0aG9kTG9va3VwIChyb3csIGNvbCkge1xuXG4gICAgcmV0dXJuIChmdW5jdGlvbiBnZXRNZXRob2RGcm9tUHJvcGVydGllcyhwcm9wZXJ0aWVzKSB7XG5cbiAgICAgIGlmICghcHJvcGVydGllcyl7XG5cbiAgICAgICAgcmV0dXJuOyAgICAgICAgICAgICAgICAgICAgICAgLy9tZXRob2Qgbm90IGZvdW5kXG5cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobWV0aG9kTmFtZSkgJiYgcHJvcGVydGllc1ttZXRob2ROYW1lXSAhPT0gdm9pZCAwKSB7IC8vY2hlY2sgaWYgaXQgaXMgb3duIGFuZCBpcyBub3QgZW1wdHlcblxuICAgICAgICByZXR1cm4gcHJvcGVydGllc1ttZXRob2ROYW1lXTsgIC8vbWV0aG9kIGRlZmluZWQgZGlyZWN0bHlcblxuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KCd0eXBlJykgJiYgcHJvcGVydGllcy50eXBlKSB7IC8vY2hlY2sgaWYgaXQgaXMgb3duIGFuZCBpcyBub3QgZW1wdHlcblxuICAgICAgICB2YXIgdHlwZTtcblxuICAgICAgICBpZih0eXBlb2YgcHJvcGVydGllcy50eXBlICE9ICdzdHJpbmcnICl7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDZWxsIHR5cGUgbXVzdCBiZSBhIHN0cmluZyAnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHR5cGUgPSB0cmFuc2xhdGVUeXBlTmFtZVRvT2JqZWN0KHByb3BlcnRpZXMudHlwZSk7XG5cbiAgICAgICAgaWYgKHR5cGUuaGFzT3duUHJvcGVydHkobWV0aG9kTmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZVttZXRob2ROYW1lXTsgLy9tZXRob2QgZGVmaW5lZCBpbiB0eXBlLlxuICAgICAgICB9IGVsc2UgaWYgKGFsbG93VW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuOyAvL21ldGhvZCBkb2VzIG5vdCBkZWZpbmVkIGluIHR5cGUgKGVnLiB2YWxpZGF0b3IpLCByZXR1cm5zIHVuZGVmaW5lZFxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldE1ldGhvZEZyb21Qcm9wZXJ0aWVzKGdldFByb3RvdHlwZU9mKHByb3BlcnRpZXMpKTtcblxuICAgIH0pKHR5cGVvZiByb3cgPT0gJ251bWJlcicgPyB0aGlzLmdldENlbGxNZXRhKHJvdywgY29sKSA6IHJvdyk7XG5cbiAgfTtcblxuICBmdW5jdGlvbiB0cmFuc2xhdGVUeXBlTmFtZVRvT2JqZWN0KHR5cGVOYW1lKSB7XG4gICAgdmFyIHR5cGUgPSBIYW5kc29udGFibGUuY2VsbFR5cGVzW3R5cGVOYW1lXTtcblxuICAgIGlmKHR5cGVvZiB0eXBlID09ICd1bmRlZmluZWQnKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGRlY2xhcmVkIGNlbGwgdHlwZSBcIicgKyB0eXBlTmFtZSArICdcIiBhcyBhIHN0cmluZyB0aGF0IGlzIG5vdCBtYXBwZWQgdG8gYSBrbm93biBvYmplY3QuICcgK1xuICAgICAgICAnQ2VsbCB0eXBlIG11c3QgYmUgYW4gb2JqZWN0IG9yIGEgc3RyaW5nIG1hcHBlZCB0byBhbiBvYmplY3QgaW4gSGFuZHNvbnRhYmxlLmNlbGxUeXBlcycpO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlO1xuICB9XG59XG4iLCJcbmltcG9ydCB7aXNJRTgsIGlzSUU5LCBpc1NhZmFyaSwgaGFzQ2FwdGlvblByb2JsZW19IGZyb20gJy4uL2Jyb3dzZXInO1xuXG4vKipcbiAqIEdvZXMgdXAgdGhlIERPTSB0cmVlIChpbmNsdWRpbmcgZ2l2ZW4gZWxlbWVudCkgdW50aWwgaXQgZmluZHMgYW4gZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIG5vZGVzIG9yIG5vZGVzIG5hbWUuXG4gKiBUaGlzIG1ldGhvZCBnb2VzIHVwIHRocm91Z2ggd2ViIGNvbXBvbmVudHMuXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBFbGVtZW50IGZyb20gd2hpY2ggdHJhdmVyc2luZyBpcyBzdGFydGVkXG4gKiBAcGFyYW0ge0FycmF5fSBub2RlcyBBcnJheSBvZiBlbGVtZW50cyBvciBBcnJheSBvZiBlbGVtZW50cyBuYW1lXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbdW50aWxdXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR8bnVsbH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb3Nlc3QoZWxlbWVudCwgbm9kZXMsIHVudGlsKSB7XG4gIHdoaWxlIChlbGVtZW50ICE9IG51bGwgJiYgZWxlbWVudCAhPT0gdW50aWwpIHtcbiAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiZcbiAgICAgIChub2Rlcy5pbmRleE9mKGVsZW1lbnQubm9kZU5hbWUpID4gLTEgfHwgbm9kZXMuaW5kZXhPZihlbGVtZW50KSA+IC0xKSkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIGlmIChlbGVtZW50Lmhvc3QgJiYgZWxlbWVudC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICBlbGVtZW50ID0gZWxlbWVudC5ob3N0O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogR29lcyB1cCB0aGUgRE9NIHRyZWUgYW5kIGNoZWNrcyBpZiBlbGVtZW50IGlzIGNoaWxkIG9mIGFub3RoZXIgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gY2hpbGQgQ2hpbGQgZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBwYXJlbnQgUGFyZW50IGVsZW1lbnQgT1Igc2VsZWN0b3Igb2YgdGhlIHBhcmVudCBlbGVtZW50LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgc3RyaW5nIHByb3ZpZGVkLCBmdW5jdGlvbiByZXR1cm5zIGB0cnVlYCBmb3IgdGhlIGZpcnN0IG9jY3VyYW5jZSBvZiBlbGVtZW50IHdpdGggdGhhdCBjbGFzcy5cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDaGlsZE9mKGNoaWxkLCBwYXJlbnQpIHtcbiAgdmFyIG5vZGUgPSBjaGlsZC5wYXJlbnROb2RlO1xuICB2YXIgcXVlcmllZFBhcmVudHMgPSBbXTtcblxuICBpZiAodHlwZW9mIHBhcmVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHF1ZXJpZWRQYXJlbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChwYXJlbnQpLCAwKTtcbiAgfSBlbHNlIHtcbiAgICBxdWVyaWVkUGFyZW50cy5wdXNoKHBhcmVudCk7XG4gIH1cblxuICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgaWYgKHF1ZXJpZWRQYXJlbnRzLmluZGV4T2Yobm9kZSkgPiAtMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGFuIGVsZW1lbnQgaXMgcGFydCBvZiBgaG90LXRhYmxlYCB3ZWIgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0NoaWxkT2ZXZWJDb21wb25lbnRUYWJsZShlbGVtZW50KSB7XG4gIHZhciBob3RUYWJsZU5hbWUgPSAnaG90LXRhYmxlJyxcbiAgICByZXN1bHQgPSBmYWxzZSxcbiAgICBwYXJlbnROb2RlO1xuXG4gIHBhcmVudE5vZGUgPSBwb2x5bWVyV3JhcChlbGVtZW50KTtcblxuICBmdW5jdGlvbiBpc0hvdFRhYmxlKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgZWxlbWVudC5ub2RlTmFtZSA9PT0gaG90VGFibGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gIH1cblxuICB3aGlsZSAocGFyZW50Tm9kZSAhPSBudWxsKSB7XG4gICAgaWYgKGlzSG90VGFibGUocGFyZW50Tm9kZSkpIHtcbiAgICAgIHJlc3VsdCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZWxzZSBpZiAocGFyZW50Tm9kZS5ob3N0ICYmIHBhcmVudE5vZGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgcmVzdWx0ID0gaXNIb3RUYWJsZShwYXJlbnROb2RlLmhvc3QpO1xuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUuaG9zdDtcbiAgICB9XG4gICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogV3JhcCBlbGVtZW50IGludG8gcG9seW1lci93ZWJjb21wb25lbnQgY29udGFpbmVyIGlmIGV4aXN0c1xuICpcbiAqIEBwYXJhbSBlbGVtZW50XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvbHltZXJXcmFwKGVsZW1lbnQpIHtcbiAgLyogZ2xvYmFsIFBvbHltZXIgKi9cbiAgcmV0dXJuIHR5cGVvZiBQb2x5bWVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd3JhcCA9PT0gJ2Z1bmN0aW9uJyA/IHdyYXAoZWxlbWVudCkgOiBlbGVtZW50O1xufVxuXG4vKipcbiAqIFVud3JhcCBlbGVtZW50IGZyb20gcG9seW1lci93ZWJjb21wb25lbnQgY29udGFpbmVyIGlmIGV4aXN0c1xuICpcbiAqIEBwYXJhbSBlbGVtZW50XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvbHltZXJVbndyYXAoZWxlbWVudCkge1xuICAvKiBnbG9iYWwgUG9seW1lciAqL1xuICByZXR1cm4gdHlwZW9mIFBvbHltZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB1bndyYXAgPT09ICdmdW5jdGlvbicgPyB1bndyYXAoZWxlbWVudCkgOiBlbGVtZW50O1xufVxuXG4vKipcbiAqIENvdW50cyBpbmRleCBvZiBlbGVtZW50IHdpdGhpbiBpdHMgcGFyZW50XG4gKiBXQVJOSU5HOiBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgYXNzdW1lcyB0aGVyZSBhcmUgb25seSBlbGVtZW50IG5vZGVzIChubyB0ZXh0IG5vZGVzKS4gVGhpcyBpcyB0cnVlIGZvciBXYWxrb3RuYWJsZVxuICogT3RoZXJ3aXNlIHdvdWxkIG5lZWQgdG8gY2hlY2sgZm9yIG5vZGVUeXBlIG9yIHVzZSBwcmV2aW91c0VsZW1lbnRTaWJsaW5nXG4gKlxuICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9zaWJsaW5nLWluZGV4LzEwXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluZGV4KGVsZW1lbnQpIHtcbiAgdmFyIGkgPSAwO1xuXG4gIGlmIChlbGVtZW50LnByZXZpb3VzU2libGluZykge1xuICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICB3aGlsZSAoZWxlbWVudCA9IGVsZW1lbnQucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICArK2k7XG4gICAgfVxuICAgIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG4gIH1cblxuICByZXR1cm4gaTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcHJvdmlkZWQgb3ZlcmxheSBjb250YWlucyB0aGUgcHJvdmlkZWQgZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvdmVybGF5XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG92ZXJsYXlDb250YWluc0VsZW1lbnQob3ZlcmxheVR5cGUsIGVsZW1lbnQpIHtcbiAgbGV0IG92ZXJsYXlFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmh0X2Nsb25lXycgKyBvdmVybGF5VHlwZSk7XG4gIHJldHVybiBvdmVybGF5RWxlbWVudCA/IG92ZXJsYXlFbGVtZW50LmNvbnRhaW5zKGVsZW1lbnQpIDogbnVsbDtcbn1cblxudmFyIGNsYXNzTGlzdFN1cHBvcnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xhc3NMaXN0ID8gdHJ1ZSA6IGZhbHNlO1xudmFyIF9oYXNDbGFzcywgX2FkZENsYXNzLCBfcmVtb3ZlQ2xhc3M7XG5cbmZ1bmN0aW9uIGZpbHRlckVtcHR5Q2xhc3NOYW1lcyhjbGFzc05hbWVzKSB7XG4gIHZhciBsZW4gPSAwLCByZXN1bHQgPSBbXTtcblxuICBpZiAoIWNsYXNzTmFtZXMgfHwgIWNsYXNzTmFtZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB3aGlsZSAoY2xhc3NOYW1lc1tsZW5dKSB7XG4gICAgcmVzdWx0LnB1c2goY2xhc3NOYW1lc1tsZW5dKTtcbiAgICBsZW4rKztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmlmIChjbGFzc0xpc3RTdXBwb3J0KSB7XG4gIHZhciBpc1N1cHBvcnRNdWx0aXBsZUNsYXNzZXNBcmcgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3Rlc3QnLCAndGVzdDInKTtcblxuICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygndGVzdDInKTtcbiAgfSgpKTtcblxuICBfaGFzQ2xhc3MgPSBmdW5jdGlvbiBfaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgaWYgKGNsYXNzTmFtZSA9PT0gJycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKTtcbiAgfTtcblxuICBfYWRkQ2xhc3MgPSBmdW5jdGlvbiBfYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgdmFyIGxlbiA9IDA7XG5cbiAgICBpZiAodHlwZW9mIGNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZS5zcGxpdCgnICcpO1xuICAgIH1cbiAgICBjbGFzc05hbWUgPSBmaWx0ZXJFbXB0eUNsYXNzTmFtZXMoY2xhc3NOYW1lKTtcblxuICAgIGlmIChpc1N1cHBvcnRNdWx0aXBsZUNsYXNzZXNBcmcpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZC5hcHBseShlbGVtZW50LmNsYXNzTGlzdCwgY2xhc3NOYW1lKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoY2xhc3NOYW1lICYmIGNsYXNzTmFtZVtsZW5dKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWVbbGVuXSk7XG4gICAgICAgIGxlbisrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiBfcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgdmFyIGxlbiA9IDA7XG5cbiAgICBpZiAodHlwZW9mIGNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZS5zcGxpdCgnICcpO1xuICAgIH1cbiAgICBjbGFzc05hbWUgPSBmaWx0ZXJFbXB0eUNsYXNzTmFtZXMoY2xhc3NOYW1lKTtcblxuICAgIGlmIChpc1N1cHBvcnRNdWx0aXBsZUNsYXNzZXNBcmcpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZS5hcHBseShlbGVtZW50LmNsYXNzTGlzdCwgY2xhc3NOYW1lKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoY2xhc3NOYW1lICYmIGNsYXNzTmFtZVtsZW5dKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWVbbGVuXSk7XG4gICAgICAgIGxlbisrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxufSBlbHNlIHtcbiAgdmFyIGNyZWF0ZUNsYXNzTmFtZVJlZ0V4cCA9IGZ1bmN0aW9uIGNyZWF0ZUNsYXNzTmFtZVJlZ0V4cChjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnKFxcXFxzfF4pJyArIGNsYXNzTmFtZSArICcoXFxcXHN8JCknKTtcbiAgfTtcblxuICBfaGFzQ2xhc3MgPSBmdW5jdGlvbiBfaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgLy8gaHR0cDovL3NuaXBwbHIuY29tL3ZpZXcvMzU2MS9hZGRjbGFzcy1yZW1vdmVjbGFzcy1oYXNjbGFzcy9cbiAgICByZXR1cm4gZWxlbWVudC5jbGFzc05hbWUubWF0Y2goY3JlYXRlQ2xhc3NOYW1lUmVnRXhwKGNsYXNzTmFtZSkpID8gdHJ1ZSA6IGZhbHNlO1xuICB9O1xuXG4gIF9hZGRDbGFzcyA9IGZ1bmN0aW9uIF9hZGRDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgICB2YXIgbGVuID0gMCxcbiAgICAgIF9jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZTtcblxuICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgY2xhc3NOYW1lID0gY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG4gICAgfVxuICAgIGlmIChfY2xhc3NOYW1lID09PSAnJykge1xuICAgICAgX2NsYXNzTmFtZSA9IGNsYXNzTmFtZS5qb2luKCcgJyk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKGNsYXNzTmFtZSAmJiBjbGFzc05hbWVbbGVuXSkge1xuICAgICAgICBpZiAoIWNyZWF0ZUNsYXNzTmFtZVJlZ0V4cChjbGFzc05hbWVbbGVuXSkudGVzdChfY2xhc3NOYW1lKSkge1xuICAgICAgICAgIF9jbGFzc05hbWUgKz0gJyAnICsgY2xhc3NOYW1lW2xlbl07XG4gICAgICAgIH1cbiAgICAgICAgbGVuKys7XG4gICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gX2NsYXNzTmFtZTtcbiAgfTtcblxuICBfcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiBfcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gICAgdmFyIGxlbiA9IDAsXG4gICAgICBfY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWU7XG5cbiAgICBpZiAodHlwZW9mIGNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZS5zcGxpdCgnICcpO1xuICAgIH1cbiAgICB3aGlsZSAoY2xhc3NOYW1lICYmIGNsYXNzTmFtZVtsZW5dKSB7XG4gICAgICAvLyBTdHJpbmcucHJvdG90eXBlLnRyaW0gaXMgZGVmaW5lZCBpbiBwb2x5ZmlsbC5qc1xuICAgICAgX2NsYXNzTmFtZSA9IF9jbGFzc05hbWUucmVwbGFjZShjcmVhdGVDbGFzc05hbWVSZWdFeHAoY2xhc3NOYW1lW2xlbl0pLCAnICcpLnRyaW0oKTtcbiAgICAgIGxlbisrO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5jbGFzc05hbWUgIT09IF9jbGFzc05hbWUpIHtcbiAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gX2NsYXNzTmFtZTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGVsZW1lbnQgaGFzIGNsYXNzIG5hbWVcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gY2xhc3NOYW1lIENsYXNzIG5hbWUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIHJldHVybiBfaGFzQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKTtcbn1cblxuLyoqXG4gKiBBZGQgY2xhc3MgbmFtZSB0byBhbiBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGNsYXNzTmFtZSBDbGFzcyBuYW1lIGFzIHN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcbiAgcmV0dXJuIF9hZGRDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpO1xufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyBuYW1lIGZyb20gYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBjbGFzc05hbWUgQ2xhc3MgbmFtZSBhcyBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5nc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIHJldHVybiBfcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVRleHROb2RlcyhlbGVtZW50LCBwYXJlbnQpIHtcbiAgaWYgKGVsZW1lbnQubm9kZVR5cGUgPT09IDMpIHtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoZWxlbWVudCk7IC8vYnllIHRleHQgbm9kZXMhXG4gIH1cbiAgZWxzZSBpZiAoWydUQUJMRScsICdUSEVBRCcsICdUQk9EWScsICdURk9PVCcsICdUUiddLmluZGV4T2YoZWxlbWVudC5ub2RlTmFtZSkgPiAtMSkge1xuICAgIHZhciBjaGlsZHMgPSBlbGVtZW50LmNoaWxkTm9kZXM7XG4gICAgZm9yICh2YXIgaSA9IGNoaWxkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgcmVtb3ZlVGV4dE5vZGVzKGNoaWxkc1tpXSwgZWxlbWVudCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGNoaWxkcyBmdW5jdGlvblxuICogV0FSTklORyAtIHRoaXMgZG9lc24ndCB1bmxvYWQgZXZlbnRzIGFuZCBkYXRhIGF0dGFjaGVkIGJ5IGpRdWVyeVxuICogaHR0cDovL2pzcGVyZi5jb20vanF1ZXJ5LWh0bWwtdnMtZW1wdHktdnMtaW5uZXJodG1sLzlcbiAqIGh0dHA6Ly9qc3BlcmYuY29tL2pxdWVyeS1odG1sLXZzLWVtcHR5LXZzLWlubmVyaHRtbC8xMSAtIG5vIHNpZ2luaWZpY2FudCBpbXByb3ZlbWVudCB3aXRoIENocm9tZSByZW1vdmUoKSBtZXRob2RcbiAqXG4gKiBAcGFyYW0gZWxlbWVudFxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbi8vXG5leHBvcnQgZnVuY3Rpb24gZW1wdHkoZWxlbWVudCkge1xuICB2YXIgY2hpbGQ7XG4gIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgd2hpbGUgKGNoaWxkID0gZWxlbWVudC5sYXN0Q2hpbGQpIHtcbiAgICBlbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgfVxuICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xufVxuXG5leHBvcnQgdmFyIEhUTUxfQ0hBUkFDVEVSUyA9IC8oPCguKik+fCYoLiopOykvO1xuXG4vKipcbiAqIEluc2VydCBjb250ZW50IGludG8gZWxlbWVudCB0cnlpbmcgYXZvaWQgaW5uZXJIVE1MIG1ldGhvZC5cbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmYXN0SW5uZXJIVE1MKGVsZW1lbnQsIGNvbnRlbnQpIHtcbiAgaWYgKEhUTUxfQ0hBUkFDVEVSUy50ZXN0KGNvbnRlbnQpKSB7XG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSBjb250ZW50O1xuICB9XG4gIGVsc2Uge1xuICAgIGZhc3RJbm5lclRleHQoZWxlbWVudCwgY29udGVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbnNlcnQgdGV4dCBjb250ZW50IGludG8gZWxlbWVudFxuICogQHJldHVybiB7dm9pZH1cbiAqL1xuXG52YXIgdGV4dENvbnRleHRTdXBwb3J0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ3Rlc3QnKS50ZXh0Q29udGVudCA/IHRydWUgOiBmYWxzZTtcblxuZXhwb3J0IGZ1bmN0aW9uIGZhc3RJbm5lclRleHQoZWxlbWVudCwgY29udGVudCkge1xuICB2YXIgY2hpbGQgPSBlbGVtZW50LmZpcnN0Q2hpbGQ7XG5cbiAgaWYgKGNoaWxkICYmIGNoaWxkLm5vZGVUeXBlID09PSAzICYmIGNoaWxkLm5leHRTaWJsaW5nID09PSBudWxsKSB7XG4gICAgLy8gZmFzdCBsYW5lIC0gcmVwbGFjZSBleGlzdGluZyB0ZXh0IG5vZGVcblxuICAgIGlmICh0ZXh0Q29udGV4dFN1cHBvcnQpIHtcbiAgICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL3JlcGxhY2UtdGV4dC12cy1yZXVzZVxuICAgICAgY2hpbGQudGV4dENvbnRlbnQgPSBjb250ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBodHRwOi8vanNwZXJmLmNvbS9yZXBsYWNlLXRleHQtdnMtcmV1c2VcbiAgICAgIGNoaWxkLmRhdGEgPSBjb250ZW50O1xuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICAvL3Nsb3cgbGFuZSAtIGVtcHR5IGVsZW1lbnQgYW5kIGluc2VydCBhIHRleHQgbm9kZVxuICAgIGVtcHR5KGVsZW1lbnQpO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY29udGVudCkpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGVsZW1lbnQgaXMgYXR0YWNoZWQgdG8gdGhlIERPTSBhbmQgdmlzaWJsZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gKiBAcGFyYW0gZWxlbVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1Zpc2libGUoZWxlbSkge1xuICB2YXIgbmV4dCA9IGVsZW07XG5cbiAgd2hpbGUgKHBvbHltZXJVbndyYXAobmV4dCkgIT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkgeyAvL3VudGlsIDxodG1sPiByZWFjaGVkXG4gICAgaWYgKG5leHQgPT09IG51bGwpIHsgLy9wYXJlbnQgZGV0YWNoZWQgZnJvbSBET01cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmV4dC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICBpZiAobmV4dC5ob3N0KSB7IC8vdGhpcyBpcyBXZWIgQ29tcG9uZW50cyBTaGFkb3cgRE9NXG4gICAgICAgIC8vc2VlOiBodHRwOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvc2hhZG93LyNlbmNhcHN1bGF0aW9uXG4gICAgICAgIC8vYWNjb3JkaW5nIHRvIHNwZWMsIHNob3VsZCBiZSBpZiAobmV4dC5vd25lckRvY3VtZW50ICE9PSB3aW5kb3cuZG9jdW1lbnQpLCBidXQgdGhhdCBkb2Vzbid0IHdvcmsgeWV0XG4gICAgICAgIGlmIChuZXh0Lmhvc3QuaW1wbCkgeyAvL0Nocm9tZSAzMy4wLjE3MjMuMCBjYW5hcnkgKDIwMTMtMTEtMjkpIFdlYiBQbGF0Zm9ybSBmZWF0dXJlcyBkaXNhYmxlZFxuICAgICAgICAgIHJldHVybiBpc1Zpc2libGUobmV4dC5ob3N0LmltcGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5leHQuaG9zdCkgeyAvL0Nocm9tZSAzMy4wLjE3MjMuMCBjYW5hcnkgKDIwMTMtMTEtMjkpIFdlYiBQbGF0Zm9ybSBmZWF0dXJlcyBlbmFibGVkXG4gICAgICAgICAgcmV0dXJuIGlzVmlzaWJsZShuZXh0Lmhvc3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvc3QgaW4gV2ViIENvbXBvbmVudHMgd29ybGRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vdGhpcyBpcyBhIG5vZGUgZGV0YWNoZWQgZnJvbSBkb2N1bWVudCBpbiBJRThcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobmV4dC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgZWxlbWVudHMgdG9wIGFuZCBsZWZ0IG9mZnNldCByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQuIEZ1bmN0aW9uIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggalF1ZXJ5IG9mZnNldC5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgb2JqZWN0IHdpdGggYHRvcGAgYW5kIGBsZWZ0YCBwcm9wc1xuICovXG5leHBvcnQgZnVuY3Rpb24gb2Zmc2V0KGVsZW0pIHtcbiAgdmFyIG9mZnNldExlZnQsXG4gICAgb2Zmc2V0VG9wLFxuICAgIGxhc3RFbGVtLFxuICAgIGRvY0VsZW0sXG4gICAgYm94O1xuXG4gIGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgaWYgKGhhc0NhcHRpb25Qcm9ibGVtKCkgJiYgZWxlbS5maXJzdENoaWxkICYmIGVsZW0uZmlyc3RDaGlsZC5ub2RlTmFtZSA9PT0gJ0NBUFRJT04nKSB7XG4gICAgLy8gZml4ZXMgcHJvYmxlbSB3aXRoIEZpcmVmb3ggaWdub3JpbmcgPGNhcHRpb24+IGluIFRBQkxFIG9mZnNldCAoc2VlIGFsc28gZXhwb3J0IG91dGVySGVpZ2h0KVxuICAgIC8vIGh0dHA6Ly9qc3BlcmYuY29tL29mZnNldC12cy1nZXRib3VuZGluZ2NsaWVudHJlY3QvOFxuICAgIGJveCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBib3gudG9wICsgKHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2NFbGVtLnNjcm9sbFRvcCkgLSAoZG9jRWxlbS5jbGllbnRUb3AgfHwgMCksXG4gICAgICBsZWZ0OiBib3gubGVmdCArICh3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jRWxlbS5zY3JvbGxMZWZ0KSAtIChkb2NFbGVtLmNsaWVudExlZnQgfHwgMClcbiAgICB9O1xuICB9XG4gIG9mZnNldExlZnQgPSBlbGVtLm9mZnNldExlZnQ7XG4gIG9mZnNldFRvcCA9IGVsZW0ub2Zmc2V0VG9wO1xuICBsYXN0RWxlbSA9IGVsZW07XG5cbiAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuICB3aGlsZSAoZWxlbSA9IGVsZW0ub2Zmc2V0UGFyZW50KSB7XG4gICAgLy8gZnJvbSBteSBvYnNlcnZhdGlvbiwgZG9jdW1lbnQuYm9keSBhbHdheXMgaGFzIHNjcm9sbExlZnQvc2Nyb2xsVG9wID09IDBcbiAgICBpZiAoZWxlbSA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9mZnNldExlZnQgKz0gZWxlbS5vZmZzZXRMZWZ0O1xuICAgIG9mZnNldFRvcCArPSBlbGVtLm9mZnNldFRvcDtcbiAgICBsYXN0RWxlbSA9IGVsZW07XG4gIH1cbiAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuICAvL3Nsb3cgLSBodHRwOi8vanNwZXJmLmNvbS9vZmZzZXQtdnMtZ2V0Ym91bmRpbmdjbGllbnRyZWN0LzZcbiAgaWYgKGxhc3RFbGVtICYmIGxhc3RFbGVtLnN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgLy9pZihsYXN0RWxlbSAhPT0gZG9jdW1lbnQuYm9keSkgeyAvL2Zhc3RlciBidXQgZG9lcyBnaXZlcyBmYWxzZSBwb3NpdGl2ZSBpbiBGaXJlZm94XG4gICAgb2Zmc2V0TGVmdCArPSB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jRWxlbS5zY3JvbGxMZWZ0O1xuICAgIG9mZnNldFRvcCArPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jRWxlbS5zY3JvbGxUb3A7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxlZnQ6IG9mZnNldExlZnQsXG4gICAgdG9wOiBvZmZzZXRUb3BcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkb2N1bWVudCdzIHNjcm9sbFRvcCBwcm9wZXJ0eS5cbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsVG9wKCkge1xuICB2YXIgcmVzID0gd2luZG93LnNjcm9sbFk7XG5cbiAgaWYgKHJlcyA9PT0gdm9pZCAwKSB7IC8vSUU4LTExXG4gICAgcmVzID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZG9jdW1lbnQncyBzY3JvbGxMZWZ0IHByb3BlcnR5LlxuICpcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxMZWZ0KCkge1xuICB2YXIgcmVzID0gd2luZG93LnNjcm9sbFg7XG5cbiAgaWYgKHJlcyA9PT0gdm9pZCAwKSB7IC8vSUU4LTExXG4gICAgcmVzID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQ7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHByb3ZpZGVkIGVsZW1lbnQncyBzY3JvbGxUb3AgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIGVsZW1lbnRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY3JvbGxUb3AoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PT0gd2luZG93KSB7XG4gICAgcmV0dXJuIGdldFdpbmRvd1Njcm9sbFRvcCgpO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBlbGVtZW50LnNjcm9sbFRvcDtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHByb3ZpZGVkIGVsZW1lbnQncyBzY3JvbGxMZWZ0IHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSBlbGVtZW50XG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2Nyb2xsTGVmdChlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09PSB3aW5kb3cpIHtcbiAgICByZXR1cm4gZ2V0V2luZG93U2Nyb2xsTGVmdCgpO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBlbGVtZW50LnNjcm9sbExlZnQ7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgRE9NIGVsZW1lbnQgcmVzcG9uc2libGUgZm9yIHNjcm9sbGluZyBvZiB0aGUgcHJvdmlkZWQgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IEVsZW1lbnQncyBzY3JvbGxhYmxlIHBhcmVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICB2YXIgZWwgPSBlbGVtZW50LnBhcmVudE5vZGUsXG4gICAgcHJvcHMgPSBbJ2F1dG8nLCAnc2Nyb2xsJ10sXG4gICAgb3ZlcmZsb3csIG92ZXJmbG93WCwgb3ZlcmZsb3dZLFxuICAgIGNvbXB1dGVkU3R5bGUgPSAnJyxcbiAgICBjb21wdXRlZE92ZXJmbG93ID0gJycsXG4gICAgY29tcHV0ZWRPdmVyZmxvd1kgPSAnJyxcbiAgICBjb21wdXRlZE92ZXJmbG93WCA9ICcnO1xuXG4gIHdoaWxlIChlbCAmJiBlbC5zdHlsZSAmJiBkb2N1bWVudC5ib2R5ICE9PSBlbCkge1xuICAgIG92ZXJmbG93ID0gZWwuc3R5bGUub3ZlcmZsb3c7XG4gICAgb3ZlcmZsb3dYID0gZWwuc3R5bGUub3ZlcmZsb3dYO1xuICAgIG92ZXJmbG93WSA9IGVsLnN0eWxlLm92ZXJmbG93WTtcblxuICAgIGlmIChvdmVyZmxvdyA9PSAnc2Nyb2xsJyB8fCBvdmVyZmxvd1ggPT0gJ3Njcm9sbCcgfHwgb3ZlcmZsb3dZID09ICdzY3JvbGwnKSB7XG4gICAgICByZXR1cm4gZWw7XG5cbiAgICB9IGVsc2UgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgICBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgICAgY29tcHV0ZWRPdmVyZmxvdyA9IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnb3ZlcmZsb3cnKTtcbiAgICAgIGNvbXB1dGVkT3ZlcmZsb3dZID0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdvdmVyZmxvdy15Jyk7XG4gICAgICBjb21wdXRlZE92ZXJmbG93WCA9IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnb3ZlcmZsb3cteCcpO1xuXG4gICAgICBpZiAoY29tcHV0ZWRPdmVyZmxvdyA9PT0gJ3Njcm9sbCcgfHwgY29tcHV0ZWRPdmVyZmxvd1ggPT09ICdzY3JvbGwnIHx8IGNvbXB1dGVkT3ZlcmZsb3dZID09PSAnc2Nyb2xsJykge1xuICAgICAgICByZXR1cm4gZWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVsLmNsaWVudEhlaWdodCA8PSBlbC5zY3JvbGxIZWlnaHQgJiYgKHByb3BzLmluZGV4T2Yob3ZlcmZsb3dZKSAhPT0gLTEgfHwgcHJvcHMuaW5kZXhPZihvdmVyZmxvdykgIT09IC0xIHx8XG4gICAgICAgIHByb3BzLmluZGV4T2YoY29tcHV0ZWRPdmVyZmxvdykgIT09IC0xIHx8IHByb3BzLmluZGV4T2YoY29tcHV0ZWRPdmVyZmxvd1kpICE9PSAtMSkpIHtcbiAgICAgIHJldHVybiBlbDtcbiAgICB9XG4gICAgaWYgKGVsLmNsaWVudFdpZHRoIDw9IGVsLnNjcm9sbFdpZHRoICYmIChwcm9wcy5pbmRleE9mKG92ZXJmbG93WCkgIT09IC0xIHx8IHByb3BzLmluZGV4T2Yob3ZlcmZsb3cpICE9PSAtMSB8fFxuICAgICAgICBwcm9wcy5pbmRleE9mKGNvbXB1dGVkT3ZlcmZsb3cpICE9PSAtMSB8fCBwcm9wcy5pbmRleE9mKGNvbXB1dGVkT3ZlcmZsb3dYKSAhPT0gLTEpKSB7XG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuICAgIGVsID0gZWwucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiB3aW5kb3c7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIERPTSBlbGVtZW50IHJlc3BvbnNpYmxlIGZvciB0cmltbWluZyB0aGUgcHJvdmlkZWQgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBiYXNlIEJhc2UgZWxlbWVudFxuICogQHJldHVybnMge0hUTUxFbGVtZW50fSBCYXNlIGVsZW1lbnQncyB0cmltbWluZyBwYXJlbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRyaW1taW5nQ29udGFpbmVyKGJhc2UpIHtcbiAgdmFyIGVsID0gYmFzZS5wYXJlbnROb2RlO1xuXG4gIHdoaWxlIChlbCAmJiBlbC5zdHlsZSAmJiBkb2N1bWVudC5ib2R5ICE9PSBlbCkge1xuICAgIGlmIChlbC5zdHlsZS5vdmVyZmxvdyAhPT0gJ3Zpc2libGUnICYmIGVsLnN0eWxlLm92ZXJmbG93ICE9PSAnJykge1xuICAgICAgcmV0dXJuIGVsO1xuXG4gICAgfSBlbHNlIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG5cbiAgICAgIGlmIChjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ292ZXJmbG93JykgIT09ICd2aXNpYmxlJyAmJiBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ292ZXJmbG93JykgIT09ICcnKSB7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbCA9IGVsLnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gd2luZG93O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHlsZSBwcm9wZXJ0eSBmb3IgdGhlIHByb3ZpZGVkIGVsZW1lbnQuIChCZSBpdCBhbiBpbmxpbmUgb3IgZXh0ZXJuYWwgc3R5bGUpLlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFdhbnRlZCBwcm9wZXJ0eVxuICogQHJldHVybnMge3N0cmluZ30gRWxlbWVudCdzIHN0eWxlIHByb3BlcnR5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdHlsZShlbGVtZW50LCBwcm9wKSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcblxuICB9IGVsc2UgaWYgKGVsZW1lbnQgPT09IHdpbmRvdykge1xuICAgIGlmIChwcm9wID09PSAnd2lkdGgnKSB7XG4gICAgICByZXR1cm4gd2luZG93LmlubmVyV2lkdGggKyAncHgnO1xuICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gJ2hlaWdodCcpIHtcbiAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQgKyAncHgnO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc3R5bGVQcm9wID0gZWxlbWVudC5zdHlsZVtwcm9wXSxcbiAgICBjb21wdXRlZFN0eWxlO1xuICBpZiAoc3R5bGVQcm9wICE9PSBcIlwiICYmIHN0eWxlUHJvcCAhPT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHN0eWxlUHJvcDtcblxuICB9IGVsc2Uge1xuICAgIGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgIGlmIChjb21wdXRlZFN0eWxlW3Byb3BdICE9PSBcIlwiICYmIGNvbXB1dGVkU3R5bGVbcHJvcF0gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGNvbXB1dGVkU3R5bGVbcHJvcF07XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgY29tcHV0ZWQgc3R5bGUgb2JqZWN0IGZvciB0aGUgcHJvdmlkZWQgZWxlbWVudC4gKE5lZWRlZCBpZiBzdHlsZSBpcyBkZWNsYXJlZCBpbiBleHRlcm5hbCBzdHlsZXNoZWV0KS5cbiAqXG4gKiBAcGFyYW0gZWxlbWVudFxuICogQHJldHVybnMge0lFRWxlbWVudFN0eWxlfENzc1N0eWxlfSBFbGVtZW50cyBjb21wdXRlZCBzdHlsZSBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC5jdXJyZW50U3R5bGUgfHwgZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50J3Mgb3V0ZXIgd2lkdGguXG4gKlxuICogQHBhcmFtIGVsZW1lbnRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEVsZW1lbnQncyBvdXRlciB3aWR0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gb3V0ZXJXaWR0aChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50Lm9mZnNldFdpZHRoO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGVsZW1lbnQncyBvdXRlciBoZWlnaHRcbiAqIEBwYXJhbSBlbGVtXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBFbGVtZW50J3Mgb3V0ZXIgaGVpZ2h0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvdXRlckhlaWdodChlbGVtKSB7XG4gIGlmIChoYXNDYXB0aW9uUHJvYmxlbSgpICYmIGVsZW0uZmlyc3RDaGlsZCAmJiBlbGVtLmZpcnN0Q2hpbGQubm9kZU5hbWUgPT09ICdDQVBUSU9OJykge1xuICAgIC8vZml4ZXMgcHJvYmxlbSB3aXRoIEZpcmVmb3ggaWdub3JpbmcgPGNhcHRpb24+IGluIFRBQkxFLm9mZnNldEhlaWdodFxuICAgIC8valF1ZXJ5ICgxLjEwLjEpIHN0aWxsIGhhcyB0aGlzIHVuc29sdmVkXG4gICAgLy9tYXkgYmUgYmV0dGVyIHRvIGp1c3Qgc3dpdGNoIHRvIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICAgIC8vaHR0cDovL2JpbGlsaXRlLmNvbS9ibG9nLzIwMDkvMDMvMjcvZmluZGluZy10aGUtc2l6ZS1vZi1hLXRhYmxlL1xuICAgIC8vaHR0cDovL2xpc3RzLnczLm9yZy9BcmNoaXZlcy9QdWJsaWMvd3d3LXN0eWxlLzIwMDlPY3QvMDA4OS5odG1sXG4gICAgLy9odHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8yMTk2XG4gICAgLy9odHRwOi8vbGlzdHMudzMub3JnL0FyY2hpdmVzL1B1YmxpYy93d3ctc3R5bGUvMjAwOU9jdC8wMTQwLmh0bWwjc3RhcnQxNDBcbiAgICByZXR1cm4gZWxlbS5vZmZzZXRIZWlnaHQgKyBlbGVtLmZpcnN0Q2hpbGQub2Zmc2V0SGVpZ2h0O1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBlbGVtLm9mZnNldEhlaWdodDtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGVsZW1lbnQncyBpbm5lciBoZWlnaHQuXG4gKlxuICogQHBhcmFtIGVsZW1lbnRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEVsZW1lbnQncyBpbm5lciBoZWlnaHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlubmVySGVpZ2h0KGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IGVsZW1lbnQuaW5uZXJIZWlnaHQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudCdzIGlubmVyIHdpZHRoLlxuICpcbiAqIEBwYXJhbSBlbGVtZW50XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBFbGVtZW50J3MgaW5uZXIgd2lkdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlubmVyV2lkdGgoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC5jbGllbnRXaWR0aCB8fCBlbGVtZW50LmlubmVyV2lkdGg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRFdmVudChlbGVtZW50LCBldmVudCwgY2FsbGJhY2spIHtcbiAgaWYgKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBjYWxsYmFjaywgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBjYWxsYmFjayk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUV2ZW50KGVsZW1lbnQsIGV2ZW50LCBjYWxsYmFjaykge1xuICBpZiAod2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrLCBmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGNhbGxiYWNrKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgY2FyZXQgcG9zaXRpb24gaW4gdGV4dCBpbnB1dFxuICpcbiAqIEBhdXRob3IgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNjM3NDMvaG93LXRvLWdldC1jYXJldC1wb3NpdGlvbi1pbi10ZXh0YXJlYVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2FyZXRQb3NpdGlvbihlbCkge1xuICBpZiAoZWwuc2VsZWN0aW9uU3RhcnQpIHtcbiAgICByZXR1cm4gZWwuc2VsZWN0aW9uU3RhcnQ7XG4gIH1cbiAgZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7IC8vIElFOFxuICAgIGVsLmZvY3VzKCk7XG5cbiAgICBsZXQgciA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuXG4gICAgaWYgKHIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGxldCByZSA9IGVsLmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgIGxldCByYyA9IHJlLmR1cGxpY2F0ZSgpO1xuXG4gICAgcmUubW92ZVRvQm9va21hcmsoci5nZXRCb29rbWFyaygpKTtcbiAgICByYy5zZXRFbmRQb2ludCgnRW5kVG9TdGFydCcsIHJlKTtcblxuICAgIHJldHVybiByYy50ZXh0Lmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG4vKipcbiAqIFJldHVybnMgZW5kIG9mIHRoZSBzZWxlY3Rpb24gaW4gdGV4dCBpbnB1dFxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbGVjdGlvbkVuZFBvc2l0aW9uKGVsKSB7XG4gIGlmIChlbC5zZWxlY3Rpb25FbmQpIHtcbiAgICByZXR1cm4gZWwuc2VsZWN0aW9uRW5kO1xuXG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7IC8vSUU4XG4gICAgbGV0IHIgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcblxuICAgIGlmIChyID09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBsZXQgcmUgPSBlbC5jcmVhdGVUZXh0UmFuZ2UoKTtcblxuICAgIHJldHVybiByZS50ZXh0LmluZGV4T2Yoci50ZXh0KSArIHIudGV4dC5sZW5ndGg7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXRzIGNhcmV0IHBvc2l0aW9uIGluIHRleHQgaW5wdXQuXG4gKlxuICogQGF1dGhvciBodHRwOi8vYmxvZy52aXNoYWxvbi5uZXQvaW5kZXgucGhwL2phdmFzY3JpcHQtZ2V0dGluZy1hbmQtc2V0dGluZy1jYXJldC1wb3NpdGlvbi1pbi10ZXh0YXJlYS9cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHBvc1xuICogQHBhcmFtIHtOdW1iZXJ9IGVuZFBvc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0Q2FyZXRQb3NpdGlvbihlbGVtZW50LCBwb3MsIGVuZFBvcykge1xuICBpZiAoZW5kUG9zID09PSB2b2lkIDApIHtcbiAgICBlbmRQb3MgPSBwb3M7XG4gIH1cbiAgaWYgKGVsZW1lbnQuc2V0U2VsZWN0aW9uUmFuZ2UpIHtcbiAgICBlbGVtZW50LmZvY3VzKCk7XG5cbiAgICB0cnkge1xuICAgICAgZWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZShwb3MsIGVuZFBvcyk7XG4gICAgfVxuICAgIGNhdGNoKGVycikge1xuICAgICAgdmFyIGVsZW1lbnRQYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGFyZW50RGlzcGxheVZhbHVlID0gZWxlbWVudFBhcmVudC5zdHlsZS5kaXNwbGF5O1xuICAgICAgZWxlbWVudFBhcmVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgIGVsZW1lbnQuc2V0U2VsZWN0aW9uUmFuZ2UocG9zLCBlbmRQb3MpO1xuICAgICAgZWxlbWVudFBhcmVudC5zdHlsZS5kaXNwbGF5ID0gcGFyZW50RGlzcGxheVZhbHVlO1xuICAgIH1cblxuICB9XG4gIGVsc2UgaWYgKGVsZW1lbnQuY3JlYXRlVGV4dFJhbmdlKSB7IC8vSUU4XG4gICAgdmFyIHJhbmdlID0gZWxlbWVudC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmRQb3MpO1xuICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgcG9zKTtcbiAgICByYW5nZS5zZWxlY3QoKTtcbiAgfVxufVxuXG52YXIgY2FjaGVkU2Nyb2xsYmFyV2lkdGg7XG5cbi8vaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85ODY5MzcvaG93LWNhbi1pLWdldC10aGUtYnJvd3NlcnMtc2Nyb2xsYmFyLXNpemVzXG5mdW5jdGlvbiB3YWxrb250YWJsZUNhbGN1bGF0ZVNjcm9sbGJhcldpZHRoKCkge1xuICB2YXIgaW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gIGlubmVyLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gIGlubmVyLnN0eWxlLmhlaWdodCA9IFwiMjAwcHhcIjtcblxuICB2YXIgb3V0ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgb3V0ZXIuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gIG91dGVyLnN0eWxlLnRvcCA9IFwiMHB4XCI7XG4gIG91dGVyLnN0eWxlLmxlZnQgPSBcIjBweFwiO1xuICBvdXRlci5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgb3V0ZXIuc3R5bGUud2lkdGggPSBcIjIwMHB4XCI7XG4gIG91dGVyLnN0eWxlLmhlaWdodCA9IFwiMTUwcHhcIjtcbiAgb3V0ZXIuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICBvdXRlci5hcHBlbmRDaGlsZChpbm5lcik7XG5cbiAgKGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5hcHBlbmRDaGlsZChvdXRlcik7XG4gIHZhciB3MSA9IGlubmVyLm9mZnNldFdpZHRoO1xuICBvdXRlci5zdHlsZS5vdmVyZmxvdyA9ICdzY3JvbGwnO1xuICB2YXIgdzIgPSBpbm5lci5vZmZzZXRXaWR0aDtcbiAgaWYgKHcxID09IHcyKSB7XG4gICAgdzIgPSBvdXRlci5jbGllbnRXaWR0aDtcbiAgfVxuXG4gIChkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkucmVtb3ZlQ2hpbGQob3V0ZXIpO1xuXG4gIHJldHVybiAodzEgLSB3Mik7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29tcHV0ZWQgd2lkdGggb2YgdGhlIG5hdGl2ZSBicm93c2VyIHNjcm9sbCBiYXIuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSB3aWR0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2Nyb2xsYmFyV2lkdGgoKSB7XG4gIGlmIChjYWNoZWRTY3JvbGxiYXJXaWR0aCA9PT0gdm9pZCAwKSB7XG4gICAgY2FjaGVkU2Nyb2xsYmFyV2lkdGggPSB3YWxrb250YWJsZUNhbGN1bGF0ZVNjcm9sbGJhcldpZHRoKCk7XG4gIH1cblxuICByZXR1cm4gY2FjaGVkU2Nyb2xsYmFyV2lkdGg7XG59XG5cblxuLyoqXG4gKiBTZXRzIG92ZXJsYXkgcG9zaXRpb24gZGVwZW5kaW5nIG9uIGl0J3MgdHlwZSBhbmQgdXNlZCBicm93c2VyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRPdmVybGF5UG9zaXRpb24ob3ZlcmxheUVsZW0sIGxlZnQsIHRvcCkge1xuICBpZiAoaXNJRTgoKSB8fCBpc0lFOSgpKSB7XG4gICAgb3ZlcmxheUVsZW0uc3R5bGUudG9wID0gdG9wO1xuICAgIG92ZXJsYXlFbGVtLnN0eWxlLmxlZnQgPSBsZWZ0O1xuICB9IGVsc2UgaWYgKGlzU2FmYXJpKCkpIHtcbiAgICAvKiBqc2hpbnQgc3ViOnRydWUgKi9cbiAgICBvdmVybGF5RWxlbS5zdHlsZVsnLXdlYmtpdC10cmFuc2Zvcm0nXSA9ICd0cmFuc2xhdGUzZCgnICsgbGVmdCArICcsJyArIHRvcCArICcsMCknO1xuICB9IGVsc2Uge1xuICAgIG92ZXJsYXlFbGVtLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgnICsgbGVmdCArICcsJyArIHRvcCArICcsMCknO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDc3NUcmFuc2Zvcm0oZWxlbWVudCkge1xuICB2YXIgdHJhbnNmb3JtO1xuXG4gIC8qIGpzaGludCBzdWI6dHJ1ZSAqL1xuICBpZiAoZWxlbWVudC5zdHlsZVsndHJhbnNmb3JtJ10gJiYgKHRyYW5zZm9ybSA9IGVsZW1lbnQuc3R5bGVbJ3RyYW5zZm9ybSddKSAhPT0gJycpIHtcbiAgICByZXR1cm4gWyd0cmFuc2Zvcm0nLCB0cmFuc2Zvcm1dO1xuXG4gIH0gZWxzZSBpZiAoZWxlbWVudC5zdHlsZVsnLXdlYmtpdC10cmFuc2Zvcm0nXSAmJiAodHJhbnNmb3JtID0gZWxlbWVudC5zdHlsZVsnLXdlYmtpdC10cmFuc2Zvcm0nXSkgIT09ICcnKSB7XG5cbiAgICByZXR1cm4gWyctd2Via2l0LXRyYW5zZm9ybScsIHRyYW5zZm9ybV07XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldENzc1RyYW5zZm9ybShlbGVtZW50KSB7XG4gIC8qIGpzaGludCBzdWI6dHJ1ZSAqL1xuICBpZiAoZWxlbWVudFsndHJhbnNmb3JtJ10gJiYgZWxlbWVudFsndHJhbnNmb3JtJ10gIT09ICcnKSB7XG4gICAgZWxlbWVudFsndHJhbnNmb3JtJ10gPSAnJztcbiAgfSBlbHNlIGlmIChlbGVtZW50Wyctd2Via2l0LXRyYW5zZm9ybSddICYmIGVsZW1lbnRbJy13ZWJraXQtdHJhbnNmb3JtJ10gIT09ICcnKSB7XG4gICAgZWxlbWVudFsnLXdlYmtpdC10cmFuc2Zvcm0nXSA9ICcnO1xuICB9XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gRE9NIGVsZW1lbnQgaXMgYW4gaW5wdXQgZmllbGQuXG4gKiBOb3RpY2U6IEJ5ICdpbnB1dCcgd2UgbWVhbiBpbnB1dCwgdGV4dGFyZWEgYW5kIHNlbGVjdCBub2Rlc1xuICogQHBhcmFtIGVsZW1lbnQgLSBET00gZWxlbWVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0lucHV0KGVsZW1lbnQpIHtcbiAgdmFyIGlucHV0cyA9IFsnSU5QVVQnLCAnU0VMRUNUJywgJ1RFWFRBUkVBJ107XG5cbiAgcmV0dXJuIGlucHV0cy5pbmRleE9mKGVsZW1lbnQubm9kZU5hbWUpID4gLTEgfHwgZWxlbWVudC5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiBET00gZWxlbWVudCBpcyBhbiBpbnB1dCBmaWVsZCBwbGFjZWQgT1VUU0lERSBvZiBIT1QuXG4gKiBOb3RpY2U6IEJ5ICdpbnB1dCcgd2UgbWVhbiBpbnB1dCwgdGV4dGFyZWEgYW5kIHNlbGVjdCBub2Rlc1xuICogQHBhcmFtIGVsZW1lbnQgLSBET00gZWxlbWVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc091dHNpZGVJbnB1dChlbGVtZW50KSB7XG4gIHJldHVybiBpc0lucHV0KGVsZW1lbnQpICYmIGVsZW1lbnQuY2xhc3NOYW1lLmluZGV4T2YoJ2hhbmRzb250YWJsZUlucHV0JykgPT0gLTEgJiYgZWxlbWVudC5jbGFzc05hbWUuaW5kZXhPZignY29weVBhc3RlJykgPT0gLTE7XG59XG5cblxuLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzE1Nzk2NzFcbmxldCBsYXN0VGltZSA9IDA7XG5sZXQgdmVuZG9ycyA9IFsnbXMnLCAnbW96JywgJ3dlYmtpdCcsICdvJ107XG5sZXQgX3JlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5sZXQgX2NhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lO1xuXG5mb3IgKGxldCB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICFfcmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3gpIHtcbiAgX3JlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICBfY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdmVuZG9yc1t4XSArICdDYW5jZWxBbmltYXRpb25GcmFtZSddIHx8IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xufVxuXG5pZiAoIV9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgX3JlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgbGV0IGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgbGV0IHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyVGltZSAtIGxhc3RUaW1lKSk7XG4gICAgbGV0IGlkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpO1xuICAgIH0sIHRpbWVUb0NhbGwpO1xuICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuXG4gICAgcmV0dXJuIGlkO1xuICB9O1xufVxuXG5pZiAoIV9jYW5jZWxBbmltYXRpb25GcmFtZSkge1xuICBfY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihpZCkge1xuICAgIGNsZWFyVGltZW91dChpZCk7XG4gIH07XG59XG5cbi8qKlxuICogUG9seWZpbGwgZm9yIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKSB7XG4gIHJldHVybiBfcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmNhbGwod2luZG93LCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogUG9seWZpbGwgZm9yIGNhbmNlbEFuaW1hdGlvbkZyYW1lXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYW5jZWxBbmltYXRpb25GcmFtZShpZCkge1xuICBfY2FuY2VsQW5pbWF0aW9uRnJhbWUuY2FsbCh3aW5kb3csIGlkKTtcbn1cbiIsIlxuZXhwb3J0IGZ1bmN0aW9uIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihldmVudCkge1xuICBldmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25FbmFibGVkID09PSBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbihldmVudCkge1xuICAvLyBpZThcbiAgLy9odHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZmY5NzU0NjIodj12cy44NSkuYXNweFxuICBpZiAodHlwZW9mIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG4gIGVsc2Uge1xuICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhZ2VYKGV2ZW50KSB7XG4gIGlmIChldmVudC5wYWdlWCkge1xuICAgIHJldHVybiBldmVudC5wYWdlWDtcbiAgfVxuXG4gIHZhciBzY3JvbGxMZWZ0ID0gZ2V0V2luZG93U2Nyb2xsTGVmdCgpO1xuICB2YXIgY3Vyc29yWCA9IGV2ZW50LmNsaWVudFggKyBzY3JvbGxMZWZ0O1xuXG4gIHJldHVybiBjdXJzb3JYO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFnZVkoZXZlbnQpIHtcbiAgaWYgKGV2ZW50LnBhZ2VZKSB7XG4gICAgcmV0dXJuIGV2ZW50LnBhZ2VZO1xuICB9XG5cbiAgdmFyIHNjcm9sbFRvcCA9IGdldFdpbmRvd1Njcm9sbFRvcCgpO1xuICB2YXIgY3Vyc29yWSA9IGV2ZW50LmNsaWVudFkgKyBzY3JvbGxUb3A7XG5cbiAgcmV0dXJuIGN1cnNvclk7XG59XG4iLCJcbmV4cG9ydCBmdW5jdGlvbiBwcm94eShmdW4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyB0aHJvdHRsZSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIG9ubHkgb25jZSBwZXIgYHdhaXRgIChpbiBtaWxpc2Vjb25kcykuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICogQHBhcmFtIHtOdW1iZXJ9IHdhaXRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQgPSAyMDApIHtcbiAgbGV0IGxhc3RDYWxsZWQgPSAwO1xuICBsZXQgcmVzdWx0ID0ge1xuICAgIGxhc3RDYWxsVGhyb3R0bGVkOiB0cnVlXG4gIH07XG4gIGxldCBsYXN0VGltZXIgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIF90aHJvdHRsZSgpIHtcbiAgICBjb25zdCBhcmdzID0gYXJndW1lbnRzO1xuICAgIGxldCBzdGFtcCA9IERhdGUubm93KCk7XG4gICAgbGV0IG5lZWRDYWxsID0gZmFsc2U7XG5cbiAgICByZXN1bHQubGFzdENhbGxUaHJvdHRsZWQgPSB0cnVlO1xuXG4gICAgaWYgKCFsYXN0Q2FsbGVkKSB7XG4gICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICBuZWVkQ2FsbCA9IHRydWU7XG4gICAgfVxuICAgIGxldCByZW1haW5pbmcgPSB3YWl0IC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICBpZiAobmVlZENhbGwpIHtcbiAgICAgIHJlc3VsdC5sYXN0Q2FsbFRocm90dGxlZCA9IGZhbHNlO1xuICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxhc3RUaW1lcikge1xuICAgICAgICBjbGVhclRpbWVvdXQobGFzdFRpbWVyKTtcbiAgICAgIH1cbiAgICAgIGxhc3RUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICByZXN1bHQubGFzdENhbGxUaHJvdHRsZWQgPSBmYWxzZTtcbiAgICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgbGFzdENhbGxlZCA9IDA7XG4gICAgICAgIGxhc3RUaW1lciA9IHZvaWQgMDtcbiAgICAgIH0sIHJlbWFpbmluZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJldHVybiBfdGhyb3R0bGU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyB0aHJvdHRsZSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIG9ubHkgb25jZSBwZXIgYHdhaXRgIChpbiBtaWxpc2Vjb25kcykgYWZ0ZXIgaGl0cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gKiBAcGFyYW0ge051bWJlcn0gd2FpdFxuICogQHBhcmFtIHtOdW1iZXJ9IGhpdHNcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlQWZ0ZXJIaXRzKGZ1bmMsIHdhaXQgPSAyMDAsIGhpdHMgPSAxMCkge1xuICBjb25zdCBmdW5jVGhyb3R0bGUgPSB0aHJvdHRsZShmdW5jLCB3YWl0KTtcbiAgbGV0IHJlbWFpbkhpdHMgPSBoaXRzO1xuXG4gIGZ1bmN0aW9uIF9jbGVhckhpdHMoKSB7XG4gICAgcmVtYWluSGl0cyA9IGhpdHM7XG4gIH1cbiAgZnVuY3Rpb24gX3Rocm90dGxlQWZ0ZXJIaXRzKCkge1xuICAgIGlmIChyZW1haW5IaXRzKSB7XG4gICAgICByZW1haW5IaXRzIC0tO1xuXG4gICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jVGhyb3R0bGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICBfdGhyb3R0bGVBZnRlckhpdHMuY2xlYXJIaXRzID0gX2NsZWFySGl0cztcblxuICByZXR1cm4gX3Rocm90dGxlQWZ0ZXJIaXRzO1xufVxuIiwiXG4vKipcbiAqIENvbnZlcnRzIGFueSB2YWx1ZSB0byBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSkge1xuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiB2YWx1ZSArICcnO1xuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG59XG4iLCJcbi8qKlxuICogQ2hlY2tzIGlmIHZhbHVlIG9mIG4gaXMgYSBudW1lcmljIG9uZVxuICogaHR0cDovL2pzcGVyZi5jb20vaXNuYW4tdnMtaXNudW1lcmljLzRcbiAqIEBwYXJhbSBuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtZXJpYyhuKSB7XG4gIHZhciB0ID0gdHlwZW9mIG47XG4gIHJldHVybiB0ID09ICdudW1iZXInID8gIWlzTmFOKG4pICYmIGlzRmluaXRlKG4pIDpcbiAgICB0ID09ICdzdHJpbmcnID8gIW4ubGVuZ3RoID8gZmFsc2UgOlxuICAgICAgbi5sZW5ndGggPT0gMSA/IC9cXGQvLnRlc3QobikgOlxuICAgICAgICAvXlxccypbKy1dP1xccyooPzooPzpcXGQrKD86XFwuXFxkKyk/KD86ZVsrLV0/XFxkKyk/KXwoPzoweFthLWZcXGRdKykpXFxzKiQvaS50ZXN0KG4pIDpcbiAgICAgIHQgPT0gJ29iamVjdCcgPyAhIW4gJiYgdHlwZW9mIG4udmFsdWVPZigpID09IFwibnVtYmVyXCIgJiYgIShuIGluc3RhbmNlb2YgRGF0ZSkgOiBmYWxzZTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYC5mb3JFYWNoYCBkZWZpbmVkIGJ5IHJhbmdlcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gcmFuZ2VGcm9tIFRoZSBudW1iZXIgZnJvbSBzdGFydCBpdGVyYXRlLlxuICogQHBhcmFtIHtOdW1iZXJ9IHJhbmdlVG8gVGhlIG51bWJlciB3aGVyZSBmaW5pc2ggaXRlcmF0ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5nZUVhY2gocmFuZ2VGcm9tLCByYW5nZVRvLCBpdGVyYXRlZSkge1xuICBsZXQgaW5kZXggPSAtMTtcblxuICBpZiAodHlwZW9mIHJhbmdlVG8gPT09ICdmdW5jdGlvbicpIHtcbiAgICBpdGVyYXRlZSA9IHJhbmdlVG87XG4gICAgcmFuZ2VUbyA9IHJhbmdlRnJvbTtcbiAgfSBlbHNlIHtcbiAgICBpbmRleCA9IHJhbmdlRnJvbSAtIDE7XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPD0gcmFuZ2VUbykge1xuICAgIGlmIChpdGVyYXRlZShpbmRleCkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdmFsdWUgZnJvbSBwZXJjZW50LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBCYXNlIHZhbHVlIGZyb20gcGVyY2VudCB3aWxsIGJlIGNhbGN1bGF0ZWQuXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHBlcmNlbnQgQ2FuIGJlIE51bWJlciBvciBTdHJpbmcgKGVxLiBgJzMzJSdgKS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWx1ZUFjY29yZGluZ1BlcmNlbnQodmFsdWUsIHBlcmNlbnQpIHtcbiAgcGVyY2VudCA9IHBhcnNlSW50KHBlcmNlbnQudG9TdHJpbmcoKS5yZXBsYWNlKCclJywgJycpLCAxMCk7XG4gIHBlcmNlbnQgPSBwYXJzZUludCh2YWx1ZSAqIHBlcmNlbnQgLyAxMDApO1xuXG4gIHJldHVybiBwZXJjZW50O1xufVxuIiwiXG4vKipcbiAqIEdlbmVyYXRlIHNjaGVtYSBmb3IgcGFzc2VkIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZHVja1NjaGVtYShvYmplY3QpIHtcbiAgdmFyIHNjaGVtYTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgc2NoZW1hID0gW107XG4gIH0gZWxzZSB7XG4gICAgc2NoZW1hID0ge307XG5cbiAgICBvYmplY3RFYWNoKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHNjaGVtYVtrZXldID0gZHVja1NjaGVtYSh2YWx1ZSk7XG5cbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAmJiB0eXBlb2YgdmFsdWVbMF0gPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbHVlWzBdKSkge1xuICAgICAgICAgIHNjaGVtYVtrZXldID0gW2R1Y2tTY2hlbWEodmFsdWVbMF0pXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY2hlbWFba2V5XSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjaGVtYVtrZXldID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBzY2hlbWE7XG59XG5cbi8qKlxuICogSW5oZXJpdCB3aXRob3V0IHdpdGhvdXQgY2FsbGluZyBwYXJlbnQgY29uc3RydWN0b3IsIGFuZCBzZXR0aW5nIGBDaGlsZC5wcm90b3R5cGUuY29uc3RydWN0b3JgIHRvIGBDaGlsZGAgaW5zdGVhZCBvZiBgUGFyZW50YC5cbiAqIENyZWF0ZXMgdGVtcG9yYXJ5IGR1bW15IGZ1bmN0aW9uIHRvIGNhbGwgaXQgYXMgY29uc3RydWN0b3IuXG4gKiBEZXNjcmliZWQgaW4gdGlja2V0OiBodHRwczovL2dpdGh1Yi5jb20vaGFuZHNvbnRhYmxlL2hhbmRzb250YWJsZS9wdWxsLzUxNlxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gQ2hpbGQgIGNoaWxkIGNsYXNzXG4gKiBAcGFyYW0gIHtPYmplY3R9IFBhcmVudCBwYXJlbnQgY2xhc3NcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgIGV4dGVuZGVkIENoaWxkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmhlcml0KENoaWxkLCBQYXJlbnQpIHtcbiAgUGFyZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhcmVudDtcbiAgQ2hpbGQucHJvdG90eXBlID0gbmV3IFBhcmVudCgpO1xuICBDaGlsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDaGlsZDtcblxuICByZXR1cm4gQ2hpbGQ7XG59XG5cbi8qKlxuICogUGVyZm9ybSBzaGFsbG93IGV4dGVuZCBvZiBhIHRhcmdldCBvYmplY3Qgd2l0aCBleHRlbnNpb24ncyBvd24gcHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBBbiBvYmplY3QgdGhhdCB3aWxsIHJlY2VpdmUgdGhlIG5ldyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gZXh0ZW5zaW9uIEFuIG9iamVjdCBjb250YWluaW5nIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0byBtZXJnZSBpbnRvIHRoZSB0YXJnZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIGV4dGVuc2lvbikge1xuICBvYmplY3RFYWNoKGV4dGVuc2lvbiwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gIH0pO1xufVxuXG4vKipcbiAqIFBlcmZvcm0gZGVlcCBleHRlbmQgb2YgYSB0YXJnZXQgb2JqZWN0IHdpdGggZXh0ZW5zaW9uJ3Mgb3duIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgQW4gb2JqZWN0IHRoYXQgd2lsbCByZWNlaXZlIHRoZSBuZXcgcHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IGV4dGVuc2lvbiBBbiBvYmplY3QgY29udGFpbmluZyBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gbWVyZ2UgaW50byB0aGUgdGFyZ2V0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWVwRXh0ZW5kKHRhcmdldCwgZXh0ZW5zaW9uKSB7XG4gIG9iamVjdEVhY2goZXh0ZW5zaW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgaWYgKGV4dGVuc2lvbltrZXldICYmIHR5cGVvZiBleHRlbnNpb25ba2V5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICghdGFyZ2V0W2tleV0pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXh0ZW5zaW9uW2tleV0pKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZWVwRXh0ZW5kKHRhcmdldFtrZXldLCBleHRlbnNpb25ba2V5XSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0W2tleV0gPSBleHRlbnNpb25ba2V5XTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFBlcmZvcm0gZGVlcCBjbG9uZSBvZiBhbiBvYmplY3QuXG4gKiBXQVJOSU5HISBPbmx5IGNsb25lcyBKU09OIHByb3BlcnRpZXMuIFdpbGwgY2F1c2UgZXJyb3Igd2hlbiBgb2JqYCBjb250YWlucyBhIGZ1bmN0aW9uLCBEYXRlLCBldGMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBBbiBvYmplY3QgdGhhdCB3aWxsIGJlIGNsb25lZFxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVlcENsb25lKG9iaikge1xuICBpZiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBTaGFsbG93IGNsb25lIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUob2JqZWN0KSB7XG4gIGxldCByZXN1bHQgPSB7fTtcblxuICBvYmplY3RFYWNoKG9iamVjdCwgKHZhbHVlLCBrZXkpID0+IHJlc3VsdFtrZXldID0gdmFsdWUpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHR3byBvYmplY3RzIG9yIGFycmF5cyBhcmUgKGRlZXApIGVxdWFsXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iamVjdDFcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmplY3QyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0RXF1YWxzKG9iamVjdDEsIG9iamVjdDIpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iamVjdDEpID09PSBKU09OLnN0cmluZ2lmeShvYmplY3QyKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgZ2l2ZW4gb2JqZWN0IGlzIGEgcGxhaW4gT2JqZWN0LlxuICogTm90ZTogU3RyaW5nIGFuZCBBcnJheSBhcmUgbm90IHBsYWluIE9iamVjdHNcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihvYmopIHtcbiAgdmFyIHByb3RvdHlwZTtcblxuICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gIGlmKHR5cGVvZiBvYmouX19wcm90b19fID09IFwib2JqZWN0XCIpe1xuICAgIHByb3RvdHlwZSA9IG9iai5fX3Byb3RvX187XG4gIH0gZWxzZSB7XG4gICAgdmFyIG9sZENvbnN0cnVjdG9yLFxuICAgICAgY29uc3RydWN0b3IgPSBvYmouY29uc3RydWN0b3I7XG5cbiAgICBpZiAodHlwZW9mIG9iai5jb25zdHJ1Y3RvciA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIG9sZENvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7XG5cbiAgICAgIGlmIChkZWxldGUgb2JqLmNvbnN0cnVjdG9yKXtcbiAgICAgICAgY29uc3RydWN0b3IgPSBvYmouY29uc3RydWN0b3I7IC8vIGdldCByZWFsIGNvbnN0cnVjdG9yXG4gICAgICAgIG9iai5jb25zdHJ1Y3RvciA9IG9sZENvbnN0cnVjdG9yOyAvLyByZXN0b3JlIGNvbnN0cnVjdG9yXG4gICAgICB9XG5cblxuICAgIH1cblxuICAgIHByb3RvdHlwZSA9IGNvbnN0cnVjdG9yID8gY29uc3RydWN0b3IucHJvdG90eXBlIDogbnVsbDsgLy8gbmVlZGVkIGZvciBJRVxuICB9XG4gIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cbiAgcmV0dXJuIHByb3RvdHlwZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZUdldHRlcihvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgb3B0aW9ucykge1xuICBvcHRpb25zLnZhbHVlID0gdmFsdWU7XG4gIG9wdGlvbnMud3JpdGFibGUgPSBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTtcbiAgb3B0aW9ucy5lbnVtZXJhYmxlID0gb3B0aW9ucy5lbnVtZXJhYmxlID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZTtcbiAgb3B0aW9ucy5jb25maWd1cmFibGUgPSBvcHRpb25zLmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWU7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgLmZvckVhY2hgIGZvciBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdEVhY2gob2JqZWN0LCBpdGVyYXRlZSkge1xuICBmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCFvYmplY3QuaGFzT3duUHJvcGVydHkgfHwgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eSAmJiBvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkpIHtcbiAgICAgIGlmIChpdGVyYXRlZShvYmplY3Rba2V5XSwga2V5LCBvYmplY3QpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufVxuIiwiXG5pbXBvcnQge2luaGVyaXR9IGZyb20gJy4vb2JqZWN0JztcblxuLyoqXG4gKiBGYWN0b3J5IGZvciBjb2x1bW5zIGNvbnN0cnVjdG9ycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gR3JpZFNldHRpbmdzXG4gKiBAcGFyYW0ge0FycmF5fSBjb25mbGljdExpc3RcbiAqIEByZXR1cm4ge09iamVjdH0gQ29sdW1uU2V0dGluZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbHVtbkZhY3RvcnkoR3JpZFNldHRpbmdzLCBjb25mbGljdExpc3QpIHtcbiAgZnVuY3Rpb24gQ29sdW1uU2V0dGluZ3MoKSB7fTtcblxuICBpbmhlcml0KENvbHVtblNldHRpbmdzLCBHcmlkU2V0dGluZ3MpO1xuXG4gIC8vIENsZWFyIGNvbmZsaWN0IHNldHRpbmdzXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjb25mbGljdExpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBDb2x1bW5TZXR0aW5ncy5wcm90b3R5cGVbY29uZmxpY3RMaXN0W2ldXSA9IHZvaWQgMDtcbiAgfVxuXG4gIHJldHVybiBDb2x1bW5TZXR0aW5ncztcbn1cbiIsIlxuaW1wb3J0IHtzdHJpbmdpZnl9IGZyb20gJy4vbWl4ZWQnO1xuXG4vKipcbiAqIENvbnZlcnQgc3RyaW5nIHRvIHVwcGVyIGNhc2UgZmlyc3QgbGV0dGVyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgU3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9VcHBlckNhc2VGaXJzdChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZ1swXS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnN1YnN0cigxKTtcbn1cblxuLyoqXG4gKiBDb21wYXJlIHN0cmluZ3MgY2FzZSBpbnNlbnNpdGl2ZWx5LlxuICpcbiAqIEBwYXJhbSB7Li4uU3RyaW5nfSBzdHJpbmdzIFN0cmluZ3MgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzSWdub3JlQ2FzZSguLi5zdHJpbmdzKSB7XG4gIGxldCB1bmlxdWUgPSBbXTtcbiAgbGV0IGxlbmd0aCA9IHN0cmluZ3MubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGggLS0pIHtcbiAgICBsZXQgc3RyaW5nID0gc3RyaW5naWZ5KHN0cmluZ3NbbGVuZ3RoXSkudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmICh1bmlxdWUuaW5kZXhPZihzdHJpbmcpID09PSAtMSkge1xuICAgICAgdW5pcXVlLnB1c2goc3RyaW5nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5pcXVlLmxlbmd0aCA9PT0gMTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gaGV4IHN0cmluZy4gVXNlZCBhcyBuYW1lc3BhY2UgZm9yIEhhbmRzb250YWJsZSBpbnN0YW5jZSBldmVudHMuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IC0gMTYgY2hhcmFjdGVyIHJhbmRvbSBzdHJpbmc6IFwiOTJiMWJmYzc0ZWM0XCJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbVN0cmluZygpIHtcbiAgZnVuY3Rpb24gczQoKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApXG4gICAgICAudG9TdHJpbmcoMTYpXG4gICAgICAuc3Vic3RyaW5nKDEpO1xuICB9XG5cbiAgcmV0dXJuIHM0KCkgKyBzNCgpICsgczQoKSArIHM0KCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHZhbHVlIGlzIHZhbGlkIHBlcmNlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGVyY2VudFZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiAvXihbMC05XVswLTldP1xcJSQpfCheMTAwXFwlJCkvLnRlc3QodmFsdWUpO1xufVxuIiwiXG5pbXBvcnQge2FycmF5RWFjaH0gZnJvbSAnLi9hcnJheSc7XG5cbmV4cG9ydCBjb25zdCBLRVlfQ09ERVMgPSB7XG4gIE1PVVNFX0xFRlQ6IDEsXG4gIE1PVVNFX1JJR0hUOiAzLFxuICBNT1VTRV9NSURETEU6IDIsXG4gIEJBQ0tTUEFDRTogOCxcbiAgQ09NTUE6IDE4OCxcbiAgSU5TRVJUOiA0NSxcbiAgREVMRVRFOiA0NixcbiAgRU5EOiAzNSxcbiAgRU5URVI6IDEzLFxuICBFU0NBUEU6IDI3LFxuICBDT05UUk9MX0xFRlQ6IDkxLFxuICBDT01NQU5EX0xFRlQ6IDE3LFxuICBDT01NQU5EX1JJR0hUOiA5MyxcbiAgQUxUOiAxOCxcbiAgSE9NRTogMzYsXG4gIFBBR0VfRE9XTjogMzQsXG4gIFBBR0VfVVA6IDMzLFxuICBQRVJJT0Q6IDE5MCxcbiAgU1BBQ0U6IDMyLFxuICBTSElGVDogMTYsXG4gIENBUFNfTE9DSzogMjAsXG4gIFRBQjogOSxcbiAgQVJST1dfUklHSFQ6IDM5LFxuICBBUlJPV19MRUZUOiAzNyxcbiAgQVJST1dfVVA6IDM4LFxuICBBUlJPV19ET1dOOiA0MCxcbiAgRjE6IDExMixcbiAgRjI6IDExMyxcbiAgRjM6IDExNCxcbiAgRjQ6IDExNSxcbiAgRjU6IDExNixcbiAgRjY6IDExNyxcbiAgRjc6IDExOCxcbiAgRjg6IDExOSxcbiAgRjk6IDEyMCxcbiAgRjEwOiAxMjEsXG4gIEYxMTogMTIyLFxuICBGMTI6IDEyMyxcbiAgQTogNjUsXG4gIFg6IDg4LFxuICBDOiA2NyxcbiAgVjogODZcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGtleUNvZGUgcmVwcmVzZW50cyBhIHByaW50YWJsZSBjaGFyYWN0ZXIuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGtleUNvZGVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNQcmludGFibGVDaGFyKGtleUNvZGUpIHtcbiAgcmV0dXJuICgoa2V5Q29kZSA9PSAzMikgfHwgLy9zcGFjZVxuICAgICAgKGtleUNvZGUgPj0gNDggJiYga2V5Q29kZSA8PSA1NykgfHwgLy8wLTlcbiAgICAgIChrZXlDb2RlID49IDk2ICYmIGtleUNvZGUgPD0gMTExKSB8fCAvL251bXBhZFxuICAgICAgKGtleUNvZGUgPj0gMTg2ICYmIGtleUNvZGUgPD0gMTkyKSB8fCAvLzs9LC0uL2BcbiAgICAgIChrZXlDb2RlID49IDIxOSAmJiBrZXlDb2RlIDw9IDIyMikgfHwgLy9bXXt9XFx8XCInXG4gICAgICBrZXlDb2RlID49IDIyNiB8fCAvL3NwZWNpYWwgY2hhcnMgKDIyOSBmb3IgQXNpYW4gY2hhcnMpXG4gICAgICAoa2V5Q29kZSA+PSA2NSAmJiBrZXlDb2RlIDw9IDkwKSk7IC8vYS16XG59XG5cbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IGtleUNvZGVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNNZXRhS2V5KGtleUNvZGUpIHtcbiAgdmFyIG1ldGFLZXlzID0gW1xuICAgIEtFWV9DT0RFUy5BUlJPV19ET1dOLFxuICAgIEtFWV9DT0RFUy5BUlJPV19VUCxcbiAgICBLRVlfQ09ERVMuQVJST1dfTEVGVCxcbiAgICBLRVlfQ09ERVMuQVJST1dfUklHSFQsXG4gICAgS0VZX0NPREVTLkhPTUUsXG4gICAgS0VZX0NPREVTLkVORCxcbiAgICBLRVlfQ09ERVMuREVMRVRFLFxuICAgIEtFWV9DT0RFUy5CQUNLU1BBQ0UsXG4gICAgS0VZX0NPREVTLkYxLFxuICAgIEtFWV9DT0RFUy5GMixcbiAgICBLRVlfQ09ERVMuRjMsXG4gICAgS0VZX0NPREVTLkY0LFxuICAgIEtFWV9DT0RFUy5GNSxcbiAgICBLRVlfQ09ERVMuRjYsXG4gICAgS0VZX0NPREVTLkY3LFxuICAgIEtFWV9DT0RFUy5GOCxcbiAgICBLRVlfQ09ERVMuRjksXG4gICAgS0VZX0NPREVTLkYxMCxcbiAgICBLRVlfQ09ERVMuRjExLFxuICAgIEtFWV9DT0RFUy5GMTIsXG4gICAgS0VZX0NPREVTLlRBQixcbiAgICBLRVlfQ09ERVMuUEFHRV9ET1dOLFxuICAgIEtFWV9DT0RFUy5QQUdFX1VQLFxuICAgIEtFWV9DT0RFUy5FTlRFUixcbiAgICBLRVlfQ09ERVMuRVNDQVBFLFxuICAgIEtFWV9DT0RFUy5TSElGVCxcbiAgICBLRVlfQ09ERVMuQ0FQU19MT0NLLFxuICAgIEtFWV9DT0RFUy5BTFRcbiAgXTtcblxuICByZXR1cm4gbWV0YUtleXMuaW5kZXhPZihrZXlDb2RlKSAhPT0gLTE7XG59XG5cbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IGtleUNvZGVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDdHJsS2V5KGtleUNvZGUpIHtcbiAgcmV0dXJuIFtLRVlfQ09ERVMuQ09OVFJPTF9MRUZULCAyMjQsIEtFWV9DT0RFUy5DT01NQU5EX0xFRlQsIEtFWV9DT0RFUy5DT01NQU5EX1JJR0hUXS5pbmRleE9mKGtleUNvZGUpICE9PSAtMTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0ga2V5Q29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2VDb2RlXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzS2V5KGtleUNvZGUsIGJhc2VDb2RlKSB7XG4gIGxldCBrZXlzID0gYmFzZUNvZGUuc3BsaXQoJ3wnKTtcbiAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuXG4gIGFycmF5RWFjaChrZXlzLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoa2V5Q29kZSA9PT0gS0VZX0NPREVTW2tleV0pIHtcbiAgICAgIHJlc3VsdCA9IHRydWU7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCJcbmV4cG9ydCB7TXVsdGlNYXB9O1xuXG4vLyBUT0RPOiBHbG9iYWwgZXhwb3NlIGZvciB0ZXN0c1xud2luZG93Lk11bHRpTWFwID0gTXVsdGlNYXA7XG5cbmZ1bmN0aW9uIE11bHRpTWFwKCkge1xuICB2YXIgbWFwID0ge1xuICAgIGFycmF5TWFwOiBbXSxcbiAgICB3ZWFrTWFwOiBuZXcgV2Vha01hcCgpXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICAnZ2V0JzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKGNhbkJlQW5BcnJheU1hcEtleShrZXkpKSB7XG4gICAgICAgIHJldHVybiBtYXAuYXJyYXlNYXBba2V5XTtcbiAgICAgIH0gZWxzZSBpZiAoY2FuQmVBV2Vha01hcEtleShrZXkpKSB7XG4gICAgICAgIHJldHVybiBtYXAud2Vha01hcC5nZXQoa2V5KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgJ3NldCc6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoY2FuQmVBbkFycmF5TWFwS2V5KGtleSkpIHtcbiAgICAgICAgbWFwLmFycmF5TWFwW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoY2FuQmVBV2Vha01hcEtleShrZXkpKSB7XG4gICAgICAgIG1hcC53ZWFrTWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXkgdHlwZScpO1xuICAgICAgfVxuXG5cbiAgICB9LFxuXG4gICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChjYW5CZUFuQXJyYXlNYXBLZXkoa2V5KSkge1xuICAgICAgICBkZWxldGUgbWFwLmFycmF5TWFwW2tleV07XG4gICAgICB9IGVsc2UgaWYgKGNhbkJlQVdlYWtNYXBLZXkoa2V5KSkge1xuICAgICAgICBtYXAud2Vha01hcFsnZGVsZXRlJ10oa2V5KTsgIC8vRGVsZXRlIG11c3QgYmUgY2FsbGVkIHVzaW5nIHNxdWFyZSBicmFja2V0IG5vdGF0aW9uLCBiZWNhdXNlIElFOCBkb2VzIG5vdCBoYW5kbGUgdXNpbmcgYGRlbGV0ZWAgd2l0aCBkb3Qgbm90YXRpb25cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY2FuQmVBbkFycmF5TWFwS2V5KG9iail7XG4gICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiAhaXNOYU5TeW1ib2wob2JqKSAmJiAodHlwZW9mIG9iaiA9PSAnc3RyaW5nJyB8fCB0eXBlb2Ygb2JqID09ICdudW1iZXInKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbkJlQVdlYWtNYXBLZXkob2JqKXtcbiAgICByZXR1cm4gb2JqICE9PSBudWxsICYmICh0eXBlb2Ygb2JqID09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT0gJ2Z1bmN0aW9uJyk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05hTlN5bWJvbChvYmope1xuICAgIHJldHVybiBvYmogIT09IG9iajsgLy8gTmFOID09PSBOYU4gaXMgYWx3YXlzIGZhbHNlXG4gIH1cbn1cbiIsIlxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEhhbmRzb250YWJsZSBldmVudHMgYXJlIHRoZSBjb21tb24gaW50ZXJmYWNlIHRoYXQgZnVuY3Rpb24gaW4gMiB3YXlzOiBhcyBfX2NhbGxiYWNrc19fIGFuZCBhcyBfX2hvb2tzX18uXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc1xuICogLy8gVXNpbmcgZXZlbnRzIGFzIGNhbGxiYWNrczpcbiAqIC4uLlxuICogdmFyIGhvdDEgPSBuZXcgSGFuZHNvbnRhYmxlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdleGFtcGxlMScpLCB7XG4gKiAgIGFmdGVyQ2hhbmdlOiBmdW5jdGlvbihjaGFuZ2VzLCBzb3VyY2UpIHtcbiAqICAgICAkLmFqYXgoe1xuICogICAgICAgdXJsOiBcInNhdmUucGhwXCIsXG4gKiAgICAgICBkYXRhOiBjaGFuZ2VcbiAqICAgICB9KTtcbiAqICAgfVxuICogfSk7XG4gKiAuLi5cbiAqIGBgYFxuICpcbiAqIGBgYGpzXG4gKiAvLyBVc2luZyBldmVudHMgYXMgcGx1Z2luIGhvb2tzOlxuICogLi4uXG4gKiB2YXIgaG90MSA9IG5ldyBIYW5kc29udGFibGUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2V4YW1wbGUxJyksIHtcbiAqICAgbXlQbHVnaW46IHRydWVcbiAqIH0pO1xuICpcbiAqIHZhciBob3QyID0gbmV3IEhhbmRzb250YWJsZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXhhbXBsZTInKSwge1xuICogICBteVBsdWdpbjogZmFsc2VcbiAqIH0pO1xuICpcbiAqIC8vIGdsb2JhbCBob29rXG4gKiBIYW5kc29udGFibGUuaG9va3MuYWRkKCdhZnRlckNoYW5nZScsIGZ1bmN0aW9uKCkge1xuICogICAvLyBGaXJlZCB0d2ljZSAtIGZvciBob3QxIGFuZCBob3QyXG4gKiAgIGlmICh0aGlzLmdldFNldHRpbmdzKCkubXlQbHVnaW4pIHtcbiAqICAgICAvLyBmdW5jdGlvbiBib2R5IC0gd2lsbCBvbmx5IHJ1biBmb3IgaG90MVxuICogICB9XG4gKiB9KTtcbiAqXG4gKiAvLyBsb2NhbCBob29rIChoYXMgc2FtZSBlZmZlY3QgYXMgYSBjYWxsYmFjaylcbiAqIGhvdDIuYWRkSG9vaygnYWZ0ZXJDaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAqICAgLy8gZnVuY3Rpb24gYm9keSAtIHdpbGwgb25seSBydW4gaW4gI2V4YW1wbGUyXG4gKiB9KTtcbiAqIGBgYFxuICogLi4uXG4gKi9cblxuLy8gQFRPRE86IE1vdmUgcGx1Z2luIGRlc2NyaXB0aW9uIGhvb2tzIHRvIHBsdWdpbj9cbmNvbnN0IFJFR0lTVEVSRURfSE9PS1MgPSBbXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBhZnRlciByZXNldCBjZWxsJ3MgbWV0YS5cbiAgICpcbiAgICogQGV2ZW50IEhvb2tzI2FmdGVyQ2VsbE1ldGFSZXNldFxuICAgKiBAc2luY2UgMC4xMVxuICAgKi9cbiAgXCJhZnRlckNlbGxNZXRhUmVzZXRcIixcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIENhbGxiYWNrIGZpcmVkIGFmdGVyIG9uZSBvciBtb3JlIGNlbGxzIGlzIGNoYW5nZWQuIEl0cyBtYWluIHVzZSBjYXNlIGlzIHRvIHNhdmUgdGhlIGlucHV0LlxuICAgKlxuICAgKiBfX05vdGU6X18gRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIHRoZSBgY2hhbmdlc2AgYXJyYXkgaXMgbnVsbCBmb3IgYFwibG9hZERhdGFcImAgc291cmNlLlxuICAgKlxuICAgKiBAZXZlbnQgSG9va3MjYWZ0ZXJDaGFuZ2VcbiAgICogQHBhcmFtIHtBcnJheX0gY2hhbmdlcyAyRCBhcnJheSBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IGVhY2ggb2YgdGhlIGVkaXRlZCBjZWxscyBgW1tyb3csIHByb3AsIG9sZFZhbCwgbmV3VmFsXSwgLi4uXWBcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNvdXJjZSBJcyBvbmUgb2YgdGhlIHN0cmluZ3M6IGBcImFsdGVyXCIsIFwiZW1wdHlcIiwgXCJlZGl0XCIsIFwicG9wdWxhdGVGcm9tQXJyYXlcIiwgXCJsb2FkRGF0YVwiLCBcImF1dG9maWxsXCIsIFwicGFzdGVcImAuXG4gICAqL1xuICBcImFmdGVyQ2hhbmdlXCIsXG4gIFwiYWZ0ZXJDaGFuZ2VzT2JzZXJ2ZWRcIixcbiAgXCJhZnRlckNvbHVtbk1vdmVcIixcbiAgXCJhZnRlckNvbHVtblJlc2l6ZVwiLFxuICBcImFmdGVyQ29udGV4dE1lbnVEZWZhdWx0T3B0aW9uc1wiLFxuICBcImFmdGVyQ29udGV4dE1lbnVIaWRlXCIsXG4gIFwiYWZ0ZXJDb250ZXh0TWVudVNob3dcIixcbiAgXCJhZnRlckNvcHlMaW1pdFwiLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBpcyBmaXJlZCB3aGVuIGEgbmV3IGNvbHVtbiBpcyBjcmVhdGVkLlxuICAgKlxuICAgKiBAZXZlbnQgSG9va3MjYWZ0ZXJDcmVhdGVDb2xcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFJlcHJlc2VudHMgdGhlIGluZGV4IG9mIGZpcnN0IG5ld2x5IGNyZWF0ZWQgY29sdW1uIGluIHRoZSBkYXRhIHNvdXJjZSBhcnJheS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFtb3VudCBOdW1iZXIgb2YgbmV3bHkgY3JlYXRlZCBjb2x1bW5zIGluIHRoZSBkYXRhIHNvdXJjZSBhcnJheS5cbiAgICovXG4gIFwiYWZ0ZXJDcmVhdGVDb2xcIixcblxuICAvKipcbiAgICogQ2FsbGJhY2sgaXMgZmlyZWQgd2hlbiBhIG5ldyByb3cgaXMgY3JlYXRlZC5cbiAgICpcbiAgICogQGV2ZW50IEhvb2tzI2FmdGVyQ3JlYXRlUm93XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBSZXByZXNlbnRzIHRoZSBpbmRleCBvZiBmaXJzdCBuZXdseSBjcmVhdGVkIHJvdyBpbiB0aGUgZGF0YSBzb3VyY2UgYXJyYXkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgTnVtYmVyIG9mIG5ld2x5IGNyZWF0ZWQgcm93cyBpbiB0aGUgZGF0YSBzb3VyY2UgYXJyYXkuXG4gICAqL1xuICBcImFmdGVyQ3JlYXRlUm93XCIsXG5cbiAgLyoqXG4gICAqIEV2ZW50IGNhbGxlZCB3aGVuIGN1cnJlbnQgY2VsbCBpcyBkZXNlbGVjdGVkLlxuICAgKlxuICAgKiBAZXZlbnQgSG9va3MjYWZ0ZXJEZXNlbGVjdFxuICAgKi9cbiAgXCJhZnRlckRlc2VsZWN0XCIsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGFmdGVyIGRlc3Ryb3lpbmcgSGFuZHNvbnRhYmxlIGluc3RhbmNlLlxuICAgKlxuICAgKiBAZXZlbnQgSG9va3MjYWZ0ZXJEZXN0cm95XG4gICAqL1xuICBcImFmdGVyRGVzdHJveVwiLFxuXG4gIC8qKlxuICAgKiBAZXZlbnQgSG9va3MjYWZ0ZXJEb2N1bWVudEtleURvd25cbiAgICovXG4gIFwiYWZ0ZXJEb2N1bWVudEtleURvd25cIixcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYWZ0ZXIgZ2V0dGluZyBjZWxsIHNldHRpbmdzLlxuICAgKlxuICAgKiBAZXZlbnQgSG9va3MjYWZ0ZXJHZXRDZWxsTWV0YVxuICAgKiBAcGFyYW0ge051bWJlcn0gcm93XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb2xcbiAgICogQHBhcmFtIHtPYmplY3R9IGNlbGxQcm9wZXJ0aWVzXG4gICAqL1xuICBcImFmdGVyR2V0Q2VsbE1ldGFcIixcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYWZ0ZXIgZ2V0dGluZyBpbmZvIGFib3V0IGNvbHVtbiBoZWFkZXIuXG4gICAqXG4gICAqIEBldmVudCBIb29rcyNhZnRlckdldENvbEhlYWRlclxuICAgKiBAcGFyYW0ge051bWJlcn0gY29sXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gVEhcbiAgICovXG4gIFwiYWZ0ZXJHZXRDb2xIZWFkZXJcIixcblxuICAvKipcbiAgICogQGV2ZW50IEhvb2tzI2FmdGVyR2V0Um93SGVhZGVyXG4gICAqL1xuICBcImFmdGVyR2V0Um93SGVhZGVyXCIsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGFmdGVyIEhhbmRzb250YWJsZSBpbnN0YW5jZSBpcyBpbml0aWF0ZWQuXG4gICAqXG4gICAqIEBldmVudCBIb29rcyNhZnRlckluaXRcbiAgICovXG4gIFwiYWZ0ZXJJbml0XCIsXG5cbiAgLyoqXG4gICAqIEBldmVudCBIb29rcyNhZnRlcklzTXVsdGlwbGVTZWxlY3Rpb25DaGVja1xuICAgKi9cbiAgXCJhZnRlcklzTXVsdGlwbGVTZWxlY3Rpb25DaGVja1wiLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBhZnRlciBuZXcgZGF0YSBpcyBsb2FkZWQgKGJ5IGBsb2FkRGF0YWAgbWV0aG9kKSBpbnRvIHRoZSBkYXRhIHNvdXJjZSBhcnJheS5cbiAgICpcbiAgICogQGV2ZW50IEhvb2tzI2FmdGVyTG9hZERhdGFcbiAgICovXG4gIFwiYWZ0ZXJMb2FkRGF0YVwiLFxuXG4gIC8qKlxuICAgKiBAZXZlbnQgSG9va3MjYWZ0ZXJNb21lbnR1bVNjcm9sbFxuICAgKi9cbiAgXCJhZnRlck1vbWVudHVtU2Nyb2xsXCIsXG5cbiAgLyoqXG4gICAqIEBldmVudCBIb29rcyNhZnRlck9uQ2VsbENvcm5lck1vdXNlRG93blxuICAgKiBAc2luY2UgMC4xMVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICovXG4gIFwiYWZ0ZXJPbkNlbGxDb3JuZXJNb3VzZURvd25cIixcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYWZ0ZXIgY2xpY2tpbmcgb24gYSBjZWxsIG9yIHJvdy9jb2x1bW4gaGVhZGVyLlxuICAgKiBJbiBjYXNlIHRoZSByb3cvY29sdW1uIGhlYWRlciB3YXMgY2xpY2tlZCwgdGhlIGluZGV4IGlzIG5lZ2F0aXZlLlxuICAgKiBGb3IgZXhhbXBsZSBjbGlja2luZyBvbiB0aGUgcm93IGhlYWRlciBvZiBjZWxsICgwLCAwKSByZXN1bHRzIHdpdGggYGFmdGVyT25DZWxsTW91c2VEb3duYCBjYWxsZWQgd2l0aCBjb29yZHMgYHtyb3c6IDAsIGNvbDogLTF9YC5cbiAgICpcbiAgICogQGV2ZW50IEhvb2tzI2FmdGVyT25DZWxsTW91c2VEb3duXG4gICAqIEBzaW5jZSAwLjExXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gY29vcmRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBURFxuICAgKi9cbiAgXCJhZnRlck9uQ2VsbE1vdXNlRG93blwiLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBhZnRlciBob3ZlcmluZyBhIGNlbGwgb3Igcm93L2NvbHVtbiBoZWFkZXIgd2l0aCB0aGUgbW91c2UgY3Vyc29yLlxuICAgKiBJbiBjYXNlIHRoZSByb3cvY29sdW1uIGhlYWRlciB3YXMgaG92ZXJlZCwgdGhlIGluZGV4IGlzIG5lZ2F0aXZlLlxuICAgKiBGb3IgZXhhbXBsZSBjbGlja2luZyBvbiB0aGUgcm93IGhlYWRlciBvZiBjZWxsICgwLCAwKSByZXN1bHRzIHdpdGggYGFmdGVyT25DZWxsTW91c2VPdmVyYCBjYWxsZWQgd2l0aCBjb29yZHMgYHtyb3c6IDAsIGNvbDogLTF9YC5cbiAgICpcbiAgICogQGV2ZW50IEhvb2tzI2FmdGVyT25DZWxsTW91c2VPdmVyXG4gICAqIEBzaW5jZSAwLjExXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gY29vcmRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBURFxuICAgKi9cbiAgXCJhZnRlck9uQ2VsbE1vdXNlT3ZlclwiLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBpcyBmaXJlZCB3aGVuIG9uZSBvciBtb3JlIGNvbHVtbnMgYXJlIHJlbW92ZWQuXG4gICAqXG4gICAqIEBldmVudCBIb29rcyNhZnRlclJlbW92ZUNvbFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSXMgYW4gaW5kZXggb2Ygc3RhcnRlciBjb2x1bW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgSXMgYW4gYW1vdW50IG9mIHJlbW92ZWQgY29sdW1ucy5cbiAgICovXG4gIFwiYWZ0ZXJSZW1vdmVDb2xcIixcblxuICAvKipcbiAgICogQ2FsbGJhY2sgaXMgZmlyZWQgd2hlbiBvbmUgb3IgbW9yZSByb3dzIGFyZSByZW1vdmVkLlxuICAgKlxuICAgKiBAZXZlbnQgSG9va3MjYWZ0ZXJSZW1vdmVSb3dcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IElzIGFuIGluZGV4IG9mIHN0YXJ0ZXIgcm93LlxuICAgKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IElzIGFuIGFtb3VudCBvZiByZW1vdmVkIHJvd3MuXG4gICAqL1xuICBcImFmdGVyUmVtb3ZlUm93XCIsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGFmdGVyIEhhbmRzb250YWJsZSB0YWJsZSBpcyByZW5kZXJlZC5cbiAgICpcbiAgICogQGV2ZW50IEhvb2tzI2FmdGVyUmVuZGVyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNGb3JjZWQgSXMgYHRydWVgIGlmIHJlbmRlcmluZyB3YXMgdHJpZ2dlcmVkIGJ5IGEgY2hhbmdlIG9mIHNldHRpbmdzIG9yIGRhdGE7IG9yIGBmYWxzZWAgaWZcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJpbmcgd2FzIHRyaWdnZXJlZCBieSBzY3JvbGxpbmcgb3IgbW92aW5nIHNlbGVjdGlvbi5cbiAgICovXG4gIFwiYWZ0ZXJSZW5kZXJcIixcblxuICAvKipcbiAgICogQGV2ZW50IEhvb2tzI2FmdGVyUmVuZGVyZXJcbiAgICogQHNpbmNlIDAuMTFcbiAgICogQHBhcmFtIHtPYmplY3R9IFREXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByb3dcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNlbGxQcm9wZXJ0aWVzXG4gICAqL1xuICBcImFmdGVyUmVuZGVyZXJcIixcbiAgXCJhZnRlclJvd01vdmVcIixcbiAgXCJhZnRlclJvd1Jlc2l6ZVwiLFxuXG4gIC8qKlxuICAgKiBAZXZlbnQgSG9va3MjYWZ0ZXJTY3JvbGxIb3Jpem9udGFsbHlcbiAgICogQHNpbmNlIDAuMTFcbiAgICovXG4gIFwiYWZ0ZXJTY3JvbGxIb3Jpem9udGFsbHlcIixcblxuICAvKipcbiAgICogQGV2ZW50IEhvb2tzI2FmdGVyU2Nyb2xsVmVydGljYWxseVxuICAgKiBAc2luY2UgMC4xMVxuICAgKi9cbiAgXCJhZnRlclNjcm9sbFZlcnRpY2FsbHlcIixcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgd2hpbGUgb25lIG9yIG1vcmUgY2VsbHMgYXJlIGJlaW5nIHNlbGVjdGVkIChvbiBtb3VzZSBtb3ZlKS5cbiAgICpcbiAgICogQGV2ZW50IEhvb2tzI2FmdGVyU2VsZWN0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByIFNlbGVjdGlvbiBzdGFydCByb3dcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGMgU2VsZWN0aW9uIHN0YXJ0IGNvbHVtblxuICAgKiBAcGFyYW0ge051bWJlcn0gcjIgU2VsZWN0aW9uIGVuZCByb3dcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGMyIFNlbGVjdGlvbiBlbmQgY29sdW1uXG4gICAqL1xuICBcImFmdGVyU2VsZWN0aW9uXCIsXG5cbiAgLyoqXG4gICAqIFRoZSBzYW1lIGFzIGFib3ZlLCBidXQgZGF0YSBzb3VyY2Ugb2JqZWN0IHByb3BlcnR5IG5hbWUgaXMgdXNlZCBpbnN0ZWFkIG9mIHRoZSBjb2x1bW4gbnVtYmVyLlxuICAgKlxuICAgKiBAZXZlbnQgSG9va3MjYWZ0ZXJTZWxlY3Rpb25CeVByb3BcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHIgU2VsZWN0aW9uIHN0YXJ0IHJvd1xuICAgKiBAcGFyYW0ge1N0cmluZ30gcCBTZWxlY3Rpb24gc3RhcnQgZGF0YSBzb3VyY2Ugb2JqZWN0IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSByMiBTZWxlY3Rpb24gZW5kIHJvd1xuICAgKiBAcGFyYW0ge1N0cmluZ30gcDIgU2VsZWN0aW9uIGVuZCBkYXRhIHNvdXJjZSBvYmplY3QgcHJvcGVydHlcbiAgICovXG4gIFwiYWZ0ZXJTZWxlY3Rpb25CeVByb3BcIixcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYWZ0ZXIgb25lIG9yIG1vcmUgY2VsbHMgYXJlIHNlbGVjdGVkIChvbiBtb3VzZSB1cCkuXG4gICAqXG4gICAqIEBldmVudCBIb29rcyNhZnRlclNlbGVjdGlvbkVuZFxuICAgKiBAcGFyYW0ge051bWJlcn0gciBTZWxlY3Rpb24gc3RhcnQgcm93XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjIFNlbGVjdGlvbiBzdGFydCBjb2x1bW5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHIyIFNlbGVjdGlvbiBlbmQgcm93XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjMiBTZWxlY3Rpb24gZW5kIGNvbHVtblxuICAgKi9cbiAgXCJhZnRlclNlbGVjdGlvbkVuZFwiLFxuXG4gIC8qKlxuICAgKiBUaGUgc2FtZSBhcyBhYm92ZSwgYnV0IGRhdGEgc291cmNlIG9iamVjdCBwcm9wZXJ0eSBuYW1lIGlzIHVzZWQgaW5zdGVhZCBvZiB0aGUgY29sdW1uIG51bWJlci5cbiAgICpcbiAgICogQGV2ZW50IEhvb2tzI2FmdGVyU2VsZWN0aW9uRW5kQnlQcm9wXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByIFNlbGVjdGlvbiBzdGFydCByb3dcbiAgICogQHBhcmFtIHtTdHJpbmd9IHAgU2VsZWN0aW9uIHN0YXJ0IGRhdGEgc291cmNlIG9iamVjdCBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge051bWJlcn0gcjIgU2VsZWN0aW9uIGVuZCByb3dcbiAgICogQHBhcmFtIHtTdHJpbmd9IHAyIFNlbGVjdGlvbiBlbmQgZGF0YSBzb3VyY2Ugb2JqZWN0IHByb3BlcnR5XG4gICAqL1xuICBcImFmdGVyU2VsZWN0aW9uRW5kQnlQcm9wXCIsXG5cbiAgLyoqXG4gICAqIENhbGxlZCBhZnRlciBjZWxsIG1ldGEgd2FzIGNoYW5nZWQsIGUuZy4gdXNpbmcgdGhlIGNvbnRleHQgbWVudS5cbiAgICpcbiAgICogQGV2ZW50IEhvb2tzI2FmdGVyU2V0Q2VsbE1ldGFcbiAgICogQHNpbmNlIDAuMTEuMFxuICAgKiBAcGFyYW0ge051bWJlcn0gcm93XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb2xcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuICBcImFmdGVyU2V0Q2VsbE1ldGFcIixcblxuICAvKipcbiAgICogQGV2ZW50IEhvb2tzI2FmdGVyVXBkYXRlU2V0dGluZ3NcbiAgICovXG4gIFwiYWZ0ZXJVcGRhdGVTZXR0aW5nc1wiLFxuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQSBwbHVnaW4gaG9vayBleGVjdXRlZCBhZnRlciB2YWxpZGF0b3IgZnVuY3Rpb24sIG9ubHkgaWYgdmFsaWRhdG9yIGZ1bmN0aW9uIGlzIGRlZmluZWQuXG4gICAqIFZhbGlkYXRpb24gcmVzdWx0IGlzIHRoZSBmaXJzdCBwYXJhbWV0ZXIuIFRoaXMgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5hdGUgaWYgdmFsaWRhdGlvbiBwYXNzZWQgc3VjY2Vzc2Z1bGx5IG9yIG5vdC5cbiAgICpcbiAgICogX19Zb3UgY2FuIGNhbmNlbCBjdXJyZW50IGNoYW5nZSBieSByZXR1cm5pbmcgZmFsc2UuX19cbiAgICpcbiAgICogQGV2ZW50IEhvb2tzI2FmdGVyVmFsaWRhdGVcbiAgICogQHNpbmNlIDAuOS41XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNWYWxpZFxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByb3dcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNvdXJjZVxuICAgKi9cbiAgXCJhZnRlclZhbGlkYXRlXCIsXG5cbiAgLyoqXG4gICAqIEBldmVudCBIb29rcyNiZWZvcmVBdXRvZmlsbFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhcnQgT2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgZmlyc3QgZmlsbGVkIGNlbGw6IGB7cm93OiAyLCBjb2w6IDB9YFxuICAgKiBAcGFyYW0ge09iamVjdH0gZW5kIE9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IGxhc3QgZmlsbGVkIGNlbGw6IGB7cm93OiA0LCBjb2w6IDF9YFxuICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhIDJEIGFycmF5IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgZmlsbCBwYXR0ZXJuOiBgW1tcIjFcIiwgXCJUZWRcIl0sIFtcIjFcIiwgXCJKb2huXCJdXWBcbiAgICovXG4gIFwiYmVmb3JlQXV0b2ZpbGxcIixcblxuICAvKipcbiAgICogQGV2ZW50IEhvb2tzI2JlZm9yZUNlbGxBbGlnbm1lbnRcbiAgICovXG4gIFwiYmVmb3JlQ2VsbEFsaWdubWVudFwiLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBiZWZvcmUgb25lIG9yIG1vcmUgY2VsbHMgaXMgY2hhbmdlZC4gSXRzIG1haW4gcHVycG9zZSBpcyB0byBhbHRlciBjaGFuZ2VzIHNpbGVudGx5IGJlZm9yZSBpbnB1dC5cbiAgICpcbiAgICogQGV2ZW50IEhvb2tzI2JlZm9yZUNoYW5nZVxuICAgKiBAcGFyYW0ge0FycmF5fSBjaGFuZ2VzIDJEIGFycmF5IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgZWFjaCBvZiB0aGUgZWRpdGVkIGNlbGxzLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlIFRoZSBuYW1lIG9mIGEgc291cmNlIG9mIGNoYW5nZXMuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIC8vIFRvIGRpc3JlZ2FyZCBhIHNpbmdsZSBjaGFuZ2UsIHNldCBjaGFuZ2VzW2ldIHRvIG51bGwgb3IgcmVtb3ZlIGl0IGZyb20gYXJyYXkgdXNpbmcgY2hhbmdlcy5zcGxpY2UoaSwgMSkuXG4gICAqIC4uLlxuICAgKiBuZXcgSGFuZHNvbnRhYmxlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdleGFtcGxlJyksIHtcbiAgICogICBiZWZvcmVDaGFuZ2U6IGZ1bmN0aW9uKGNoYW5nZXMsIHNvdXJjZSkge1xuICAgKiAgICAgLy8gW1tyb3csIHByb3AsIG9sZFZhbCwgbmV3VmFsXSwgLi4uXVxuICAgKiAgICAgY2hhbmdlc1swXSA9IG51bGw7XG4gICAqICAgfVxuICAgKiB9KTtcbiAgICogLi4uXG4gICAqXG4gICAqIC8vIFRvIGFsdGVyIGEgc2luZ2xlIGNoYW5nZSwgb3ZlcndyaXRlIHRoZSBkZXNpcmVkIHZhbHVlIHRvIGNoYW5nZXNbaV1bM10uXG4gICAqIC4uLlxuICAgKiBuZXcgSGFuZHNvbnRhYmxlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdleGFtcGxlJyksIHtcbiAgICogICBiZWZvcmVDaGFuZ2U6IGZ1bmN0aW9uKGNoYW5nZXMsIHNvdXJjZSkge1xuICAgKiAgICAgLy8gW1tyb3csIHByb3AsIG9sZFZhbCwgbmV3VmFsXSwgLi4uXVxuICAgKiAgICAgY2hhbmdlc1swXVsxXSA9IDEwO1xuICAgKiAgIH1cbiAgICogfSk7XG4gICAqIC4uLlxuICAgKlxuICAgKiAvLyBUbyBjYW5jZWwgYWxsIGVkaXQsIHJldHVybiBmYWxzZSBmcm9tIHRoZSBjYWxsYmFjayBvciBzZXQgYXJyYXkgbGVuZ3RoIHRvIDAgKGNoYW5nZXMubGVuZ3RoID0gMCkuXG4gICAqIC4uLlxuICAgKiBuZXcgSGFuZHNvbnRhYmxlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdleGFtcGxlJyksIHtcbiAgICogICBiZWZvcmVDaGFuZ2U6IGZ1bmN0aW9uKGNoYW5nZXMsIHNvdXJjZSkge1xuICAgKiAgICAgLy8gW1tyb3csIHByb3AsIG9sZFZhbCwgbmV3VmFsXSwgLi4uXVxuICAgKiAgICAgcmV0dXJuIGZhbHNlO1xuICAgKiAgIH1cbiAgICogfSk7XG4gICAqIC4uLlxuICAgKiBgYGBcbiAgICovXG4gIFwiYmVmb3JlQ2hhbmdlXCIsXG5cbiAgLyoqXG4gICAqIEBldmVudCBIb29rcyNiZWZvcmVDaGFuZ2VSZW5kZXJcbiAgICogQHNpbmNlIDAuMTFcbiAgICovXG4gIFwiYmVmb3JlQ2hhbmdlUmVuZGVyXCIsXG5cbiAgLyoqXG4gICAqIEBldmVudCBIb29rcyNiZWZvcmVEcmF3Qm9yZGVyc1xuICAgKi9cbiAgXCJiZWZvcmVEcmF3Qm9yZGVyc1wiLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBiZWZvcmUgZ2V0dGluZyBjZWxsIHNldHRpbmdzLlxuICAgKlxuICAgKiBAZXZlbnQgSG9va3MjYmVmb3JlR2V0Q2VsbE1ldGFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJvd1xuICAgKiBAcGFyYW0ge051bWJlcn0gY29sXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjZWxsUHJvcGVydGllc1xuICAgKi9cbiAgXCJiZWZvcmVHZXRDZWxsTWV0YVwiLFxuXG4gIC8qKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQ2FsbGJhY2sgZmlyZWQgYmVmb3JlIEhhbmRzb250YWJsZSBpbnN0YW5jZSBpcyBpbml0aWF0ZWQuXG4gICAqXG4gICAqIEBldmVudCBIb29rcyNiZWZvcmVJbml0XG4gICAqL1xuXG4gIFwiYmVmb3JlSW5pdFwiLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBiZWZvcmUgV2Fsa29udGFibGUgaW5zdGFuY2UgaXMgaW5pdGlhdGVkLlxuICAgKlxuICAgKiBAc2luY2UgMC4xMVxuICAgKiBAZXZlbnQgSG9va3MjYmVmb3JlSW5pdFdhbGtvbnRhYmxlXG4gICAqL1xuICBcImJlZm9yZUluaXRXYWxrb250YWJsZVwiLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBiZWZvcmUga2V5ZG93biBldmVudCBpcyBoYW5kbGVkLiBJdCBjYW4gYmUgdXNlZCB0byBvdmVyd3JpdGUgZGVmYXVsdCBrZXkgYmluZGluZ3MuXG4gICAqIENhdXRpb24gLSBpbiB5b3VyIGBiZWZvcmVLZXlEb3duYCBoYW5kbGVyIHlvdSBuZWVkIHRvIGNhbGwgYGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpYCB0byBwcmV2ZW50IGRlZmF1bHQga2V5IGJlaGF2aW9yLlxuICAgKlxuICAgKiBAZXZlbnQgSG9va3MjYmVmb3JlS2V5RG93blxuICAgKiBAc2luY2UgMC45LjBcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IE9yaWdpbmFsIERPTSBldmVudFxuICAgKi9cbiAgXCJiZWZvcmVLZXlEb3duXCIsXG5cbiAgLyoqXG4gICAqIEBldmVudCBIb29rcyNiZWZvcmVPbkNlbGxNb3VzZURvd25cbiAgICovXG4gIFwiYmVmb3JlT25DZWxsTW91c2VEb3duXCIsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGlzIGZpcmVkIHdoZW4gb25lIG9yIG1vcmUgY29sdW1ucyBhcmUgYWJvdXQgdG8gYmUgcmVtb3ZlZC5cbiAgICpcbiAgICogQGV2ZW50IEhvb2tzI2JlZm9yZVJlbW92ZUNvbFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggb2Ygc3RhcnRlciBjb2x1bW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgQW1vdW50IG9mIGNvbHVtbnMgdG8gYmUgcmVtb3ZlZC5cbiAgICovXG4gIFwiYmVmb3JlUmVtb3ZlQ29sXCIsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGlzIGZpcmVkIHdoZW4gb25lIG9yIG1vcmUgcm93cyBhcmUgYWJvdXQgdG8gYmUgcmVtb3ZlZC5cbiAgICpcbiAgICogQGV2ZW50IEhvb2tzI2JlZm9yZVJlbW92ZVJvd1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggb2Ygc3RhcnRlciBjb2x1bW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhbW91bnQgQW1vdW50IG9mIGNvbHVtbnMgdG8gYmUgcmVtb3ZlZC5cbiAgICovXG4gIFwiYmVmb3JlUmVtb3ZlUm93XCIsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGJlZm9yZSBIYW5kc29udGFibGUgdGFibGUgaXMgcmVuZGVyZWQuXG4gICAqXG4gICAqIEBldmVudCBIb29rcyNiZWZvcmVSZW5kZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc0ZvcmNlZCBJZiBgdHJ1ZWAgcmVuZGVyaW5nIHdhcyB0cmlnZ2VyZWQgYnkgYSBjaGFuZ2Ugb2Ygc2V0dGluZ3Mgb3IgZGF0YTsgb3IgYGZhbHNlYCBpZlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmluZyB3YXMgdHJpZ2dlcmVkIGJ5IHNjcm9sbGluZyBvciBtb3Zpbmcgc2VsZWN0aW9uLlxuICAgKi9cbiAgXCJiZWZvcmVSZW5kZXJcIixcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYmVmb3JlIHNldHRpbmcgcmFuZ2UgaXMgZW5kZWQuXG4gICAqXG4gICAqIEBldmVudCBIb29rcyNiZWZvcmVTZXRSYW5nZUVuZFxuICAgKiBAcGFyYW0ge0FycmF5fSBjb29yZHMgV2Fsa29udGFibGVDZWxsQ29vcmRzIGFycmF5LlxuICAgKi9cbiAgXCJiZWZvcmVTZXRSYW5nZUVuZFwiLFxuXG4gIC8qKlxuICAgKiBAZXZlbnQgSG9va3MjYmVmb3JlVG91Y2hTY3JvbGxcbiAgICovXG4gIFwiYmVmb3JlVG91Y2hTY3JvbGxcIixcblxuICAvKipcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEEgcGx1Z2luIGhvb2sgZXhlY3V0ZWQgYmVmb3JlIHZhbGlkYXRvciBmdW5jdGlvbiwgb25seSBpZiB2YWxpZGF0b3IgZnVuY3Rpb24gaXMgZGVmaW5lZC5cbiAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBtYW5pcHVsYXRlIHZhbHVlIG9mIGNoYW5nZWQgY2VsbCBiZWZvcmUgaXQgaXMgYXBwbGllZCB0byB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBfX05vdGljZTpfXyB0aGlzIHdpbGwgbm90IGFmZmVjdCB2YWx1ZXMgb2YgY2hhbmdlcy4gVGhpcyB3aWxsIGNoYW5nZSB2YWx1ZSBPTkxZIGZvciB2YWxpZGF0aW9uIVxuICAgKlxuICAgKiBAZXZlbnQgSG9va3MjYmVmb3JlVmFsaWRhdGVcbiAgICogQHNpbmNlIDAuOS41XG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJvd1xuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc291cmNlXG4gICAqL1xuICBcImJlZm9yZVZhbGlkYXRlXCIsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGFmdGVyIEhhbmRzb250YWJsZSBpbnN0YW5jZSBpcyBjb25zdHJ1Y3RlZCAodmlhIGBuZXdgIG9wZXJhdG9yKS5cbiAgICpcbiAgICogQGV2ZW50IEhvb2tzI2NvbnN0cnVjdFxuICAgKiBAc2luY2UgMC4xNi4xXG4gICAqL1xuICBcImNvbnN0cnVjdFwiLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBhZnRlciBIYW5kc29udGFibGUgaW5zdGFuY2UgaXMgaW5pdGlhdGVkIGJ1dCBiZWZvcmUgdGFibGUgaXMgcmVuZGVyZWQuXG4gICAqXG4gICAqIEBldmVudCBIb29rcyNpbml0XG4gICAqIEBzaW5jZSAwLjE2LjFcbiAgICovXG4gIFwiaW5pdFwiLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBmaXJlZCBhZnRlciBjb2x1bW4gbW9kaWZ5LlxuICAgKlxuICAgKiBAZXZlbnQgSG9va3MjbW9kaWZ5Q29sXG4gICAqIEBzaW5jZSAwLjExXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb2xcbiAgICovXG4gIFwibW9kaWZ5Q29sXCIsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGFmdGVyIG1vZGlmeSBjb2x1bW4ncyB3aWR0aC5cbiAgICpcbiAgICogQGV2ZW50IEhvb2tzI21vZGlmeUNvbFdpZHRoXG4gICAqIEBzaW5jZSAwLjExXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgKiBAcGFyYW0ge051bWJlcn0gY29sXG4gICAqL1xuICBcIm1vZGlmeUNvbFdpZHRoXCIsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGFmdGVyIHJvdyBtb2RpZnkuXG4gICAqXG4gICAqIEBldmVudCBIb29rcyNtb2RpZnlSb3dcbiAgICogQHNpbmNlIDAuMTFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHJvd1xuICAgKi9cbiAgXCJtb2RpZnlSb3dcIixcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYWZ0ZXIgbW9kaWZ5IGhlaWdodCBvZiByb3cuXG4gICAqXG4gICAqIEBldmVudCBIb29rcyNtb2RpZnlSb3dIZWlnaHRcbiAgICogQHNpbmNlIDAuMTFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgKiBAcGFyYW0ge051bWJlcn0gcm93XG4gICAqL1xuICBcIm1vZGlmeVJvd0hlaWdodFwiLFxuXG4gIC8qKlxuICAgKiBAZXZlbnQgSG9va3MjcGVyc2lzdGVudFN0YXRlTG9hZFxuICAgKi9cbiAgXCJwZXJzaXN0ZW50U3RhdGVMb2FkXCIsXG5cbiAgLyoqXG4gICAqIEBldmVudCBIb29rcyNwZXJzaXN0ZW50U3RhdGVSZXNldFxuICAgKi9cbiAgXCJwZXJzaXN0ZW50U3RhdGVSZXNldFwiLFxuXG4gIC8qKlxuICAgKiBAZXZlbnQgSG9va3MjcGVyc2lzdGVudFN0YXRlU2F2ZVxuICAgKi9cbiAgXCJwZXJzaXN0ZW50U3RhdGVTYXZlXCJcbl07XG5cbmltcG9ydCB7RXZlbnRNYW5hZ2VyfSBmcm9tICcuL2V2ZW50TWFuYWdlcic7XG5pbXBvcnQge2FycmF5RWFjaH0gZnJvbSAnLi9oZWxwZXJzL2FycmF5JztcbmltcG9ydCB7b2JqZWN0RWFjaH0gZnJvbSAnLi9oZWxwZXJzL29iamVjdCc7XG5cbmNsYXNzIEhvb2tzIHtcbiAgLyoqXG4gICAqXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmdsb2JhbEJ1Y2tldCA9IHRoaXMuY3JlYXRlRW1wdHlCdWNrZXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG5ldyBvYmplY3Qgd2l0aCBlbXB0eSBoYW5kbGVycyByZWxhdGVkIHRvIGV2ZXJ5IHJlZ2lzdGVyZWQgaG9vayBuYW1lLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBIYW5kc29udGFibGUuaG9va3MuY3JlYXRlRW1wdHlCdWNrZXQoKTtcbiAgICogLy8gUmVzdWx0czpcbiAgICoge1xuICAgKiAuLi5cbiAgICogYWZ0ZXJDcmVhdGVDb2w6IFtdLFxuICAgKiBhZnRlckNyZWF0ZVJvdzogW10sXG4gICAqIGJlZm9yZUluaXQ6IFtdLFxuICAgKiAuLi5cbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGNyZWF0ZUVtcHR5QnVja2V0KCkge1xuICAgIGNvbnN0IGJ1Y2tldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICBhcnJheUVhY2goUkVHSVNURVJFRF9IT09LUywgKGhvb2spID0+IChidWNrZXRbaG9va10gPSBbXSkpO1xuXG4gICAgcmV0dXJuIGJ1Y2tldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgaG9vayBidWNrZXQgYmFzZWQgb24gY29udGV4dCBvYmplY3Qgb3IgaWYgYXJndW1lbnQgaXMgYHVuZGVmaW5lZGAgZ2V0IGdsb2JhbCBob29rIGJ1Y2tlZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0PW51bGxdXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgZ2xvYmFsIG9yIGhhbmRzb250YWJsZSBpbnN0YW5jZSBidWNrZXRcbiAgICovXG4gIGdldEJ1Y2tldChjb250ZXh0ID0gbnVsbCkge1xuICAgIGlmIChjb250ZXh0KSB7XG4gICAgICBpZiAoIWNvbnRleHQucGx1Z2luSG9va0J1Y2tldCkge1xuICAgICAgICBjb250ZXh0LnBsdWdpbkhvb2tCdWNrZXQgPSB0aGlzLmNyZWF0ZUVtcHR5QnVja2V0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZXh0LnBsdWdpbkhvb2tCdWNrZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2xvYmFsQnVja2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgbGlzdGVuZXIgKGdsb2JhbGx5IG9yIGxvY2FsbHkpIHRvIHNwZWNpZmllZCBob29rIG5hbWUuXG4gICAqXG4gICAqIEBzZWUgQ29yZSNhZGRIb29rXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgSG9vay9FdmVudCBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258QXJyYXl9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIG9yIGFycmF5IG9mIGZ1bmN0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHQ9bnVsbF1cbiAgICogQHJldHVybnMge0hvb2tzfSBJbnN0YW5jZSBvZiBIb29rc1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBIYW5kc29udGFibGUuaG9va3MuYWRkKCdiZWZvcmVJbml0JywgbXlDYWxsYmFjaywgaG90SW5zdGFuY2UpO1xuICAgKiBgYGBcbiAgICovXG4gIGFkZChrZXksIGNhbGxiYWNrLCBjb250ZXh0ID0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNhbGxiYWNrKSkge1xuICAgICAgYXJyYXlFYWNoKGNhbGxiYWNrLCAoYykgPT4gKHRoaXMuYWRkKGtleSwgYywgY29udGV4dCkpKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBidWNrZXQgPSB0aGlzLmdldEJ1Y2tldChjb250ZXh0KTtcblxuICAgICAgaWYgKHR5cGVvZiBidWNrZXRba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlcihrZXkpO1xuICAgICAgICBidWNrZXRba2V5XSA9IFtdO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2suc2tpcCA9IGZhbHNlO1xuXG4gICAgICBpZiAoYnVja2V0W2tleV0uaW5kZXhPZihjYWxsYmFjaykgPT09IC0xKSB7XG4gICAgICAgIC8vIG9ubHkgYWRkIGEgaG9vayBpZiBpdCBoYXMgbm90IGFscmVhZHkgYmVlbiBhZGRlZCAoYWRkaW5nIHRoZSBzYW1lIGhvb2sgdHdpY2UgaXMgbm93IHNpbGVudGx5IGlnbm9yZWQpXG4gICAgICAgIGJ1Y2tldFtrZXldLnB1c2goY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgbGlzdGVuZXIgdG8gc3BlY2lmaWVkIGhvb2suIEFmdGVyIGhvb2sgcnVucyB0aGlzIGxpc3RlbmVyIHdpbGwgYmUgYXV0b21hdGljYWxseSByZW1vdmVkLlxuICAgKlxuICAgKiBAc2VlIENvcmUjYWRkSG9va09uY2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBIb29rL0V2ZW50IG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0PW51bGxdXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIEhhbmRzb250YWJsZS5ob29rcy5vbmNlKCdiZWZvcmVJbml0JywgbXlDYWxsYmFjaywgaG90SW5zdGFuY2UpO1xuICAgKiBgYGBcbiAgICovXG4gIG9uY2Uoa2V5LCBjYWxsYmFjaywgY29udGV4dCA9IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjYWxsYmFjaykpIHtcbiAgICAgIGFycmF5RWFjaChjYWxsYmFjaywgKGMpID0+ICh0aGlzLm9uY2Uoa2V5LCBjLCBjb250ZXh0KSkpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrLnJ1bk9uY2UgPSB0cnVlO1xuICAgICAgdGhpcy5hZGQoa2V5LCBjYWxsYmFjaywgY29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgbGlzdGVuZXIgZnJvbSBob29rcy5cbiAgICpcbiAgICogQHNlZSBDb3JlI3JlbW92ZUhvb2tcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBIb29rL0V2ZW50IG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0PW51bGxdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGhvb2sgd2FzIHJlbW92ZWRcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogSGFuZHNvbnRhYmxlLmhvb2tzLnJlbW92ZSgnYmVmb3JlSW5pdCcsIG15Q2FsbGJhY2spO1xuICAgKiBgYGBcbiAgICovXG4gIHJlbW92ZShrZXksIGNhbGxiYWNrLCBjb250ZXh0ID0gbnVsbCkge1xuICAgIGxldCBidWNrZXQgPSB0aGlzLmdldEJ1Y2tldChjb250ZXh0KTtcblxuICAgIGlmICh0eXBlb2YgYnVja2V0W2tleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAoYnVja2V0W2tleV0uaW5kZXhPZihjYWxsYmFjaykgPj0gMCkge1xuICAgICAgICBjYWxsYmFjay5za2lwID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUnVuIGFsbCBsb2NhbCBhbmQgZ2xvYmFsIGxpc3RlbmVycyBieSBob29rIG5hbWUuXG4gICAqXG4gICAqIEBzZWUgQ29yZSNydW5Ib29rc1xuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IEhvb2svRXZlbnQgbmFtZVxuICAgKiBAcGFyYW0geyp9IFtwMV1cbiAgICogQHBhcmFtIHsqfSBbcDJdXG4gICAqIEBwYXJhbSB7Kn0gW3AzXVxuICAgKiBAcGFyYW0geyp9IFtwNF1cbiAgICogQHBhcmFtIHsqfSBbcDVdXG4gICAqIEBwYXJhbSB7Kn0gW3A2XVxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogSGFuZHNvbnRhYmxlLmhvb2tzLnJ1bihob3QsICdiZWZvcmVJbml0Jyk7XG4gICAqIGBgYFxuICAgKi9cbiAgcnVuKGNvbnRleHQsIGtleSwgcDEsIHAyLCBwMywgcDQsIHA1LCBwNikge1xuICAgIHtcbiAgICAgIGNvbnN0IGdsb2JhbEhhbmRsZXJzID0gdGhpcy5nbG9iYWxCdWNrZXRba2V5XTtcbiAgICAgIGxldCBpbmRleCA9IC0xO1xuICAgICAgbGV0IGxlbmd0aCA9IGdsb2JhbEhhbmRsZXJzID8gZ2xvYmFsSGFuZGxlcnMubGVuZ3RoIDogMDtcblxuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICAvLyBEbyBub3Qgb3B0aW1pc2UgdGhpcyBsb29wIHdpdGggYXJyYXlFYWNoIG9yIGFycm93IGZ1bmN0aW9uISBJZiB5b3UgZG8gWW91J2xsIGRlY3JlYXNlIHBlcmYgYmVjYXVzZSBvZiBHQy5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIWdsb2JhbEhhbmRsZXJzW2luZGV4XSB8fCBnbG9iYWxIYW5kbGVyc1tpbmRleF0uc2tpcCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHBlcmZvcm1hbmNlIGNvbnNpZGVyYXRpb25zIC0gaHR0cDovL2pzcGVyZi5jb20vY2FsbC12cy1hcHBseS1mb3ItYS1wbHVnaW4tYXJjaGl0ZWN0dXJlXG4gICAgICAgICAgbGV0IHJlcyA9IGdsb2JhbEhhbmRsZXJzW2luZGV4XS5jYWxsKGNvbnRleHQsIHAxLCBwMiwgcDMsIHA0LCBwNSwgcDYpO1xuXG4gICAgICAgICAgaWYgKHJlcyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBwMSA9IHJlcztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGdsb2JhbEhhbmRsZXJzW2luZGV4XSAmJiBnbG9iYWxIYW5kbGVyc1tpbmRleF0ucnVuT25jZSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoa2V5LCBnbG9iYWxIYW5kbGVyc1tpbmRleF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICBjb25zdCBsb2NhbEhhbmRsZXJzID0gdGhpcy5nZXRCdWNrZXQoY29udGV4dClba2V5XTtcbiAgICAgIGxldCBpbmRleCA9IC0xO1xuICAgICAgbGV0IGxlbmd0aCA9IGxvY2FsSGFuZGxlcnMgPyBsb2NhbEhhbmRsZXJzLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgLy8gRG8gbm90IG9wdGltaXNlIHRoaXMgbG9vcCB3aXRoIGFycmF5RWFjaCBvciBhcnJvdyBmdW5jdGlvbiEgSWYgeW91IGRvIFlvdSdsbCBkZWNyZWFzZSBwZXJmIGJlY2F1c2Ugb2YgR0MuXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCFsb2NhbEhhbmRsZXJzW2luZGV4XSB8fCBsb2NhbEhhbmRsZXJzW2luZGV4XS5za2lwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gcGVyZm9ybWFuY2UgY29uc2lkZXJhdGlvbnMgLSBodHRwOi8vanNwZXJmLmNvbS9jYWxsLXZzLWFwcGx5LWZvci1hLXBsdWdpbi1hcmNoaXRlY3R1cmVcbiAgICAgICAgICBsZXQgcmVzID0gbG9jYWxIYW5kbGVyc1tpbmRleF0uY2FsbChjb250ZXh0LCBwMSwgcDIsIHAzLCBwNCwgcDUsIHA2KTtcblxuICAgICAgICAgIGlmIChyZXMgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcDEgPSByZXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsb2NhbEhhbmRsZXJzW2luZGV4XSAmJiBsb2NhbEhhbmRsZXJzW2luZGV4XS5ydW5PbmNlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShrZXksIGxvY2FsSGFuZGxlcnNbaW5kZXhdLCBjb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcDE7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveSBhbGwgbGlzdGVuZXJzIGNvbm5lY3RlZCB0byB0aGUgY29udGV4dC4gSWYgY29udGV4dCBpcyBub3QgZXhpc3RzIHRoZW4gbGlzdGVuZXJzIHdpbGwgYnkgZGVzdHJveVxuICAgKiBmcm9tIGdsb2JhbGx5LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbnRleHQ9bnVsbF1cbiAgICovXG4gIGRlc3Ryb3koY29udGV4dCA9IG51bGwpIHtcbiAgICBvYmplY3RFYWNoKHRoaXMuZ2V0QnVja2V0KGNvbnRleHQpLCAodmFsdWUsIGtleSwgYnVja2V0KSA9PiAoYnVja2V0W2tleV0ubGVuZ3RoID0gMCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGhvb2sgbmFtZSAoYWRkcyBpdCB0byB0aGUgbGlzdCBvZiB0aGUga25vd24gaG9vayBuYW1lcykuIFVzZWQgYnkgcGx1Z2lucy4gSXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjYWxsLFxuICAgKiByZWdpc3RlciwgYnV0IGlmIHlvdSB1c2UgaXQsIHlvdXIgcGx1Z2luIGhvb2sgd2lsbCBiZSB1c2VkIHJldHVybmVkIGJ5IGdldFJlZ2lzdGVyZWRcbiAgICogKHdoaWNoIGl0c2VsZiBpcyB1c2VkIGluIHRoZSBkZW1vIGh0dHA6Ly9oYW5kc29udGFibGUuY29tL2RlbW8vY2FsbGJhY2tzLmh0bWwpLlxuICAgKlxuICAgKiBAcGFyYW0ga2V5IHtTdHJpbmd9IEhvb2sgbmFtZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBIYW5kc29udGFibGUuaG9va3MucmVnaXN0ZXIoJ215SG9vaycpO1xuICAgKiBgYGBcbiAgICovXG4gIHJlZ2lzdGVyKGtleSkge1xuICAgIGlmICghdGhpcy5pc1JlZ2lzdGVyZWQoa2V5KSkge1xuICAgICAgUkVHSVNURVJFRF9IT09LUy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVucmVnaXN0ZXIgYSBob29rIG5hbWUgKHJlbW92ZXMgaXQgZnJvbSB0aGUgbGlzdCBvZiBrbm93biBob29rIG5hbWVzKS5cbiAgICpcbiAgICogQHBhcmFtIGtleSB7U3RyaW5nfSBIb29rIG5hbWVcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogSGFuZHNvbnRhYmxlLmhvb2tzLmRlcmVnaXN0ZXIoJ215SG9vaycpO1xuICAgKiBgYGBcbiAgICovXG4gIGRlcmVnaXN0ZXIoa2V5KSB7XG4gICAgaWYgKHRoaXMuaXNSZWdpc3RlcmVkKGtleSkpIHtcbiAgICAgIFJFR0lTVEVSRURfSE9PS1Muc3BsaWNlKFJFR0lTVEVSRURfSE9PS1MuaW5kZXhPZihrZXkpLCAxKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBib29sZWFuIGluZm9ybWF0aW9uIGlmIGEgaG9vayBieSBzdWNoIG5hbWUgaGFzIGJlZW4gcmVnaXN0ZXJlZC5cbiAgICpcbiAgICogQHBhcmFtIGtleSB7U3RyaW5nfSBIb29rIG5hbWVcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIEhhbmRzb250YWJsZS5ob29rcy5pc1JlZ2lzdGVyZWQoJ2JlZm9yZUluaXQnKTtcbiAgICogLy8gUmVzdWx0czpcbiAgICogdHJ1ZVxuICAgKiBgYGBcbiAgICovXG4gIGlzUmVnaXN0ZXJlZChrZXkpIHtcbiAgICByZXR1cm4gUkVHSVNURVJFRF9IT09LUy5pbmRleE9mKGtleSkgPj0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHJlZ2lzdGVyZWQgaG9va3MuXG4gICAqXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganNcbiAgICogSGFuZHNvbnRhYmxlLmhvb2tzLmdldFJlZ2lzdGVyZWQoKTtcbiAgICogLy8gUmVzdWx0czpcbiAgICogW1xuICAgKiAuLi5cbiAgICogICBcImJlZm9yZUluaXRcIixcbiAgICogICBcImJlZm9yZVJlbmRlclwiLFxuICAgKiAgIFwiYmVmb3JlU2V0UmFuZ2VFbmRcIixcbiAgICogICBcImJlZm9yZURyYXdCb3JkZXJzXCIsXG4gICAqICAgXCJiZWZvcmVDaGFuZ2VcIixcbiAgICogLi4uXG4gICAqIF1cbiAgICogYGBgXG4gICAqL1xuICBnZXRSZWdpc3RlcmVkKCkge1xuICAgIHJldHVybiBSRUdJU1RFUkVEX0hPT0tTO1xuICB9XG59XG5cbmV4cG9ydCB7SG9va3N9O1xuXG4vLyB0ZW1wIGZvciB0ZXN0cyBvbmx5IVxuSGFuZHNvbnRhYmxlLnV0aWxzID0gSGFuZHNvbnRhYmxlLnV0aWxzIHx8IHt9O1xuSGFuZHNvbnRhYmxlLnV0aWxzLkhvb2tzID0gSG9va3M7XG4iLCIvKipcbiAqIFV0aWxpdHkgdG8gcmVnaXN0ZXIgcGx1Z2lucyBhbmQgY29tbW9uIG5hbWVzcGFjZSBmb3Iga2VlcGluZyByZWZlcmVuY2UgdG8gYWxsIHBsdWdpbnMgY2xhc3Nlc1xuICovXG5cbmltcG9ydCB7b2JqZWN0RWFjaH0gZnJvbSAnLi9oZWxwZXJzL29iamVjdCc7XG5pbXBvcnQge3RvVXBwZXJDYXNlRmlyc3R9IGZyb20gJy4vaGVscGVycy9zdHJpbmcnO1xuXG5jb25zdCByZWdpc3RlcmVkUGx1Z2lucyA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogUmVnaXN0ZXJzIHBsdWdpbiB1bmRlciBnaXZlbiBuYW1lXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBsdWdpbk5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFBsdWdpbkNsYXNzXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2luKHBsdWdpbk5hbWUsIFBsdWdpbkNsYXNzKSB7XG4gIHBsdWdpbk5hbWUgPSB0b1VwcGVyQ2FzZUZpcnN0KHBsdWdpbk5hbWUpO1xuXG4gIEhhbmRzb250YWJsZS5ob29rcy5hZGQoJ2NvbnN0cnVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaG9sZGVyO1xuXG4gICAgaWYgKCFyZWdpc3RlcmVkUGx1Z2lucy5oYXModGhpcykpIHtcbiAgICAgIHJlZ2lzdGVyZWRQbHVnaW5zLnNldCh0aGlzLCB7fSk7XG4gICAgfVxuICAgIGhvbGRlciA9IHJlZ2lzdGVyZWRQbHVnaW5zLmdldCh0aGlzKTtcblxuICAgIGlmICghaG9sZGVyW3BsdWdpbk5hbWVdKSB7XG4gICAgICBob2xkZXJbcGx1Z2luTmFtZV0gPSBuZXcgUGx1Z2luQ2xhc3ModGhpcyk7XG4gICAgfVxuICB9KTtcbiAgSGFuZHNvbnRhYmxlLmhvb2tzLmFkZCgnYWZ0ZXJEZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBpLCBwbHVnaW5zSG9sZGVyO1xuXG4gICAgaWYgKHJlZ2lzdGVyZWRQbHVnaW5zLmhhcyh0aGlzKSkge1xuICAgICAgcGx1Z2luc0hvbGRlciA9IHJlZ2lzdGVyZWRQbHVnaW5zLmdldCh0aGlzKTtcblxuICAgICAgZm9yIChpIGluIHBsdWdpbnNIb2xkZXIpIHtcbiAgICAgICAgaWYgKHBsdWdpbnNIb2xkZXIuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICBwbHVnaW5zSG9sZGVyW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVnaXN0ZXJlZFBsdWdpbnMuZGVsZXRlKHRoaXMpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gcGx1Z2luTmFtZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSBwbHVnaW5DbGFzcyBSZXR1cm5zIHBsdWdpbiBpbnN0YW5jZSBpZiBleGlzdHMgb3IgYHVuZGVmaW5lZGAgaWYgbm90IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gZ2V0UGx1Z2luKGluc3RhbmNlLCBwbHVnaW5OYW1lKSB7XG4gIGlmICh0eXBlb2YgcGx1Z2luTmFtZSAhPSAnc3RyaW5nJykge1xuICAgIHRocm93IEVycm9yKCdPbmx5IHN0cmluZ3MgY2FuIGJlIHBhc3NlZCBhcyBcInBsdWdpblwiIHBhcmFtZXRlcicpO1xuICB9XG4gIGxldCBfcGx1Z2luTmFtZSA9IHRvVXBwZXJDYXNlRmlyc3QocGx1Z2luTmFtZSk7XG5cbiAgaWYgKCFyZWdpc3RlcmVkUGx1Z2lucy5oYXMoaW5zdGFuY2UpIHx8ICFyZWdpc3RlcmVkUGx1Z2lucy5nZXQoaW5zdGFuY2UpW19wbHVnaW5OYW1lXSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cblxuICByZXR1cm4gcmVnaXN0ZXJlZFBsdWdpbnMuZ2V0KGluc3RhbmNlKVtfcGx1Z2luTmFtZV07XG59XG5cbi8qKlxuICogR2V0IGFsbCByZWdpc3RyZWQgcGx1Z2lucyBuYW1lcyBmb3IgY29uY3JldGUgSGFuZHNvbnRhYmxlIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBob3RJbnN0YW5jZVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5mdW5jdGlvbiBnZXRSZWdpc3RyZWRQbHVnaW5OYW1lcyhob3RJbnN0YW5jZSkge1xuICByZXR1cm4gcmVnaXN0ZXJlZFBsdWdpbnMuaGFzKGhvdEluc3RhbmNlKSA/IE9iamVjdC5rZXlzKHJlZ2lzdGVyZWRQbHVnaW5zLmdldChob3RJbnN0YW5jZSkpIDogW107XG59XG5cbi8qKlxuICogR2V0IHBsdWdpbiBuYW1lLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBob3RJbnN0YW5jZVxuICogQHBhcmFtIHtPYmplY3R9IHBsdWdpblxuICogQHJldHVybnMge1N0cmluZ3xudWxsfVxuICovXG5mdW5jdGlvbiBnZXRQbHVnaW5OYW1lKGhvdEluc3RhbmNlLCBwbHVnaW4pIHtcbiAgbGV0IHBsdWdpbk5hbWUgPSBudWxsO1xuXG4gIGlmIChyZWdpc3RlcmVkUGx1Z2lucy5oYXMoaG90SW5zdGFuY2UpKSB7XG4gICAgb2JqZWN0RWFjaChyZWdpc3RlcmVkUGx1Z2lucy5nZXQoaG90SW5zdGFuY2UpLCAocGx1Z2luSW5zdGFuY2UsIG5hbWUpID0+IHtcbiAgICAgIGlmIChwbHVnaW5JbnN0YW5jZSA9PT0gcGx1Z2luKSB7XG4gICAgICAgIHBsdWdpbk5hbWUgPSBuYW1lO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHBsdWdpbk5hbWU7XG59XG5cbmV4cG9ydCB7cmVnaXN0ZXJQbHVnaW4sIGdldFBsdWdpbiwgZ2V0UmVnaXN0cmVkUGx1Z2luTmFtZXMsIGdldFBsdWdpbk5hbWV9O1xuIiwiLyoqXG4gKiBVdGlsaXR5IHRvIHJlZ2lzdGVyIHJlbmRlcmVycyBhbmQgY29tbW9uIG5hbWVzcGFjZSBmb3Iga2VlcGluZyByZWZlcmVuY2UgdG8gYWxsIHJlbmRlcmVycyBjbGFzc2VzXG4gKi9cblxuaW1wb3J0IHt0b1VwcGVyQ2FzZUZpcnN0fSBmcm9tICcuL2hlbHBlcnMvc3RyaW5nJztcblxudmFyIHJlZ2lzdGVyZWRSZW5kZXJlcnMgPSB7fTtcblxuLy8gc3VwcG9ydCBmb3Igb2xkZXIgdmVyc2lvbnMgb2YgSGFuZHNvbnRhYmxlXG5IYW5kc29udGFibGUucmVuZGVyZXJzID0gSGFuZHNvbnRhYmxlLnJlbmRlcmVycyB8fCB7fTtcbkhhbmRzb250YWJsZS5yZW5kZXJlcnMucmVnaXN0ZXJSZW5kZXJlciA9IHJlZ2lzdGVyUmVuZGVyZXI7XG5IYW5kc29udGFibGUucmVuZGVyZXJzLmdldFJlbmRlcmVyID0gZ2V0UmVuZGVyZXI7XG5cbi8qKlxuICogUmVnaXN0ZXJzIHJlbmRlcmVyIHVuZGVyIGdpdmVuIG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSByZW5kZXJlck5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlbmRlcmVyRnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJSZW5kZXJlcihyZW5kZXJlck5hbWUsIHJlbmRlcmVyRnVuY3Rpb24pIHtcbiAgdmFyIHJlZ2lzdGVyTmFtZTtcblxuICByZWdpc3RlcmVkUmVuZGVyZXJzW3JlbmRlcmVyTmFtZV0gPSByZW5kZXJlckZ1bmN0aW9uO1xuXG4gIHJlZ2lzdGVyTmFtZSA9IHRvVXBwZXJDYXNlRmlyc3QocmVuZGVyZXJOYW1lKSArICdSZW5kZXJlcic7XG4gIC8vIHN1cHBvcnQgZm9yIG9sZGVyIHZlcnNpb25zIG9mIEhhbmRzb250YWJsZVxuICBIYW5kc29udGFibGUucmVuZGVyZXJzW3JlZ2lzdGVyTmFtZV0gPSByZW5kZXJlckZ1bmN0aW9uO1xuICBIYW5kc29udGFibGVbcmVnaXN0ZXJOYW1lXSA9IHJlbmRlcmVyRnVuY3Rpb247XG59XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHJlbmRlcmVyTmFtZVxuICogQHJldHVybnMge0Z1bmN0aW9ufSByZW5kZXJlckZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldFJlbmRlcmVyKHJlbmRlcmVyTmFtZSkge1xuICBpZiAodHlwZW9mIHJlbmRlcmVyTmFtZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHJlbmRlcmVyTmFtZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVuZGVyZXJOYW1lICE9ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgRXJyb3IoJ09ubHkgc3RyaW5ncyBhbmQgZnVuY3Rpb25zIGNhbiBiZSBwYXNzZWQgYXMgXCJyZW5kZXJlclwiIHBhcmFtZXRlcicpO1xuICB9XG5cbiAgaWYgKCEocmVuZGVyZXJOYW1lIGluIHJlZ2lzdGVyZWRSZW5kZXJlcnMpKSB7XG4gICAgdGhyb3cgRXJyb3IoJ05vIGVkaXRvciByZWdpc3RlcmVkIHVuZGVyIG5hbWUgXCInICsgcmVuZGVyZXJOYW1lICsgJ1wiJyk7XG4gIH1cblxuICByZXR1cm4gcmVnaXN0ZXJlZFJlbmRlcmVyc1tyZW5kZXJlck5hbWVdO1xufVxuXG4vKipcbiAqIEBwYXJhbSByZW5kZXJlck5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNSZW5kZXJlcihyZW5kZXJlck5hbWUpIHtcbiAgcmV0dXJuIHJlbmRlcmVyTmFtZSBpbiByZWdpc3RlcmVkUmVuZGVyZXJzO1xufVxuXG5leHBvcnQge3JlZ2lzdGVyUmVuZGVyZXIsIGdldFJlbmRlcmVyLCBoYXNSZW5kZXJlcn07XG4iLCIvKipcbiAqIEFkZHMgYXBwcm9wcmlhdGUgQ1NTIGNsYXNzIHRvIHRhYmxlIGNlbGwsIGJhc2VkIG9uIGNlbGxQcm9wZXJ0aWVzXG4gKi9cblxuaW1wb3J0IHthZGRDbGFzcywgcmVtb3ZlQ2xhc3N9IGZyb20gJy4vLi4vaGVscGVycy9kb20vZWxlbWVudCc7XG5pbXBvcnQge3JlZ2lzdGVyUmVuZGVyZXJ9IGZyb20gJy4vLi4vcmVuZGVyZXJzJztcblxuZXhwb3J0IHtjZWxsRGVjb3JhdG9yfTtcblxucmVnaXN0ZXJSZW5kZXJlcignYmFzZScsIGNlbGxEZWNvcmF0b3IpO1xuXG4vLyBzdXBwb3J0IGZvciBvbGRlciB2ZXJzaW9ucyBvZiBIYW5kc29udGFibGVcbkhhbmRzb250YWJsZS5yZW5kZXJlcnMuY2VsbERlY29yYXRvciA9IGNlbGxEZWNvcmF0b3I7XG5cbmZ1bmN0aW9uIGNlbGxEZWNvcmF0b3IoaW5zdGFuY2UsIFRELCByb3csIGNvbCwgcHJvcCwgdmFsdWUsIGNlbGxQcm9wZXJ0aWVzKSB7XG4gIGlmIChjZWxsUHJvcGVydGllcy5jbGFzc05hbWUpIHtcbiAgICBpZihURC5jbGFzc05hbWUpIHtcbiAgICAgIFRELmNsYXNzTmFtZSA9IFRELmNsYXNzTmFtZSArIFwiIFwiICsgY2VsbFByb3BlcnRpZXMuY2xhc3NOYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBURC5jbGFzc05hbWUgPSBjZWxsUHJvcGVydGllcy5jbGFzc05hbWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNlbGxQcm9wZXJ0aWVzLnJlYWRPbmx5KSB7XG4gICAgYWRkQ2xhc3MoVEQsIGNlbGxQcm9wZXJ0aWVzLnJlYWRPbmx5Q2VsbENsYXNzTmFtZSk7XG4gIH1cblxuICBpZiAoY2VsbFByb3BlcnRpZXMudmFsaWQgPT09IGZhbHNlICYmIGNlbGxQcm9wZXJ0aWVzLmludmFsaWRDZWxsQ2xhc3NOYW1lKSB7XG4gICAgYWRkQ2xhc3MoVEQsIGNlbGxQcm9wZXJ0aWVzLmludmFsaWRDZWxsQ2xhc3NOYW1lKTtcbiAgfSBlbHNlIHtcbiAgICByZW1vdmVDbGFzcyhURCwgY2VsbFByb3BlcnRpZXMuaW52YWxpZENlbGxDbGFzc05hbWUpO1xuICB9XG5cbiAgaWYgKGNlbGxQcm9wZXJ0aWVzLndvcmRXcmFwID09PSBmYWxzZSAmJiBjZWxsUHJvcGVydGllcy5ub1dvcmRXcmFwQ2xhc3NOYW1lKSB7XG4gICAgYWRkQ2xhc3MoVEQsIGNlbGxQcm9wZXJ0aWVzLm5vV29yZFdyYXBDbGFzc05hbWUpO1xuICB9XG5cbiAgaWYgKCF2YWx1ZSAmJiBjZWxsUHJvcGVydGllcy5wbGFjZWhvbGRlcikge1xuICAgIGFkZENsYXNzKFRELCBjZWxsUHJvcGVydGllcy5wbGFjZWhvbGRlckNlbGxDbGFzc05hbWUpO1xuICB9XG59XG4iLCJcbmltcG9ydCB7YWRkQ2xhc3MsIGhhc0NsYXNzfSBmcm9tICcuLy4uL2hlbHBlcnMvZG9tL2VsZW1lbnQnO1xuaW1wb3J0IHtldmVudE1hbmFnZXIgYXMgZXZlbnRNYW5hZ2VyT2JqZWN0fSBmcm9tICcuLy4uL2V2ZW50TWFuYWdlcic7XG5pbXBvcnQge2dldFJlbmRlcmVyLCByZWdpc3RlclJlbmRlcmVyfSBmcm9tICcuLy4uL3JlbmRlcmVycyc7XG5pbXBvcnQge1dhbGtvbnRhYmxlQ2VsbENvb3Jkc30gZnJvbSAnLi8uLi8zcmRwYXJ0eS93YWxrb250YWJsZS9zcmMvY2VsbC9jb29yZHMnO1xuXG52YXIgY2xvbmFibGVXUkFQUEVSID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG5jbG9uYWJsZVdSQVBQRVIuY2xhc3NOYW1lID0gJ2h0QXV0b2NvbXBsZXRlV3JhcHBlcic7XG5cbnZhciBjbG9uYWJsZUFSUk9XID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG5jbG9uYWJsZUFSUk9XLmNsYXNzTmFtZSA9ICdodEF1dG9jb21wbGV0ZUFycm93Jztcbi8vIHdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9oYW5kc29udGFibGUvaGFuZHNvbnRhYmxlL2lzc3Vlcy8xOTQ2XG4vLyB0aGlzIGlzIGZhc3RlciB0aGFuIGlubmVySFRNTC4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vaGFuZHNvbnRhYmxlL2hhbmRzb250YWJsZS93aWtpL0phdmFTY3JpcHQtJi1ET00tcGVyZm9ybWFuY2UtdGlwc1xuY2xvbmFibGVBUlJPVy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcuZnJvbUNoYXJDb2RlKDk2NjApKSk7XG5cbnZhciB3cmFwVGRDb250ZW50V2l0aFdyYXBwZXIgPSBmdW5jdGlvbihURCwgV1JBUFBFUil7XG4gIFdSQVBQRVIuaW5uZXJIVE1MID0gVEQuaW5uZXJIVE1MO1xuICBkb20uZW1wdHkoVEQpO1xuICBURC5hcHBlbmRDaGlsZChXUkFQUEVSKTtcbn07XG5cbi8qKlxuICogQXV0b2NvbXBsZXRlIHJlbmRlcmVyXG4gKlxuICogQHByaXZhdGVcbiAqIEByZW5kZXJlciBBdXRvY29tcGxldGVSZW5kZXJlclxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlIEhhbmRzb250YWJsZSBpbnN0YW5jZVxuICogQHBhcmFtIHtFbGVtZW50fSBURCBUYWJsZSBjZWxsIHdoZXJlIHRvIHJlbmRlclxuICogQHBhcmFtIHtOdW1iZXJ9IHJvd1xuICogQHBhcmFtIHtOdW1iZXJ9IGNvbFxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBwcm9wIFJvdyBvYmplY3QgcHJvcGVydHkgbmFtZVxuICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIHJlbmRlciAocmVtZW1iZXIgdG8gZXNjYXBlIHVuc2FmZSBIVE1MIGJlZm9yZSBpbnNlcnRpbmcgdG8gRE9NISlcbiAqIEBwYXJhbSB7T2JqZWN0fSBjZWxsUHJvcGVydGllcyBDZWxsIHByb3Blcml0ZXMgKHNoYXJlZCBieSBjZWxsIHJlbmRlcmVyIGFuZCBlZGl0b3IpXG4gKi9cbmZ1bmN0aW9uIGF1dG9jb21wbGV0ZVJlbmRlcmVyKGluc3RhbmNlLCBURCwgcm93LCBjb2wsIHByb3AsIHZhbHVlLCBjZWxsUHJvcGVydGllcykge1xuXG4gIHZhciBXUkFQUEVSID0gY2xvbmFibGVXUkFQUEVSLmNsb25lTm9kZSh0cnVlKTsgLy90aGlzIGlzIGZhc3RlciB0aGFuIGNyZWF0ZUVsZW1lbnRcbiAgdmFyIEFSUk9XID0gY2xvbmFibGVBUlJPVy5jbG9uZU5vZGUodHJ1ZSk7IC8vdGhpcyBpcyBmYXN0ZXIgdGhhbiBjcmVhdGVFbGVtZW50XG5cbiAgZ2V0UmVuZGVyZXIoJ3RleHQnKShpbnN0YW5jZSwgVEQsIHJvdywgY29sLCBwcm9wLCB2YWx1ZSwgY2VsbFByb3BlcnRpZXMpO1xuXG4gIFRELmFwcGVuZENoaWxkKEFSUk9XKTtcbiAgYWRkQ2xhc3MoVEQsICdodEF1dG9jb21wbGV0ZScpO1xuXG5cbiAgaWYgKCFURC5maXJzdENoaWxkKSB7IC8vaHR0cDovL2pzcGVyZi5jb20vZW1wdHktbm9kZS1pZi1uZWVkZWRcbiAgICAvL290aGVyd2lzZSBlbXB0eSBmaWVsZHMgYXBwZWFyIGJvcmRlcmxlc3MgaW4gZGVtby9yZW5kZXJlcnMuaHRtbCAoSUUpXG4gICAgVEQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nLmZyb21DaGFyQ29kZSgxNjApKSk7IC8vIHdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9oYW5kc29udGFibGUvaGFuZHNvbnRhYmxlL2lzc3Vlcy8xOTQ2XG4gICAgLy90aGlzIGlzIGZhc3RlciB0aGFuIGlubmVySFRNTC4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vaGFuZHNvbnRhYmxlL2hhbmRzb250YWJsZS93aWtpL0phdmFTY3JpcHQtJi1ET00tcGVyZm9ybWFuY2UtdGlwc1xuICB9XG5cblxuXG4gIGlmICghaW5zdGFuY2UuYWNBcnJvd0xpc3RlbmVyKSB7XG4gICAgdmFyIGV2ZW50TWFuYWdlciA9IGV2ZW50TWFuYWdlck9iamVjdChpbnN0YW5jZSk7XG5cbiAgICAvL25vdCB2ZXJ5IGVsZWdhbnQgYnV0IGVhc3kgYW5kIGZhc3RcbiAgICBpbnN0YW5jZS5hY0Fycm93TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChoYXNDbGFzcyhldmVudC50YXJnZXQsICdodEF1dG9jb21wbGV0ZUFycm93JykpIHtcbiAgICAgICAgaW5zdGFuY2Uudmlldy53dC5nZXRTZXR0aW5nKCdvbkNlbGxEYmxDbGljaycsIG51bGwsIG5ldyBXYWxrb250YWJsZUNlbGxDb29yZHMocm93LCBjb2wpLCBURCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGV2ZW50TWFuYWdlci5hZGRFdmVudExpc3RlbmVyKGluc3RhbmNlLnJvb3RFbGVtZW50LCAnbW91c2Vkb3duJywgaW5zdGFuY2UuYWNBcnJvd0xpc3RlbmVyKTtcblxuICAgIC8vV2UgbmVlZCB0byB1bmJpbmQgdGhlIGxpc3RlbmVyIGFmdGVyIHRoZSB0YWJsZSBoYXMgYmVlbiBkZXN0cm95ZWRcbiAgICBpbnN0YW5jZS5hZGRIb29rT25jZSgnYWZ0ZXJEZXN0cm95JywgZnVuY3Rpb24gKCkge1xuICAgICAgZXZlbnRNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQge2F1dG9jb21wbGV0ZVJlbmRlcmVyfTtcblxucmVnaXN0ZXJSZW5kZXJlcignYXV0b2NvbXBsZXRlJywgYXV0b2NvbXBsZXRlUmVuZGVyZXIpO1xuIiwiXG5pbXBvcnQge2VtcHR5LCBhZGRDbGFzcywgaGFzQ2xhc3N9IGZyb20gJy4vLi4vaGVscGVycy9kb20vZWxlbWVudCc7XG5pbXBvcnQge2VxdWFsc0lnbm9yZUNhc2V9IGZyb20gJy4vLi4vaGVscGVycy9zdHJpbmcnO1xuaW1wb3J0IHtFdmVudE1hbmFnZXJ9IGZyb20gJy4vLi4vZXZlbnRNYW5hZ2VyJztcbmltcG9ydCB7Z2V0UmVuZGVyZXIsIHJlZ2lzdGVyUmVuZGVyZXJ9IGZyb20gJy4vLi4vcmVuZGVyZXJzJztcbmltcG9ydCB7S0VZX0NPREVTfSBmcm9tICcuLy4uL2hlbHBlcnMvdW5pY29kZSc7XG5pbXBvcnQge3N0b3BQcm9wYWdhdGlvbiwgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uLCBpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZH0gZnJvbSAnLi8uLi9oZWxwZXJzL2RvbS9ldmVudCc7XG5cbmNvbnN0IGlzTGlzdGVuaW5nS2V5RG93bkV2ZW50ID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IEJBRF9WQUxVRV9DTEFTUyA9ICdodEJhZFZhbHVlJztcblxuLyoqXG4gKiBDaGVja2JveCByZW5kZXJlclxuICpcbiAqIEBwcml2YXRlXG4gKiBAcmVuZGVyZXIgQ2hlY2tib3hSZW5kZXJlclxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlIEhhbmRzb250YWJsZSBpbnN0YW5jZVxuICogQHBhcmFtIHtFbGVtZW50fSBURCBUYWJsZSBjZWxsIHdoZXJlIHRvIHJlbmRlclxuICogQHBhcmFtIHtOdW1iZXJ9IHJvd1xuICogQHBhcmFtIHtOdW1iZXJ9IGNvbFxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBwcm9wIFJvdyBvYmplY3QgcHJvcGVydHkgbmFtZVxuICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIHJlbmRlciAocmVtZW1iZXIgdG8gZXNjYXBlIHVuc2FmZSBIVE1MIGJlZm9yZSBpbnNlcnRpbmcgdG8gRE9NISlcbiAqIEBwYXJhbSB7T2JqZWN0fSBjZWxsUHJvcGVydGllcyBDZWxsIHByb3BlcnRpZXMgKHNoYXJlZCBieSBjZWxsIHJlbmRlcmVyIGFuZCBlZGl0b3IpXG4gKi9cbmZ1bmN0aW9uIGNoZWNrYm94UmVuZGVyZXIoaW5zdGFuY2UsIFRELCByb3csIGNvbCwgcHJvcCwgdmFsdWUsIGNlbGxQcm9wZXJ0aWVzKSB7XG4gIGNvbnN0IGV2ZW50TWFuYWdlciA9IG5ldyBFdmVudE1hbmFnZXIoaW5zdGFuY2UpO1xuICBjb25zdCBpbnB1dCA9IGNyZWF0ZUlucHV0KCk7XG5cbiAgaWYgKHR5cGVvZiBjZWxsUHJvcGVydGllcy5jaGVja2VkVGVtcGxhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY2VsbFByb3BlcnRpZXMuY2hlY2tlZFRlbXBsYXRlID0gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIGNlbGxQcm9wZXJ0aWVzLnVuY2hlY2tlZFRlbXBsYXRlID09PSAndW5kZWZpbmVkJykge1xuICAgIGNlbGxQcm9wZXJ0aWVzLnVuY2hlY2tlZFRlbXBsYXRlID0gZmFsc2U7XG4gIH1cbiAgZW1wdHkoVEQpOyAvLyBUT0RPIGlkZW50aWZ5IHVuZGVyIHdoYXQgY2lyY3Vtc3RhbmNlcyB0aGlzIGxpbmUgY2FuIGJlIHJlbW92ZWRcblxuICBpZiAodmFsdWUgPT09IGNlbGxQcm9wZXJ0aWVzLmNoZWNrZWRUZW1wbGF0ZSB8fCBlcXVhbHNJZ25vcmVDYXNlKHZhbHVlLCBjZWxsUHJvcGVydGllcy5jaGVja2VkVGVtcGxhdGUpKSB7XG4gICAgaW5wdXQuY2hlY2tlZCA9IHRydWU7XG4gICAgVEQuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICB9XG4gIGVsc2UgaWYgKHZhbHVlID09PSBjZWxsUHJvcGVydGllcy51bmNoZWNrZWRUZW1wbGF0ZSB8fCBlcXVhbHNJZ25vcmVDYXNlKHZhbHVlLCBjZWxsUHJvcGVydGllcy51bmNoZWNrZWRUZW1wbGF0ZSkpIHtcbiAgICBURC5hcHBlbmRDaGlsZChpbnB1dCk7XG4gIH1cbiAgZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHsgLy8gZGVmYXVsdCB2YWx1ZVxuICAgIGFkZENsYXNzKGlucHV0LCAnbm9WYWx1ZScpO1xuICAgIFRELmFwcGVuZENoaWxkKGlucHV0KTtcbiAgfVxuICBlbHNlIHtcbiAgICBpbnB1dC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGFkZENsYXNzKGlucHV0LCBCQURfVkFMVUVfQ0xBU1MpO1xuICAgIFRELmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICBURC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnI2JhZC12YWx1ZSMnKSk7XG4gIH1cblxuICBpZiAoY2VsbFByb3BlcnRpZXMucmVhZE9ubHkpIHtcbiAgICBldmVudE1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcihpbnB1dCwgJ2NsaWNrJywgcHJldmVudERlZmF1bHQpO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50TWFuYWdlci5hZGRFdmVudExpc3RlbmVyKGlucHV0LCAnbW91c2Vkb3duJywgc3RvcFByb3BhZ2F0aW9uKTtcbiAgICBldmVudE1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcihpbnB1dCwgJ21vdXNldXAnLCBzdG9wUHJvcGFnYXRpb24pO1xuICAgIGV2ZW50TWFuYWdlci5hZGRFdmVudExpc3RlbmVyKGlucHV0LCAnY2hhbmdlJywgKGV2ZW50KSA9PiB7XG4gICAgICBpbnN0YW5jZS5zZXREYXRhQXRSb3dQcm9wKHJvdywgcHJvcCwgZXZlbnQudGFyZ2V0LmNoZWNrZWQgPyBjZWxsUHJvcGVydGllcy5jaGVja2VkVGVtcGxhdGUgOiBjZWxsUHJvcGVydGllcy51bmNoZWNrZWRUZW1wbGF0ZSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoIWlzTGlzdGVuaW5nS2V5RG93bkV2ZW50LmhhcyhpbnN0YW5jZSkpIHtcbiAgICBpc0xpc3RlbmluZ0tleURvd25FdmVudC5zZXQoaW5zdGFuY2UsIHRydWUpO1xuICAgIGluc3RhbmNlLmFkZEhvb2soJ2JlZm9yZUtleURvd24nLCBvbkJlZm9yZUtleURvd24pO1xuICB9XG5cbiAgLyoqXG4gICAqIE9uIGJlZm9yZSBrZXkgZG93biBET00gbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqL1xuICBmdW5jdGlvbiBvbkJlZm9yZUtleURvd24oZXZlbnQpIHtcbiAgICBjb25zdCBhbGxvd2VkS2V5cyA9IFtcbiAgICAgIEtFWV9DT0RFUy5TUEFDRSxcbiAgICAgIEtFWV9DT0RFUy5FTlRFUixcbiAgICAgIEtFWV9DT0RFUy5ERUxFVEUsXG4gICAgICBLRVlfQ09ERVMuQkFDS1NQQUNFXG4gICAgXTtcblxuICAgIGlmIChhbGxvd2VkS2V5cy5pbmRleE9mKGV2ZW50LmtleUNvZGUpICE9PSAtMSAmJiAhaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoZXZlbnQpKSB7XG4gICAgICBlYWNoU2VsZWN0ZWRDaGVja2JveENlbGwoZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbihldmVudCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gS0VZX0NPREVTLlNQQUNFIHx8IGV2ZW50LmtleUNvZGUgPT0gS0VZX0NPREVTLkVOVEVSKSB7XG4gICAgICB0b2dnbGVTZWxlY3RlZCgpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSBLRVlfQ09ERVMuREVMRVRFIHx8IGV2ZW50LmtleUNvZGUgPT0gS0VZX0NPREVTLkJBQ0tTUEFDRSkge1xuICAgICAgdG9nZ2xlU2VsZWN0ZWQoZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGUgY2hlY2tib3ggY2hlY2tlZCBwcm9wZXJ0eVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjaGVja2VkPW51bGxdXG4gICAqL1xuICBmdW5jdGlvbiB0b2dnbGVTZWxlY3RlZChjaGVja2VkID0gbnVsbCkge1xuICAgIGVhY2hTZWxlY3RlZENoZWNrYm94Q2VsbChmdW5jdGlvbihjaGVja2JveGVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2hlY2tib3hlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyBCbG9jayBjaGFuZ2luZyBjaGVja2VkIHByb3BlcnR5IG9uIHRvZ2dsZSBrZXlzIChTUEFDRSBhbmQgRU5URVIpXG4gICAgICAgIGlmIChoYXNDbGFzcyhjaGVja2JveGVzW2ldLCBCQURfVkFMVUVfQ0xBU1MpICYmIGNoZWNrZWQgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdG9nZ2xlQ2hlY2tib3goY2hlY2tib3hlc1tpXSwgY2hlY2tlZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlIGNoZWNrYm94IGVsZW1lbnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gY2hlY2tib3hcbiAgICogQHBhcmFtIHtCb29sZWFufSBbY2hlY2tlZD1udWxsXVxuICAgKi9cbiAgZnVuY3Rpb24gdG9nZ2xlQ2hlY2tib3goY2hlY2tib3gsIGNoZWNrZWQgPSBudWxsKSB7XG4gICAgaWYgKGNoZWNrZWQgPT09IG51bGwpIHtcbiAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSAhY2hlY2tib3guY2hlY2tlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hlY2tib3guY2hlY2tlZCA9IGNoZWNrZWQ7XG4gICAgfVxuICAgIGV2ZW50TWFuYWdlci5maXJlRXZlbnQoY2hlY2tib3gsICdjaGFuZ2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGNhbGxiYWNrIGZvciBlYWNoIGZvdW5kIHNlbGVjdGVkIGNlbGwgd2l0aCBjaGVja2JveCB0eXBlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgZnVuY3Rpb24gZWFjaFNlbGVjdGVkQ2hlY2tib3hDZWxsKGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VsUmFuZ2UgPSBpbnN0YW5jZS5nZXRTZWxlY3RlZFJhbmdlKCk7XG4gICAgY29uc3QgdG9wTGVmdCA9IHNlbFJhbmdlLmdldFRvcExlZnRDb3JuZXIoKTtcbiAgICBjb25zdCBib3R0b21SaWdodCA9IHNlbFJhbmdlLmdldEJvdHRvbVJpZ2h0Q29ybmVyKCk7XG5cbiAgICBmb3IgKGxldCByb3cgPSB0b3BMZWZ0LnJvdzsgcm93IDw9IGJvdHRvbVJpZ2h0LnJvdzsgcm93KyspIHtcbiAgICAgIGZvciAobGV0IGNvbCA9IHRvcExlZnQuY29sOyBjb2wgPD0gYm90dG9tUmlnaHQuY29sOyBjb2wrKykge1xuICAgICAgICBsZXQgY2VsbCA9IGluc3RhbmNlLmdldENlbGwocm93LCBjb2wpO1xuICAgICAgICBsZXQgY2VsbFByb3BlcnRpZXMgPSBpbnN0YW5jZS5nZXRDZWxsTWV0YShyb3csIGNvbCk7XG4gICAgICAgIGxldCBjaGVja2JveGVzID0gY2VsbC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPWNoZWNrYm94XScpO1xuXG4gICAgICAgIGlmIChjaGVja2JveGVzLmxlbmd0aCA+IDAgJiYgIWNlbGxQcm9wZXJ0aWVzLnJlYWRPbmx5KSB7XG4gICAgICAgICAgY2FsbGJhY2soY2hlY2tib3hlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHtjaGVja2JveFJlbmRlcmVyfTtcblxucmVnaXN0ZXJSZW5kZXJlcignY2hlY2tib3gnLCBjaGVja2JveFJlbmRlcmVyKTtcblxuXG4vKipcbiAqIENyZWF0ZSBpbnB1dCBlbGVtZW50LlxuICpcbiAqIEByZXR1cm5zIHtOb2RlfVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dCgpIHtcbiAgbGV0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnSU5QVVQnKTtcblxuICBpbnB1dC5jbGFzc05hbWUgPSAnaHRDaGVja2JveFJlbmRlcmVySW5wdXQnO1xuICBpbnB1dC50eXBlID0gJ2NoZWNrYm94JztcbiAgaW5wdXQuc2V0QXR0cmlidXRlKCdhdXRvY29tcGxldGUnLCAnb2ZmJyk7XG5cbiAgcmV0dXJuIGlucHV0LmNsb25lTm9kZShmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59XG4iLCJcbmltcG9ydCB7ZmFzdElubmVySFRNTH0gZnJvbSAnLi8uLi9oZWxwZXJzL2RvbS9lbGVtZW50JztcbmltcG9ydCB7Z2V0UmVuZGVyZXIsIHJlZ2lzdGVyUmVuZGVyZXJ9IGZyb20gJy4vLi4vcmVuZGVyZXJzJztcblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcmVuZGVyZXIgSHRtbFJlbmRlcmVyXG4gKiBAcGFyYW0gaW5zdGFuY2VcbiAqIEBwYXJhbSBURFxuICogQHBhcmFtIHJvd1xuICogQHBhcmFtIGNvbFxuICogQHBhcmFtIHByb3BcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIGNlbGxQcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIGh0bWxSZW5kZXJlcihpbnN0YW5jZSwgVEQsIHJvdywgY29sLCBwcm9wLCB2YWx1ZSwgY2VsbFByb3BlcnRpZXMpIHtcbiAgZ2V0UmVuZGVyZXIoJ2Jhc2UnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBmYXN0SW5uZXJIVE1MKFRELCB2YWx1ZSk7XG59XG5cbmV4cG9ydCB7aHRtbFJlbmRlcmVyfTtcblxucmVnaXN0ZXJSZW5kZXJlcignaHRtbCcsIGh0bWxSZW5kZXJlcik7XG4iLCJcbmltcG9ydCBudW1lcmFsIGZyb20gJ251bWVyYWwnO1xuaW1wb3J0IHthZGRDbGFzc30gZnJvbSAnLi8uLi9oZWxwZXJzL2RvbS9lbGVtZW50JztcbmltcG9ydCB7Z2V0UmVuZGVyZXIsIHJlZ2lzdGVyUmVuZGVyZXJ9IGZyb20gJy4vLi4vcmVuZGVyZXJzJztcbmltcG9ydCB7aXNOdW1lcmljfSBmcm9tICcuLy4uL2hlbHBlcnMvbnVtYmVyJztcblxuLyoqXG4gKiBOdW1lcmljIGNlbGwgcmVuZGVyZXJcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHJlbmRlcmVyIE51bWVyaWNSZW5kZXJlclxuICogQGRlcGVuZGVuY2llcyBudW1lcmFsXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2UgSGFuZHNvbnRhYmxlIGluc3RhbmNlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IFREIFRhYmxlIGNlbGwgd2hlcmUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge051bWJlcn0gcm93XG4gKiBAcGFyYW0ge051bWJlcn0gY29sXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHByb3AgUm93IG9iamVjdCBwcm9wZXJ0eSBuYW1lXG4gKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gcmVuZGVyIChyZW1lbWJlciB0byBlc2NhcGUgdW5zYWZlIEhUTUwgYmVmb3JlIGluc2VydGluZyB0byBET00hKVxuICogQHBhcmFtIHtPYmplY3R9IGNlbGxQcm9wZXJ0aWVzIENlbGwgcHJvcGVydGllcyAoc2hhcmVkIGJ5IGNlbGwgcmVuZGVyZXIgYW5kIGVkaXRvcilcbiAqL1xuZnVuY3Rpb24gbnVtZXJpY1JlbmRlcmVyKGluc3RhbmNlLCBURCwgcm93LCBjb2wsIHByb3AsIHZhbHVlLCBjZWxsUHJvcGVydGllcykge1xuICBpZiAoaXNOdW1lcmljKHZhbHVlKSkge1xuICAgIGlmICh0eXBlb2YgY2VsbFByb3BlcnRpZXMubGFuZ3VhZ2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBudW1lcmFsLmxhbmd1YWdlKGNlbGxQcm9wZXJ0aWVzLmxhbmd1YWdlKTtcbiAgICB9XG4gICAgdmFsdWUgPSBudW1lcmFsKHZhbHVlKS5mb3JtYXQoY2VsbFByb3BlcnRpZXMuZm9ybWF0IHx8ICcwJyk7IC8vZG9jczogaHR0cDovL251bWVyYWxqcy5jb20vXG4gICAgYWRkQ2xhc3MoVEQsICdodE51bWVyaWMnKTtcbiAgfVxuICBnZXRSZW5kZXJlcigndGV4dCcpKGluc3RhbmNlLCBURCwgcm93LCBjb2wsIHByb3AsIHZhbHVlLCBjZWxsUHJvcGVydGllcyk7XG59XG5cbmV4cG9ydCB7bnVtZXJpY1JlbmRlcmVyfTtcblxucmVnaXN0ZXJSZW5kZXJlcignbnVtZXJpYycsIG51bWVyaWNSZW5kZXJlcik7XG4iLCJcbmltcG9ydCB7ZmFzdElubmVySFRNTH0gZnJvbSAnLi8uLi9oZWxwZXJzL2RvbS9lbGVtZW50JztcbmltcG9ydCB7Z2V0UmVuZGVyZXIsIHJlZ2lzdGVyUmVuZGVyZXJ9IGZyb20gJy4vLi4vcmVuZGVyZXJzJztcblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcmVuZGVyZXIgUGFzc3dvcmRSZW5kZXJlclxuICogQHBhcmFtIGluc3RhbmNlXG4gKiBAcGFyYW0gVERcbiAqIEBwYXJhbSByb3dcbiAqIEBwYXJhbSBjb2xcbiAqIEBwYXJhbSBwcm9wXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBjZWxsUHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBwYXNzd29yZFJlbmRlcmVyKGluc3RhbmNlLCBURCwgcm93LCBjb2wsIHByb3AsIHZhbHVlLCBjZWxsUHJvcGVydGllcykge1xuICBnZXRSZW5kZXJlcigndGV4dCcpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgdmFsdWUgPSBURC5pbm5lckhUTUw7XG5cbiAgdmFyIGhhc2g7XG4gIHZhciBoYXNoTGVuZ3RoID0gY2VsbFByb3BlcnRpZXMuaGFzaExlbmd0aCB8fCB2YWx1ZS5sZW5ndGg7XG4gIHZhciBoYXNoU3ltYm9sID0gY2VsbFByb3BlcnRpZXMuaGFzaFN5bWJvbCB8fCAnKic7XG5cbiAgZm9yIChoYXNoID0gJyc7IGhhc2guc3BsaXQoaGFzaFN5bWJvbCkubGVuZ3RoIC0gMSA8IGhhc2hMZW5ndGg7IGhhc2ggKz0gaGFzaFN5bWJvbCkge31cblxuICBmYXN0SW5uZXJIVE1MKFRELCBoYXNoKTtcbn1cblxuZXhwb3J0IHtwYXNzd29yZFJlbmRlcmVyfTtcblxucmVnaXN0ZXJSZW5kZXJlcigncGFzc3dvcmQnLCBwYXNzd29yZFJlbmRlcmVyKTtcbiIsIlxuaW1wb3J0IHtlbXB0eSwgZmFzdElubmVyVGV4dH0gZnJvbSAnLi8uLi9oZWxwZXJzL2RvbS9lbGVtZW50JztcbmltcG9ydCB7c3RyaW5naWZ5fSBmcm9tICcuLy4uL2hlbHBlcnMvbWl4ZWQnO1xuaW1wb3J0IHtnZXRSZW5kZXJlciwgcmVnaXN0ZXJSZW5kZXJlcn0gZnJvbSAnLi8uLi9yZW5kZXJlcnMnO1xuXG4vKipcbiAqIERlZmF1bHQgdGV4dCByZW5kZXJlclxuICpcbiAqIEBwcml2YXRlXG4gKiBAcmVuZGVyZXIgVGV4dFJlbmRlcmVyXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2UgSGFuZHNvbnRhYmxlIGluc3RhbmNlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IFREIFRhYmxlIGNlbGwgd2hlcmUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge051bWJlcn0gcm93XG4gKiBAcGFyYW0ge051bWJlcn0gY29sXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHByb3AgUm93IG9iamVjdCBwcm9wZXJ0eSBuYW1lXG4gKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gcmVuZGVyIChyZW1lbWJlciB0byBlc2NhcGUgdW5zYWZlIEhUTUwgYmVmb3JlIGluc2VydGluZyB0byBET00hKVxuICogQHBhcmFtIHtPYmplY3R9IGNlbGxQcm9wZXJ0aWVzIENlbGwgcHJvcGVydGllcyAoc2hhcmVkIGJ5IGNlbGwgcmVuZGVyZXIgYW5kIGVkaXRvcilcbiAqL1xuZnVuY3Rpb24gdGV4dFJlbmRlcmVyKGluc3RhbmNlLCBURCwgcm93LCBjb2wsIHByb3AsIHZhbHVlLCBjZWxsUHJvcGVydGllcykge1xuICBnZXRSZW5kZXJlcignYmFzZScpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKCF2YWx1ZSAmJiBjZWxsUHJvcGVydGllcy5wbGFjZWhvbGRlcikge1xuICAgIHZhbHVlID0gY2VsbFByb3BlcnRpZXMucGxhY2Vob2xkZXI7XG4gIH1cblxuICB2YXIgZXNjYXBlZCA9IHN0cmluZ2lmeSh2YWx1ZSk7XG5cbiAgaWYoIWluc3RhbmNlLmdldFNldHRpbmdzKCkudHJpbVdoaXRlc3BhY2UpIHtcbiAgICBlc2NhcGVkID0gZXNjYXBlZC5yZXBsYWNlKC8gL2csIFN0cmluZy5mcm9tQ2hhckNvZGUoMTYwKSk7XG4gIH1cblxuICBpZiAoY2VsbFByb3BlcnRpZXMucmVuZGVyZXJUZW1wbGF0ZSkge1xuICAgIGVtcHR5KFREKTtcbiAgICB2YXIgVEVNUExBVEUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdURU1QTEFURScpO1xuICAgIFRFTVBMQVRFLnNldEF0dHJpYnV0ZSgnYmluZCcsICd7e319Jyk7XG4gICAgVEVNUExBVEUuaW5uZXJIVE1MID0gY2VsbFByb3BlcnRpZXMucmVuZGVyZXJUZW1wbGF0ZTtcbiAgICBIVE1MVGVtcGxhdGVFbGVtZW50LmRlY29yYXRlKFRFTVBMQVRFKTtcbiAgICBURU1QTEFURS5tb2RlbCA9IGluc3RhbmNlLmdldFNvdXJjZURhdGFBdFJvdyhyb3cpO1xuICAgIFRELmFwcGVuZENoaWxkKFRFTVBMQVRFKTtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyB0aGlzIGlzIGZhc3RlciB0aGFuIGlubmVySFRNTC4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vaGFuZHNvbnRhYmxlL2hhbmRzb250YWJsZS93aWtpL0phdmFTY3JpcHQtJi1ET00tcGVyZm9ybWFuY2UtdGlwc1xuICAgIGZhc3RJbm5lclRleHQoVEQsIGVzY2FwZWQpO1xuICB9XG59XG5cbmV4cG9ydCB7dGV4dFJlbmRlcmVyfTtcblxucmVnaXN0ZXJSZW5kZXJlcigndGV4dCcsIHRleHRSZW5kZXJlcik7XG4iLCIvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgaWYgKGdsb2JhbC4kdHJhY2V1clJ1bnRpbWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyICRPYmplY3QgPSBPYmplY3Q7XG4gIHZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuICB2YXIgJGNyZWF0ZSA9ICRPYmplY3QuY3JlYXRlO1xuICB2YXIgJGRlZmluZVByb3BlcnRpZXMgPSAkT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG4gIHZhciAkZGVmaW5lUHJvcGVydHkgPSAkT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuICB2YXIgJGZyZWV6ZSA9ICRPYmplY3QuZnJlZXplO1xuICB2YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9ICRPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICB2YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSAkT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG4gIHZhciAka2V5cyA9ICRPYmplY3Qua2V5cztcbiAgdmFyICRoYXNPd25Qcm9wZXJ0eSA9ICRPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgJHByZXZlbnRFeHRlbnNpb25zID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zO1xuICB2YXIgJHNlYWwgPSBPYmplY3Quc2VhbDtcbiAgdmFyICRpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xuICBmdW5jdGlvbiBub25FbnVtKHZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9O1xuICB9XG4gIHZhciBtZXRob2QgPSBub25FbnVtO1xuICB2YXIgY291bnRlciA9IDA7XG4gIGZ1bmN0aW9uIG5ld1VuaXF1ZVN0cmluZygpIHtcbiAgICByZXR1cm4gJ19fJCcgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTkpICsgJyQnICsgKytjb3VudGVyICsgJyRfXyc7XG4gIH1cbiAgdmFyIHN5bWJvbEludGVybmFsUHJvcGVydHkgPSBuZXdVbmlxdWVTdHJpbmcoKTtcbiAgdmFyIHN5bWJvbERlc2NyaXB0aW9uUHJvcGVydHkgPSBuZXdVbmlxdWVTdHJpbmcoKTtcbiAgdmFyIHN5bWJvbERhdGFQcm9wZXJ0eSA9IG5ld1VuaXF1ZVN0cmluZygpO1xuICB2YXIgc3ltYm9sVmFsdWVzID0gJGNyZWF0ZShudWxsKTtcbiAgdmFyIHByaXZhdGVOYW1lcyA9ICRjcmVhdGUobnVsbCk7XG4gIGZ1bmN0aW9uIGlzUHJpdmF0ZU5hbWUocykge1xuICAgIHJldHVybiBwcml2YXRlTmFtZXNbc107XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlUHJpdmF0ZU5hbWUoKSB7XG4gICAgdmFyIHMgPSBuZXdVbmlxdWVTdHJpbmcoKTtcbiAgICBwcml2YXRlTmFtZXNbc10gPSB0cnVlO1xuICAgIHJldHVybiBzO1xuICB9XG4gIGZ1bmN0aW9uIGlzU2hpbVN5bWJvbChzeW1ib2wpIHtcbiAgICByZXR1cm4gdHlwZW9mIHN5bWJvbCA9PT0gJ29iamVjdCcgJiYgc3ltYm9sIGluc3RhbmNlb2YgU3ltYm9sVmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gdHlwZU9mKHYpIHtcbiAgICBpZiAoaXNTaGltU3ltYm9sKHYpKVxuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIHJldHVybiB0eXBlb2YgdjtcbiAgfVxuICBmdW5jdGlvbiBTeW1ib2woZGVzY3JpcHRpb24pIHtcbiAgICB2YXIgdmFsdWUgPSBuZXcgU3ltYm9sVmFsdWUoZGVzY3JpcHRpb24pO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTeW1ib2wpKVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1N5bWJvbCBjYW5ub3QgYmUgbmV3XFwnZWQnKTtcbiAgfVxuICAkZGVmaW5lUHJvcGVydHkoU3ltYm9sLnByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgbm9uRW51bShTeW1ib2wpKTtcbiAgJGRlZmluZVByb3BlcnR5KFN5bWJvbC5wcm90b3R5cGUsICd0b1N0cmluZycsIG1ldGhvZChmdW5jdGlvbigpIHtcbiAgICB2YXIgc3ltYm9sVmFsdWUgPSB0aGlzW3N5bWJvbERhdGFQcm9wZXJ0eV07XG4gICAgaWYgKCFnZXRPcHRpb24oJ3N5bWJvbHMnKSlcbiAgICAgIHJldHVybiBzeW1ib2xWYWx1ZVtzeW1ib2xJbnRlcm5hbFByb3BlcnR5XTtcbiAgICBpZiAoIXN5bWJvbFZhbHVlKVxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdDb252ZXJzaW9uIGZyb20gc3ltYm9sIHRvIHN0cmluZycpO1xuICAgIHZhciBkZXNjID0gc3ltYm9sVmFsdWVbc3ltYm9sRGVzY3JpcHRpb25Qcm9wZXJ0eV07XG4gICAgaWYgKGRlc2MgPT09IHVuZGVmaW5lZClcbiAgICAgIGRlc2MgPSAnJztcbiAgICByZXR1cm4gJ1N5bWJvbCgnICsgZGVzYyArICcpJztcbiAgfSkpO1xuICAkZGVmaW5lUHJvcGVydHkoU3ltYm9sLnByb3RvdHlwZSwgJ3ZhbHVlT2YnLCBtZXRob2QoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN5bWJvbFZhbHVlID0gdGhpc1tzeW1ib2xEYXRhUHJvcGVydHldO1xuICAgIGlmICghc3ltYm9sVmFsdWUpXG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ0NvbnZlcnNpb24gZnJvbSBzeW1ib2wgdG8gc3RyaW5nJyk7XG4gICAgaWYgKCFnZXRPcHRpb24oJ3N5bWJvbHMnKSlcbiAgICAgIHJldHVybiBzeW1ib2xWYWx1ZVtzeW1ib2xJbnRlcm5hbFByb3BlcnR5XTtcbiAgICByZXR1cm4gc3ltYm9sVmFsdWU7XG4gIH0pKTtcbiAgZnVuY3Rpb24gU3ltYm9sVmFsdWUoZGVzY3JpcHRpb24pIHtcbiAgICB2YXIga2V5ID0gbmV3VW5pcXVlU3RyaW5nKCk7XG4gICAgJGRlZmluZVByb3BlcnR5KHRoaXMsIHN5bWJvbERhdGFQcm9wZXJ0eSwge3ZhbHVlOiB0aGlzfSk7XG4gICAgJGRlZmluZVByb3BlcnR5KHRoaXMsIHN5bWJvbEludGVybmFsUHJvcGVydHksIHt2YWx1ZToga2V5fSk7XG4gICAgJGRlZmluZVByb3BlcnR5KHRoaXMsIHN5bWJvbERlc2NyaXB0aW9uUHJvcGVydHksIHt2YWx1ZTogZGVzY3JpcHRpb259KTtcbiAgICBmcmVlemUodGhpcyk7XG4gICAgc3ltYm9sVmFsdWVzW2tleV0gPSB0aGlzO1xuICB9XG4gICRkZWZpbmVQcm9wZXJ0eShTeW1ib2xWYWx1ZS5wcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIG5vbkVudW0oU3ltYm9sKSk7XG4gICRkZWZpbmVQcm9wZXJ0eShTeW1ib2xWYWx1ZS5wcm90b3R5cGUsICd0b1N0cmluZycsIHtcbiAgICB2YWx1ZTogU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZyxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICB9KTtcbiAgJGRlZmluZVByb3BlcnR5KFN5bWJvbFZhbHVlLnByb3RvdHlwZSwgJ3ZhbHVlT2YnLCB7XG4gICAgdmFsdWU6IFN5bWJvbC5wcm90b3R5cGUudmFsdWVPZixcbiAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICB9KTtcbiAgdmFyIGhhc2hQcm9wZXJ0eSA9IGNyZWF0ZVByaXZhdGVOYW1lKCk7XG4gIHZhciBoYXNoUHJvcGVydHlEZXNjcmlwdG9yID0ge3ZhbHVlOiB1bmRlZmluZWR9O1xuICB2YXIgaGFzaE9iamVjdFByb3BlcnRpZXMgPSB7XG4gICAgaGFzaDoge3ZhbHVlOiB1bmRlZmluZWR9LFxuICAgIHNlbGY6IHt2YWx1ZTogdW5kZWZpbmVkfVxuICB9O1xuICB2YXIgaGFzaENvdW50ZXIgPSAwO1xuICBmdW5jdGlvbiBnZXRPd25IYXNoT2JqZWN0KG9iamVjdCkge1xuICAgIHZhciBoYXNoT2JqZWN0ID0gb2JqZWN0W2hhc2hQcm9wZXJ0eV07XG4gICAgaWYgKGhhc2hPYmplY3QgJiYgaGFzaE9iamVjdC5zZWxmID09PSBvYmplY3QpXG4gICAgICByZXR1cm4gaGFzaE9iamVjdDtcbiAgICBpZiAoJGlzRXh0ZW5zaWJsZShvYmplY3QpKSB7XG4gICAgICBoYXNoT2JqZWN0UHJvcGVydGllcy5oYXNoLnZhbHVlID0gaGFzaENvdW50ZXIrKztcbiAgICAgIGhhc2hPYmplY3RQcm9wZXJ0aWVzLnNlbGYudmFsdWUgPSBvYmplY3Q7XG4gICAgICBoYXNoUHJvcGVydHlEZXNjcmlwdG9yLnZhbHVlID0gJGNyZWF0ZShudWxsLCBoYXNoT2JqZWN0UHJvcGVydGllcyk7XG4gICAgICAkZGVmaW5lUHJvcGVydHkob2JqZWN0LCBoYXNoUHJvcGVydHksIGhhc2hQcm9wZXJ0eURlc2NyaXB0b3IpO1xuICAgICAgcmV0dXJuIGhhc2hQcm9wZXJ0eURlc2NyaXB0b3IudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgZnVuY3Rpb24gZnJlZXplKG9iamVjdCkge1xuICAgIGdldE93bkhhc2hPYmplY3Qob2JqZWN0KTtcbiAgICByZXR1cm4gJGZyZWV6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKG9iamVjdCkge1xuICAgIGdldE93bkhhc2hPYmplY3Qob2JqZWN0KTtcbiAgICByZXR1cm4gJHByZXZlbnRFeHRlbnNpb25zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbiAgZnVuY3Rpb24gc2VhbChvYmplY3QpIHtcbiAgICBnZXRPd25IYXNoT2JqZWN0KG9iamVjdCk7XG4gICAgcmV0dXJuICRzZWFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbiAgZnJlZXplKFN5bWJvbFZhbHVlLnByb3RvdHlwZSk7XG4gIGZ1bmN0aW9uIGlzU3ltYm9sU3RyaW5nKHMpIHtcbiAgICByZXR1cm4gc3ltYm9sVmFsdWVzW3NdIHx8IHByaXZhdGVOYW1lc1tzXTtcbiAgfVxuICBmdW5jdGlvbiB0b1Byb3BlcnR5KG5hbWUpIHtcbiAgICBpZiAoaXNTaGltU3ltYm9sKG5hbWUpKVxuICAgICAgcmV0dXJuIG5hbWVbc3ltYm9sSW50ZXJuYWxQcm9wZXJ0eV07XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlU3ltYm9sS2V5cyhhcnJheSkge1xuICAgIHZhciBydiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghaXNTeW1ib2xTdHJpbmcoYXJyYXlbaV0pKSB7XG4gICAgICAgIHJ2LnB1c2goYXJyYXlbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnY7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpIHtcbiAgICByZXR1cm4gcmVtb3ZlU3ltYm9sS2V5cygkZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpKTtcbiAgfVxuICBmdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICAgIHJldHVybiByZW1vdmVTeW1ib2xLZXlzKCRrZXlzKG9iamVjdCkpO1xuICB9XG4gIGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpIHtcbiAgICB2YXIgcnYgPSBbXTtcbiAgICB2YXIgbmFtZXMgPSAkZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzeW1ib2wgPSBzeW1ib2xWYWx1ZXNbbmFtZXNbaV1dO1xuICAgICAgaWYgKHN5bWJvbCkge1xuICAgICAgICBydi5wdXNoKHN5bWJvbCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydjtcbiAgfVxuICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBuYW1lKSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCB0b1Byb3BlcnR5KG5hbWUpKTtcbiAgfVxuICBmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShuYW1lKSB7XG4gICAgcmV0dXJuICRoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMsIHRvUHJvcGVydHkobmFtZSkpO1xuICB9XG4gIGZ1bmN0aW9uIGdldE9wdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIGdsb2JhbC50cmFjZXVyICYmIGdsb2JhbC50cmFjZXVyLm9wdGlvbnNbbmFtZV07XG4gIH1cbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCBkZXNjcmlwdG9yKSB7XG4gICAgaWYgKGlzU2hpbVN5bWJvbChuYW1lKSkge1xuICAgICAgbmFtZSA9IG5hbWVbc3ltYm9sSW50ZXJuYWxQcm9wZXJ0eV07XG4gICAgfVxuICAgICRkZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIGRlc2NyaXB0b3IpO1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgZnVuY3Rpb24gcG9seWZpbGxPYmplY3QoT2JqZWN0KSB7XG4gICAgJGRlZmluZVByb3BlcnR5KE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jywge3ZhbHVlOiBkZWZpbmVQcm9wZXJ0eX0pO1xuICAgICRkZWZpbmVQcm9wZXJ0eShPYmplY3QsICdnZXRPd25Qcm9wZXJ0eU5hbWVzJywge3ZhbHVlOiBnZXRPd25Qcm9wZXJ0eU5hbWVzfSk7XG4gICAgJGRlZmluZVByb3BlcnR5KE9iamVjdCwgJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcicsIHt2YWx1ZTogZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yfSk7XG4gICAgJGRlZmluZVByb3BlcnR5KE9iamVjdC5wcm90b3R5cGUsICdoYXNPd25Qcm9wZXJ0eScsIHt2YWx1ZTogaGFzT3duUHJvcGVydHl9KTtcbiAgICAkZGVmaW5lUHJvcGVydHkoT2JqZWN0LCAnZnJlZXplJywge3ZhbHVlOiBmcmVlemV9KTtcbiAgICAkZGVmaW5lUHJvcGVydHkoT2JqZWN0LCAncHJldmVudEV4dGVuc2lvbnMnLCB7dmFsdWU6IHByZXZlbnRFeHRlbnNpb25zfSk7XG4gICAgJGRlZmluZVByb3BlcnR5KE9iamVjdCwgJ3NlYWwnLCB7dmFsdWU6IHNlYWx9KTtcbiAgICAkZGVmaW5lUHJvcGVydHkoT2JqZWN0LCAna2V5cycsIHt2YWx1ZToga2V5c30pO1xuICB9XG4gIGZ1bmN0aW9uIGV4cG9ydFN0YXIob2JqZWN0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lcyA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzKGFyZ3VtZW50c1tpXSk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5hbWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBuYW1lID0gbmFtZXNbal07XG4gICAgICAgIGlmIChpc1N5bWJvbFN0cmluZyhuYW1lKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgKGZ1bmN0aW9uKG1vZCwgbmFtZSkge1xuICAgICAgICAgICRkZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBtb2RbbmFtZV07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KShhcmd1bWVudHNbaV0sIG5hbWVzW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuICBmdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gICAgcmV0dXJuIHggIT0gbnVsbCAmJiAodHlwZW9mIHggPT09ICdvYmplY3QnIHx8IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nKTtcbiAgfVxuICBmdW5jdGlvbiB0b09iamVjdCh4KSB7XG4gICAgaWYgKHggPT0gbnVsbClcbiAgICAgIHRocm93ICRUeXBlRXJyb3IoKTtcbiAgICByZXR1cm4gJE9iamVjdCh4KTtcbiAgfVxuICBmdW5jdGlvbiBjaGVja09iamVjdENvZXJjaWJsZShhcmd1bWVudCkge1xuICAgIGlmIChhcmd1bWVudCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdWYWx1ZSBjYW5ub3QgYmUgY29udmVydGVkIHRvIGFuIE9iamVjdCcpO1xuICAgIH1cbiAgICByZXR1cm4gYXJndW1lbnQ7XG4gIH1cbiAgZnVuY3Rpb24gcG9seWZpbGxTeW1ib2woZ2xvYmFsLCBTeW1ib2wpIHtcbiAgICBpZiAoIWdsb2JhbC5TeW1ib2wpIHtcbiAgICAgIGdsb2JhbC5TeW1ib2wgPSBTeW1ib2w7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuICAgIH1cbiAgICBpZiAoIWdsb2JhbC5TeW1ib2wuaXRlcmF0b3IpIHtcbiAgICAgIGdsb2JhbC5TeW1ib2wuaXRlcmF0b3IgPSBTeW1ib2woJ1N5bWJvbC5pdGVyYXRvcicpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzZXR1cEdsb2JhbHMoZ2xvYmFsKSB7XG4gICAgcG9seWZpbGxTeW1ib2woZ2xvYmFsLCBTeW1ib2wpO1xuICAgIGdsb2JhbC5SZWZsZWN0ID0gZ2xvYmFsLlJlZmxlY3QgfHwge307XG4gICAgZ2xvYmFsLlJlZmxlY3QuZ2xvYmFsID0gZ2xvYmFsLlJlZmxlY3QuZ2xvYmFsIHx8IGdsb2JhbDtcbiAgICBwb2x5ZmlsbE9iamVjdChnbG9iYWwuT2JqZWN0KTtcbiAgfVxuICBzZXR1cEdsb2JhbHMoZ2xvYmFsKTtcbiAgZ2xvYmFsLiR0cmFjZXVyUnVudGltZSA9IHtcbiAgICBjaGVja09iamVjdENvZXJjaWJsZTogY2hlY2tPYmplY3RDb2VyY2libGUsXG4gICAgY3JlYXRlUHJpdmF0ZU5hbWU6IGNyZWF0ZVByaXZhdGVOYW1lLFxuICAgIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAgIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gICAgZXhwb3J0U3RhcjogZXhwb3J0U3RhcixcbiAgICBnZXRPd25IYXNoT2JqZWN0OiBnZXRPd25IYXNoT2JqZWN0LFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgICBpc09iamVjdDogaXNPYmplY3QsXG4gICAgaXNQcml2YXRlTmFtZTogaXNQcml2YXRlTmFtZSxcbiAgICBpc1N5bWJvbFN0cmluZzogaXNTeW1ib2xTdHJpbmcsXG4gICAga2V5czogJGtleXMsXG4gICAgc2V0dXBHbG9iYWxzOiBzZXR1cEdsb2JhbHMsXG4gICAgdG9PYmplY3Q6IHRvT2JqZWN0LFxuICAgIHRvUHJvcGVydHk6IHRvUHJvcGVydHksXG4gICAgdHlwZW9mOiB0eXBlT2ZcbiAgfTtcbn0pKHdpbmRvdyk7XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyICR0b1Byb3BlcnR5ID0gJHRyYWNldXJSdW50aW1lLnRvUHJvcGVydHk7XG5cbiAgZnVuY3Rpb24gc3ByZWFkKCkge1xuICAgIHZhciBydiA9IFtdLFxuICAgICAgaiA9IDAsXG4gICAgICBpdGVyUmVzdWx0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWVUb1NwcmVhZCA9ICR0cmFjZXVyUnVudGltZS5jaGVja09iamVjdENvZXJjaWJsZShhcmd1bWVudHNbaV0pO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZVRvU3ByZWFkWyR0b1Byb3BlcnR5KFN5bWJvbC5pdGVyYXRvcildICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBzcHJlYWQgbm9uLWl0ZXJhYmxlIG9iamVjdC4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBpdGVyID0gdmFsdWVUb1NwcmVhZFskdG9Qcm9wZXJ0eShTeW1ib2wuaXRlcmF0b3IpXSgpO1xuICAgICAgd2hpbGUgKCEoaXRlclJlc3VsdCA9IGl0ZXIubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIHJ2W2orK10gPSBpdGVyUmVzdWx0LnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnY7XG4gIH1cbiAgJHRyYWNldXJSdW50aW1lLnNwcmVhZCA9IHNwcmVhZDtcbn0pKCk7XG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyICRPYmplY3QgPSBPYmplY3Q7XG4gIHZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuICB2YXIgJGNyZWF0ZSA9ICRPYmplY3QuY3JlYXRlO1xuICB2YXIgJGRlZmluZVByb3BlcnRpZXMgPSAkdHJhY2V1clJ1bnRpbWUuZGVmaW5lUHJvcGVydGllcztcbiAgdmFyICRkZWZpbmVQcm9wZXJ0eSA9ICR0cmFjZXVyUnVudGltZS5kZWZpbmVQcm9wZXJ0eTtcbiAgdmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSAkdHJhY2V1clJ1bnRpbWUuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICB2YXIgJGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgJHRvUHJvcGVydHkgPSAkdHJhY2V1clJ1bnRpbWUudG9Qcm9wZXJ0eTtcbiAgdmFyICRfXzAgPSBPYmplY3QsXG4gICAgZ2V0T3duUHJvcGVydHlOYW1lcyA9ICRfXzAuZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSAkX18wLmdldE93blByb3BlcnR5U3ltYm9scztcbiAgZnVuY3Rpb24gc3VwZXJEZXNjcmlwdG9yKGhvbWVPYmplY3QsIG5hbWUpIHtcbiAgICB2YXIgcHJvdG8gPSAkZ2V0UHJvdG90eXBlT2YoaG9tZU9iamVjdCk7XG4gICAgZG8ge1xuICAgICAgdmFyIHJlc3VsdCA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIG5hbWUpO1xuICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHByb3RvID0gJGdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICB9IHdoaWxlIChwcm90byk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBmdW5jdGlvbiBzdXBlckNvbnN0cnVjdG9yKGN0b3IpIHtcbiAgICByZXR1cm4gY3Rvci5fX3Byb3RvX187XG4gIH1cbiAgZnVuY3Rpb24gc3VwZXJDYWxsKHNlbGYsIGhvbWVPYmplY3QsIG5hbWUsIGFyZ3MpIHtcbiAgICByZXR1cm4gc3VwZXJHZXQoc2VsZiwgaG9tZU9iamVjdCwgbmFtZSkuYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbiAgZnVuY3Rpb24gc3VwZXJHZXQoc2VsZiwgaG9tZU9iamVjdCwgbmFtZSkge1xuICAgIHZhciBkZXNjcmlwdG9yID0gc3VwZXJEZXNjcmlwdG9yKGhvbWVPYmplY3QsIG5hbWUpO1xuICAgIGlmIChkZXNjcmlwdG9yKSB7XG4gICAgICBpZiAoIWRlc2NyaXB0b3IuZ2V0KVxuICAgICAgICByZXR1cm4gZGVzY3JpcHRvci52YWx1ZTtcbiAgICAgIHJldHVybiBkZXNjcmlwdG9yLmdldC5jYWxsKHNlbGYpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGZ1bmN0aW9uIHN1cGVyU2V0KHNlbGYsIGhvbWVPYmplY3QsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBzdXBlckRlc2NyaXB0b3IoaG9tZU9iamVjdCwgbmFtZSk7XG4gICAgaWYgKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5zZXQpIHtcbiAgICAgIGRlc2NyaXB0b3Iuc2V0LmNhbGwoc2VsZiwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICB0aHJvdyAkVHlwZUVycm9yKChcInN1cGVyIGhhcyBubyBzZXR0ZXIgJ1wiICsgbmFtZSArIFwiJy5cIikpO1xuICB9XG4gIGZ1bmN0aW9uIGdldERlc2NyaXB0b3JzKG9iamVjdCkge1xuICAgIHZhciBkZXNjcmlwdG9ycyA9IHt9O1xuICAgIHZhciBuYW1lcyA9IGdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgZGVzY3JpcHRvcnNbbmFtZV0gPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgbmFtZSk7XG4gICAgfVxuICAgIHZhciBzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3ltYm9sID0gc3ltYm9sc1tpXTtcbiAgICAgIGRlc2NyaXB0b3JzWyR0b1Byb3BlcnR5KHN5bWJvbCldID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsICR0b1Byb3BlcnR5KHN5bWJvbCkpO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlQ2xhc3MoY3Rvciwgb2JqZWN0LCBzdGF0aWNPYmplY3QsIHN1cGVyQ2xhc3MpIHtcbiAgICAkZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnY29uc3RydWN0b3InLCB7XG4gICAgICB2YWx1ZTogY3RvcixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDMpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgY3Rvci5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xuICAgICAgY3Rvci5wcm90b3R5cGUgPSAkY3JlYXRlKGdldFByb3RvUGFyZW50KHN1cGVyQ2xhc3MpLCBnZXREZXNjcmlwdG9ycyhvYmplY3QpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3Rvci5wcm90b3R5cGUgPSBvYmplY3Q7XG4gICAgfVxuICAgICRkZWZpbmVQcm9wZXJ0eShjdG9yLCAncHJvdG90eXBlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiAkZGVmaW5lUHJvcGVydGllcyhjdG9yLCBnZXREZXNjcmlwdG9ycyhzdGF0aWNPYmplY3QpKTtcbiAgfVxuICBmdW5jdGlvbiBnZXRQcm90b1BhcmVudChzdXBlckNsYXNzKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBlckNsYXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgcHJvdG90eXBlID0gc3VwZXJDbGFzcy5wcm90b3R5cGU7XG4gICAgICBpZiAoJE9iamVjdChwcm90b3R5cGUpID09PSBwcm90b3R5cGUgfHwgcHJvdG90eXBlID09PSBudWxsKVxuICAgICAgICByZXR1cm4gc3VwZXJDbGFzcy5wcm90b3R5cGU7XG4gICAgICB0aHJvdyBuZXcgJFR5cGVFcnJvcignc3VwZXIgcHJvdG90eXBlIG11c3QgYmUgYW4gT2JqZWN0IG9yIG51bGwnKTtcbiAgICB9XG4gICAgaWYgKHN1cGVyQ2xhc3MgPT09IG51bGwpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB0aHJvdyBuZXcgJFR5cGVFcnJvcigoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MgKyBcIi5cIikpO1xuICB9XG4gIGZ1bmN0aW9uIGRlZmF1bHRTdXBlckNhbGwoc2VsZiwgaG9tZU9iamVjdCwgYXJncykge1xuICAgIGlmICgkZ2V0UHJvdG90eXBlT2YoaG9tZU9iamVjdCkgIT09IG51bGwpXG4gICAgICBzdXBlckNhbGwoc2VsZiwgaG9tZU9iamVjdCwgJ2NvbnN0cnVjdG9yJywgYXJncyk7XG4gIH1cbiAgJHRyYWNldXJSdW50aW1lLmNyZWF0ZUNsYXNzID0gY3JlYXRlQ2xhc3M7XG4gICR0cmFjZXVyUnVudGltZS5kZWZhdWx0U3VwZXJDYWxsID0gZGVmYXVsdFN1cGVyQ2FsbDtcbiAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ2FsbCA9IHN1cGVyQ2FsbDtcbiAgJHRyYWNldXJSdW50aW1lLnN1cGVyQ29uc3RydWN0b3IgPSBzdXBlckNvbnN0cnVjdG9yO1xuICAkdHJhY2V1clJ1bnRpbWUuc3VwZXJHZXQgPSBzdXBlckdldDtcbiAgJHRyYWNldXJSdW50aW1lLnN1cGVyU2V0ID0gc3VwZXJTZXQ7XG59KSgpO1xuLyoganNoaW50IGlnbm9yZTplbmQgKi9cbiIsIlxuaW1wb3J0IHtcbiAgYWRkQ2xhc3MsXG4gIGVtcHR5LFxuICBmYXN0SW5uZXJIVE1MLFxuICBmYXN0SW5uZXJUZXh0LFxuICBnZXRTY3JvbGxiYXJXaWR0aCxcbiAgaGFzQ2xhc3MsXG4gIGlzQ2hpbGRPZixcbiAgaXNJbnB1dCxcbiAgaXNPdXRzaWRlSW5wdXQsXG4gICAgfSBmcm9tICcuL2hlbHBlcnMvZG9tL2VsZW1lbnQnO1xuaW1wb3J0IHtldmVudE1hbmFnZXIgYXMgZXZlbnRNYW5hZ2VyT2JqZWN0fSBmcm9tICcuL2V2ZW50TWFuYWdlcic7XG5pbXBvcnQge3N0b3BQcm9wYWdhdGlvbiwgaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWR9IGZyb20gJy4vaGVscGVycy9kb20vZXZlbnQnO1xuaW1wb3J0IHtXYWxrb250YWJsZUNlbGxDb29yZHN9IGZyb20gJy4vM3JkcGFydHkvd2Fsa29udGFibGUvc3JjL2NlbGwvY29vcmRzJztcbmltcG9ydCB7V2Fsa29udGFibGVTZWxlY3Rpb259IGZyb20gJy4vM3JkcGFydHkvd2Fsa29udGFibGUvc3JjL3NlbGVjdGlvbic7XG5pbXBvcnQge1dhbGtvbnRhYmxlfSBmcm9tICcuLzNyZHBhcnR5L3dhbGtvbnRhYmxlL3NyYy9jb3JlJztcblxuXG4vLyBTdXBwb3J0IGZvciBvbGRlciBIYW5kc29udGFibGUgdmVyc2lvbnNcbkhhbmRzb250YWJsZS5UYWJsZVZpZXcgPSBUYWJsZVZpZXc7XG5cbi8qKlxuICogSGFuZHNvbnRhYmxlIFRhYmxlVmlldyBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIFRhYmxlVmlldyhpbnN0YW5jZSkge1xuICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgdGhpcy5ldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXJPYmplY3QoaW5zdGFuY2UpO1xuICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gIHRoaXMuc2V0dGluZ3MgPSBpbnN0YW5jZS5nZXRTZXR0aW5ncygpO1xuXG4gIHZhciBvcmlnaW5hbFN0eWxlID0gaW5zdGFuY2Uucm9vdEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuXG4gIGlmIChvcmlnaW5hbFN0eWxlKSB7XG4gICAgaW5zdGFuY2Uucm9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsc3R5bGUnLCBvcmlnaW5hbFN0eWxlKTsgLy9uZWVkZWQgdG8gcmV0cmlldmUgb3JpZ2luYWwgc3R5bGUgaW4ganNGaWRkbGUgbGluayBnZW5lcmF0b3IgaW4gSFQgZXhhbXBsZXMuIG1heSBiZSByZW1vdmVkIGluIGZ1dHVyZSB2ZXJzaW9uc1xuICB9XG5cbiAgYWRkQ2xhc3MoaW5zdGFuY2Uucm9vdEVsZW1lbnQsICdoYW5kc29udGFibGUnKTtcbiAgLy8gIGluc3RhbmNlLnJvb3RFbGVtZW50LmFkZENsYXNzKCdoYW5kc29udGFibGUnKTtcblxuICB2YXIgdGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdUQUJMRScpO1xuICBhZGRDbGFzcyh0YWJsZSwgJ2h0Q29yZScpO1xuXG4gIGlmIChpbnN0YW5jZS5nZXRTZXR0aW5ncygpLnRhYmxlQ2xhc3NOYW1lKSB7XG4gICAgYWRkQ2xhc3ModGFibGUsIGluc3RhbmNlLmdldFNldHRpbmdzKCkudGFibGVDbGFzc05hbWUpO1xuICB9XG4gIHRoaXMuVEhFQUQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdUSEVBRCcpO1xuICB0YWJsZS5hcHBlbmRDaGlsZCh0aGlzLlRIRUFEKTtcbiAgdGhpcy5UQk9EWSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ1RCT0RZJyk7XG4gIHRhYmxlLmFwcGVuZENoaWxkKHRoaXMuVEJPRFkpO1xuXG4gIGluc3RhbmNlLnRhYmxlID0gdGFibGU7XG5cbiAgaW5zdGFuY2UuY29udGFpbmVyLmluc2VydEJlZm9yZSh0YWJsZSwgaW5zdGFuY2UuY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuXG4gIHRoaXMuZXZlbnRNYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIoaW5zdGFuY2Uucm9vdEVsZW1lbnQsICdtb3VzZWRvd24nLCBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICghdGhhdC5pc1RleHRTZWxlY3Rpb25BbGxvd2VkKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIGNsZWFyVGV4dFNlbGVjdGlvbigpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHdpbmRvdy5mb2N1cygpOyAvL21ha2Ugc3VyZSB0aGF0IHdpbmRvdyB0aGF0IGNvbnRhaW5zIEhPVCBpcyBhY3RpdmUuIEltcG9ydGFudCB3aGVuIEhPVCBpcyBpbiBpZnJhbWUuXG4gICAgfVxuICB9KTtcblxuICB0aGlzLmV2ZW50TWFuYWdlci5hZGRFdmVudExpc3RlbmVyKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJ2tleXVwJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoaW5zdGFuY2Uuc2VsZWN0aW9uLmlzSW5Qcm9ncmVzcygpICYmICFldmVudC5zaGlmdEtleSkge1xuICAgICAgaW5zdGFuY2Uuc2VsZWN0aW9uLmZpbmlzaCgpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGlzTW91c2VEb3duO1xuICB0aGlzLmlzTW91c2VEb3duID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzTW91c2VEb3duO1xuICB9O1xuXG4gIHRoaXMuZXZlbnRNYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnbW91c2V1cCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKGluc3RhbmNlLnNlbGVjdGlvbi5pc0luUHJvZ3Jlc3MoKSAmJiBldmVudC53aGljaCA9PT0gMSkgeyAvL2lzIGxlZnQgbW91c2UgYnV0dG9uXG4gICAgICBpbnN0YW5jZS5zZWxlY3Rpb24uZmluaXNoKCk7XG4gICAgfVxuXG4gICAgaXNNb3VzZURvd24gPSBmYWxzZTtcblxuICAgIGlmIChpc091dHNpZGVJbnB1dChkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgaW5zdGFuY2UudW5saXN0ZW4oKTtcbiAgICB9XG4gIH0pO1xuXG4gIHRoaXMuZXZlbnRNYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnbW91c2Vkb3duJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgbmV4dCA9IGV2ZW50LnRhcmdldDtcbiAgICB2YXIgZXZlbnRYID0gZXZlbnQueCB8fCBldmVudC5jbGllbnRYO1xuICAgIHZhciBldmVudFkgPSBldmVudC55IHx8IGV2ZW50LmNsaWVudFk7XG5cbiAgICBpZiAoaXNNb3VzZURvd24gfHwgIWluc3RhbmNlLnJvb3RFbGVtZW50KSB7XG4gICAgICByZXR1cm47IC8vIGl0IG11c3QgaGF2ZSBiZWVuIHN0YXJ0ZWQgaW4gYSBjZWxsXG4gICAgfVxuXG4gICAgLy8gaW1tZWRpYXRlIGNsaWNrIG9uIFwiaG9sZGVyXCIgbWVhbnMgY2xpY2sgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdmVydGljYWwgc2Nyb2xsYmFyXG4gICAgaWYgKG5leHQgIT09IGluc3RhbmNlLnZpZXcud3Qud3RUYWJsZS5ob2xkZXIpIHtcbiAgICAgIHdoaWxlIChuZXh0ICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoZXZlbnQuaXNUYXJnZXRXZWJDb21wb25lbnQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjbGljayBvbiBzb21ldGhpbmcgdGhhdCB3YXMgYSByb3cgYnV0IG5vdyBpcyBkZXRhY2hlZCAocG9zc2libHkgYmVjYXVzZSB5b3VyIGNsaWNrIHRyaWdnZXJlZCBhIHJlcmVuZGVyKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dCA9PT0gaW5zdGFuY2Uucm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBjbGljayBpbnNpZGUgY29udGFpbmVyXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzY3JvbGxiYXJXaWR0aCA9IGdldFNjcm9sbGJhcldpZHRoKCk7XG5cbiAgICAgIGlmIChkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50WCArIHNjcm9sbGJhcldpZHRoLCBldmVudFkpICE9PSBpbnN0YW5jZS52aWV3Lnd0Lnd0VGFibGUuaG9sZGVyIHx8XG4gICAgICAgIGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZXZlbnRYLCBldmVudFkgKyBzY3JvbGxiYXJXaWR0aCkgIT09IGluc3RhbmNlLnZpZXcud3Qud3RUYWJsZS5ob2xkZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZ1bmN0aW9uIGRpZCBub3QgcmV0dXJuIHVudGlsIGhlcmUsIHdlIGhhdmUgYW4gb3V0c2lkZSBjbGljayFcbiAgICBpZiAodGhhdC5zZXR0aW5ncy5vdXRzaWRlQ2xpY2tEZXNlbGVjdHMpIHtcbiAgICAgIGluc3RhbmNlLmRlc2VsZWN0Q2VsbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZS5kZXN0cm95RWRpdG9yKCk7XG4gICAgfVxuICB9KTtcblxuXG4gIHRoaXMuZXZlbnRNYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIodGFibGUsICdzZWxlY3RzdGFydCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKHRoYXQuc2V0dGluZ3MuZnJhZ21lbnRTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvL2h0dHBzOi8vZ2l0aHViLmNvbS9oYW5kc29udGFibGUvaGFuZHNvbnRhYmxlL2lzc3Vlcy8xNjBcbiAgICAvL3NlbGVjdHN0YXJ0IGlzIElFIG9ubHkgZXZlbnQuIFByZXZlbnQgdGV4dCBmcm9tIGJlaW5nIHNlbGVjdGVkIHdoZW4gcGVyZm9ybWluZyBkcmFnIGRvd24gaW4gSUU4XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG5cbiAgdmFyIGNsZWFyVGV4dFNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIC8vaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMTY5Nzg2L2NsZWFyLXRleHQtc2VsZWN0aW9uLXdpdGgtamF2YXNjcmlwdFxuICAgIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgICBpZiAod2luZG93LmdldFNlbGVjdGlvbigpLmVtcHR5KSB7IC8vIENocm9tZVxuICAgICAgICB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkuZW1wdHkoKTtcbiAgICAgIH0gZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcykgeyAvLyBGaXJlZm94XG4gICAgICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikgeyAvLyBJRT9cbiAgICAgIGRvY3VtZW50LnNlbGVjdGlvbi5lbXB0eSgpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgc2VsZWN0aW9ucyA9IFtcbiAgICBuZXcgV2Fsa29udGFibGVTZWxlY3Rpb24oe1xuICAgICAgY2xhc3NOYW1lOiAnY3VycmVudCcsXG4gICAgICBib3JkZXI6IHtcbiAgICAgICAgd2lkdGg6IDIsXG4gICAgICAgIGNvbG9yOiAnIzUyOTJGNycsXG4gICAgICAgIC8vc3R5bGU6ICdzb2xpZCcsIC8vbm90IHVzZWRcbiAgICAgICAgY29ybmVyVmlzaWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoYXQuc2V0dGluZ3MuZmlsbEhhbmRsZSAmJiAhdGhhdC5pc0NlbGxFZGl0ZWQoKSAmJiAhaW5zdGFuY2Uuc2VsZWN0aW9uLmlzTXVsdGlwbGUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbXVsdGlwbGVTZWxlY3Rpb25IYW5kbGVzVmlzaWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuICF0aGF0LmlzQ2VsbEVkaXRlZCgpICYmICFpbnN0YW5jZS5zZWxlY3Rpb24uaXNNdWx0aXBsZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksXG4gICAgbmV3IFdhbGtvbnRhYmxlU2VsZWN0aW9uKHtcbiAgICAgIGNsYXNzTmFtZTogJ2FyZWEnLFxuICAgICAgYm9yZGVyOiB7XG4gICAgICAgIHdpZHRoOiAxLFxuICAgICAgICBjb2xvcjogJyM4OUFGRjknLFxuICAgICAgICAvL3N0eWxlOiAnc29saWQnLCAvLyBub3QgdXNlZFxuICAgICAgICBjb3JuZXJWaXNpYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhhdC5zZXR0aW5ncy5maWxsSGFuZGxlICYmICF0aGF0LmlzQ2VsbEVkaXRlZCgpICYmIGluc3RhbmNlLnNlbGVjdGlvbi5pc011bHRpcGxlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG11bHRpcGxlU2VsZWN0aW9uSGFuZGxlc1Zpc2libGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiAhdGhhdC5pc0NlbGxFZGl0ZWQoKSAmJiBpbnN0YW5jZS5zZWxlY3Rpb24uaXNNdWx0aXBsZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksXG4gICAgbmV3IFdhbGtvbnRhYmxlU2VsZWN0aW9uKHtcbiAgICAgIGNsYXNzTmFtZTogJ2hpZ2hsaWdodCcsXG4gICAgICBoaWdobGlnaHRSb3dDbGFzc05hbWU6IHRoYXQuc2V0dGluZ3MuY3VycmVudFJvd0NsYXNzTmFtZSxcbiAgICAgIGhpZ2hsaWdodENvbHVtbkNsYXNzTmFtZTogdGhhdC5zZXR0aW5ncy5jdXJyZW50Q29sQ2xhc3NOYW1lXG4gICAgfSksXG4gICAgbmV3IFdhbGtvbnRhYmxlU2VsZWN0aW9uKHtcbiAgICAgIGNsYXNzTmFtZTogJ2ZpbGwnLFxuICAgICAgYm9yZGVyOiB7XG4gICAgICAgIHdpZHRoOiAxLFxuICAgICAgICBjb2xvcjogJ3JlZCdcbiAgICAgICAgLy9zdHlsZTogJ3NvbGlkJyAvLyBub3QgdXNlZFxuICAgICAgfVxuICAgIH0pXTtcbiAgc2VsZWN0aW9ucy5jdXJyZW50ID0gc2VsZWN0aW9uc1swXTtcbiAgc2VsZWN0aW9ucy5hcmVhID0gc2VsZWN0aW9uc1sxXTtcbiAgc2VsZWN0aW9ucy5oaWdobGlnaHQgPSBzZWxlY3Rpb25zWzJdO1xuICBzZWxlY3Rpb25zLmZpbGwgPSBzZWxlY3Rpb25zWzNdO1xuXG4gIHZhciB3YWxrb250YWJsZUNvbmZpZyA9IHtcbiAgICBkZWJ1ZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhhdC5zZXR0aW5ncy5kZWJ1ZztcbiAgICB9LFxuICAgIGV4dGVybmFsUm93Q2FsY3VsYXRvcjogdGhpcy5pbnN0YW5jZS5nZXRQbHVnaW4oJ2F1dG9Sb3dTaXplJykgJiYgdGhpcy5pbnN0YW5jZS5nZXRQbHVnaW4oJ2F1dG9Sb3dTaXplJykuaXNFbmFibGVkKCksXG4gICAgdGFibGU6IHRhYmxlLFxuICAgIHN0cmV0Y2hIOiB0aGlzLnNldHRpbmdzLnN0cmV0Y2hILFxuICAgIGRhdGE6IGluc3RhbmNlLmdldERhdGFBdENlbGwsXG4gICAgdG90YWxSb3dzOiBpbnN0YW5jZS5jb3VudFJvd3MsXG4gICAgdG90YWxDb2x1bW5zOiBpbnN0YW5jZS5jb3VudENvbHMsXG4gICAgZml4ZWRDb2x1bW5zTGVmdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhhdC5zZXR0aW5ncy5maXhlZENvbHVtbnNMZWZ0O1xuICAgIH0sXG4gICAgZml4ZWRSb3dzVG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGF0LnNldHRpbmdzLmZpeGVkUm93c1RvcDtcbiAgICB9LFxuICAgIHJlbmRlckFsbFJvd3M6IHRoYXQuc2V0dGluZ3MucmVuZGVyQWxsUm93cyxcbiAgICByb3dIZWFkZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgIGlmIChpbnN0YW5jZS5oYXNSb3dIZWFkZXJzKCkpIHtcbiAgICAgICAgYXJyLnB1c2goZnVuY3Rpb24oaW5kZXgsIFRIKSB7XG4gICAgICAgICAgdGhhdC5hcHBlbmRSb3dIZWFkZXIoaW5kZXgsIFRIKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBIYW5kc29udGFibGUuaG9va3MucnVuKGluc3RhbmNlLCAnYWZ0ZXJHZXRSb3dIZWFkZXJSZW5kZXJlcnMnLCBhcnIpO1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9LFxuICAgIGNvbHVtbkhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYXJyID0gW107XG4gICAgICBpZiAoaW5zdGFuY2UuaGFzQ29sSGVhZGVycygpKSB7XG4gICAgICAgIGFyci5wdXNoKGZ1bmN0aW9uKGluZGV4LCBUSCkge1xuICAgICAgICAgIHRoYXQuYXBwZW5kQ29sSGVhZGVyKGluZGV4LCBUSCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgSGFuZHNvbnRhYmxlLmhvb2tzLnJ1bihpbnN0YW5jZSwgJ2FmdGVyR2V0Q29sdW1uSGVhZGVyUmVuZGVyZXJzJywgYXJyKTtcbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcbiAgICBjb2x1bW5XaWR0aDogaW5zdGFuY2UuZ2V0Q29sV2lkdGgsXG4gICAgcm93SGVpZ2h0OiBpbnN0YW5jZS5nZXRSb3dIZWlnaHQsXG4gICAgY2VsbFJlbmRlcmVyOiBmdW5jdGlvbihyb3csIGNvbCwgVEQpIHtcblxuICAgICAgdmFyIHByb3AgPSB0aGF0Lmluc3RhbmNlLmNvbFRvUHJvcChjb2wpLFxuICAgICAgICBjZWxsUHJvcGVydGllcyA9IHRoYXQuaW5zdGFuY2UuZ2V0Q2VsbE1ldGEocm93LCBjb2wpLFxuICAgICAgICByZW5kZXJlciA9IHRoYXQuaW5zdGFuY2UuZ2V0Q2VsbFJlbmRlcmVyKGNlbGxQcm9wZXJ0aWVzKTtcblxuICAgICAgdmFyIHZhbHVlID0gdGhhdC5pbnN0YW5jZS5nZXREYXRhQXRSb3dQcm9wKHJvdywgcHJvcCk7XG5cbiAgICAgIHJlbmRlcmVyKHRoYXQuaW5zdGFuY2UsIFRELCByb3csIGNvbCwgcHJvcCwgdmFsdWUsIGNlbGxQcm9wZXJ0aWVzKTtcbiAgICAgIEhhbmRzb250YWJsZS5ob29rcy5ydW4odGhhdC5pbnN0YW5jZSwgJ2FmdGVyUmVuZGVyZXInLCBURCwgcm93LCBjb2wsIHByb3AsIHZhbHVlLCBjZWxsUHJvcGVydGllcyk7XG5cbiAgICB9LFxuICAgIHNlbGVjdGlvbnM6IHNlbGVjdGlvbnMsXG4gICAgaGlkZUJvcmRlck9uTW91c2VEb3duT3ZlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhhdC5zZXR0aW5ncy5mcmFnbWVudFNlbGVjdGlvbjtcbiAgICB9LFxuICAgIG9uQ2VsbE1vdXNlRG93bjogZnVuY3Rpb24oZXZlbnQsIGNvb3JkcywgVEQsIHd0KSB7XG4gICAgICBpbnN0YW5jZS5saXN0ZW4oKTtcbiAgICAgIHRoYXQuYWN0aXZlV3QgPSB3dDtcblxuICAgICAgaXNNb3VzZURvd24gPSB0cnVlO1xuXG4gICAgICBIYW5kc29udGFibGUuaG9va3MucnVuKGluc3RhbmNlLCAnYmVmb3JlT25DZWxsTW91c2VEb3duJywgZXZlbnQsIGNvb3JkcywgVEQpO1xuXG4gICAgICBpZiAoIWlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKGV2ZW50KSkge1xuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uID09PSAyICYmIGluc3RhbmNlLnNlbGVjdGlvbi5pbkluU2VsZWN0aW9uKGNvb3JkcykpIHsgLy9yaWdodCBtb3VzZSBidXR0b25cbiAgICAgICAgICAvL2RvIG5vdGhpbmdcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgIGlmIChjb29yZHMucm93ID49IDAgJiYgY29vcmRzLmNvbCA+PSAwKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZWxlY3Rpb24uc2V0UmFuZ2VFbmQoY29vcmRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKChjb29yZHMucm93IDwgMCB8fCBjb29yZHMuY29sIDwgMCkgJiYgKGNvb3Jkcy5yb3cgPj0gMCB8fCBjb29yZHMuY29sID49IDApKSB7XG4gICAgICAgICAgICBpZiAoY29vcmRzLnJvdyA8IDApIHtcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc2VsZWN0Q2VsbCgwLCBjb29yZHMuY29sLCBpbnN0YW5jZS5jb3VudFJvd3MoKSAtIDEsIGNvb3Jkcy5jb2wpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zZWxlY3Rpb24uc2V0U2VsZWN0ZWRIZWFkZXJzKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb29yZHMuY29sIDwgMCkge1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zZWxlY3RDZWxsKGNvb3Jkcy5yb3csIDAsIGNvb3Jkcy5yb3csIGluc3RhbmNlLmNvdW50Q29scygpIC0gMSk7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnNlbGVjdGlvbi5zZXRTZWxlY3RlZEhlYWRlcnModHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb29yZHMucm93ID0gY29vcmRzLnJvdyA8IDAgPyAwIDogY29vcmRzLnJvdztcbiAgICAgICAgICAgIGNvb3Jkcy5jb2wgPSBjb29yZHMuY29sIDwgMCA/IDAgOiBjb29yZHMuY29sO1xuXG4gICAgICAgICAgICBpbnN0YW5jZS5zZWxlY3Rpb24uc2V0UmFuZ2VTdGFydChjb29yZHMpO1xuXG4gICAgICAgICAgICBpbnN0YW5jZS5zZWxlY3Rpb24uc2V0U2VsZWN0ZWRIZWFkZXJzKGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgSGFuZHNvbnRhYmxlLmhvb2tzLnJ1bihpbnN0YW5jZSwgJ2FmdGVyT25DZWxsTW91c2VEb3duJywgZXZlbnQsIGNvb3JkcywgVEQpO1xuXG4gICAgICAgIHRoYXQuYWN0aXZlV3QgPSB0aGF0Lnd0O1xuICAgICAgfVxuICAgIH0sXG4gICAgLypvbkNlbGxNb3VzZU91dDogZnVuY3Rpb24gKC8qZXZlbnQsIGNvb3JkcywgVEQqIC8pIHtcbiAgICAgaWYgKGlzTW91c2VEb3duICYmIHRoYXQuc2V0dGluZ3MuZnJhZ21lbnRTZWxlY3Rpb24gPT09ICdzaW5nbGUnKSB7XG4gICAgIGNsZWFyVGV4dFNlbGVjdGlvbigpOyAvL290aGVyd2lzZSB0ZXh0IHNlbGVjdGlvbiBibGlua3MgZHVyaW5nIG11bHRpcGxlIGNlbGxzIHNlbGVjdGlvblxuICAgICB9XG4gICAgIH0sKi9cbiAgICBvbkNlbGxNb3VzZU92ZXI6IGZ1bmN0aW9uKGV2ZW50LCBjb29yZHMsIFRELCB3dCkge1xuICAgICAgdGhhdC5hY3RpdmVXdCA9IHd0O1xuICAgICAgaWYgKGNvb3Jkcy5yb3cgPj0gMCAmJiBjb29yZHMuY29sID49IDApIHsgLy9pcyBub3QgYSBoZWFkZXJcbiAgICAgICAgaWYgKGlzTW91c2VEb3duKSB7XG4gICAgICAgICAgLyppZiAodGhhdC5zZXR0aW5ncy5mcmFnbWVudFNlbGVjdGlvbiA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgY2xlYXJUZXh0U2VsZWN0aW9uKCk7IC8vb3RoZXJ3aXNlIHRleHQgc2VsZWN0aW9uIGJsaW5rcyBkdXJpbmcgbXVsdGlwbGUgY2VsbHMgc2VsZWN0aW9uXG4gICAgICAgICAgIH0qL1xuICAgICAgICAgIGluc3RhbmNlLnNlbGVjdGlvbi5zZXRSYW5nZUVuZChjb29yZHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNNb3VzZURvd24pIHtcbiAgICAgICAgICAvLyBtdWx0aSBzZWxlY3QgY29sdW1uc1xuICAgICAgICAgIGlmIChjb29yZHMucm93IDwgMCkge1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlLnNlbGVjdGlvbi5zZWxlY3RlZEhlYWRlci5jb2xzKSB7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnNlbGVjdGlvbi5zZXRSYW5nZUVuZChuZXcgV2Fsa29udGFibGVDZWxsQ29vcmRzKGluc3RhbmNlLmNvdW50Um93cygpIC0gMSwgY29vcmRzLmNvbCkpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zZWxlY3Rpb24uc2V0U2VsZWN0ZWRIZWFkZXJzKGZhbHNlLCB0cnVlKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc2VsZWN0aW9uLnNldFJhbmdlRW5kKG5ldyBXYWxrb250YWJsZUNlbGxDb29yZHMoY29vcmRzLnJvdywgY29vcmRzLmNvbCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbXVsdGkgc2VsZWN0IHJvd3NcbiAgICAgICAgICBpZiAoY29vcmRzLmNvbCA8IDApIHtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zZWxlY3Rpb24uc2VsZWN0ZWRIZWFkZXIucm93cykge1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zZWxlY3Rpb24uc2V0UmFuZ2VFbmQobmV3IFdhbGtvbnRhYmxlQ2VsbENvb3Jkcyhjb29yZHMucm93LCBpbnN0YW5jZS5jb3VudENvbHMoKSAtIDEpKTtcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc2VsZWN0aW9uLnNldFNlbGVjdGVkSGVhZGVycyh0cnVlLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnNlbGVjdGlvbi5zZXRSYW5nZUVuZChuZXcgV2Fsa29udGFibGVDZWxsQ29vcmRzKGNvb3Jkcy5yb3csIGNvb3Jkcy5jb2wpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgSGFuZHNvbnRhYmxlLmhvb2tzLnJ1bihpbnN0YW5jZSwgJ2FmdGVyT25DZWxsTW91c2VPdmVyJywgZXZlbnQsIGNvb3JkcywgVEQpO1xuICAgICAgdGhhdC5hY3RpdmVXdCA9IHRoYXQud3Q7XG4gICAgfSxcbiAgICBvbkNlbGxDb3JuZXJNb3VzZURvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgSGFuZHNvbnRhYmxlLmhvb2tzLnJ1bihpbnN0YW5jZSwgJ2FmdGVyT25DZWxsQ29ybmVyTW91c2VEb3duJywgZXZlbnQpO1xuICAgIH0sXG4gICAgYmVmb3JlRHJhdzogZnVuY3Rpb24oZm9yY2UpIHtcbiAgICAgIHRoYXQuYmVmb3JlUmVuZGVyKGZvcmNlKTtcbiAgICB9LFxuICAgIG9uRHJhdzogZnVuY3Rpb24oZm9yY2UpIHtcbiAgICAgIHRoYXQub25EcmF3KGZvcmNlKTtcbiAgICB9LFxuICAgIG9uU2Nyb2xsVmVydGljYWxseTogZnVuY3Rpb24oKSB7XG4gICAgICBpbnN0YW5jZS5ydW5Ib29rcygnYWZ0ZXJTY3JvbGxWZXJ0aWNhbGx5Jyk7XG4gICAgfSxcbiAgICBvblNjcm9sbEhvcml6b250YWxseTogZnVuY3Rpb24oKSB7XG4gICAgICBpbnN0YW5jZS5ydW5Ib29rcygnYWZ0ZXJTY3JvbGxIb3Jpem9udGFsbHknKTtcbiAgICB9LFxuICAgIG9uQmVmb3JlRHJhd0JvcmRlcnM6IGZ1bmN0aW9uKGNvcm5lcnMsIGJvcmRlckNsYXNzTmFtZSkge1xuICAgICAgaW5zdGFuY2UucnVuSG9va3MoJ2JlZm9yZURyYXdCb3JkZXJzJywgY29ybmVycywgYm9yZGVyQ2xhc3NOYW1lKTtcbiAgICB9LFxuICAgIG9uQmVmb3JlVG91Y2hTY3JvbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgaW5zdGFuY2UucnVuSG9va3MoJ2JlZm9yZVRvdWNoU2Nyb2xsJyk7XG4gICAgfSxcbiAgICBvbkFmdGVyTW9tZW50dW1TY3JvbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgaW5zdGFuY2UucnVuSG9va3MoJ2FmdGVyTW9tZW50dW1TY3JvbGwnKTtcbiAgICB9LFxuICAgIHZpZXdwb3J0Um93Q2FsY3VsYXRvck92ZXJyaWRlOiBmdW5jdGlvbihjYWxjKSB7XG4gICAgICBsZXQgcm93cyA9IGluc3RhbmNlLmNvdW50Um93cygpO1xuICAgICAgbGV0IHZpZXdwb3J0T2Zmc2V0ID0gdGhhdC5zZXR0aW5ncy52aWV3cG9ydFJvd1JlbmRlcmluZ09mZnNldDtcblxuICAgICAgaWYgKHZpZXdwb3J0T2Zmc2V0ID09PSAnYXV0bycgJiYgdGhhdC5zZXR0aW5ncy5maXhlZFJvd3NUb3ApIHtcbiAgICAgICAgdmlld3BvcnRPZmZzZXQgPSAxMDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygdmlld3BvcnRPZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNhbGMuc3RhcnRSb3cgPSBNYXRoLm1heChjYWxjLnN0YXJ0Um93IC0gdmlld3BvcnRPZmZzZXQsIDApO1xuICAgICAgICBjYWxjLmVuZFJvdyA9IE1hdGgubWluKGNhbGMuZW5kUm93ICsgdmlld3BvcnRPZmZzZXQsIHJvd3MgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmICh2aWV3cG9ydE9mZnNldCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIGxldCBjZW50ZXIgPSBjYWxjLnN0YXJ0Um93ICsgY2FsYy5lbmRSb3cgLSBjYWxjLnN0YXJ0Um93O1xuICAgICAgICBsZXQgb2Zmc2V0ID0gTWF0aC5jZWlsKGNlbnRlciAvIHJvd3MgKiAxMik7XG5cbiAgICAgICAgY2FsYy5zdGFydFJvdyA9IE1hdGgubWF4KGNhbGMuc3RhcnRSb3cgLSBvZmZzZXQsIDApO1xuICAgICAgICBjYWxjLmVuZFJvdyA9IE1hdGgubWluKGNhbGMuZW5kUm93ICsgb2Zmc2V0LCByb3dzIC0gMSk7XG4gICAgICB9XG4gICAgICBpbnN0YW5jZS5ydW5Ib29rcygnYWZ0ZXJWaWV3cG9ydFJvd0NhbGN1bGF0b3JPdmVycmlkZScsIGNhbGMpO1xuICAgIH0sXG4gICAgdmlld3BvcnRDb2x1bW5DYWxjdWxhdG9yT3ZlcnJpZGU6IGZ1bmN0aW9uKGNhbGMpIHtcbiAgICAgIGxldCBjb2xzID0gaW5zdGFuY2UuY291bnRDb2xzKCk7XG4gICAgICBsZXQgdmlld3BvcnRPZmZzZXQgPSB0aGF0LnNldHRpbmdzLnZpZXdwb3J0Q29sdW1uUmVuZGVyaW5nT2Zmc2V0O1xuXG4gICAgICBpZiAodmlld3BvcnRPZmZzZXQgPT09ICdhdXRvJyAmJiB0aGF0LnNldHRpbmdzLmZpeGVkQ29sdW1uc0xlZnQpIHtcbiAgICAgICAgdmlld3BvcnRPZmZzZXQgPSAxMDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygdmlld3BvcnRPZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNhbGMuc3RhcnRDb2x1bW4gPSBNYXRoLm1heChjYWxjLnN0YXJ0Q29sdW1uIC0gdmlld3BvcnRPZmZzZXQsIDApO1xuICAgICAgICBjYWxjLmVuZENvbHVtbiA9IE1hdGgubWluKGNhbGMuZW5kQ29sdW1uICsgdmlld3BvcnRPZmZzZXQsIGNvbHMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmICh2aWV3cG9ydE9mZnNldCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIGxldCBjZW50ZXIgPSBjYWxjLnN0YXJ0Q29sdW1uICsgY2FsYy5lbmRDb2x1bW4gLSBjYWxjLnN0YXJ0Q29sdW1uO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gTWF0aC5jZWlsKGNlbnRlciAvIGNvbHMgKiAxMik7XG5cbiAgICAgICAgY2FsYy5zdGFydFJvdyA9IE1hdGgubWF4KGNhbGMuc3RhcnRDb2x1bW4gLSBvZmZzZXQsIDApO1xuICAgICAgICBjYWxjLmVuZENvbHVtbiA9IE1hdGgubWluKGNhbGMuZW5kQ29sdW1uICsgb2Zmc2V0LCBjb2xzIC0gMSk7XG4gICAgICB9XG4gICAgICBpbnN0YW5jZS5ydW5Ib29rcygnYWZ0ZXJWaWV3cG9ydENvbHVtbkNhbGN1bGF0b3JPdmVycmlkZScsIGNhbGMpO1xuICAgIH1cbiAgfTtcblxuICBIYW5kc29udGFibGUuaG9va3MucnVuKGluc3RhbmNlLCAnYmVmb3JlSW5pdFdhbGtvbnRhYmxlJywgd2Fsa29udGFibGVDb25maWcpO1xuXG4gIHRoaXMud3QgPSBuZXcgV2Fsa29udGFibGUod2Fsa29udGFibGVDb25maWcpO1xuICB0aGlzLmFjdGl2ZVd0ID0gdGhpcy53dDtcblxuICB0aGlzLmV2ZW50TWFuYWdlci5hZGRFdmVudExpc3RlbmVyKHRoYXQud3Qud3RUYWJsZS5zcHJlYWRlciwgJ21vdXNlZG93bicsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgLy9yaWdodCBtb3VzZSBidXR0b24gZXhhY3RseSBvbiBzcHJlYWRlciBtZWFucyByaWdodCBjbGljayBvbiB0aGUgcmlnaHQgaGFuZCBzaWRlIG9mIHZlcnRpY2FsIHNjcm9sbGJhclxuICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoYXQud3Qud3RUYWJsZS5zcHJlYWRlciAmJiBldmVudC53aGljaCA9PT0gMykge1xuICAgICAgc3RvcFByb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICAgIC8vZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9KTtcblxuICB0aGlzLmV2ZW50TWFuYWdlci5hZGRFdmVudExpc3RlbmVyKHRoYXQud3Qud3RUYWJsZS5zcHJlYWRlciwgJ2NvbnRleHRtZW51JywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAvL3JpZ2h0IG1vdXNlIGJ1dHRvbiBleGFjdGx5IG9uIHNwcmVhZGVyIG1lYW5zIHJpZ2h0IGNsaWNrIG9uIHRoZSByaWdodCBoYW5kIHNpZGUgb2YgdmVydGljYWwgc2Nyb2xsYmFyXG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhhdC53dC53dFRhYmxlLnNwcmVhZGVyICYmIGV2ZW50LndoaWNoID09PSAzKSB7XG4gICAgICBzdG9wUHJvcGFnYXRpb24oZXZlbnQpO1xuICAgICAgLy9ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gIH0pO1xuXG5cbiAgdGhpcy5ldmVudE1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcihkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGF0LnNldHRpbmdzLm9ic2VydmVET01WaXNpYmlsaXR5KSB7XG4gICAgICBpZiAodGhhdC53dC5kcmF3SW50ZXJydXB0ZWQpIHtcbiAgICAgICAgdGhhdC5pbnN0YW5jZS5mb3JjZUZ1bGxSZW5kZXIgPSB0cnVlO1xuICAgICAgICB0aGF0LnJlbmRlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cblRhYmxlVmlldy5wcm90b3R5cGUuaXNUZXh0U2VsZWN0aW9uQWxsb3dlZCA9IGZ1bmN0aW9uKGVsKSB7XG4gIGlmIChpc0lucHV0KGVsKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh0aGlzLnNldHRpbmdzLmZyYWdtZW50U2VsZWN0aW9uICYmIGlzQ2hpbGRPZihlbCwgdGhpcy5UQk9EWSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cblRhYmxlVmlldy5wcm90b3R5cGUuaXNDZWxsRWRpdGVkID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhY3RpdmVFZGl0b3IgPSB0aGlzLmluc3RhbmNlLmdldEFjdGl2ZUVkaXRvcigpO1xuXG4gIHJldHVybiBhY3RpdmVFZGl0b3IgJiYgYWN0aXZlRWRpdG9yLmlzT3BlbmVkKCk7XG59O1xuXG5UYWJsZVZpZXcucHJvdG90eXBlLmJlZm9yZVJlbmRlciA9IGZ1bmN0aW9uKGZvcmNlKSB7XG4gIGlmIChmb3JjZSkge1xuICAgIC8vdGhpcy5pbnN0YW5jZS5mb3JjZUZ1bGxSZW5kZXIgPSBkaWQgSGFuZHNvbnRhYmxlIHJlcXVlc3QgZnVsbCByZW5kZXI/XG4gICAgSGFuZHNvbnRhYmxlLmhvb2tzLnJ1bih0aGlzLmluc3RhbmNlLCAnYmVmb3JlUmVuZGVyJywgdGhpcy5pbnN0YW5jZS5mb3JjZUZ1bGxSZW5kZXIpO1xuICB9XG59O1xuXG5UYWJsZVZpZXcucHJvdG90eXBlLm9uRHJhdyA9IGZ1bmN0aW9uKGZvcmNlKSB7XG4gIGlmIChmb3JjZSkge1xuICAgIC8vdGhpcy5pbnN0YW5jZS5mb3JjZUZ1bGxSZW5kZXIgPSBkaWQgSGFuZHNvbnRhYmxlIHJlcXVlc3QgZnVsbCByZW5kZXI/XG4gICAgSGFuZHNvbnRhYmxlLmhvb2tzLnJ1bih0aGlzLmluc3RhbmNlLCAnYWZ0ZXJSZW5kZXInLCB0aGlzLmluc3RhbmNlLmZvcmNlRnVsbFJlbmRlcik7XG4gIH1cbn07XG5cblRhYmxlVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMud3QuZHJhdyghdGhpcy5pbnN0YW5jZS5mb3JjZUZ1bGxSZW5kZXIpO1xuICB0aGlzLmluc3RhbmNlLmZvcmNlRnVsbFJlbmRlciA9IGZhbHNlO1xuICB0aGlzLmluc3RhbmNlLnJlbmRlckNhbGwgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0ZCBvYmplY3QgZ2l2ZW4gY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7V2Fsa29udGFibGVDZWxsQ29vcmRzfSBjb29yZHNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdG9wbW9zdFxuICovXG5UYWJsZVZpZXcucHJvdG90eXBlLmdldENlbGxBdENvb3JkcyA9IGZ1bmN0aW9uKGNvb3JkcywgdG9wbW9zdCkge1xuICB2YXIgdGQgPSB0aGlzLnd0LmdldENlbGwoY29vcmRzLCB0b3Btb3N0KTtcbiAgLy92YXIgdGQgPSB0aGlzLnd0Lnd0VGFibGUuZ2V0Q2VsbChjb29yZHMpO1xuICBpZiAodGQgPCAwKSB7IC8vdGhlcmUgd2FzIGFuIGV4aXQgY29kZSAoY2VsbCBpcyBvdXQgb2YgYm91bmRzKVxuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0ZDtcbiAgfVxufTtcblxuLyoqXG4gKiBTY3JvbGwgdmlld3BvcnQgdG8gc2VsZWN0aW9uXG4gKiBAcGFyYW0ge1dhbGtvbnRhYmxlQ2VsbENvb3Jkc30gY29vcmRzXG4gKi9cblRhYmxlVmlldy5wcm90b3R5cGUuc2Nyb2xsVmlld3BvcnQgPSBmdW5jdGlvbihjb29yZHMpIHtcbiAgdGhpcy53dC5zY3JvbGxWaWV3cG9ydChjb29yZHMpO1xufTtcblxuLyoqXG4gKiBBcHBlbmQgcm93IGhlYWRlciB0byBhIFRIIGVsZW1lbnRcbiAqIEBwYXJhbSByb3dcbiAqIEBwYXJhbSBUSFxuICovXG5UYWJsZVZpZXcucHJvdG90eXBlLmFwcGVuZFJvd0hlYWRlciA9IGZ1bmN0aW9uKHJvdywgVEgpIHtcbiAgaWYgKFRILmZpcnN0Q2hpbGQpIHtcbiAgICBsZXQgY29udGFpbmVyID0gVEguZmlyc3RDaGlsZDtcblxuICAgIGlmICghaGFzQ2xhc3MoY29udGFpbmVyLCAncmVsYXRpdmUnKSkge1xuICAgICAgZW1wdHkoVEgpO1xuICAgICAgdGhpcy5hcHBlbmRSb3dIZWFkZXIocm93LCBUSCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVDZWxsSGVhZGVyKGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcucm93SGVhZGVyJyksIHJvdywgdGhpcy5pbnN0YW5jZS5nZXRSb3dIZWFkZXIpO1xuXG4gIH0gZWxzZSB7XG4gICAgbGV0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuXG4gICAgZGl2LmNsYXNzTmFtZSA9ICdyZWxhdGl2ZSc7XG4gICAgc3Bhbi5jbGFzc05hbWUgPSAncm93SGVhZGVyJztcbiAgICB0aGlzLnVwZGF0ZUNlbGxIZWFkZXIoc3Bhbiwgcm93LCB0aGlzLmluc3RhbmNlLmdldFJvd0hlYWRlcik7XG5cbiAgICBkaXYuYXBwZW5kQ2hpbGQoc3Bhbik7XG4gICAgVEguYXBwZW5kQ2hpbGQoZGl2KTtcbiAgfVxuICBIYW5kc29udGFibGUuaG9va3MucnVuKHRoaXMuaW5zdGFuY2UsICdhZnRlckdldFJvd0hlYWRlcicsIHJvdywgVEgpO1xufTtcblxuLyoqXG4gKiBBcHBlbmQgY29sdW1uIGhlYWRlciB0byBhIFRIIGVsZW1lbnRcbiAqIEBwYXJhbSBjb2xcbiAqIEBwYXJhbSBUSFxuICovXG5UYWJsZVZpZXcucHJvdG90eXBlLmFwcGVuZENvbEhlYWRlciA9IGZ1bmN0aW9uKGNvbCwgVEgpIHtcbiAgaWYgKFRILmZpcnN0Q2hpbGQpIHtcbiAgICBsZXQgY29udGFpbmVyID0gVEguZmlyc3RDaGlsZDtcblxuICAgIGlmICghaGFzQ2xhc3MoY29udGFpbmVyLCAncmVsYXRpdmUnKSkge1xuICAgICAgZW1wdHkoVEgpO1xuICAgICAgdGhpcy5hcHBlbmRSb3dIZWFkZXIoY29sLCBUSCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVDZWxsSGVhZGVyKGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuY29sSGVhZGVyJyksIGNvbCwgdGhpcy5pbnN0YW5jZS5nZXRDb2xIZWFkZXIpO1xuXG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxldCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuXG4gICAgZGl2LmNsYXNzTmFtZSA9ICdyZWxhdGl2ZSc7XG4gICAgc3Bhbi5jbGFzc05hbWUgPSAnY29sSGVhZGVyJztcbiAgICB0aGlzLnVwZGF0ZUNlbGxIZWFkZXIoc3BhbiwgY29sLCB0aGlzLmluc3RhbmNlLmdldENvbEhlYWRlcik7XG5cbiAgICBkaXYuYXBwZW5kQ2hpbGQoc3Bhbik7XG4gICAgVEguYXBwZW5kQ2hpbGQoZGl2KTtcbiAgfVxuICBIYW5kc29udGFibGUuaG9va3MucnVuKHRoaXMuaW5zdGFuY2UsICdhZnRlckdldENvbEhlYWRlcicsIGNvbCwgVEgpO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgaGVhZGVyIGNlbGwgY29udGVudFxuICpcbiAqIEBzaW5jZSAwLjE1LjAtYmV0YTRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0byB1cGRhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBSb3cgaW5kZXggb3IgY29sdW1uIGluZGV4XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb250ZW50IEZ1bmN0aW9uIHdoaWNoIHNob3VsZCBiZSByZXR1cm5zIGNvbnRlbnQgZm9yIHRoaXMgY2VsbFxuICovXG5UYWJsZVZpZXcucHJvdG90eXBlLnVwZGF0ZUNlbGxIZWFkZXIgPSBmdW5jdGlvbihlbGVtZW50LCBpbmRleCwgY29udGVudCkge1xuICBpZiAoaW5kZXggPiAtMSkge1xuICAgIGZhc3RJbm5lckhUTUwoZWxlbWVudCwgY29udGVudChpbmRleCkpO1xuXG4gIH0gZWxzZSB7XG4gICAgLy8gd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2hhbmRzb250YWJsZS9oYW5kc29udGFibGUvaXNzdWVzLzE5NDZcbiAgICBmYXN0SW5uZXJUZXh0KGVsZW1lbnQsIFN0cmluZy5mcm9tQ2hhckNvZGUoMTYwKSk7XG4gICAgYWRkQ2xhc3MoZWxlbWVudCwgJ2Nvcm5lckhlYWRlcicpO1xuICB9XG59O1xuXG4vKipcbiAqIEdpdmVuIGEgZWxlbWVudCdzIGxlZnQgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LCByZXR1cm5zIG1heGltdW0gZWxlbWVudCB3aWR0aCB1bnRpbCB0aGUgcmlnaHRcbiAqIGVkZ2Ugb2YgdGhlIHZpZXdwb3J0IChiZWZvcmUgc2Nyb2xsYmFyKVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0T2Zmc2V0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblRhYmxlVmlldy5wcm90b3R5cGUubWF4aW11bVZpc2libGVFbGVtZW50V2lkdGggPSBmdW5jdGlvbihsZWZ0T2Zmc2V0KSB7XG4gIHZhciB3b3Jrc3BhY2VXaWR0aCA9IHRoaXMud3Qud3RWaWV3cG9ydC5nZXRXb3Jrc3BhY2VXaWR0aCgpO1xuICB2YXIgbWF4V2lkdGggPSB3b3Jrc3BhY2VXaWR0aCAtIGxlZnRPZmZzZXQ7XG4gIHJldHVybiBtYXhXaWR0aCA+IDAgPyBtYXhXaWR0aCA6IDA7XG59O1xuXG4vKipcbiAqIEdpdmVuIGEgZWxlbWVudCdzIHRvcCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQsIHJldHVybnMgbWF4aW11bSBlbGVtZW50IGhlaWdodCB1bnRpbCB0aGUgYm90dG9tXG4gKiBlZGdlIG9mIHRoZSB2aWV3cG9ydCAoYmVmb3JlIHNjcm9sbGJhcilcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdG9wT2Zmc2V0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblRhYmxlVmlldy5wcm90b3R5cGUubWF4aW11bVZpc2libGVFbGVtZW50SGVpZ2h0ID0gZnVuY3Rpb24odG9wT2Zmc2V0KSB7XG4gIHZhciB3b3Jrc3BhY2VIZWlnaHQgPSB0aGlzLnd0Lnd0Vmlld3BvcnQuZ2V0V29ya3NwYWNlSGVpZ2h0KCk7XG4gIHZhciBtYXhIZWlnaHQgPSB3b3Jrc3BhY2VIZWlnaHQgLSB0b3BPZmZzZXQ7XG4gIHJldHVybiBtYXhIZWlnaHQgPiAwID8gbWF4SGVpZ2h0IDogMDtcbn07XG5cblRhYmxlVmlldy5wcm90b3R5cGUubWFpblZpZXdJc0FjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy53dCA9PT0gdGhpcy5hY3RpdmVXdDtcbn07XG5cblRhYmxlVmlldy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnd0LmRlc3Ryb3koKTtcbiAgdGhpcy5ldmVudE1hbmFnZXIuZGVzdHJveSgpO1xufTtcblxuZXhwb3J0IHtUYWJsZVZpZXd9O1xuIiwiXG5pbXBvcnQge3N0cmluZ2lmeX0gZnJvbSAnLi8uLi9oZWxwZXJzL21peGVkJztcblxuLyoqXG4gKiBBdXRvY29tcGxldGUgY2VsbCB2YWxpZGF0b3IuXG4gKlxuICogQHByaXZhdGVcbiAqIEB2YWxpZGF0b3IgQXV0b2NvbXBsZXRlVmFsaWRhdG9yXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgb2YgZWRpdGVkIGNlbGxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgY2FsbGVkIHdpdGggdmFsaWRhdGlvbiByZXN1bHRcbiAqL1xuSGFuZHNvbnRhYmxlLkF1dG9jb21wbGV0ZVZhbGlkYXRvciA9IGZ1bmN0aW9uICh2YWx1ZSwgY2FsbGJhY2spIHtcbiAgaWYgKHRoaXMuc3RyaWN0ICYmIHRoaXMuc291cmNlKSB7XG4gICAgaWYgKCB0eXBlb2YgdGhpcy5zb3VyY2UgPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICB0aGlzLnNvdXJjZSh2YWx1ZSwgcHJvY2Vzcyh2YWx1ZSwgY2FsbGJhY2spKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcyh2YWx1ZSwgY2FsbGJhY2spKHRoaXMuc291cmNlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY2FsbGJhY2sodHJ1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogRnVuY3Rpb24gcmVzcG9uc2libGUgZm9yIHZhbGlkYXRpb24gb2YgYXV0b2NvbXBsZXRlIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSBvZiBlZGl0ZWQgY2VsbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayBjYWxsZWQgd2l0aCB2YWxpZGF0aW9uIHJlc3VsdFxuICovXG5mdW5jdGlvbiBwcm9jZXNzKHZhbHVlLCBjYWxsYmFjaykge1xuICB2YXIgb3JpZ2luYWxWYWwgID0gdmFsdWU7XG4gIHZhciBsb3dlcmNhc2VWYWwgPSB0eXBlb2Ygb3JpZ2luYWxWYWwgPT09ICdzdHJpbmcnID8gb3JpZ2luYWxWYWwudG9Mb3dlckNhc2UoKSA6IG51bGw7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBzID0gMCwgc2xlbiA9IHNvdXJjZS5sZW5ndGg7IHMgPCBzbGVuOyBzKyspIHtcbiAgICAgIGlmIChvcmlnaW5hbFZhbCA9PT0gc291cmNlW3NdKSB7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTsgLy9wZXJmZWN0IG1hdGNoXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobG93ZXJjYXNlVmFsID09PSBzdHJpbmdpZnkoc291cmNlW3NdKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIC8vIGNoYW5nZXNbaV1bM10gPSBzb3VyY2Vbc107IC8vZ29vZCBtYXRjaCwgZml4IHRoZSBjYXNlIDw8IFRPRE8/XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2FsbGJhY2soZm91bmQpO1xuICB9O1xufVxuIiwiXG5pbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudCc7XG5pbXBvcnQge2dldEVkaXRvcn0gZnJvbSAnLi8uLi9lZGl0b3JzJztcblxuLyoqXG4gKiBEYXRlIGNlbGwgdmFsaWRhdG9yXG4gKlxuICogQHByaXZhdGVcbiAqIEB2YWxpZGF0b3IgRGF0ZVZhbGlkYXRvclxuICogQGRlcGVuZGVuY2llcyBtb21lbnRcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSBvZiBlZGl0ZWQgY2VsbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayBjYWxsZWQgd2l0aCB2YWxpZGF0aW9uIHJlc3VsdFxuICovXG5IYW5kc29udGFibGUuRGF0ZVZhbGlkYXRvciA9IGZ1bmN0aW9uKHZhbHVlLCBjYWxsYmFjaykge1xuICBsZXQgdmFsaWQgPSB0cnVlO1xuICBsZXQgZGF0ZUVkaXRvciA9IGdldEVkaXRvcignZGF0ZScsIHRoaXMuaW5zdGFuY2UpO1xuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHZhbHVlID0gJyc7XG4gIH1cbiAgbGV0IGlzVmFsaWREYXRlID0gbW9tZW50KG5ldyBEYXRlKHZhbHVlKSkuaXNWYWxpZCgpO1xuICAvLyBpcyBpdCBpbiB0aGUgc3BlY2lmaWVkIGZvcm1hdFxuICBsZXQgaXNWYWxpZEZvcm1hdCA9IG1vbWVudCh2YWx1ZSwgdGhpcy5kYXRlRm9ybWF0IHx8IGRhdGVFZGl0b3IuZGVmYXVsdERhdGVGb3JtYXQsIHRydWUpLmlzVmFsaWQoKTtcblxuICBpZiAoIWlzVmFsaWREYXRlKSB7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICBpZiAoIWlzVmFsaWREYXRlICYmIGlzVmFsaWRGb3JtYXQpIHtcbiAgICB2YWxpZCA9IHRydWU7XG4gIH1cblxuICBpZiAoaXNWYWxpZERhdGUgJiYgIWlzVmFsaWRGb3JtYXQpIHtcbiAgICBpZiAodGhpcy5jb3JyZWN0Rm9ybWF0ID09PSB0cnVlKSB7IC8vIGlmIGZvcm1hdCBjb3JyZWN0aW9uIGlzIGVuYWJsZWRcbiAgICAgIGxldCBjb3JyZWN0ZWRWYWx1ZSA9IGNvcnJlY3RGb3JtYXQodmFsdWUsIHRoaXMuZGF0ZUZvcm1hdCk7XG5cbiAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0RGF0YUF0Q2VsbCh0aGlzLnJvdywgdGhpcy5jb2wsIGNvcnJlY3RlZFZhbHVlLCAnZGF0ZVZhbGlkYXRvcicpO1xuICAgICAgdmFsaWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGNhbGxiYWNrKHZhbGlkKTtcbn07XG5cbi8qKlxuICogRm9ybWF0IHRoZSBnaXZlbiBzdHJpbmcgdXNpbmcgbW9tZW50LmpzJyBmb3JtYXQgZmVhdHVyZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGVGb3JtYXRcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmxldCBjb3JyZWN0Rm9ybWF0ID0gZnVuY3Rpb24gY29ycmVjdEZvcm1hdCh2YWx1ZSwgZGF0ZUZvcm1hdCkge1xuICBsZXQgZGF0ZSA9IG1vbWVudChuZXcgRGF0ZSh2YWx1ZSkpO1xuICBsZXQgeWVhciA9IGRhdGUuZm9ybWF0KCdZWVlZJyk7XG4gIGxldCB5ZWFyTm93ID0gbW9tZW50KCkuZm9ybWF0KCdZWVlZJyk7XG5cbiAgLy8gRmlyZWZveCBhbmQgSUUgY291bnRpbmcgMi1kaWdpdHMgeWVhciBmcm9tIDE5MDAgcmVzdCBmcm9tIGN1cnJlbnQgYWdlLlxuICBpZiAoeWVhci5zdWJzdHIoMCwgMikgIT09IHllYXJOb3cuc3Vic3RyKDAsIDIpKSB7XG4gICAgaWYgKCF2YWx1ZS5tYXRjaChuZXcgUmVnRXhwKHllYXIpKSkge1xuICAgICAgZGF0ZS55ZWFyKHllYXIucmVwbGFjZSh5ZWFyLnN1YnN0cigwLCAyKSwgeWVhck5vdy5zdWJzdHIoMCwgMikpKTtcbiAgICB9XG5cbiAgfSBlbHNlIGlmICh5ZWFyLmxlbmd0aCA+IDQpIHtcbiAgICAvLyBVZ2x5IGZpeCBmb3IgbW9tZW50IGJ1ZyB3aGljaCBjYW4gbm90IGZvcm1hdCA1LWRpZ2l0cyB5ZWFyIHVzaW5nIFlZWVlcbiAgICBkYXRlLnllYXIoKGRhdGUueWVhcigpICsgJycpLnN1YnN0cigwLCA0KSk7XG4gIH1cblxuICByZXR1cm4gZGF0ZS5mb3JtYXQoZGF0ZUZvcm1hdCk7XG59O1xuXG4iLCIvKipcbiAqIE51bWVyaWMgY2VsbCB2YWxpZGF0b3JcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHZhbGlkYXRvciBOdW1lcmljVmFsaWRhdG9yXG4gKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgb2YgZWRpdGVkIGNlbGxcbiAqIEBwYXJhbSB7Kn0gY2FsbGJhY2sgLSBDYWxsYmFjayBjYWxsZWQgd2l0aCB2YWxpZGF0aW9uIHJlc3VsdFxuICovXG5IYW5kc29udGFibGUuTnVtZXJpY1ZhbGlkYXRvciA9IGZ1bmN0aW9uICh2YWx1ZSwgY2FsbGJhY2spIHtcbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgdmFsdWUgPSAnJztcbiAgfVxuICBjYWxsYmFjaygvXi0/XFxkKihcXC58XFwsKT9cXGQqJC8udGVzdCh2YWx1ZSkpO1xufTtcbiJdfQ==
